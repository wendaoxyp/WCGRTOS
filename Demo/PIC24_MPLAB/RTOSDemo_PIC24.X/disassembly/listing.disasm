Disassembly Listing for RTOSDemo_PIC24
Generated From:
D:/code/FreeRTOS/Demo/PIC24_MPLAB/RTOSDemo_PIC24.X/dist/default/debug/RTOSDemo_PIC24.X.debug.elf
2018-12-10 20:56:07

---  D:/code/FreeRTOS/Source/tasks.c  -------------------------------------------------------------------
1:                 /*
2:                     FreeRTOS V9.0.0 - Copyright (C) 2016 Real Time Engineers Ltd.
3:                     All rights reserved
4:                 
5:                     VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
6:                 
7:                     This file is part of the FreeRTOS distribution.
8:                 
9:                     FreeRTOS is free software; you can redistribute it and/or modify it under
10:                    the terms of the GNU General Public License (version 2) as published by the
11:                    Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
12:                
13:                    ***************************************************************************
14:                    >>!   NOTE: The modification to the GPL is included to allow you to     !<<
15:                    >>!   distribute a combined work that includes FreeRTOS without being   !<<
16:                    >>!   obliged to provide the source code for proprietary components     !<<
17:                    >>!   outside of the FreeRTOS kernel.                                   !<<
18:                    ***************************************************************************
19:                
20:                    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
21:                    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
22:                    FOR A PARTICULAR PURPOSE.  Full license text is available on the following
23:                    link: http://www.freertos.org/a00114.html
24:                
25:                    ***************************************************************************
26:                     *                                                                       *
27:                     *    FreeRTOS provides completely free yet professionally developed,    *
28:                     *    robust, strictly quality controlled, supported, and cross          *
29:                     *    platform software that is more than just the market leader, it     *
30:                     *    is the industry's de facto standard.                               *
31:                     *                                                                       *
32:                     *    Help yourself get started quickly while simultaneously helping     *
33:                     *    to support the FreeRTOS project by purchasing a FreeRTOS           *
34:                     *    tutorial book, reference manual, or both:                          *
35:                     *    http://www.FreeRTOS.org/Documentation                              *
36:                     *                                                                       *
37:                    ***************************************************************************
38:                
39:                    http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
40:                    the FAQ page "My application does not run, what could be wrong?".  Have you
41:                    defined configASSERT()?
42:                
43:                    http://www.FreeRTOS.org/support - In return for receiving this top quality
44:                    embedded software for free we request you assist our global community by
45:                    participating in the support forum.
46:                
47:                    http://www.FreeRTOS.org/training - Investing in training allows your team to
48:                    be as productive as possible as early as possible.  Now you can receive
49:                    FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
50:                    Ltd, and the world's leading authority on the world's leading RTOS.
51:                
52:                    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
53:                    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
54:                    compatible FAT file system, and our tiny thread aware UDP/IP stack.
55:                
56:                    http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
57:                    Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
58:                
59:                    http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
60:                    Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
61:                    licenses offer ticketed support, indemnification and commercial middleware.
62:                
63:                    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
64:                    engineered and independently SIL3 certified version for use in safety and
65:                    mission critical applications that require provable dependability.
66:                
67:                    1 tab == 4 spaces!
68:                */
69:                
70:                /* Standard includes. */
71:                #include <stdlib.h>
72:                #include <string.h>
73:                
74:                /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
75:                all the API functions to use the MPU wrappers.  That should only be done when
76:                task.h is included from an application file. */
77:                #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
78:                
79:                /* FreeRTOS includes. */
80:                #include "FreeRTOS.h"
81:                #include "task.h"
82:                #include "timers.h"
83:                #include "StackMacros.h"
84:                
85:                /* Lint e961 and e750 are suppressed as a MISRA exception justified because the
86:                MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined for the
87:                header files above, but not in this file, in order to generate the correct
88:                privileged Vs unprivileged linkage and placement. */
89:                #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750. */
90:                
91:                /* Set configUSE_STATS_FORMATTING_FUNCTIONS to 2 to include the stats formatting
92:                functions but without including stdio.h here. */
93:                #if ( configUSE_STATS_FORMATTING_FUNCTIONS == 1 )
94:                	/* At the bottom of this file are two optional functions that can be used
95:                	to generate human readable text from the raw data generated by the
96:                	uxTaskGetSystemState() function.  Note the formatting functions are provided
97:                	for convenience only, and are NOT considered part of the kernel. */
98:                	#include <stdio.h>
99:                #endif /* configUSE_STATS_FORMATTING_FUNCTIONS == 1 ) */
100:               
101:               #if( configUSE_PREEMPTION == 0 )
102:               	/* If the cooperative scheduler is being used then a yield should not be
103:               	performed just because a higher priority task has been woken. */
104:               	#define taskYIELD_IF_USING_PREEMPTION()
105:               #else
106:               	#define taskYIELD_IF_USING_PREEMPTION() portYIELD_WITHIN_API()
107:               #endif
108:               
109:               /* Values that can be assigned to the ucNotifyState member of the TCB. */
110:               #define taskNOT_WAITING_NOTIFICATION	( ( uint8_t ) 0 )
111:               #define taskWAITING_NOTIFICATION		( ( uint8_t ) 1 )
112:               #define taskNOTIFICATION_RECEIVED		( ( uint8_t ) 2 )
113:               
114:               /*
115:                * The value used to fill the stack of a task when the task is created.  This
116:                * is used purely for checking the high water mark for tasks.
117:                */
118:               #define tskSTACK_FILL_BYTE	( 0xa5U )
119:               
120:               /* Sometimes the FreeRTOSConfig.h settings only allow a task to be created using
121:               dynamically allocated RAM, in which case when any task is deleted it is known
122:               that both the task's stack and TCB need to be freed.  Sometimes the
123:               FreeRTOSConfig.h settings only allow a task to be created using statically
124:               allocated RAM, in which case when any task is deleted it is known that neither
125:               the task's stack or TCB should be freed.  Sometimes the FreeRTOSConfig.h
126:               settings allow a task to be created using either statically or dynamically
127:               allocated RAM, in which case a member of the TCB is used to record whether the
128:               stack and/or TCB were allocated statically or dynamically, so when a task is
129:               deleted the RAM that was allocated dynamically is freed again and no attempt is
130:               made to free the RAM that was allocated statically.
131:               tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE is only true if it is possible for a
132:               task to be created using either statically or dynamically allocated RAM.  Note
133:               that if portUSING_MPU_WRAPPERS is 1 then a protected task can be created with
134:               a statically allocated stack and a dynamically allocated TCB. */
135:               #define tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE ( ( ( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) || ( portUSING_MPU_WRAPPERS == 1 ) )
136:               #define tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB 		( ( uint8_t ) 0 )
137:               #define tskSTATICALLY_ALLOCATED_STACK_ONLY 			( ( uint8_t ) 1 )
138:               #define tskSTATICALLY_ALLOCATED_STACK_AND_TCB		( ( uint8_t ) 2 )
139:               
140:               /*
141:                * Macros used by vListTask to indicate which state a task is in.
142:                */
143:               #define tskBLOCKED_CHAR		( 'B' )
144:               #define tskREADY_CHAR		( 'R' )
145:               #define tskDELETED_CHAR		( 'D' )
146:               #define tskSUSPENDED_CHAR	( 'S' )
147:               
148:               /*
149:                * Some kernel aware debuggers require the data the debugger needs access to be
150:                * global, rather than file scope.
151:                */
152:               #ifdef portREMOVE_STATIC_QUALIFIER
153:               	#define static
154:               #endif
155:               
156:               #if ( configUSE_PORT_OPTIMISED_TASK_SELECTION == 0 )
157:               
158:               	/* If configUSE_PORT_OPTIMISED_TASK_SELECTION is 0 then task selection is
159:               	performed in a generic way that is not optimised to any particular
160:               	microcontroller architecture. */
161:               
162:               	/* uxTopReadyPriority holds the priority of the highest priority ready
163:               	state task. */
164:               	#define taskRECORD_READY_PRIORITY( uxPriority )														\
165:               	{																									\
166:               		if( ( uxPriority ) > uxTopReadyPriority )														\
167:               		{																								\
168:               			uxTopReadyPriority = ( uxPriority );														\
169:               		}																								\
170:               	} /* taskRECORD_READY_PRIORITY */
171:               
172:               	/*-----------------------------------------------------------*/
173:               
174:               	#define taskSELECT_HIGHEST_PRIORITY_TASK()															\
175:               	{																									\
176:               	UBaseType_t uxTopPriority = uxTopReadyPriority;														\
177:               																										\
178:               		/* Find the highest priority queue that contains ready tasks. */								\
179:               		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopPriority ] ) ) )							\
180:               		{																								\
181:               			configASSERT( uxTopPriority );																\
182:               			--uxTopPriority;																			\
183:               		}																								\
184:               																										\
185:               		/* listGET_OWNER_OF_NEXT_ENTRY indexes through the list, so the tasks of						\
186:               		the	same priority get an equal share of the processor time. */									\
187:               		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopPriority ] ) );			\
188:               		uxTopReadyPriority = uxTopPriority;																\
189:               	} /* taskSELECT_HIGHEST_PRIORITY_TASK */
190:               
191:               	/*-----------------------------------------------------------*/
192:               
193:               	/* Define away taskRESET_READY_PRIORITY() and portRESET_READY_PRIORITY() as
194:               	they are only required when a port optimised method of task selection is
195:               	being used. */
196:               	#define taskRESET_READY_PRIORITY( uxPriority )
197:               	#define portRESET_READY_PRIORITY( uxPriority, uxTopReadyPriority )
198:               
199:               #else /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
200:               
201:               	/* If configUSE_PORT_OPTIMISED_TASK_SELECTION is 1 then task selection is
202:               	performed in a way that is tailored to the particular microcontroller
203:               	architecture being used. */
204:               
205:               	/* A port optimised version is provided.  Call the port defined macros. */
206:               	#define taskRECORD_READY_PRIORITY( uxPriority )	portRECORD_READY_PRIORITY( uxPriority, uxTopReadyPriority )
207:               
208:               	/*-----------------------------------------------------------*/
209:               
210:               	#define taskSELECT_HIGHEST_PRIORITY_TASK()														\
211:               	{																								\
212:               	UBaseType_t uxTopPriority;																		\
213:               																									\
214:               		/* Find the highest priority list that contains ready tasks. */								\
215:               		portGET_HIGHEST_PRIORITY( uxTopPriority, uxTopReadyPriority );								\
216:               		configASSERT( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ uxTopPriority ] ) ) > 0 );		\
217:               		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopPriority ] ) );		\
218:               	} /* taskSELECT_HIGHEST_PRIORITY_TASK() */
219:               
220:               	/*-----------------------------------------------------------*/
221:               
222:               	/* A port optimised version is provided, call it only if the TCB being reset
223:               	is being referenced from a ready list.  If it is referenced from a delayed
224:               	or suspended list then it won't be in a ready list. */
225:               	#define taskRESET_READY_PRIORITY( uxPriority )														\
226:               	{																									\
227:               		if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ ( uxPriority ) ] ) ) == ( UBaseType_t ) 0 )	\
228:               		{																								\
229:               			portRESET_READY_PRIORITY( ( uxPriority ), ( uxTopReadyPriority ) );							\
230:               		}																								\
231:               	}
232:               
233:               #endif /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
234:               
235:               /*-----------------------------------------------------------*/
236:               
237:               /* pxDelayedTaskList and pxOverflowDelayedTaskList are switched when the tick
238:               count overflows. */
239:               #define taskSWITCH_DELAYED_LISTS()																	\
240:               {																									\
241:               	List_t *pxTemp;																					\
242:               																									\
243:               	/* The delayed tasks list should be empty when the lists are switched. */						\
244:               	configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );										\
245:               																									\
246:               	pxTemp = pxDelayedTaskList;																		\
247:               	pxDelayedTaskList = pxOverflowDelayedTaskList;													\
248:               	pxOverflowDelayedTaskList = pxTemp;																\
249:               	xNumOfOverflows++;																				\
250:               	prvResetNextTaskUnblockTime();																	\
251:               }
252:               
253:               /*-----------------------------------------------------------*/
254:               
255:               /*
256:                * Place the task represented by pxTCB into the appropriate ready list for
257:                * the task.  It is inserted at the end of the list.
258:                */
259:               #define prvAddTaskToReadyList( pxTCB )																\
260:               	traceMOVED_TASK_TO_READY_STATE( pxTCB );														\
261:               	taskRECORD_READY_PRIORITY( ( pxTCB )->uxPriority );												\
262:               	vListInsertEnd( &( pxReadyTasksLists[ ( pxTCB )->uxPriority ] ), &( ( pxTCB )->xStateListItem ) ); \
263:               	tracePOST_MOVED_TASK_TO_READY_STATE( pxTCB )
264:               /*-----------------------------------------------------------*/
265:               
266:               /*
267:                * Several functions take an TaskHandle_t parameter that can optionally be NULL,
268:                * where NULL is used to indicate that the handle of the currently executing
269:                * task should be used in place of the parameter.  This macro simply checks to
270:                * see if the parameter is NULL and returns a pointer to the appropriate TCB.
271:                */
272:               #define prvGetTCBFromHandle( pxHandle ) ( ( ( pxHandle ) == NULL ) ? ( TCB_t * ) pxCurrentTCB : ( TCB_t * ) ( pxHandle ) )
273:               
274:               /* The item value of the event list item is normally used to hold the priority
275:               of the task to which it belongs (coded to allow it to be held in reverse
276:               priority order).  However, it is occasionally borrowed for other purposes.  It
277:               is important its value is not updated due to a task priority change while it is
278:               being used for another purpose.  The following bit definition is used to inform
279:               the scheduler that the value should not be changed - in which case it is the
280:               responsibility of whichever module is using the value to ensure it gets set back
281:               to its original value when it is released. */
282:               #if( configUSE_16_BIT_TICKS == 1 )
283:               	#define taskEVENT_LIST_ITEM_VALUE_IN_USE	0x8000U
284:               #else
285:               	#define taskEVENT_LIST_ITEM_VALUE_IN_USE	0x80000000UL
286:               #endif
287:               
288:               /*
289:                * Task control block.  A task control block (TCB) is allocated for each task,
290:                * and stores task state information, including a pointer to the task's context
291:                * (the task's run time environment, including register values)
292:                */
293:               typedef struct tskTaskControlBlock
294:               {
295:               	volatile StackType_t	*pxTopOfStack;	/*< Points to the location of the last item placed on the tasks stack.  THIS MUST BE THE FIRST MEMBER OF THE TCB STRUCT. */
296:               
297:               	#if ( portUSING_MPU_WRAPPERS == 1 )
298:               		xMPU_SETTINGS	xMPUSettings;		/*< The MPU settings are defined as part of the port layer.  THIS MUST BE THE SECOND MEMBER OF THE TCB STRUCT. */
299:               	#endif
300:               
301:               	ListItem_t			xStateListItem;	/*< The list that the state list item of a task is reference from denotes the state of that task (Ready, Blocked, Suspended ). */
302:               	ListItem_t			xEventListItem;		/*< Used to reference a task from an event list. */
303:               	UBaseType_t			uxPriority;			/*< The priority of the task.  0 is the lowest priority. */
304:               	StackType_t			*pxStack;			/*< Points to the start of the stack. */
305:               	char				pcTaskName[ configMAX_TASK_NAME_LEN ];/*< Descriptive name given to the task when created.  Facilitates debugging only. */ /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
306:               
307:               	#if ( portSTACK_GROWTH > 0 )
308:               		StackType_t		*pxEndOfStack;		/*< Points to the end of the stack on architectures where the stack grows up from low memory. */
309:               	#endif
310:               
311:               	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
312:               		UBaseType_t		uxCriticalNesting;	/*< Holds the critical section nesting depth for ports that do not maintain their own count in the port layer. */
313:               	#endif
314:               
315:               	#if ( configUSE_TRACE_FACILITY == 1 )
316:               		UBaseType_t		uxTCBNumber;		/*< Stores a number that increments each time a TCB is created.  It allows debuggers to determine when a task has been deleted and then recreated. */
317:               		UBaseType_t		uxTaskNumber;		/*< Stores a number specifically for use by third party trace code. */
318:               	#endif
319:               
320:               	#if ( configUSE_MUTEXES == 1 )
321:               		UBaseType_t		uxBasePriority;		/*< The priority last assigned to the task - used by the priority inheritance mechanism. */
322:               		UBaseType_t		uxMutexesHeld;
323:               	#endif
324:               
325:               	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
326:               		TaskHookFunction_t pxTaskTag;
327:               	#endif
328:               
329:               	#if( configNUM_THREAD_LOCAL_STORAGE_POINTERS > 0 )
330:               		void *pvThreadLocalStoragePointers[ configNUM_THREAD_LOCAL_STORAGE_POINTERS ];
331:               	#endif
332:               
333:               	#if( configGENERATE_RUN_TIME_STATS == 1 )
334:               		uint32_t		ulRunTimeCounter;	/*< Stores the amount of time the task has spent in the Running state. */
335:               	#endif
336:               
337:               	#if ( configUSE_NEWLIB_REENTRANT == 1 )
338:               		/* Allocate a Newlib reent structure that is specific to this task.
339:               		Note Newlib support has been included by popular demand, but is not
340:               		used by the FreeRTOS maintainers themselves.  FreeRTOS is not
341:               		responsible for resulting newlib operation.  User must be familiar with
342:               		newlib and must provide system-wide implementations of the necessary
343:               		stubs. Be warned that (at the time of writing) the current newlib design
344:               		implements a system-wide malloc() that must be provided with locks. */
345:               		struct	_reent xNewLib_reent;
346:               	#endif
347:               
348:               	#if( configUSE_TASK_NOTIFICATIONS == 1 )
349:               		volatile uint32_t ulNotifiedValue;
350:               		volatile uint8_t ucNotifyState;
351:               	#endif
352:               
353:               	/* See the comments above the definition of
354:               	tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE. */
355:               	#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 )
356:               		uint8_t	ucStaticallyAllocated; 		/*< Set to pdTRUE if the task is a statically allocated to ensure no attempt is made to free the memory. */
357:               	#endif
358:               
359:               	#if( INCLUDE_xTaskAbortDelay == 1 )
360:               		uint8_t ucDelayAborted;
361:               	#endif
362:               
363:               } tskTCB;
364:               
365:               /* The old tskTCB name is maintained above then typedefed to the new TCB_t name
366:               below to enable the use of older kernel aware debuggers. */
367:               typedef tskTCB TCB_t;
368:               
369:               /*lint -e956 A manual analysis and inspection has been used to determine which
370:               static variables must be declared volatile. */
371:               
372:               PRIVILEGED_DATA TCB_t * volatile pxCurrentTCB = NULL;
373:               
374:               /* Lists for ready and blocked tasks. --------------------*/
375:               PRIVILEGED_DATA static List_t pxReadyTasksLists[ configMAX_PRIORITIES ];/*< Prioritised ready tasks. */
376:               PRIVILEGED_DATA static List_t xDelayedTaskList1;						/*< Delayed tasks. */
377:               PRIVILEGED_DATA static List_t xDelayedTaskList2;						/*< Delayed tasks (two lists are used - one for delays that have overflowed the current tick count. */
378:               PRIVILEGED_DATA static List_t * volatile pxDelayedTaskList;				/*< Points to the delayed task list currently being used. */
379:               PRIVILEGED_DATA static List_t * volatile pxOverflowDelayedTaskList;		/*< Points to the delayed task list currently being used to hold tasks that have overflowed the current tick count. */
380:               PRIVILEGED_DATA static List_t xPendingReadyList;						/*< Tasks that have been readied while the scheduler was suspended.  They will be moved to the ready list when the scheduler is resumed. */
381:               
382:               #if( INCLUDE_vTaskDelete == 1 )
383:               
384:               	PRIVILEGED_DATA static List_t xTasksWaitingTermination;				/*< Tasks that have been deleted - but their memory not yet freed. */
385:               	PRIVILEGED_DATA static volatile UBaseType_t uxDeletedTasksWaitingCleanUp = ( UBaseType_t ) 0U;
386:               
387:               #endif
388:               
389:               #if ( INCLUDE_vTaskSuspend == 1 )
390:               
391:               	PRIVILEGED_DATA static List_t xSuspendedTaskList;					/*< Tasks that are currently suspended. */
392:               
393:               #endif
394:               
395:               /* Other file private variables. --------------------------------*/
396:               PRIVILEGED_DATA static volatile UBaseType_t uxCurrentNumberOfTasks 	= ( UBaseType_t ) 0U;
397:               PRIVILEGED_DATA static volatile TickType_t xTickCount 				= ( TickType_t ) 0U;
398:               PRIVILEGED_DATA static volatile UBaseType_t uxTopReadyPriority 		= tskIDLE_PRIORITY;
399:               PRIVILEGED_DATA static volatile BaseType_t xSchedulerRunning 		= pdFALSE;
400:               PRIVILEGED_DATA static volatile UBaseType_t uxPendedTicks 			= ( UBaseType_t ) 0U;
401:               PRIVILEGED_DATA static volatile BaseType_t xYieldPending 			= pdFALSE;
402:               PRIVILEGED_DATA static volatile BaseType_t xNumOfOverflows 			= ( BaseType_t ) 0;
403:               PRIVILEGED_DATA static UBaseType_t uxTaskNumber 					= ( UBaseType_t ) 0U;
404:               PRIVILEGED_DATA static volatile TickType_t xNextTaskUnblockTime		= ( TickType_t ) 0U; /* Initialised to portMAX_DELAY before the scheduler starts. */
405:               PRIVILEGED_DATA static TaskHandle_t xIdleTaskHandle					= NULL;			/*< Holds the handle of the idle task.  The idle task is created automatically when the scheduler is started. */
406:               
407:               /* Context switches are held pending while the scheduler is suspended.  Also,
408:               interrupts must not manipulate the xStateListItem of a TCB, or any of the
409:               lists the xStateListItem can be referenced from, if the scheduler is suspended.
410:               If an interrupt needs to unblock a task while the scheduler is suspended then it
411:               moves the task's event list item into the xPendingReadyList, ready for the
412:               kernel to move the task from the pending ready list into the real ready list
413:               when the scheduler is unsuspended.  The pending ready list itself can only be
414:               accessed from a critical section. */
415:               PRIVILEGED_DATA static volatile UBaseType_t uxSchedulerSuspended	= ( UBaseType_t ) pdFALSE;
416:               
417:               #if ( configGENERATE_RUN_TIME_STATS == 1 )
418:               
419:               	PRIVILEGED_DATA static uint32_t ulTaskSwitchedInTime = 0UL;	/*< Holds the value of a timer/counter the last time a task was switched in. */
420:               	PRIVILEGED_DATA static uint32_t ulTotalRunTime = 0UL;		/*< Holds the total amount of execution time as defined by the run time counter clock. */
421:               
422:               #endif
423:               
424:               /*lint +e956 */
425:               
426:               /*-----------------------------------------------------------*/
427:               
428:               /* Callback function prototypes. --------------------------*/
429:               #if(  configCHECK_FOR_STACK_OVERFLOW > 0 )
430:               	extern void vApplicationStackOverflowHook( TaskHandle_t xTask, char *pcTaskName );
431:               #endif
432:               
433:               #if( configUSE_TICK_HOOK > 0 )
434:               	extern void vApplicationTickHook( void );
435:               #endif
436:               
437:               #if( configSUPPORT_STATIC_ALLOCATION == 1 )
438:               	extern void vApplicationGetIdleTaskMemory( StaticTask_t **ppxIdleTaskTCBBuffer, StackType_t **ppxIdleTaskStackBuffer, uint32_t *pulIdleTaskStackSize );
439:               #endif
440:               
441:               /* File private functions. --------------------------------*/
442:               
443:               /**
444:                * Utility task that simply returns pdTRUE if the task referenced by xTask is
445:                * currently in the Suspended state, or pdFALSE if the task referenced by xTask
446:                * is in any other state.
447:                */
448:               #if ( INCLUDE_vTaskSuspend == 1 )
449:               	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
450:               #endif /* INCLUDE_vTaskSuspend */
451:               
452:               /*
453:                * Utility to ready all the lists used by the scheduler.  This is called
454:                * automatically upon the creation of the first task.
455:                */
456:               static void prvInitialiseTaskLists( void ) PRIVILEGED_FUNCTION;
457:               
458:               /*
459:                * The idle task, which as all tasks is implemented as a never ending loop.
460:                * The idle task is automatically created and added to the ready lists upon
461:                * creation of the first user task.
462:                *
463:                * The portTASK_FUNCTION_PROTO() macro is used to allow port/compiler specific
464:                * language extensions.  The equivalent prototype for this function is:
465:                *
466:                * void prvIdleTask( void *pvParameters );
467:                *
468:                */
469:               static portTASK_FUNCTION_PROTO( prvIdleTask, pvParameters );
470:               
471:               /*
472:                * Utility to free all memory allocated by the scheduler to hold a TCB,
473:                * including the stack pointed to by the TCB.
474:                *
475:                * This does not free memory allocated by the task itself (i.e. memory
476:                * allocated by calls to pvPortMalloc from within the tasks application code).
477:                */
478:               #if ( INCLUDE_vTaskDelete == 1 )
479:               
480:               	static void prvDeleteTCB( TCB_t *pxTCB ) PRIVILEGED_FUNCTION;
481:               
482:               #endif
483:               
484:               /*
485:                * Used only by the idle task.  This checks to see if anything has been placed
486:                * in the list of tasks waiting to be deleted.  If so the task is cleaned up
487:                * and its TCB deleted.
488:                */
489:               static void prvCheckTasksWaitingTermination( void ) PRIVILEGED_FUNCTION;
490:               
491:               /*
492:                * The currently executing task is entering the Blocked state.  Add the task to
493:                * either the current or the overflow delayed task list.
494:                */
495:               static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely ) PRIVILEGED_FUNCTION;
496:               
497:               /*
498:                * Fills an TaskStatus_t structure with information on each task that is
499:                * referenced from the pxList list (which may be a ready list, a delayed list,
500:                * a suspended list, etc.).
501:                *
502:                * THIS FUNCTION IS INTENDED FOR DEBUGGING ONLY, AND SHOULD NOT BE CALLED FROM
503:                * NORMAL APPLICATION CODE.
504:                */
505:               #if ( configUSE_TRACE_FACILITY == 1 )
506:               
507:               	static UBaseType_t prvListTasksWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, eTaskState eState ) PRIVILEGED_FUNCTION;
508:               
509:               #endif
510:               
511:               /*
512:                * Searches pxList for a task with name pcNameToQuery - returning a handle to
513:                * the task if it is found, or NULL if the task is not found.
514:                */
515:               #if ( INCLUDE_xTaskGetHandle == 1 )
516:               
517:               	static TCB_t *prvSearchForNameWithinSingleList( List_t *pxList, const char pcNameToQuery[] ) PRIVILEGED_FUNCTION;
518:               
519:               #endif
520:               
521:               /*
522:                * When a task is created, the stack of the task is filled with a known value.
523:                * This function determines the 'high water mark' of the task stack by
524:                * determining how much of the stack remains at the original preset value.
525:                */
526:               #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
527:               
528:               	static uint16_t prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte ) PRIVILEGED_FUNCTION;
529:               
530:               #endif
531:               
532:               /*
533:                * Return the amount of time, in ticks, that will pass before the kernel will
534:                * next move a task from the Blocked state to the Running state.
535:                *
536:                * This conditional compilation should use inequality to 0, not equality to 1.
537:                * This is to ensure portSUPPRESS_TICKS_AND_SLEEP() can be called when user
538:                * defined low power mode implementations require configUSE_TICKLESS_IDLE to be
539:                * set to a value other than 1.
540:                */
541:               #if ( configUSE_TICKLESS_IDLE != 0 )
542:               
543:               	static TickType_t prvGetExpectedIdleTime( void ) PRIVILEGED_FUNCTION;
544:               
545:               #endif
546:               
547:               /*
548:                * Set xNextTaskUnblockTime to the time at which the next Blocked state task
549:                * will exit the Blocked state.
550:                */
551:               static void prvResetNextTaskUnblockTime( void );
552:               
553:               #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) )
554:               
555:               	/*
556:               	 * Helper function used to pad task names with spaces when printing out
557:               	 * human readable tables of task information.
558:               	 */
559:               	static char *prvWriteNameToBuffer( char *pcBuffer, const char *pcTaskName ) PRIVILEGED_FUNCTION;
560:               
561:               #endif
562:               
563:               /*
564:                * Called after a Task_t structure has been allocated either statically or
565:                * dynamically to fill in the structure's members.
566:                */
567:               static void prvInitialiseNewTask( 	TaskFunction_t pxTaskCode,
568:               									const char * const pcName,
569:               									const uint32_t ulStackDepth,
570:               									void * const pvParameters,
571:               									UBaseType_t uxPriority,
572:               									TaskHandle_t * const pxCreatedTask,
573:               									TCB_t *pxNewTCB,
574:               									const MemoryRegion_t * const xRegions ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
575:               
576:               /*
577:                * Called after a new task has been created and initialised to place the task
578:                * under the control of the scheduler.
579:                */
580:               static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB ) PRIVILEGED_FUNCTION;
581:               
582:               /*-----------------------------------------------------------*/
583:               
584:               #if( configSUPPORT_STATIC_ALLOCATION == 1 )
585:               
586:               	TaskHandle_t xTaskCreateStatic(	TaskFunction_t pxTaskCode,
587:               									const char * const pcName,
588:               									const uint32_t ulStackDepth,
589:               									void * const pvParameters,
590:               									UBaseType_t uxPriority,
591:               									StackType_t * const puxStackBuffer,
592:               									StaticTask_t * const pxTaskBuffer ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
593:               	{
594:               	TCB_t *pxNewTCB;
595:               	TaskHandle_t xReturn;
596:               
597:               		configASSERT( puxStackBuffer != NULL );
598:               		configASSERT( pxTaskBuffer != NULL );
599:               
600:               		if( ( pxTaskBuffer != NULL ) && ( puxStackBuffer != NULL ) )
601:               		{
602:               			/* The memory used for the task's TCB and stack are passed into this
603:               			function - use them. */
604:               			pxNewTCB = ( TCB_t * ) pxTaskBuffer; /*lint !e740 Unusual cast is ok as the structures are designed to have the same alignment, and the size is checked by an assert. */
605:               			pxNewTCB->pxStack = ( StackType_t * ) puxStackBuffer;
606:               
607:               			#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 )
608:               			{
609:               				/* Tasks can be created statically or dynamically, so note this
610:               				task was created statically in case the task is later deleted. */
611:               				pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;
612:               			}
613:               			#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
614:               
615:               			prvInitialiseNewTask( pxTaskCode, pcName, ulStackDepth, pvParameters, uxPriority, &xReturn, pxNewTCB, NULL );
616:               			prvAddNewTaskToReadyList( pxNewTCB );
617:               		}
618:               		else
619:               		{
620:               			xReturn = NULL;
621:               		}
622:               
623:               		return xReturn;
624:               	}
625:               
626:               #endif /* SUPPORT_STATIC_ALLOCATION */
627:               /*-----------------------------------------------------------*/
628:               
629:               #if( portUSING_MPU_WRAPPERS == 1 )
630:               
631:               	BaseType_t xTaskCreateRestricted( const TaskParameters_t * const pxTaskDefinition, TaskHandle_t *pxCreatedTask )
632:               	{
633:               	TCB_t *pxNewTCB;
634:               	BaseType_t xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
635:               
636:               		configASSERT( pxTaskDefinition->puxStackBuffer );
637:               
638:               		if( pxTaskDefinition->puxStackBuffer != NULL )
639:               		{
640:               			/* Allocate space for the TCB.  Where the memory comes from depends
641:               			on the implementation of the port malloc function and whether or
642:               			not static allocation is being used. */
643:               			pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
644:               
645:               			if( pxNewTCB != NULL )
646:               			{
647:               				/* Store the stack location in the TCB. */
648:               				pxNewTCB->pxStack = pxTaskDefinition->puxStackBuffer;
649:               
650:               				/* Tasks can be created statically or dynamically, so note
651:               				this task had a statically allocated stack in case it is
652:               				later deleted.  The TCB was allocated dynamically. */
653:               				pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_ONLY;
654:               
655:               				prvInitialiseNewTask(	pxTaskDefinition->pvTaskCode,
656:               										pxTaskDefinition->pcName,
657:               										( uint32_t ) pxTaskDefinition->usStackDepth,
658:               										pxTaskDefinition->pvParameters,
659:               										pxTaskDefinition->uxPriority,
660:               										pxCreatedTask, pxNewTCB,
661:               										pxTaskDefinition->xRegions );
662:               
663:               				prvAddNewTaskToReadyList( pxNewTCB );
664:               				xReturn = pdPASS;
665:               			}
666:               		}
667:               
668:               		return xReturn;
669:               	}
670:               
671:               #endif /* portUSING_MPU_WRAPPERS */
672:               /*-----------------------------------------------------------*/
673:               
674:               #if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
675:               
676:               	BaseType_t xTaskCreate(	TaskFunction_t pxTaskCode,
677:               							const char * const pcName,
678:               							const uint16_t usStackDepth,
679:               							void * const pvParameters,
680:               							UBaseType_t uxPriority,
681:               							TaskHandle_t * const pxCreatedTask ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
682:               	{
0012C4  BE9F88     MOV.D W8, [W15++]
0012C6  BE9F8A     MOV.D W10, [W15++]
0012C8  BE9F8C     MOV.D W12, [W15++]
0012CA  781F8E     MOV W14, [W15++]
0012CC  780700     MOV W0, W14
0012CE  780681     MOV W1, W13
0012D0  780482     MOV W2, W9
0012D2  780603     MOV W3, W12
0012D4  780584     MOV W4, W11
0012D6  780505     MOV W5, W10
683:               	TCB_t *pxNewTCB;
684:               	BaseType_t xReturn;
685:               
686:               		/* If the stack grows down then allocate the stack then the TCB so the stack
687:               		does not grow into the TCB.  Likewise if the stack grows up then allocate
688:               		the TCB then the stack. */
689:               		#if( portSTACK_GROWTH > 0 )
690:               		{
691:               			/* Allocate space for the TCB.  Where the memory comes from depends on
692:               			the implementation of the port malloc function and whether or not static
693:               			allocation is being used. */
694:               			pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
0012D8  200260     MOV #0x26, W0
0012DA  022E18     CALL pvPortMalloc
0012DC  000000     NOP
0012DE  780400     MOV W0, W8
695:               
696:               			if( pxNewTCB != NULL )
0012E2  E00008     CP0 W8
0012E4  32000A     BRA Z, .L79
697:               			{
698:               				/* Allocate space for the stack used by the task being created.
699:               				The base of the stack memory stored in the TCB so the task can
700:               				be deleted later if required. */
701:               				pxNewTCB->pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
0012E6  448009     ADD W9, W9, W0
0012E8  022E18     CALL pvPortMalloc
0012EA  000000     NOP
0012EC  980C40     MOV W0, [W8+24]
702:               
703:               				if( pxNewTCB->pxStack == NULL )
0012EE  E00000     CP0 W0
0012F0  3A0009     BRA NZ, .L80
704:               				{
705:               					/* Could not allocate the stack.  Delete the allocated TCB. */
706:               					vPortFree( pxNewTCB );
0012F2  780008     MOV W8, W0
0012F4  022E52     CALL vPortFree
0012F6  000000     NOP
707:               					pxNewTCB = NULL;
708:               				}
709:               			}
710:               		}
711:               		#else /* portSTACK_GROWTH */
712:               		{
713:               		StackType_t *pxStack;
714:               
715:               			/* Allocate space for the stack used by the task being created. */
716:               			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
717:               
718:               			if( pxStack != NULL )
719:               			{
720:               				/* Allocate space for the TCB. */
721:               				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e961 MISRA exception as the casts are only redundant for some paths. */
722:               
723:               				if( pxNewTCB != NULL )
724:               				{
725:               					/* Store the stack location in the TCB. */
726:               					pxNewTCB->pxStack = pxStack;
727:               				}
728:               				else
729:               				{
730:               					/* The stack cannot be used as the TCB was not created.  Free
731:               					it again. */
732:               					vPortFree( pxStack );
733:               				}
734:               			}
735:               			else
736:               			{
737:               				pxNewTCB = NULL;
738:               			}
739:               		}
740:               		#endif /* portSTACK_GROWTH */
741:               
742:               		if( pxNewTCB != NULL )
743:               		{
744:               			#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 )
745:               			{
746:               				/* Tasks can be created statically or dynamically, so note this
747:               				task was created dynamically in case it is later deleted. */
748:               				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
749:               			}
750:               			#endif /* configSUPPORT_STATIC_ALLOCATION */
751:               
752:               			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
001304  B84961     MUL.UU W9, #1, W2
001306  EB1F80     CLR [W15++]
001308  780388     MOV W8, W7
00130A  78030A     MOV W10, W6
00130C  78028B     MOV W11, W5
00130E  78020C     MOV W12, W4
001310  78008D     MOV W13, W1
001312  78000E     MOV W14, W0
001314  07FDD7     RCALL prvInitialiseNewTask
753:               			prvAddNewTaskToReadyList( pxNewTCB );
001316  780008     MOV W8, W0
001318  07FFA7     RCALL prvAddNewTaskToReadyList
00131A  E9878F     DEC2 W15, W15
754:               			xReturn = pdPASS;
00131C  200010     MOV #0x1, W0
00131E  37FFED     BRA .L79
755:               		}
756:               		else
757:               		{
758:               			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
0012E0  EB8000     SETM W0
0012F8  EB8000     SETM W0
759:               		}
760:               
761:               		return xReturn;
762:               	}
0012FA  78074F     MOV [--W15], W14
0012FC  BE064F     MOV.D [--W15], W12
0012FE  BE054F     MOV.D [--W15], W10
001300  BE044F     MOV.D [--W15], W8
001302  060000     RETURN
001304  B84961     MUL.UU W9, #1, W2
001306  EB1F80     CLR [W15++]
001308  780388     MOV W8, W7
00130A  78030A     MOV W10, W6
00130C  78028B     MOV W11, W5
00130E  78020C     MOV W12, W4
001310  78008D     MOV W13, W1
001312  78000E     MOV W14, W0
001314  07FDD7     RCALL prvInitialiseNewTask
001316  780008     MOV W8, W0
001318  07FFA7     RCALL prvAddNewTaskToReadyList
00131A  E9878F     DEC2 W15, W15
00131C  200010     MOV #0x1, W0
00131E  37FFED     BRA .L79
763:               
764:               #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
765:               /*-----------------------------------------------------------*/
766:               
767:               static void prvInitialiseNewTask( 	TaskFunction_t pxTaskCode,
000EF8  44007A     ADD W8, #0x1A, W0
000EFA  4500E3     ADD W10, #0x3, W1
768:               									const char * const pcName,
769:               									const uint32_t ulStackDepth,
770:               									void * const pvParameters,
771:               									UBaseType_t uxPriority,
772:               									TaskHandle_t * const pxCreatedTask,
773:               									TCB_t *pxNewTCB,
774:               									const MemoryRegion_t * const xRegions ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
775:               {
000EC4  4787E4     ADD W15, #0x4, W15
000EC6  BE9F88     MOV.D W8, [W15++]
000EC8  BE9F8A     MOV.D W10, [W15++]
000ECA  BE9F8C     MOV.D W12, [W15++]
000ECC  781F8E     MOV W14, [W15++]
000ECE  9FBF80     MOV W0, [W15-16]
000ED0  780501     MOV W1, W10
000ED2  780704     MOV W4, W14
000ED4  780685     MOV W5, W13
000ED6  780606     MOV W6, W12
000ED8  780407     MOV W7, W8
776:               StackType_t *pxTopOfStack;
777:               UBaseType_t x;
778:               
779:               	#if( portUSING_MPU_WRAPPERS == 1 )
780:               		/* Should the task be created in privileged mode? */
781:               		BaseType_t xRunPrivileged;
782:               		if( ( uxPriority & portPRIVILEGE_BIT ) != 0U )
783:               		{
784:               			xRunPrivileged = pdTRUE;
785:               		}
786:               		else
787:               		{
788:               			xRunPrivileged = pdFALSE;
789:               		}
790:               		uxPriority &= ~portPRIVILEGE_BIT;
791:               	#endif /* portUSING_MPU_WRAPPERS == 1 */
792:               
793:               	/* Avoid dependency on memset() if it is not required. */
794:               	#if( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
795:               	{
796:               		/* Fill the stack with a known value to assist debugging. */
797:               		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
000EDA  780482     MOV W2, W9
000EDC  448109     ADD W9, W9, W2
000EDE  900848     MOV [W8+24], W0
000EE0  200A51     MOV #0xA5, W1
000EE2  020D2A     CALL _memset
000EE4  000000     NOP
798:               	}
799:               	#endif /* ( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) ) ) */
800:               
801:               	/* Calculate the top of stack address.  This depends on whether the stack
802:               	grows from high memory to low (as per the 80x86) or vice versa.
803:               	portSTACK_GROWTH is used to make the result positive or negative as required
804:               	by the port. */
805:               	#if( portSTACK_GROWTH < 0 )
806:               	{
807:               		pxTopOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
808:               		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type. */
809:               
810:               		/* Check the alignment of the calculated top of stack is correct. */
811:               		configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack & ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
812:               	}
813:               	#else /* portSTACK_GROWTH */
814:               	{
815:               		pxTopOfStack = pxNewTCB->pxStack;
000EE6  900DC8     MOV [W8+24], W11
816:               
817:               		/* Check the alignment of the stack buffer is correct. */
818:               		configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxNewTCB->pxStack & ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
819:               
820:               		/* The other extreme of the stack space is required if stack checking is
821:               		performed. */
822:               		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
000EE8  D00489     SL W9, W9
000EEA  E98489     DEC2 W9, W9
000EEC  458489     ADD W11, W9, W9
000EEE  980C79     MOV W9, [W8+30]
823:               	}
824:               	#endif /* portSTACK_GROWTH */
825:               
826:               	/* Store the task name in the TCB. */
827:               	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
000F02  550F81     SUB W10, W1, [W15]
000F04  3AFFFB     BRA NZ, .L6
828:               	{
829:               		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
000EF0  78401A     MOV.B [W10], W0
000EF2  985C20     MOV.B W0, [W8+26]
000EFC  78685A     MOV.B [++W10], [++W0]
830:               
831:               		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
832:               		configMAX_TASK_NAME_LEN characters just in case the memory after the
833:               		string is not accessible (extremely unlikely). */
834:               		if( pcName[ x ] == 0x00 )
000EF4  E0041A     CP0.B [W10]
000EF6  320007     BRA Z, .L5
000EFE  E0041A     CP0.B [W10]
000F00  320002     BRA Z, .L5
835:               		{
836:               			break;
837:               		}
838:               		else
839:               		{
840:               			mtCOVERAGE_TEST_MARKER();
841:               		}
842:               	}
843:               
844:               	/* Ensure the name string is terminated in the case that the string length
845:               	was greater or equal to configMAX_TASK_NAME_LEN. */
846:               	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
000F06  EB4000     CLR.B W0
000F08  985C50     MOV.B W0, [W8+29]
000F0A  78048D     MOV W13, W9
000F0C  548FE3     SUB W9, #0x3, [W15]
000F0E  360001     BRA LEU, .L7
000F10  200039     MOV #0x3, W9
847:               
848:               	/* This is used as an array index so must ensure it's not too large.  First
849:               	remove the privilege bit if one is present. */
850:               	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
851:               	{
852:               		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
853:               	}
854:               	else
855:               	{
856:               		mtCOVERAGE_TEST_MARKER();
857:               	}
858:               
859:               	pxNewTCB->uxPriority = uxPriority;
000F12  980C39     MOV W9, [W8+22]
860:               	#if ( configUSE_MUTEXES == 1 )
861:               	{
862:               		pxNewTCB->uxBasePriority = uxPriority;
863:               		pxNewTCB->uxMutexesHeld = 0;
864:               	}
865:               	#endif /* configUSE_MUTEXES */
866:               
867:               	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
000F14  E88008     INC2 W8, W0
000F16  022D0A     CALL vListInitialiseItem
000F18  000000     NOP
868:               	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
000F1A  44006C     ADD W8, #0xC, W0
000F1C  022D0A     CALL vListInitialiseItem
000F1E  000000     NOP
869:               
870:               	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
871:               	back to	the containing TCB from a generic item in a list. */
872:               	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
000F20  980448     MOV W8, [W8+8]
873:               
874:               	/* Event lists are always in priority order. */
875:               	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
000F22  1484E4     SUBR W9, #0x4, W9
000F24  980469     MOV W9, [W8+12]
876:               	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
000F26  980C18     MOV W8, [W8+18]
877:               
878:               	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
879:               	{
880:               		pxNewTCB->uxCriticalNesting = ( UBaseType_t ) 0U;
881:               	}
882:               	#endif /* portCRITICAL_NESTING_IN_TCB */
883:               
884:               	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
885:               	{
886:               		pxNewTCB->pxTaskTag = NULL;
887:               	}
888:               	#endif /* configUSE_APPLICATION_TASK_TAG */
889:               
890:               	#if ( configGENERATE_RUN_TIME_STATS == 1 )
891:               	{
892:               		pxNewTCB->ulRunTimeCounter = 0UL;
893:               	}
894:               	#endif /* configGENERATE_RUN_TIME_STATS */
895:               
896:               	#if ( portUSING_MPU_WRAPPERS == 1 )
897:               	{
898:               		vPortStoreTaskMPUSettings( &( pxNewTCB->xMPUSettings ), xRegions, pxNewTCB->pxStack, ulStackDepth );
899:               	}
900:               	#else
901:               	{
902:               		/* Avoid compiler warning about unreferenced parameter. */
903:               		( void ) xRegions;
904:               	}
905:               	#endif
906:               
907:               	#if( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
908:               	{
909:               		for( x = 0; x < ( UBaseType_t ) configNUM_THREAD_LOCAL_STORAGE_POINTERS; x++ )
910:               		{
911:               			pxNewTCB->pvThreadLocalStoragePointers[ x ] = NULL;
912:               		}
913:               	}
914:               	#endif
915:               
916:               	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
917:               	{
918:               		pxNewTCB->ulNotifiedValue = 0;
000F28  B80060     MUL.UU W0, #0, W0
000F2A  981400     MOV W0, [W8+32]
000F2C  981411     MOV W1, [W8+34]
919:               		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
000F2E  EB4000     CLR.B W0
000F30  986440     MOV.B W0, [W8+36]
920:               	}
921:               	#endif
922:               
923:               	#if ( configUSE_NEWLIB_REENTRANT == 1 )
924:               	{
925:               		/* Initialise this task's Newlib reent structure. */
926:               		_REENT_INIT_PTR( ( &( pxNewTCB->xNewLib_reent ) ) );
927:               	}
928:               	#endif
929:               
930:               	#if( INCLUDE_xTaskAbortDelay == 1 )
931:               	{
932:               		pxNewTCB->ucDelayAborted = pdFALSE;
933:               	}
934:               	#endif
935:               
936:               	/* Initialize the TCB stack to look as if the task was already running,
937:               	but had been interrupted by the scheduler.  The return address is set
938:               	to the start of the task function. Once the stack has been initialised
939:               	the	top of stack variable is updated. */
940:               	#if( portUSING_MPU_WRAPPERS == 1 )
941:               	{
942:               		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
943:               	}
944:               	#else /* portUSING_MPU_WRAPPERS */
945:               	{
946:               		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
000F32  78010E     MOV W14, W2
000F34  97B88F     MOV [W15-16], W1
000F36  78000B     MOV W11, W0
000F38  022B28     CALL pxPortInitialiseStack
000F3A  000000     NOP
000F3C  780C00     MOV W0, [W8]
947:               	}
948:               	#endif /* portUSING_MPU_WRAPPERS */
949:               
950:               	if( ( void * ) pxCreatedTask != NULL )
000F3E  E0000C     CP0 W12
000F40  320001     BRA Z, .L4
951:               	{
952:               		/* Pass the handle out in an anonymous way.  The handle can be used to
953:               		change the created task's priority, delete the created task, etc.*/
954:               		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
000F42  780E08     MOV W8, [W12]
955:               	}
956:               	else
957:               	{
958:               		mtCOVERAGE_TEST_MARKER();
959:               	}
960:               }
000F44  78074F     MOV [--W15], W14
000F46  BE064F     MOV.D [--W15], W12
000F48  BE054F     MOV.D [--W15], W10
000F4A  BE044F     MOV.D [--W15], W8
000F4C  B1004F     SUB #0x4, W15
000F4E  060000     RETURN
961:               /*-----------------------------------------------------------*/
962:               
963:               static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
964:               {
001268  781F88     MOV W8, [W15++]
00126A  780400     MOV W0, W8
965:               	/* Ensure interrupts don't access the task lists while the lists are being
966:               	updated. */
967:               	taskENTER_CRITICAL();
00126C  022BB0     CALL vPortEnterCritical
00126E  000000     NOP
968:               	{
969:               		uxCurrentNumberOfTasks++;
001270  EC2852     INC uxCurrentNumberOfTasks
970:               		if( pxCurrentTCB == NULL )
001272  E20850     CP0 pxCurrentTCB
001274  3A0006     BRA NZ, .L74
971:               		{
972:               			/* There are no other tasks, or all the other tasks are in
973:               			the suspended state - make this the current task. */
974:               			pxCurrentTCB = pxNewTCB;
001276  884288     MOV W8, pxCurrentTCB
975:               
976:               			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
001278  804290     MOV uxCurrentNumberOfTasks, W0
00127A  500FE1     SUB W0, #0x1, [W15]
977:               			{
978:               				/* This is the first task to be created so do the preliminary
979:               				initialisation required.  We will not recover if this call
980:               				fails, but we will report the failure. */
981:               				prvInitialiseTaskLists();
00127C  3A000A     BRA NZ, .L75
00127E  07FFD8     RCALL prvInitialiseTaskLists
001280  370008     BRA .L75
982:               			}
983:               			else
984:               			{
985:               				mtCOVERAGE_TEST_MARKER();
986:               			}
987:               		}
988:               		else
989:               		{
990:               			/* If the scheduler is not already running, make this task the
991:               			current task if it is the highest priority task to be created
992:               			so far. */
993:               			if( xSchedulerRunning == pdFALSE )
001282  E20858     CP0 xSchedulerRunning
001284  3A0006     BRA NZ, .L75
994:               			{
995:               				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
001286  804280     MOV pxCurrentTCB, W0
001288  9008B0     MOV [W0+22], W1
00128A  900838     MOV [W8+22], W0
00128C  508F80     SUB W1, W0, [W15]
00128E  3E0001     BRA GTU, .L75
996:               				{
997:               					pxCurrentTCB = pxNewTCB;
001290  884288     MOV W8, pxCurrentTCB
998:               				}
999:               				else
1000:              				{
1001:              					mtCOVERAGE_TEST_MARKER();
1002:              				}
1003:              			}
1004:              			else
1005:              			{
1006:              				mtCOVERAGE_TEST_MARKER();
1007:              			}
1008:              		}
1009:              
1010:              		uxTaskNumber++;
001292  EC2860     INC uxTaskNumber
1011:              
1012:              		#if ( configUSE_TRACE_FACILITY == 1 )
1013:              		{
1014:              			/* Add a counter into the TCB for tracing only. */
1015:              			pxNewTCB->uxTCBNumber = uxTaskNumber;
1016:              		}
1017:              		#endif /* configUSE_TRACE_FACILITY */
1018:              		traceTASK_CREATE( pxNewTCB );
1019:              
1020:              		prvAddTaskToReadyList( pxNewTCB );
001294  900838     MOV [W8+22], W0
001296  E30856     CP uxTopReadyPriority
001298  310001     BRA C, .L76
00129A  8842B0     MOV W0, uxTopReadyPriority
00129C  E88088     INC2 W8, W1
00129E  B9016A     MUL.SU W0, #10, W2
0012A0  21CF80     MOV #0x1CF8, W0
0012A2  400002     ADD W0, W2, W0
0012A4  022D10     CALL vListInsertEnd
0012A6  000000     NOP
1021:              
1022:              		portSETUP_TCB( pxNewTCB );
1023:              	}
1024:              	taskEXIT_CRITICAL();
0012A8  022BC0     CALL vPortExitCritical
0012AA  000000     NOP
1025:              
1026:              	if( xSchedulerRunning != pdFALSE )
0012AC  E20858     CP0 xSchedulerRunning
0012AE  320008     BRA Z, .L73
1027:              	{
1028:              		/* If the created task is of a higher priority than the current task
1029:              		then it should run now. */
1030:              		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
0012B0  804280     MOV pxCurrentTCB, W0
0012B2  9008B0     MOV [W0+22], W1
0012B4  900838     MOV [W8+22], W0
0012B6  508F80     SUB W1, W0, [W15]
0012B8  310003     BRA C, .L73
1031:              		{
1032:              			taskYIELD_IF_USING_PREEMPTION();
0012BA  022DC4     CALL .Letext0, .LFE2, _vPortYield
0012BC  000000     NOP
0012BE  000000     NOP
1033:              		}
1034:              		else
1035:              		{
1036:              			mtCOVERAGE_TEST_MARKER();
1037:              		}
1038:              	}
1039:              	else
1040:              	{
1041:              		mtCOVERAGE_TEST_MARKER();
1042:              	}
1043:              }
0012C0  78044F     MOV [--W15], W8
0012C2  060000     RETURN
1044:              /*-----------------------------------------------------------*/
1045:              
1046:              #if ( INCLUDE_vTaskDelete == 1 )
1047:              
1048:              	void vTaskDelete( TaskHandle_t xTaskToDelete )
1049:              	{
1050:              	TCB_t *pxTCB;
1051:              
1052:              		taskENTER_CRITICAL();
1053:              		{
1054:              			/* If null is passed in here then it is the calling task that is
1055:              			being deleted. */
1056:              			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
1057:              
1058:              			/* Remove task from the ready list. */
1059:              			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
1060:              			{
1061:              				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
1062:              			}
1063:              			else
1064:              			{
1065:              				mtCOVERAGE_TEST_MARKER();
1066:              			}
1067:              
1068:              			/* Is the task waiting on an event also? */
1069:              			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
1070:              			{
1071:              				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
1072:              			}
1073:              			else
1074:              			{
1075:              				mtCOVERAGE_TEST_MARKER();
1076:              			}
1077:              
1078:              			/* Increment the uxTaskNumber also so kernel aware debuggers can
1079:              			detect that the task lists need re-generating.  This is done before
1080:              			portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
1081:              			not return. */
1082:              			uxTaskNumber++;
1083:              
1084:              			if( pxTCB == pxCurrentTCB )
1085:              			{
1086:              				/* A task is deleting itself.  This cannot complete within the
1087:              				task itself, as a context switch to another task is required.
1088:              				Place the task in the termination list.  The idle task will
1089:              				check the termination list and free up any memory allocated by
1090:              				the scheduler for the TCB and stack of the deleted task. */
1091:              				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
1092:              
1093:              				/* Increment the ucTasksDeleted variable so the idle task knows
1094:              				there is a task that has been deleted and that it should therefore
1095:              				check the xTasksWaitingTermination list. */
1096:              				++uxDeletedTasksWaitingCleanUp;
1097:              
1098:              				/* The pre-delete hook is primarily for the Windows simulator,
1099:              				in which Windows specific clean up operations are performed,
1100:              				after which it is not possible to yield away from this task -
1101:              				hence xYieldPending is used to latch that a context switch is
1102:              				required. */
1103:              				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
1104:              			}
1105:              			else
1106:              			{
1107:              				--uxCurrentNumberOfTasks;
1108:              				prvDeleteTCB( pxTCB );
1109:              
1110:              				/* Reset the next expected unblock time in case it referred to
1111:              				the task that has just been deleted. */
1112:              				prvResetNextTaskUnblockTime();
1113:              			}
1114:              
1115:              			traceTASK_DELETE( pxTCB );
1116:              		}
1117:              		taskEXIT_CRITICAL();
1118:              
1119:              		/* Force a reschedule if it is the currently running task that has just
1120:              		been deleted. */
1121:              		if( xSchedulerRunning != pdFALSE )
1122:              		{
1123:              			if( pxTCB == pxCurrentTCB )
1124:              			{
1125:              				configASSERT( uxSchedulerSuspended == 0 );
1126:              				portYIELD_WITHIN_API();
1127:              			}
1128:              			else
1129:              			{
1130:              				mtCOVERAGE_TEST_MARKER();
1131:              			}
1132:              		}
1133:              	}
1134:              
1135:              #endif /* INCLUDE_vTaskDelete */
1136:              /*-----------------------------------------------------------*/
1137:              
1138:              #if ( INCLUDE_vTaskDelayUntil == 1 )
1139:              
1140:              	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
1141:              	{
001888  BE9F88     MOV.D W8, [W15++]
1142:              	TickType_t xTimeToWake;
1143:              	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
1144:              
1145:              		configASSERT( pxPreviousWakeTime );
1146:              		configASSERT( ( xTimeIncrement > 0U ) );
1147:              		configASSERT( uxSchedulerSuspended == 0 );
1148:              
1149:              		vTaskSuspendAll();
00188A  BE0400     MOV.D W0, W8
00188C  07FC0E     RCALL vTaskSuspendAll
1150:              		{
1151:              			/* Minor optimisation.  The tick count cannot change in this
1152:              			block. */
1153:              			const TickType_t xConstTickCount = xTickCount;
00188E  8042A0     MOV xTickCount, W0
1154:              
1155:              			/* Generate the tick time at which the task wants to wake. */
1156:              			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
001890  780098     MOV [W8], W1
001892  448481     ADD W9, W1, W9
1157:              
1158:              			if( xConstTickCount < *pxPreviousWakeTime )
001894  500F81     SUB W0, W1, [W15]
001896  310006     BRA C, .L199
1159:              			{
1160:              				/* The tick count has overflowed since this function was
1161:              				lasted called.  In this case the only time we should ever
1162:              				actually delay is if the wake time has also	overflowed,
1163:              				and the wake time is greater than the tick time.  When this
1164:              				is the case it is as if neither time had overflowed. */
1165:              				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
001898  508F89     SUB W1, W9, [W15]
00189A  360015     BRA LEU, .L200
1166:              				{
1167:              					xShouldDelay = pdTRUE;
1168:              				}
1169:              				else
1170:              				{
1171:              					mtCOVERAGE_TEST_MARKER();
1172:              				}
1173:              			}
1174:              			else
1175:              			{
1176:              				/* The tick time has not overflowed.  In this case we will
1177:              				delay if either the wake time has overflowed, and/or the
1178:              				tick time is less than the wake time. */
1179:              				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
0018A4  508F89     SUB W1, W9, [W15]
0018A6  3E000D     BRA GTU, .L203
0018A8  500F89     SUB W0, W9, [W15]
0018AA  39000B     BRA NC, .L203
0018AC  37000C     BRA .L200
1180:              				{
1181:              					xShouldDelay = pdTRUE;
1182:              				}
1183:              				else
1184:              				{
1185:              					mtCOVERAGE_TEST_MARKER();
1186:              				}
1187:              			}
1188:              
1189:              			/* Update the wake time ready for the next call. */
1190:              			*pxPreviousWakeTime = xTimeToWake;
00189C  780C09     MOV W9, [W8]
0018C2  780C09     MOV W9, [W8]
0018C4  37FFF4     BRA .L201
0018C6  780C09     MOV W9, [W8]
0018C8  37FFF5     BRA .L202, .LBE11
1191:              
1192:              			if( xShouldDelay != pdFALSE )
00189E  500F89     SUB W0, W9, [W15]
0018A0  310009     BRA C, .L202, .LBE11
0018A2  370005     BRA .L201
1193:              			{
1194:              				traceTASK_DELAY_UNTIL( xTimeToWake );
1195:              
1196:              				/* prvAddCurrentTaskToDelayedList() needs the block time, not
1197:              				the time to wake, so subtract the current tick count. */
1198:              				prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
0018AE  548000     SUB W9, W0, W0
0018B0  EB0080     CLR W1
1199:              			}
1200:              			else
1201:              			{
1202:              				mtCOVERAGE_TEST_MARKER();
1203:              			}
1204:              		}
1205:              		xAlreadyYielded = xTaskResumeAll();
0018B2  07FF12     RCALL prvAddCurrentTaskToDelayedList
0018B4  07FDA9     RCALL xTaskResumeAll
1206:              
1207:              		/* Force a reschedule if xTaskResumeAll has not already done so, we may
1208:              		have put ourselves to sleep. */
1209:              		if( xAlreadyYielded == pdFALSE )
0018B6  E00000     CP0 W0
0018B8  3A0008     BRA NZ, .L198
1210:              		{
1211:              			portYIELD_WITHIN_API();
0018BA  022DC4     CALL .Letext0, .LFE2, _vPortYield
0018BC  000000     NOP
0018BE  000000     NOP
0018C0  370004     BRA .L198
1212:              		}
1213:              		else
1214:              		{
1215:              			mtCOVERAGE_TEST_MARKER();
1216:              		}
1217:              	}
0018CA  BE044F     MOV.D [--W15], W8
0018CC  060000     RETURN
1218:              
1219:              #endif /* INCLUDE_vTaskDelayUntil */
1220:              /*-----------------------------------------------------------*/
1221:              
1222:              #if ( INCLUDE_vTaskDelay == 1 )
1223:              
1224:              	void vTaskDelay( const TickType_t xTicksToDelay )
1225:              	{
001868  781F88     MOV W8, [W15++]
00186A  780400     MOV W0, W8
1226:              	BaseType_t xAlreadyYielded = pdFALSE;
1227:              
1228:              		/* A delay time of zero just forces a reschedule. */
1229:              		if( xTicksToDelay > ( TickType_t ) 0U )
00186C  E00008     CP0 W8
1230:              		{
1231:              			configASSERT( uxSchedulerSuspended == 0 );
1232:              			vTaskSuspendAll();
00186E  320007     BRA Z, .L196
001870  07FC1C     RCALL vTaskSuspendAll
1233:              			{
1234:              				traceTASK_DELAY();
1235:              
1236:              				/* A task that is removed from the event list while the
1237:              				scheduler is suspended will not get placed in the ready
1238:              				list or removed from the blocked list until the scheduler
1239:              				is resumed.
1240:              
1241:              				This task cannot be in an event list as it is the currently
1242:              				executing task. */
1243:              				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
001872  EB0080     CLR W1
001874  780008     MOV W8, W0
1244:              			}
1245:              			xAlreadyYielded = xTaskResumeAll();
001876  07FF30     RCALL prvAddCurrentTaskToDelayedList
001878  07FDC7     RCALL xTaskResumeAll
1246:              		}
1247:              		else
1248:              		{
1249:              			mtCOVERAGE_TEST_MARKER();
1250:              		}
1251:              
1252:              		/* Force a reschedule if xTaskResumeAll has not already done so, we may
1253:              		have put ourselves to sleep. */
1254:              		if( xAlreadyYielded == pdFALSE )
00187A  E00000     CP0 W0
00187C  3A0003     BRA NZ, .L195
1255:              		{
1256:              			portYIELD_WITHIN_API();
00187E  022DC4     CALL .Letext0, .LFE2, _vPortYield
001880  000000     NOP
001882  000000     NOP
1257:              		}
1258:              		else
1259:              		{
1260:              			mtCOVERAGE_TEST_MARKER();
1261:              		}
1262:              	}
001884  78044F     MOV [--W15], W8
001886  060000     RETURN
1263:              
1264:              #endif /* INCLUDE_vTaskDelay */
1265:              /*-----------------------------------------------------------*/
1266:              
1267:              #if( ( INCLUDE_eTaskGetState == 1 ) || ( configUSE_TRACE_FACILITY == 1 ) )
1268:              
1269:              	eTaskState eTaskGetState( TaskHandle_t xTask )
1270:              	{
1271:              	eTaskState eReturn;
1272:              	List_t *pxStateList;
1273:              	const TCB_t * const pxTCB = ( TCB_t * ) xTask;
1274:              
1275:              		configASSERT( pxTCB );
1276:              
1277:              		if( pxTCB == pxCurrentTCB )
1278:              		{
1279:              			/* The task calling this function is querying its own state. */
1280:              			eReturn = eRunning;
1281:              		}
1282:              		else
1283:              		{
1284:              			taskENTER_CRITICAL();
1285:              			{
1286:              				pxStateList = ( List_t * ) listLIST_ITEM_CONTAINER( &( pxTCB->xStateListItem ) );
1287:              			}
1288:              			taskEXIT_CRITICAL();
1289:              
1290:              			if( ( pxStateList == pxDelayedTaskList ) || ( pxStateList == pxOverflowDelayedTaskList ) )
1291:              			{
1292:              				/* The task being queried is referenced from one of the Blocked
1293:              				lists. */
1294:              				eReturn = eBlocked;
1295:              			}
1296:              
1297:              			#if ( INCLUDE_vTaskSuspend == 1 )
1298:              				else if( pxStateList == &xSuspendedTaskList )
1299:              				{
1300:              					/* The task being queried is referenced from the suspended
1301:              					list.  Is it genuinely suspended or is it block
1302:              					indefinitely? */
1303:              					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL )
1304:              					{
1305:              						eReturn = eSuspended;
1306:              					}
1307:              					else
1308:              					{
1309:              						eReturn = eBlocked;
1310:              					}
1311:              				}
1312:              			#endif
1313:              
1314:              			#if ( INCLUDE_vTaskDelete == 1 )
1315:              				else if( ( pxStateList == &xTasksWaitingTermination ) || ( pxStateList == NULL ) )
1316:              				{
1317:              					/* The task being queried is referenced from the deleted
1318:              					tasks list, or it is not referenced from any lists at
1319:              					all. */
1320:              					eReturn = eDeleted;
1321:              				}
1322:              			#endif
1323:              
1324:              			else /*lint !e525 Negative indentation is intended to make use of pre-processor clearer. */
1325:              			{
1326:              				/* If the task is not in any other state, it must be in the
1327:              				Ready (including pending ready) state. */
1328:              				eReturn = eReady;
1329:              			}
1330:              		}
1331:              
1332:              		return eReturn;
1333:              	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
1334:              
1335:              #endif /* INCLUDE_eTaskGetState */
1336:              /*-----------------------------------------------------------*/
1337:              
1338:              #if ( INCLUDE_uxTaskPriorityGet == 1 )
1339:              
1340:              	UBaseType_t uxTaskPriorityGet( TaskHandle_t xTask )
1341:              	{
1342:              	TCB_t *pxTCB;
1343:              	UBaseType_t uxReturn;
1344:              
1345:              		taskENTER_CRITICAL();
1346:              		{
1347:              			/* If null is passed in here then it is the priority of the that
1348:              			called uxTaskPriorityGet() that is being queried. */
1349:              			pxTCB = prvGetTCBFromHandle( xTask );
1350:              			uxReturn = pxTCB->uxPriority;
1351:              		}
1352:              		taskEXIT_CRITICAL();
1353:              
1354:              		return uxReturn;
1355:              	}
1356:              
1357:              #endif /* INCLUDE_uxTaskPriorityGet */
1358:              /*-----------------------------------------------------------*/
1359:              
1360:              #if ( INCLUDE_uxTaskPriorityGet == 1 )
1361:              
1362:              	UBaseType_t uxTaskPriorityGetFromISR( TaskHandle_t xTask )
1363:              	{
1364:              	TCB_t *pxTCB;
1365:              	UBaseType_t uxReturn, uxSavedInterruptState;
1366:              
1367:              		/* RTOS ports that support interrupt nesting have the concept of a
1368:              		maximum	system call (or maximum API call) interrupt priority.
1369:              		Interrupts that are	above the maximum system call priority are keep
1370:              		permanently enabled, even when the RTOS kernel is in a critical section,
1371:              		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
1372:              		is defined in FreeRTOSConfig.h then
1373:              		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1374:              		failure if a FreeRTOS API function is called from an interrupt that has
1375:              		been assigned a priority above the configured maximum system call
1376:              		priority.  Only FreeRTOS functions that end in FromISR can be called
1377:              		from interrupts	that have been assigned a priority at or (logically)
1378:              		below the maximum system call interrupt priority.  FreeRTOS maintains a
1379:              		separate interrupt safe API to ensure interrupt entry is as fast and as
1380:              		simple as possible.  More information (albeit Cortex-M specific) is
1381:              		provided on the following link:
1382:              		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1383:              		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1384:              
1385:              		uxSavedInterruptState = portSET_INTERRUPT_MASK_FROM_ISR();
1386:              		{
1387:              			/* If null is passed in here then it is the priority of the calling
1388:              			task that is being queried. */
1389:              			pxTCB = prvGetTCBFromHandle( xTask );
1390:              			uxReturn = pxTCB->uxPriority;
1391:              		}
1392:              		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptState );
1393:              
1394:              		return uxReturn;
1395:              	}
1396:              
1397:              #endif /* INCLUDE_uxTaskPriorityGet */
1398:              /*-----------------------------------------------------------*/
1399:              
1400:              #if ( INCLUDE_vTaskPrioritySet == 1 )
1401:              
1402:              	void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority )
1403:              	{
000F50  BE9F88     MOV.D W8, [W15++]
000F52  781F8A     MOV W10, [W15++]
000F54  BE0400     MOV.D W0, W8
1404:              	TCB_t *pxTCB;
1405:              	UBaseType_t uxCurrentBasePriority, uxPriorityUsedOnEntry;
1406:              	BaseType_t xYieldRequired = pdFALSE;
000F56  548FE3     SUB W9, #0x3, [W15]
000F58  360001     BRA LEU, .L11
000F5A  200039     MOV #0x3, W9
000F6E  EB0500     CLR W10
1407:              
1408:              		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );
1409:              
1410:              		/* Ensure the new priority is valid. */
1411:              		if( uxNewPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
1412:              		{
1413:              			uxNewPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
1414:              		}
1415:              		else
1416:              		{
1417:              			mtCOVERAGE_TEST_MARKER();
1418:              		}
1419:              
1420:              		taskENTER_CRITICAL();
000F5C  022BB0     CALL vPortEnterCritical
000F5E  000000     NOP
1421:              		{
1422:              			/* If null is passed in here then it is the priority of the calling
1423:              			task that is being changed. */
1424:              			pxTCB = prvGetTCBFromHandle( xTask );
000F60  E00008     CP0 W8
000F62  3A0001     BRA NZ, .L13
000F64  804288     MOV pxCurrentTCB, W8
1425:              
1426:              			traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );
1427:              
1428:              			#if ( configUSE_MUTEXES == 1 )
1429:              			{
1430:              				uxCurrentBasePriority = pxTCB->uxBasePriority;
1431:              			}
1432:              			#else
1433:              			{
1434:              				uxCurrentBasePriority = pxTCB->uxPriority;
000F66  900838     MOV [W8+22], W0
1435:              			}
1436:              			#endif
1437:              
1438:              			if( uxCurrentBasePriority != uxNewPriority )
000F68  500F89     SUB W0, W9, [W15]
000F6A  320031     BRA Z, .L14
1439:              			{
1440:              				/* The priority change may have readied a task of higher
1441:              				priority than the calling task. */
1442:              				if( uxNewPriority > uxCurrentBasePriority )
000F6C  31000B     BRA C, .L15
1443:              				{
1444:              					if( pxTCB != pxCurrentTCB )
000F70  804281     MOV pxCurrentTCB, W1
000F72  508F88     SUB W1, W8, [W15]
000F74  32000D     BRA Z, .L16
1445:              					{
1446:              						/* The priority of a task other than the currently
1447:              						running task is being raised.  Is the priority being
1448:              						raised above that of the running task? */
1449:              						if( uxNewPriority >= pxCurrentTCB->uxPriority )
000F76  804281     MOV pxCurrentTCB, W1
1450:              						{
1451:              							xYieldRequired = pdTRUE;
000F78  20001A     MOV #0x1, W10
000F7A  9008B1     MOV [W1+22], W1
000F7C  508F89     SUB W1, W9, [W15]
000F7E  360008     BRA LEU, .L16
000F80  EB0500     CLR W10
000F82  370006     BRA .L16
000F84  804281     MOV pxCurrentTCB, W1
000F86  688508     XOR W1, W8, W10
000F88  A7F00A     BTSC W10, #15
000F8A  EA050A     NEG W10, W10
000F8C  E9050A     DEC W10, W10
000F8E  DE554F     LSR W10, #15, W10
1452:              						}
1453:              						else
1454:              						{
1455:              							mtCOVERAGE_TEST_MARKER();
1456:              						}
1457:              					}
1458:              					else
1459:              					{
1460:              						/* The priority of the running task is being raised,
1461:              						but the running task must already be the highest
1462:              						priority task able to run so no yield is required. */
1463:              					}
1464:              				}
1465:              				else if( pxTCB == pxCurrentTCB )
1466:              				{
1467:              					/* Setting the priority of the running task down means
1468:              					there may now be another task of higher priority that
1469:              					is ready to execute. */
1470:              					xYieldRequired = pdTRUE;
1471:              				}
1472:              				else
1473:              				{
1474:              					/* Setting the priority of any other task down does not
1475:              					require a yield as the running task must be above the
1476:              					new priority of the task being modified. */
1477:              				}
1478:              
1479:              				/* Remember the ready list the task might be referenced from
1480:              				before its uxPriority member is changed so the
1481:              				taskRESET_READY_PRIORITY() macro can function correctly. */
1482:              				uxPriorityUsedOnEntry = pxTCB->uxPriority;
1483:              
1484:              				#if ( configUSE_MUTEXES == 1 )
1485:              				{
1486:              					/* Only change the priority being used if the task is not
1487:              					currently using an inherited priority. */
1488:              					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
1489:              					{
1490:              						pxTCB->uxPriority = uxNewPriority;
1491:              					}
1492:              					else
1493:              					{
1494:              						mtCOVERAGE_TEST_MARKER();
1495:              					}
1496:              
1497:              					/* The base priority gets set whatever. */
1498:              					pxTCB->uxBasePriority = uxNewPriority;
1499:              				}
1500:              				#else
1501:              				{
1502:              					pxTCB->uxPriority = uxNewPriority;
000F90  980C39     MOV W9, [W8+22]
1503:              				}
1504:              				#endif
1505:              
1506:              				/* Only reset the event list item value if the value is not
1507:              				being used for anything else. */
1508:              				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
000F92  9000E8     MOV [W8+12], W1
000F94  E00001     CP0 W1
000F96  350002     BRA LT, .L18
1509:              				{
1510:              					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxNewPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
000F98  1484E4     SUBR W9, #0x4, W9
000F9A  980469     MOV W9, [W8+12]
1511:              				}
1512:              				else
1513:              				{
1514:              					mtCOVERAGE_TEST_MARKER();
1515:              				}
1516:              
1517:              				/* If the task is in the blocked or suspended list we need do
1518:              				nothing more than change it's priority variable. However, if
1519:              				the task is in a ready list it needs to be removed and placed
1520:              				in the list appropriate to its new priority. */
1521:              				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
000F9C  B9006A     MUL.SU W0, #10, W0
000F9E  21CF82     MOV #0x1CF8, W2
000FA0  410000     ADD W2, W0, W0
000FA2  9000D8     MOV [W8+10], W1
000FA4  508F80     SUB W1, W0, [W15]
000FA6  3A000E     BRA NZ, .L19
1522:              				{
1523:              					/* The task is currently in its ready list - remove before adding
1524:              					it to it's new ready list.  As we are in a critical section we
1525:              					can do this even if the scheduler is suspended. */
1526:              					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
000FA8  E88488     INC2 W8, W9
000FAA  780009     MOV W9, W0
000FAC  022D4A     CALL uxListRemove
000FAE  000000     NOP
1527:              					{
1528:              						/* It is known that the task is in its ready list so
1529:              						there is no need to check again and the port level
1530:              						reset macro can be called directly. */
1531:              						portRESET_READY_PRIORITY( uxPriorityUsedOnEntry, uxTopReadyPriority );
1532:              					}
1533:              					else
1534:              					{
1535:              						mtCOVERAGE_TEST_MARKER();
1536:              					}
1537:              					prvAddTaskToReadyList( pxTCB );
000FB0  900838     MOV [W8+22], W0
000FB2  E30856     CP uxTopReadyPriority
000FB4  310001     BRA C, .L20
000FB6  8842B0     MOV W0, uxTopReadyPriority
000FB8  B9006A     MUL.SU W0, #10, W0
000FBA  21CF82     MOV #0x1CF8, W2
000FBC  410000     ADD W2, W0, W0
000FBE  780089     MOV W9, W1
000FC0  022D10     CALL vListInsertEnd
000FC2  000000     NOP
1538:              				}
1539:              				else
1540:              				{
1541:              					mtCOVERAGE_TEST_MARKER();
1542:              				}
1543:              
1544:              				if( xYieldRequired != pdFALSE )
000FC4  E0000A     CP0 W10
000FC6  320003     BRA Z, .L14
1545:              				{
1546:              					taskYIELD_IF_USING_PREEMPTION();
000FC8  022DC4     CALL .Letext0, .LFE2, _vPortYield
000FCA  000000     NOP
000FCC  000000     NOP
1547:              				}
1548:              				else
1549:              				{
1550:              					mtCOVERAGE_TEST_MARKER();
1551:              				}
1552:              
1553:              				/* Remove compiler warning about unused variables when the port
1554:              				optimised task selection is not being used. */
1555:              				( void ) uxPriorityUsedOnEntry;
1556:              			}
1557:              		}
1558:              		taskEXIT_CRITICAL();
000FCE  022BC0     CALL vPortExitCritical
000FD0  000000     NOP
1559:              	}
000FD2  78054F     MOV [--W15], W10
000FD4  BE044F     MOV.D [--W15], W8
000FD6  060000     RETURN
1560:              
1561:              #endif /* INCLUDE_vTaskPrioritySet */
1562:              /*-----------------------------------------------------------*/
1563:              
1564:              #if ( INCLUDE_vTaskSuspend == 1 )
1565:              
1566:              	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
1567:              	{
001490  BE9F88     MOV.D W8, [W15++]
001492  780400     MOV W0, W8
1568:              	TCB_t *pxTCB;
1569:              
1570:              		taskENTER_CRITICAL();
001494  022BB0     CALL vPortEnterCritical
001496  000000     NOP
1571:              		{
1572:              			/* If null is passed in here then it is the running task that is
1573:              			being suspended. */
1574:              			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
001498  E00008     CP0 W8
00149A  3A0001     BRA NZ, .L129
00149C  804288     MOV pxCurrentTCB, W8
1575:              
1576:              			traceTASK_SUSPEND( pxTCB );
1577:              
1578:              			/* Remove task from the ready/delayed list and place in the
1579:              			suspended list. */
1580:              			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
00149E  E88488     INC2 W8, W9
0014A0  780009     MOV W9, W0
0014A2  022D4A     CALL uxListRemove
0014A4  000000     NOP
1581:              			{
1582:              				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
1583:              			}
1584:              			else
1585:              			{
1586:              				mtCOVERAGE_TEST_MARKER();
1587:              			}
1588:              
1589:              			/* Is the task waiting on an event also? */
1590:              			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
0014A6  900828     MOV [W8+20], W0
0014A8  E00000     CP0 W0
0014AA  320003     BRA Z, .L130
1591:              			{
1592:              				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
0014AC  44006C     ADD W8, #0xC, W0
0014AE  022D4A     CALL uxListRemove
0014B0  000000     NOP
1593:              			}
1594:              			else
1595:              			{
1596:              				mtCOVERAGE_TEST_MARKER();
1597:              			}
1598:              
1599:              			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
0014B2  780089     MOV W9, W1
0014B4  21D3E0     MOV #0x1D3E, W0
0014B6  022D10     CALL vListInsertEnd
0014B8  000000     NOP
1600:              		}
1601:              		taskEXIT_CRITICAL();
0014BA  022BC0     CALL vPortExitCritical
0014BC  000000     NOP
1602:              
1603:              		if( xSchedulerRunning != pdFALSE )
0014BE  E20858     CP0 xSchedulerRunning
0014C0  320005     BRA Z, .L131
1604:              		{
1605:              			/* Reset the next expected unblock time in case it referred to the
1606:              			task that is now in the Suspended state. */
1607:              			taskENTER_CRITICAL();
0014C2  022BB0     CALL vPortEnterCritical
1608:              			{
1609:              				prvResetNextTaskUnblockTime();
0014C4  000000     NOP
0014C6  07FF43     RCALL prvResetNextTaskUnblockTime
1610:              			}
1611:              			taskEXIT_CRITICAL();
0014C8  022BC0     CALL vPortExitCritical
0014CA  000000     NOP
1612:              		}
1613:              		else
1614:              		{
1615:              			mtCOVERAGE_TEST_MARKER();
1616:              		}
1617:              
1618:              		if( pxTCB == pxCurrentTCB )
0014CC  804280     MOV pxCurrentTCB, W0
0014CE  500F88     SUB W0, W8, [W15]
0014D0  3A000C     BRA NZ, .L127
1619:              		{
1620:              			if( xSchedulerRunning != pdFALSE )
0014D2  E20858     CP0 xSchedulerRunning
0014D4  320004     BRA Z, .L133
1621:              			{
1622:              				/* The current task has just been suspended. */
1623:              				configASSERT( uxSchedulerSuspended == 0 );
1624:              				portYIELD_WITHIN_API();
0014D6  022DC4     CALL .Letext0, .LFE2, _vPortYield
0014D8  000000     NOP
0014DA  000000     NOP
0014DC  370006     BRA .L127
1625:              			}
1626:              			else
1627:              			{
1628:              				/* The scheduler is not running, but the task that was pointed
1629:              				to by pxCurrentTCB has just been suspended and pxCurrentTCB
1630:              				must be adjusted to point to a different task. */
1631:              				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
0014DE  80E9F0     MOV xSuspendedTaskList, W0
0014E0  E30852     CP uxCurrentNumberOfTasks
0014E2  3A0002     BRA NZ, .L134
1632:              				{
1633:              					/* No other tasks are ready, so set pxCurrentTCB back to
1634:              					NULL so when the next task is created pxCurrentTCB will
1635:              					be set to point to it no matter what its relative priority
1636:              					is. */
1637:              					pxCurrentTCB = NULL;
0014E4  EF2850     CLR pxCurrentTCB
1638:              				}
1639:              				else
1640:              				{
1641:              					vTaskSwitchContext();
0014E6  370001     BRA .L127
0014E8  07FDF4     RCALL vTaskSwitchContext
1642:              				}
1643:              			}
1644:              		}
1645:              		else
1646:              		{
1647:              			mtCOVERAGE_TEST_MARKER();
1648:              		}
1649:              	}
0014EA  BE044F     MOV.D [--W15], W8
0014EC  060000     RETURN
1650:              
1651:              #endif /* INCLUDE_vTaskSuspend */
1652:              /*-----------------------------------------------------------*/
1653:              
1654:              #if ( INCLUDE_vTaskSuspend == 1 )
1655:              
1656:              	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
1657:              	{
000FD8  780080     MOV W0, W1
1658:              	BaseType_t xReturn = pdFALSE;
000FDC  EB0000     CLR W0
000FEC  A7F001     BTSC W1, #15
000FEE  EA0081     NEG W1, W1
000FF0  E90001     DEC W1, W0
000FF2  DE004F     LSR W0, #15, W0
1659:              	const TCB_t * const pxTCB = ( TCB_t * ) xTask;
1660:              
1661:              		/* Accesses xPendingReadyList so must be called from a critical
1662:              		section. */
1663:              
1664:              		/* It does not make sense to check if the calling task is suspended. */
1665:              		configASSERT( xTask );
1666:              
1667:              		/* Is the task being resumed actually in the suspended list? */
1668:              		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
000FDA  9001D1     MOV [W1+10], W3
000FDE  21D3E2     MOV #0x1D3E, W2
000FE0  518F82     SUB W3, W2, [W15]
000FE2  3A0008     BRA NZ, .L23
1669:              		{
1670:              			/* Has the task already been resumed from within an ISR? */
1671:              			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
000FE4  9008A1     MOV [W1+20], W1
000FE6  21D342     MOV #0x1D34, W2
000FE8  508F82     SUB W1, W2, [W15]
000FEA  320004     BRA Z, .L23
1672:              			{
1673:              				/* Is it in the suspended list because it is in the	Suspended
1674:              				state, or because is is blocked with no timeout? */
1675:              				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE )
1676:              				{
1677:              					xReturn = pdTRUE;
1678:              				}
1679:              				else
1680:              				{
1681:              					mtCOVERAGE_TEST_MARKER();
1682:              				}
1683:              			}
1684:              			else
1685:              			{
1686:              				mtCOVERAGE_TEST_MARKER();
1687:              			}
1688:              		}
1689:              		else
1690:              		{
1691:              			mtCOVERAGE_TEST_MARKER();
1692:              		}
1693:              
1694:              		return xReturn;
1695:              	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
000FF4  060000     RETURN
1696:              
1697:              #endif /* INCLUDE_vTaskSuspend */
1698:              /*-----------------------------------------------------------*/
1699:              
1700:              #if ( INCLUDE_vTaskSuspend == 1 )
1701:              
1702:              	void vTaskResume( TaskHandle_t xTaskToResume )
1703:              	{
000FF6  BE9F88     MOV.D W8, [W15++]
000FF8  780400     MOV W0, W8
1704:              	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;
1705:              
1706:              		/* It does not make sense to resume the calling task. */
1707:              		configASSERT( xTaskToResume );
1708:              
1709:              		/* The parameter cannot be NULL as it is impossible to resume the
1710:              		currently executing task. */
1711:              		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
000FFA  E00008     CP0 W8
000FFC  320021     BRA Z, .L26
000FFE  804280     MOV pxCurrentTCB, W0
001000  500F88     SUB W0, W8, [W15]
001002  32001E     BRA Z, .L26
1712:              		{
1713:              			taskENTER_CRITICAL();
001004  022BB0     CALL vPortEnterCritical
001006  000000     NOP
1714:              			{
1715:              				if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
001008  780008     MOV W8, W0
00100A  07FFE6     RCALL prvTaskIsTaskSuspended
00100C  E00000     CP0 W0
00100E  320016     BRA Z, .L28
1716:              				{
1717:              					traceTASK_RESUME( pxTCB );
1718:              
1719:              					/* As we are in a critical section we can access the ready
1720:              					lists even if the scheduler is suspended. */
1721:              					( void ) uxListRemove(  &( pxTCB->xStateListItem ) );
001010  E88488     INC2 W8, W9
001012  780009     MOV W9, W0
001014  022D4A     CALL uxListRemove
001016  000000     NOP
1722:              					prvAddTaskToReadyList( pxTCB );
001018  900838     MOV [W8+22], W0
00101A  E30856     CP uxTopReadyPriority
00101C  310001     BRA C, .L29
00101E  8842B0     MOV W0, uxTopReadyPriority
001020  B9006A     MUL.SU W0, #10, W0
001022  21CF82     MOV #0x1CF8, W2
001024  410000     ADD W2, W0, W0
001026  780089     MOV W9, W1
001028  022D10     CALL vListInsertEnd
00102A  000000     NOP
1723:              
1724:              					/* We may have just resumed a higher priority task. */
1725:              					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
00102C  804280     MOV pxCurrentTCB, W0
00102E  9008B8     MOV [W8+22], W1
001030  900830     MOV [W0+22], W0
001032  508F80     SUB W1, W0, [W15]
001034  390003     BRA NC, .L28
1726:              					{
1727:              						/* This yield may not cause the task just resumed to run,
1728:              						but will leave the lists in the correct state for the
1729:              						next yield. */
1730:              						taskYIELD_IF_USING_PREEMPTION();
001036  022DC4     CALL .Letext0, .LFE2, _vPortYield
001038  000000     NOP
00103A  000000     NOP
1731:              					}
1732:              					else
1733:              					{
1734:              						mtCOVERAGE_TEST_MARKER();
1735:              					}
1736:              				}
1737:              				else
1738:              				{
1739:              					mtCOVERAGE_TEST_MARKER();
1740:              				}
1741:              			}
1742:              			taskEXIT_CRITICAL();
00103C  022BC0     CALL vPortExitCritical
00103E  000000     NOP
1743:              		}
1744:              		else
1745:              		{
1746:              			mtCOVERAGE_TEST_MARKER();
1747:              		}
1748:              	}
001040  BE044F     MOV.D [--W15], W8
001042  060000     RETURN
1749:              
1750:              #endif /* INCLUDE_vTaskSuspend */
1751:              
1752:              /*-----------------------------------------------------------*/
1753:              
1754:              #if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )
1755:              
1756:              	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
1757:              	{
001044  BE9F88     MOV.D W8, [W15++]
001046  781F8A     MOV W10, [W15++]
001048  780400     MOV W0, W8
1758:              	BaseType_t xYieldRequired = pdFALSE;
00104E  EB0480     CLR W9
00105A  200019     MOV #0x1, W9
00105C  9008B8     MOV [W8+22], W1
00105E  900830     MOV [W0+22], W0
001060  508F80     SUB W1, W0, [W15]
001062  310001     BRA C, .L33
001064  EB0480     CLR W9
00108C  EB0480     CLR W9
1759:              	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;
1760:              	UBaseType_t uxSavedInterruptStatus;
1761:              
1762:              		configASSERT( xTaskToResume );
1763:              
1764:              		/* RTOS ports that support interrupt nesting have the concept of a
1765:              		maximum	system call (or maximum API call) interrupt priority.
1766:              		Interrupts that are	above the maximum system call priority are keep
1767:              		permanently enabled, even when the RTOS kernel is in a critical section,
1768:              		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
1769:              		is defined in FreeRTOSConfig.h then
1770:              		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1771:              		failure if a FreeRTOS API function is called from an interrupt that has
1772:              		been assigned a priority above the configured maximum system call
1773:              		priority.  Only FreeRTOS functions that end in FromISR can be called
1774:              		from interrupts	that have been assigned a priority at or (logically)
1775:              		below the maximum system call interrupt priority.  FreeRTOS maintains a
1776:              		separate interrupt safe API to ensure interrupt entry is as fast and as
1777:              		simple as possible.  More information (albeit Cortex-M specific) is
1778:              		provided on the following link:
1779:              		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1780:              		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1781:              
1782:              		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
1783:              		{
1784:              			if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
00104A  780008     MOV W8, W0
00104C  07FFC5     RCALL prvTaskIsTaskSuspended
001050  E00000     CP0 W0
001052  32001D     BRA Z, .L31
1785:              			{
1786:              				traceTASK_RESUME_FROM_ISR( pxTCB );
1787:              
1788:              				/* Check the ready lists can be accessed. */
1789:              				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
001054  E20866     CP0 uxSchedulerSuspended
001056  3A0016     BRA NZ, .L32
1790:              				{
1791:              					/* Ready lists can be accessed so move the task from the
1792:              					suspended list to the ready list directly. */
1793:              					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
001058  804280     MOV pxCurrentTCB, W0
1794:              					{
1795:              						xYieldRequired = pdTRUE;
1796:              					}
1797:              					else
1798:              					{
1799:              						mtCOVERAGE_TEST_MARKER();
1800:              					}
1801:              
1802:              					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
001066  E88508     INC2 W8, W10
001068  78000A     MOV W10, W0
00106A  022D4A     CALL uxListRemove
00106C  000000     NOP
1803:              					prvAddTaskToReadyList( pxTCB );
00106E  900838     MOV [W8+22], W0
001070  E30856     CP uxTopReadyPriority
001072  310001     BRA C, .L34
001074  8842B0     MOV W0, uxTopReadyPriority
001076  B9006A     MUL.SU W0, #10, W0
001078  21CF82     MOV #0x1CF8, W2
00107A  410000     ADD W2, W0, W0
00107C  78008A     MOV W10, W1
00107E  022D10     CALL vListInsertEnd
001080  000000     NOP
001082  370005     BRA .L31
1804:              				}
1805:              				else
1806:              				{
1807:              					/* The delayed or ready lists cannot be accessed so the task
1808:              					is held in the pending ready list until the scheduler is
1809:              					unsuspended. */
1810:              					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
001084  4400EC     ADD W8, #0xC, W1
001086  21D340     MOV #0x1D34, W0
001088  022D10     CALL vListInsertEnd
00108A  000000     NOP
1811:              				}
1812:              			}
1813:              			else
1814:              			{
1815:              				mtCOVERAGE_TEST_MARKER();
1816:              			}
1817:              		}
1818:              		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1819:              
1820:              		return xYieldRequired;
1821:              	}
00108E  780009     MOV W9, W0
001090  78054F     MOV [--W15], W10
001092  BE044F     MOV.D [--W15], W8
001094  060000     RETURN
1822:              
1823:              #endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
1824:              /*-----------------------------------------------------------*/
1825:              
1826:              void vTaskStartScheduler( void )
1827:              {
1828:              BaseType_t xReturn;
1829:              
1830:              	/* Add the idle task at the lowest priority. */
1831:              	#if( configSUPPORT_STATIC_ALLOCATION == 1 )
1832:              	{
1833:              		StaticTask_t *pxIdleTaskTCBBuffer = NULL;
1834:              		StackType_t *pxIdleTaskStackBuffer = NULL;
1835:              		uint32_t ulIdleTaskStackSize;
1836:              
1837:              		/* The Idle task is created using user provided RAM - obtain the
1838:              		address of the RAM then create the idle task. */
1839:              		vApplicationGetIdleTaskMemory( &pxIdleTaskTCBBuffer, &pxIdleTaskStackBuffer, &ulIdleTaskStackSize );
1840:              		xIdleTaskHandle = xTaskCreateStatic(	prvIdleTask,
1841:              												"IDLE",
1842:              												ulIdleTaskStackSize,
1843:              												( void * ) NULL,
1844:              												( tskIDLE_PRIORITY | portPRIVILEGE_BIT ),
1845:              												pxIdleTaskStackBuffer,
1846:              												pxIdleTaskTCBBuffer ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
1847:              
1848:              		if( xIdleTaskHandle != NULL )
1849:              		{
1850:              			xReturn = pdPASS;
1851:              		}
1852:              		else
1853:              		{
1854:              			xReturn = pdFAIL;
1855:              		}
1856:              	}
1857:              	#else
1858:              	{
1859:              		/* The Idle task is being created using dynamically allocated RAM. */
1860:              		xReturn = xTaskCreate(	prvIdleTask,
001320  208645     MOV #0x864, W5
001322  EB0200     CLR W4
001324  EB0180     CLR W3
001326  200732     MOV #0x73, W2
001328  28E4C1     MOV #0x8E4C, W1
00132A  20EAE0     MOV #0xEAE, W0
00132C  07FFCB     RCALL xTaskCreate
1861:              								"IDLE", configMINIMAL_STACK_SIZE,
1862:              								( void * ) NULL,
1863:              								( tskIDLE_PRIORITY | portPRIVILEGE_BIT ),
1864:              								&xIdleTaskHandle ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
1865:              	}
1866:              	#endif /* configSUPPORT_STATIC_ALLOCATION */
1867:              
1868:              	#if ( configUSE_TIMERS == 1 )
1869:              	{
1870:              		if( xReturn == pdPASS )
1871:              		{
1872:              			xReturn = xTimerCreateTimerTask();
1873:              		}
1874:              		else
1875:              		{
1876:              			mtCOVERAGE_TEST_MARKER();
1877:              		}
1878:              	}
1879:              	#endif /* configUSE_TIMERS */
1880:              
1881:              	if( xReturn == pdPASS )
00132E  500FE1     SUB W0, #0x1, [W15]
001330  3A000C     BRA NZ, .L82
1882:              	{
1883:              		/* Interrupts are turned off here, to ensure a tick does not occur
1884:              		before or during the call to xPortStartScheduler().  The stacks of
1885:              		the created tasks contain a status word with interrupts switched on
1886:              		so interrupts will automatically get re-enabled when the first task
1887:              		starts to run. */
1888:              		portDISABLE_INTERRUPTS();
001332  2FF1F0     MOV #0xFF1F, W0
001334  B60042     AND SR, WREG
001336  A05000     BSET W0, #5
001338  880210     MOV W0, SR
00133A  000000     NOP
00133C  000000     NOP
1889:              
1890:              		#if ( configUSE_NEWLIB_REENTRANT == 1 )
1891:              		{
1892:              			/* Switch Newlib's _impure_ptr variable to point to the _reent
1893:              			structure specific to the task that will run first. */
1894:              			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
1895:              		}
1896:              		#endif /* configUSE_NEWLIB_REENTRANT */
1897:              
1898:              		xNextTaskUnblockTime = portMAX_DELAY;
00133E  EFA862     SETM xNextTaskUnblockTime
1899:              		xSchedulerRunning = pdTRUE;
001340  200010     MOV #0x1, W0
001342  8842C0     MOV W0, xSchedulerRunning
1900:              		xTickCount = ( TickType_t ) 0U;
001344  EF2854     CLR xTickCount
1901:              
1902:              		/* If configGENERATE_RUN_TIME_STATS is defined then the following
1903:              		macro must be defined to configure the timer/counter used to generate
1904:              		the run time counter time base. */
1905:              		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
1906:              
1907:              		/* Setting up the timer tick is hardware specific and thus in the
1908:              		portable interface. */
1909:              		if( xPortStartScheduler() != pdFALSE )
001346  022B82     CALL xPortStartScheduler
001348  000000     NOP
1910:              		{
1911:              			/* Should not reach here as if the scheduler is running the
1912:              			function will not return. */
1913:              		}
1914:              		else
1915:              		{
1916:              			/* Should only reach here if a task calls xTaskEndScheduler(). */
1917:              		}
1918:              	}
1919:              	else
1920:              	{
1921:              		/* This line will only be reached if the kernel could not be started,
1922:              		because there was not enough FreeRTOS heap to create the idle task
1923:              		or the timer task. */
1924:              		configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
1925:              	}
1926:              
1927:              	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
1928:              	meaning xIdleTaskHandle is not used anywhere else. */
1929:              	( void ) xIdleTaskHandle;
1930:              }
00134A  060000     RETURN
1931:              /*-----------------------------------------------------------*/
1932:              
1933:              void vTaskEndScheduler( void )
1934:              {
1935:              	/* Stop the scheduler interrupts and call the portable scheduler end
1936:              	routine so the original ISRs can be restored if necessary.  The port
1937:              	layer must ensure interrupts enable	bit is left in the correct state. */
1938:              	portDISABLE_INTERRUPTS();
001096  2FF1F0     MOV #0xFF1F, W0
001098  B60042     AND SR, WREG
00109A  A05000     BSET W0, #5
00109C  880210     MOV W0, SR
00109E  000000     NOP
0010A0  000000     NOP
1939:              	xSchedulerRunning = pdFALSE;
0010A2  EF2858     CLR xSchedulerRunning
1940:              	vPortEndScheduler();
0010A4  022B64     CALL vPortEndScheduler
0010A6  000000     NOP
1941:              }
0010A8  060000     RETURN
1942:              /*----------------------------------------------------------*/
1943:              
1944:              void vTaskSuspendAll( void )
1945:              {
1946:              	/* A critical section is not required as the variable is of type
1947:              	BaseType_t.  Please read Richard Barry's reply in the following link to a
1948:              	post in the FreeRTOS support forum before reporting this as a bug! -
1949:              	http://goo.gl/wu4acr */
1950:              	++uxSchedulerSuspended;
0010AA  EC2866     INC uxSchedulerSuspended
1951:              }
0010AC  060000     RETURN
1952:              /*----------------------------------------------------------*/
1953:              
1954:              #if ( configUSE_TICKLESS_IDLE != 0 )
1955:              
1956:              	static TickType_t prvGetExpectedIdleTime( void )
1957:              	{
1958:              	TickType_t xReturn;
1959:              	UBaseType_t uxHigherPriorityReadyTasks = pdFALSE;
1960:              
1961:              		/* uxHigherPriorityReadyTasks takes care of the case where
1962:              		configUSE_PREEMPTION is 0, so there may be tasks above the idle priority
1963:              		task that are in the Ready state, even though the idle task is
1964:              		running. */
1965:              		#if( configUSE_PORT_OPTIMISED_TASK_SELECTION == 0 )
1966:              		{
1967:              			if( uxTopReadyPriority > tskIDLE_PRIORITY )
1968:              			{
1969:              				uxHigherPriorityReadyTasks = pdTRUE;
1970:              			}
1971:              		}
1972:              		#else
1973:              		{
1974:              			const UBaseType_t uxLeastSignificantBit = ( UBaseType_t ) 0x01;
1975:              
1976:              			/* When port optimised task selection is used the uxTopReadyPriority
1977:              			variable is used as a bit map.  If bits other than the least
1978:              			significant bit are set then there are tasks that have a priority
1979:              			above the idle priority that are in the Ready state.  This takes
1980:              			care of the case where the co-operative scheduler is in use. */
1981:              			if( uxTopReadyPriority > uxLeastSignificantBit )
1982:              			{
1983:              				uxHigherPriorityReadyTasks = pdTRUE;
1984:              			}
1985:              		}
1986:              		#endif
1987:              
1988:              		if( pxCurrentTCB->uxPriority > tskIDLE_PRIORITY )
1989:              		{
1990:              			xReturn = 0;
1991:              		}
1992:              		else if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > 1 )
1993:              		{
1994:              			/* There are other idle priority tasks in the ready state.  If
1995:              			time slicing is used then the very next tick interrupt must be
1996:              			processed. */
1997:              			xReturn = 0;
1998:              		}
1999:              		else if( uxHigherPriorityReadyTasks != pdFALSE )
2000:              		{
2001:              			/* There are tasks in the Ready state that have a priority above the
2002:              			idle priority.  This path can only be reached if
2003:              			configUSE_PREEMPTION is 0. */
2004:              			xReturn = 0;
2005:              		}
2006:              		else
2007:              		{
2008:              			xReturn = xNextTaskUnblockTime - xTickCount;
2009:              		}
2010:              
2011:              		return xReturn;
2012:              	}
2013:              
2014:              #endif /* configUSE_TICKLESS_IDLE */
2015:              /*----------------------------------------------------------*/
2016:              
2017:              BaseType_t xTaskResumeAll( void )
2018:              {
001408  BE9F88     MOV.D W8, [W15++]
00140A  BE9F8A     MOV.D W10, [W15++]
2019:              TCB_t *pxTCB = NULL;
2020:              BaseType_t xAlreadyYielded = pdFALSE;
001412  EB0400     CLR W8
001476  EB0400     CLR W8
2021:              
2022:              	/* If uxSchedulerSuspended is zero then this function does not match a
2023:              	previous call to vTaskSuspendAll(). */
2024:              	configASSERT( uxSchedulerSuspended );
2025:              
2026:              	/* It is possible that an ISR caused a task to be removed from an event
2027:              	list while the scheduler was suspended.  If this was the case then the
2028:              	removed task will have been added to the xPendingReadyList.  Once the
2029:              	scheduler has been resumed it is safe to move all the pending ready
2030:              	tasks from this list into their appropriate ready list. */
2031:              	taskENTER_CRITICAL();
00140C  022BB0     CALL vPortEnterCritical
00140E  000000     NOP
2032:              	{
2033:              		--uxSchedulerSuspended;
001410  ED2866     DEC uxSchedulerSuspended
2034:              
2035:              		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
001414  E20866     CP0 uxSchedulerSuspended
001416  3A0036     BRA NZ, .L109
2036:              		{
2037:              			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
001418  E20852     CP0 uxCurrentNumberOfTasks
00141A  3A001B     BRA NZ, .L122
00141C  370033     BRA .L109
2038:              			{
2039:              				/* Move any readied tasks from the pending list into the
2040:              				appropriate ready list. */
2041:              				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
001452  21D34A     MOV #0x1D34, W10
001456  E0001A     CP0 [W10]
001458  3AFFE2     BRA NZ, .L113
2042:              				{
2043:              					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
00141E  80E9D0     MOV 0x1D3A, W0
001420  900430     MOV [W0+6], W8
2044:              					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
001422  44006C     ADD W8, #0xC, W0
001424  022D4A     CALL uxListRemove
001426  000000     NOP
2045:              					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
001428  E88488     INC2 W8, W9
00142A  780009     MOV W9, W0
00142C  022D4A     CALL uxListRemove
00142E  000000     NOP
2046:              					prvAddTaskToReadyList( pxTCB );
001430  900838     MOV [W8+22], W0
001432  E30856     CP uxTopReadyPriority
001434  310001     BRA C, .L111
001436  8842B0     MOV W0, uxTopReadyPriority
001438  B9006A     MUL.SU W0, #10, W0
00143A  458000     ADD W11, W0, W0
00143C  780089     MOV W9, W1
00143E  022D10     CALL vListInsertEnd
001440  000000     NOP
001454  21CF8B     MOV #0x1CF8, W11
2047:              
2048:              					/* If the moved task has a priority higher than the current
2049:              					task then a yield must be performed. */
2050:              					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
001442  804280     MOV pxCurrentTCB, W0
001444  9008B8     MOV [W8+22], W1
001446  900830     MOV [W0+22], W0
001448  508F80     SUB W1, W0, [W15]
00144A  390005     BRA NC, .L126
2051:              					{
2052:              						xYieldPending = pdTRUE;
00144C  200010     MOV #0x1, W0
00144E  8842E0     MOV W0, xYieldPending
001450  370002     BRA .L126
2053:              					}
2054:              					else
2055:              					{
2056:              						mtCOVERAGE_TEST_MARKER();
2057:              					}
2058:              				}
2059:              
2060:              				if( pxTCB != NULL )
00145A  E00008     CP0 W8
2061:              				{
2062:              					/* A task was unblocked while the scheduler was suspended,
2063:              					which may have prevented the next unblock time from being
2064:              					re-calculated, in which case re-calculate it now.  Mainly
2065:              					important for low power tickless implementations, where
2066:              					this can prevent an unnecessary exit from low power
2067:              					state. */
2068:              					prvResetNextTaskUnblockTime();
00145C  320001     BRA Z, .L114, .LBB10
00145E  07FF77     RCALL prvResetNextTaskUnblockTime
2069:              				}
2070:              
2071:              				/* If any ticks occurred while the scheduler was suspended then
2072:              				they should be processed now.  This ensures the tick count does
2073:              				not	slip, and that any delayed tasks are resumed at the correct
2074:              				time. */
2075:              				{
2076:              					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
001460  8042D8     MOV uxPendedTicks, W8
2077:              
2078:              					if( uxPendedCounts > ( UBaseType_t ) 0U )
001462  E00008     CP0 W8
001464  320008     BRA Z, .L115, .LBE10
2079:              					{
2080:              						do
2081:              						{
2082:              							if( xTaskIncrementTick() != pdFALSE )
001466  200019     MOV #0x1, W9
001468  07FF7D     RCALL xTaskIncrementTick
00146A  E00000     CP0 W0
00146C  320001     BRA Z, .L116
2083:              							{
2084:              								xYieldPending = pdTRUE;
00146E  8842E9     MOV W9, xYieldPending
2085:              							}
2086:              							else
2087:              							{
2088:              								mtCOVERAGE_TEST_MARKER();
2089:              							}
2090:              							--uxPendedCounts;
001470  E90408     DEC W8, W8
2091:              						} while( uxPendedCounts > ( UBaseType_t ) 0U );
001472  3AFFFA     BRA NZ, .L123
2092:              
2093:              						uxPendedTicks = 0;
001474  EF285A     CLR uxPendedTicks
2094:              					}
2095:              					else
2096:              					{
2097:              						mtCOVERAGE_TEST_MARKER();
2098:              					}
2099:              				}
2100:              
2101:              				if( xYieldPending != pdFALSE )
001478  E2085C     CP0 xYieldPending
00147A  320004     BRA Z, .L109
2102:              				{
2103:              					#if( configUSE_PREEMPTION != 0 )
2104:              					{
2105:              						xAlreadyYielded = pdTRUE;
001482  200018     MOV #0x1, W8
2106:              					}
2107:              					#endif
2108:              					taskYIELD_IF_USING_PREEMPTION();
00147C  022DC4     CALL .Letext0, .LFE2, _vPortYield
00147E  000000     NOP
001480  000000     NOP
2109:              				}
2110:              				else
2111:              				{
2112:              					mtCOVERAGE_TEST_MARKER();
2113:              				}
2114:              			}
2115:              		}
2116:              		else
2117:              		{
2118:              			mtCOVERAGE_TEST_MARKER();
2119:              		}
2120:              	}
2121:              	taskEXIT_CRITICAL();
001484  022BC0     CALL vPortExitCritical
001486  000000     NOP
2122:              
2123:              	return xAlreadyYielded;
2124:              }
001488  780008     MOV W8, W0
00148A  BE054F     MOV.D [--W15], W10
00148C  BE044F     MOV.D [--W15], W8
00148E  060000     RETURN
2125:              /*-----------------------------------------------------------*/
2126:              
2127:              TickType_t xTaskGetTickCount( void )
2128:              {
0010AE  781F88     MOV W8, [W15++]
2129:              TickType_t xTicks;
2130:              
2131:              	/* Critical section required if running on a 16 bit processor. */
2132:              	portTICK_TYPE_ENTER_CRITICAL();
0010B0  022BB0     CALL vPortEnterCritical
0010B2  000000     NOP
2133:              	{
2134:              		xTicks = xTickCount;
0010B4  8042A8     MOV xTickCount, W8
2135:              	}
2136:              	portTICK_TYPE_EXIT_CRITICAL();
0010B6  022BC0     CALL vPortExitCritical
0010B8  000000     NOP
2137:              
2138:              	return xTicks;
2139:              }
0010BA  780008     MOV W8, W0
0010BC  78044F     MOV [--W15], W8
0010BE  060000     RETURN
2140:              /*-----------------------------------------------------------*/
2141:              
2142:              TickType_t xTaskGetTickCountFromISR( void )
2143:              {
2144:              TickType_t xReturn;
2145:              UBaseType_t uxSavedInterruptStatus;
2146:              
2147:              	/* RTOS ports that support interrupt nesting have the concept of a maximum
2148:              	system call (or maximum API call) interrupt priority.  Interrupts that are
2149:              	above the maximum system call priority are kept permanently enabled, even
2150:              	when the RTOS kernel is in a critical section, but cannot make any calls to
2151:              	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
2152:              	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
2153:              	failure if a FreeRTOS API function is called from an interrupt that has been
2154:              	assigned a priority above the configured maximum system call priority.
2155:              	Only FreeRTOS functions that end in FromISR can be called from interrupts
2156:              	that have been assigned a priority at or (logically) below the maximum
2157:              	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
2158:              	safe API to ensure interrupt entry is as fast and as simple as possible.
2159:              	More information (albeit Cortex-M specific) is provided on the following
2160:              	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
2161:              	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
2162:              
2163:              	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
2164:              	{
2165:              		xReturn = xTickCount;
0010C0  8042A0     MOV xTickCount, W0
2166:              	}
2167:              	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
2168:              
2169:              	return xReturn;
2170:              }
0010C2  060000     RETURN
2171:              /*-----------------------------------------------------------*/
2172:              
2173:              UBaseType_t uxTaskGetNumberOfTasks( void )
2174:              {
2175:              	/* A critical section is not required because the variables are of type
2176:              	BaseType_t. */
2177:              	return uxCurrentNumberOfTasks;
0010C4  804290     MOV uxCurrentNumberOfTasks, W0
2178:              }
0010C6  060000     RETURN
2179:              /*-----------------------------------------------------------*/
2180:              
2181:              char *pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
2182:              {
2183:              TCB_t *pxTCB;
2184:              
2185:              	/* If null is passed in here then the name of the calling task is being
2186:              	queried. */
2187:              	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
0010C8  E00000     CP0 W0
0010CA  3A0001     BRA NZ, .L43
0010CC  804280     MOV pxCurrentTCB, W0
2188:              	configASSERT( pxTCB );
2189:              	return &( pxTCB->pcTaskName[ 0 ] );
0010CE  40007A     ADD W0, #0x1A, W0
2190:              }
0010D0  060000     RETURN
2191:              /*-----------------------------------------------------------*/
2192:              
2193:              #if ( INCLUDE_xTaskGetHandle == 1 )
2194:              
2195:              	static TCB_t *prvSearchForNameWithinSingleList( List_t *pxList, const char pcNameToQuery[] )
2196:              	{
2197:              	TCB_t *pxNextTCB, *pxFirstTCB, *pxReturn = NULL;
2198:              	UBaseType_t x;
2199:              	char cNextChar;
2200:              
2201:              		/* This function is called with the scheduler suspended. */
2202:              
2203:              		if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
2204:              		{
2205:              			listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
2206:              
2207:              			do
2208:              			{
2209:              				listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
2210:              
2211:              				/* Check each character in the name looking for a match or
2212:              				mismatch. */
2213:              				for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
2214:              				{
2215:              					cNextChar = pxNextTCB->pcTaskName[ x ];
2216:              
2217:              					if( cNextChar != pcNameToQuery[ x ] )
2218:              					{
2219:              						/* Characters didn't match. */
2220:              						break;
2221:              					}
2222:              					else if( cNextChar == 0x00 )
2223:              					{
2224:              						/* Both strings terminated, a match must have been
2225:              						found. */
2226:              						pxReturn = pxNextTCB;
2227:              						break;
2228:              					}
2229:              					else
2230:              					{
2231:              						mtCOVERAGE_TEST_MARKER();
2232:              					}
2233:              				}
2234:              
2235:              				if( pxReturn != NULL )
2236:              				{
2237:              					/* The handle has been found. */
2238:              					break;
2239:              				}
2240:              
2241:              			} while( pxNextTCB != pxFirstTCB );
2242:              		}
2243:              		else
2244:              		{
2245:              			mtCOVERAGE_TEST_MARKER();
2246:              		}
2247:              
2248:              		return pxReturn;
2249:              	}
2250:              
2251:              #endif /* INCLUDE_xTaskGetHandle */
2252:              /*-----------------------------------------------------------*/
2253:              
2254:              #if ( INCLUDE_xTaskGetHandle == 1 )
2255:              
2256:              	TaskHandle_t xTaskGetHandle( const char *pcNameToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
2257:              	{
2258:              	UBaseType_t uxQueue = configMAX_PRIORITIES;
2259:              	TCB_t* pxTCB;
2260:              
2261:              		/* Task names will be truncated to configMAX_TASK_NAME_LEN - 1 bytes. */
2262:              		configASSERT( strlen( pcNameToQuery ) < configMAX_TASK_NAME_LEN );
2263:              
2264:              		vTaskSuspendAll();
2265:              		{
2266:              			/* Search the ready lists. */
2267:              			do
2268:              			{
2269:              				uxQueue--;
2270:              				pxTCB = prvSearchForNameWithinSingleList( ( List_t * ) &( pxReadyTasksLists[ uxQueue ] ), pcNameToQuery );
2271:              
2272:              				if( pxTCB != NULL )
2273:              				{
2274:              					/* Found the handle. */
2275:              					break;
2276:              				}
2277:              
2278:              			} while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
2279:              
2280:              			/* Search the delayed lists. */
2281:              			if( pxTCB == NULL )
2282:              			{
2283:              				pxTCB = prvSearchForNameWithinSingleList( ( List_t * ) pxDelayedTaskList, pcNameToQuery );
2284:              			}
2285:              
2286:              			if( pxTCB == NULL )
2287:              			{
2288:              				pxTCB = prvSearchForNameWithinSingleList( ( List_t * ) pxOverflowDelayedTaskList, pcNameToQuery );
2289:              			}
2290:              
2291:              			#if ( INCLUDE_vTaskSuspend == 1 )
2292:              			{
2293:              				if( pxTCB == NULL )
2294:              				{
2295:              					/* Search the suspended list. */
2296:              					pxTCB = prvSearchForNameWithinSingleList( &xSuspendedTaskList, pcNameToQuery );
2297:              				}
2298:              			}
2299:              			#endif
2300:              
2301:              			#if( INCLUDE_vTaskDelete == 1 )
2302:              			{
2303:              				if( pxTCB == NULL )
2304:              				{
2305:              					/* Search the deleted list. */
2306:              					pxTCB = prvSearchForNameWithinSingleList( &xTasksWaitingTermination, pcNameToQuery );
2307:              				}
2308:              			}
2309:              			#endif
2310:              		}
2311:              		( void ) xTaskResumeAll();
2312:              
2313:              		return ( TaskHandle_t ) pxTCB;
2314:              	}
2315:              
2316:              #endif /* INCLUDE_xTaskGetHandle */
2317:              /*-----------------------------------------------------------*/
2318:              
2319:              #if ( configUSE_TRACE_FACILITY == 1 )
2320:              
2321:              	UBaseType_t uxTaskGetSystemState( TaskStatus_t * const pxTaskStatusArray, const UBaseType_t uxArraySize, uint32_t * const pulTotalRunTime )
2322:              	{
2323:              	UBaseType_t uxTask = 0, uxQueue = configMAX_PRIORITIES;
2324:              
2325:              		vTaskSuspendAll();
2326:              		{
2327:              			/* Is there a space in the array for each task in the system? */
2328:              			if( uxArraySize >= uxCurrentNumberOfTasks )
2329:              			{
2330:              				/* Fill in an TaskStatus_t structure with information on each
2331:              				task in the Ready state. */
2332:              				do
2333:              				{
2334:              					uxQueue--;
2335:              					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &( pxReadyTasksLists[ uxQueue ] ), eReady );
2336:              
2337:              				} while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
2338:              
2339:              				/* Fill in an TaskStatus_t structure with information on each
2340:              				task in the Blocked state. */
2341:              				uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxDelayedTaskList, eBlocked );
2342:              				uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxOverflowDelayedTaskList, eBlocked );
2343:              
2344:              				#if( INCLUDE_vTaskDelete == 1 )
2345:              				{
2346:              					/* Fill in an TaskStatus_t structure with information on
2347:              					each task that has been deleted but not yet cleaned up. */
2348:              					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xTasksWaitingTermination, eDeleted );
2349:              				}
2350:              				#endif
2351:              
2352:              				#if ( INCLUDE_vTaskSuspend == 1 )
2353:              				{
2354:              					/* Fill in an TaskStatus_t structure with information on
2355:              					each task in the Suspended state. */
2356:              					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xSuspendedTaskList, eSuspended );
2357:              				}
2358:              				#endif
2359:              
2360:              				#if ( configGENERATE_RUN_TIME_STATS == 1)
2361:              				{
2362:              					if( pulTotalRunTime != NULL )
2363:              					{
2364:              						#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
2365:              							portALT_GET_RUN_TIME_COUNTER_VALUE( ( *pulTotalRunTime ) );
2366:              						#else
2367:              							*pulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
2368:              						#endif
2369:              					}
2370:              				}
2371:              				#else
2372:              				{
2373:              					if( pulTotalRunTime != NULL )
2374:              					{
2375:              						*pulTotalRunTime = 0;
2376:              					}
2377:              				}
2378:              				#endif
2379:              			}
2380:              			else
2381:              			{
2382:              				mtCOVERAGE_TEST_MARKER();
2383:              			}
2384:              		}
2385:              		( void ) xTaskResumeAll();
2386:              
2387:              		return uxTask;
2388:              	}
2389:              
2390:              #endif /* configUSE_TRACE_FACILITY */
2391:              /*----------------------------------------------------------*/
2392:              
2393:              #if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
2394:              
2395:              	TaskHandle_t xTaskGetIdleTaskHandle( void )
2396:              	{
2397:              		/* If xTaskGetIdleTaskHandle() is called before the scheduler has been
2398:              		started, then xIdleTaskHandle will be NULL. */
2399:              		configASSERT( ( xIdleTaskHandle != NULL ) );
2400:              		return xIdleTaskHandle;
2401:              	}
2402:              
2403:              #endif /* INCLUDE_xTaskGetIdleTaskHandle */
2404:              /*----------------------------------------------------------*/
2405:              
2406:              /* This conditional compilation should use inequality to 0, not equality to 1.
2407:              This is to ensure vTaskStepTick() is available when user defined low power mode
2408:              implementations require configUSE_TICKLESS_IDLE to be set to a value other than
2409:              1. */
2410:              #if ( configUSE_TICKLESS_IDLE != 0 )
2411:              
2412:              	void vTaskStepTick( const TickType_t xTicksToJump )
2413:              	{
2414:              		/* Correct the tick count value after a period during which the tick
2415:              		was suppressed.  Note this does *not* call the tick hook function for
2416:              		each stepped tick. */
2417:              		configASSERT( ( xTickCount + xTicksToJump ) <= xNextTaskUnblockTime );
2418:              		xTickCount += xTicksToJump;
2419:              		traceINCREASE_TICK_COUNT( xTicksToJump );
2420:              	}
2421:              
2422:              #endif /* configUSE_TICKLESS_IDLE */
2423:              /*----------------------------------------------------------*/
2424:              
2425:              #if ( INCLUDE_xTaskAbortDelay == 1 )
2426:              
2427:              	BaseType_t xTaskAbortDelay( TaskHandle_t xTask )
2428:              	{
2429:              	TCB_t *pxTCB = ( TCB_t * ) xTask;
2430:              	BaseType_t xReturn = pdFALSE;
2431:              
2432:              		configASSERT( pxTCB );
2433:              
2434:              		vTaskSuspendAll();
2435:              		{
2436:              			/* A task can only be prematurely removed from the Blocked state if
2437:              			it is actually in the Blocked state. */
2438:              			if( eTaskGetState( xTask ) == eBlocked )
2439:              			{
2440:              				/* Remove the reference to the task from the blocked list.  An
2441:              				interrupt won't touch the xStateListItem because the
2442:              				scheduler is suspended. */
2443:              				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
2444:              
2445:              				/* Is the task waiting on an event also?  If so remove it from
2446:              				the event list too.  Interrupts can touch the event list item,
2447:              				even though the scheduler is suspended, so a critical section
2448:              				is used. */
2449:              				taskENTER_CRITICAL();
2450:              				{
2451:              					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
2452:              					{
2453:              						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
2454:              						pxTCB->ucDelayAborted = pdTRUE;
2455:              					}
2456:              					else
2457:              					{
2458:              						mtCOVERAGE_TEST_MARKER();
2459:              					}
2460:              				}
2461:              				taskEXIT_CRITICAL();
2462:              
2463:              				/* Place the unblocked task into the appropriate ready list. */
2464:              				prvAddTaskToReadyList( pxTCB );
2465:              
2466:              				/* A task being unblocked cannot cause an immediate context
2467:              				switch if preemption is turned off. */
2468:              				#if (  configUSE_PREEMPTION == 1 )
2469:              				{
2470:              					/* Preemption is on, but a context switch should only be
2471:              					performed if the unblocked task has a priority that is
2472:              					equal to or higher than the currently executing task. */
2473:              					if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
2474:              					{
2475:              						/* Pend the yield to be performed when the scheduler
2476:              						is unsuspended. */
2477:              						xYieldPending = pdTRUE;
2478:              					}
2479:              					else
2480:              					{
2481:              						mtCOVERAGE_TEST_MARKER();
2482:              					}
2483:              				}
2484:              				#endif /* configUSE_PREEMPTION */
2485:              			}
2486:              			else
2487:              			{
2488:              				mtCOVERAGE_TEST_MARKER();
2489:              			}
2490:              		}
2491:              		xTaskResumeAll();
2492:              
2493:              		return xReturn;
2494:              	}
2495:              
2496:              #endif /* INCLUDE_xTaskAbortDelay */
2497:              /*----------------------------------------------------------*/
2498:              
2499:              BaseType_t xTaskIncrementTick( void )
2500:              {
001364  BE9F88     MOV.D W8, [W15++]
001366  BE9F8A     MOV.D W10, [W15++]
001368  BE9F8C     MOV.D W12, [W15++]
2501:              TCB_t * pxTCB;
2502:              TickType_t xItemValue;
2503:              BaseType_t xSwitchRequired = pdFALSE;
0013F2  EB0500     CLR W10
0013F4  370001     BRA .L99
2504:              
2505:              	/* Called by the portable layer each time a tick interrupt occurs.
2506:              	Increments the tick then checks to see if the new tick value will cause any
2507:              	tasks to be unblocked. */
2508:              	traceTASK_INCREMENT_TICK( xTickCount );
2509:              	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
00136A  E20866     CP0 uxSchedulerSuspended
00136C  3A0041     BRA NZ, .L89, .LBE7
2510:              	{
2511:              		/* Minor optimisation.  The tick count cannot change in this
2512:              		block. */
2513:              		const TickType_t xConstTickCount = xTickCount + 1;
00136E  8042AB     MOV xTickCount, W11
001370  E8058B     INC W11, W11
2514:              
2515:              		/* Increment the RTOS tick, switching the delayed and overflowed
2516:              		delayed lists if it wraps to 0. */
2517:              		xTickCount = xConstTickCount;
001372  8842AB     MOV W11, xTickCount
2518:              
2519:              		if( xConstTickCount == ( TickType_t ) 0U )
001374  3A0006     BRA NZ, .L90, .LBE8
2520:              		{
2521:              			taskSWITCH_DELAYED_LISTS();
001376  804340     MOV pxDelayedTaskList, W0
001378  F8086A     PUSH pxOverflowDelayedTaskList
00137A  F90868     POP pxDelayedTaskList
00137C  884350     MOV W0, pxOverflowDelayedTaskList
00137E  EC285E     INC xNumOfOverflows
001380  07FFE6     RCALL prvResetNextTaskUnblockTime
2522:              		}
2523:              		else
2524:              		{
2525:              			mtCOVERAGE_TEST_MARKER();
2526:              		}
2527:              
2528:              		/* See if this tick has made a timeout expire.  Tasks are stored in
2529:              		the	queue in the order of their wake time - meaning once one task
2530:              		has been found whose block time has not expired there is no need to
2531:              		look any further down the list. */
2532:              		if( xConstTickCount >= xNextTaskUnblockTime )
001382  EB0500     CLR W10
001384  804310     MOV xNextTaskUnblockTime, W0
001386  500F8B     SUB W0, W11, [W15]
001388  360003     BRA LEU, .L106
00138A  37002A     BRA .L92
2533:              		{
2534:              			for( ;; )
2535:              			{
2536:              				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
001394  804340     MOV pxDelayedTaskList, W0
001396  E00010     CP0 [W0]
001398  3A0002     BRA NZ, .L93
2537:              				{
2538:              					/* The delayed list is empty.  Set xNextTaskUnblockTime
2539:              					to the maximum possible value so it is extremely
2540:              					unlikely that the
2541:              					if( xTickCount >= xNextTaskUnblockTime ) test will pass
2542:              					next time through. */
2543:              					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
00139A  EFA862     SETM xNextTaskUnblockTime
2544:              					break;
00139C  370021     BRA .L92
2545:              				}
2546:              				else
2547:              				{
2548:              					/* The delayed list is not empty, get the value of the
2549:              					item at the head of the delayed list.  This is the time
2550:              					at which the task at the head of the delayed list must
2551:              					be removed from the Blocked state. */
2552:              					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
00139E  804340     MOV pxDelayedTaskList, W0
0013A0  900030     MOV [W0+6], W0
0013A2  900430     MOV [W0+6], W8
2553:              					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
0013A4  900018     MOV [W8+2], W0
2554:              
2555:              					if( xConstTickCount < xItemValue )
0013A6  558F80     SUB W11, W0, [W15]
0013A8  310002     BRA C, .L94
2556:              					{
2557:              						/* It is not time to unblock this item yet, but the
2558:              						item value is the time at which the task at the head
2559:              						of the blocked list must be removed from the Blocked
2560:              						state -	so record the item value in
2561:              						xNextTaskUnblockTime. */
2562:              						xNextTaskUnblockTime = xItemValue;
0013AA  884310     MOV W0, xNextTaskUnblockTime
2563:              						break;
0013AC  370019     BRA .L92
2564:              					}
2565:              					else
2566:              					{
2567:              						mtCOVERAGE_TEST_MARKER();
2568:              					}
2569:              
2570:              					/* It is time to remove the item from the Blocked state. */
2571:              					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
0013AE  E88488     INC2 W8, W9
0013B0  780009     MOV W9, W0
0013B2  022D4A     CALL uxListRemove
0013B4  000000     NOP
2572:              
2573:              					/* Is the task waiting on an event also?  If so remove
2574:              					it from the event list. */
2575:              					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
0013B6  900828     MOV [W8+20], W0
0013B8  E00000     CP0 W0
0013BA  320003     BRA Z, .L95
2576:              					{
2577:              						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
0013BC  44006C     ADD W8, #0xC, W0
0013BE  022D4A     CALL uxListRemove
0013C0  000000     NOP
2578:              					}
2579:              					else
2580:              					{
2581:              						mtCOVERAGE_TEST_MARKER();
2582:              					}
2583:              
2584:              					/* Place the unblocked task into the appropriate ready
2585:              					list. */
2586:              					prvAddTaskToReadyList( pxTCB );
001390  21CF8C     MOV #0x1CF8, W12
0013C2  900838     MOV [W8+22], W0
0013C4  E30856     CP uxTopReadyPriority
0013C6  310001     BRA C, .L96
0013C8  8842B0     MOV W0, uxTopReadyPriority
0013CA  B9006A     MUL.SU W0, #10, W0
0013CC  460000     ADD W12, W0, W0
0013CE  780089     MOV W9, W1
0013D0  022D10     CALL vListInsertEnd
0013D2  000000     NOP
2587:              
2588:              					/* A task being unblocked cannot cause an immediate
2589:              					context switch if preemption is turned off. */
2590:              					#if (  configUSE_PREEMPTION == 1 )
2591:              					{
2592:              						/* Preemption is on, but a context switch should
2593:              						only be performed if the unblocked task has a
2594:              						priority that is equal to or higher than the
2595:              						currently executing task. */
2596:              						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
0013D4  804280     MOV pxCurrentTCB, W0
0013D6  9008B8     MOV [W8+22], W1
0013D8  900830     MOV [W0+22], W0
0013DA  508F80     SUB W1, W0, [W15]
0013DC  31FFD7     BRA C, .L102
0013DE  37FFDA     BRA .L107
2597:              						{
2598:              							xSwitchRequired = pdTRUE;
00138C  78050D     MOV W13, W10
00138E  370002     BRA .L107
001392  20001D     MOV #0x1, W13
2599:              						}
2600:              						else
2601:              						{
2602:              							mtCOVERAGE_TEST_MARKER();
2603:              						}
2604:              					}
2605:              					#endif /* configUSE_PREEMPTION */
2606:              				}
2607:              			}
2608:              		}
2609:              
2610:              		/* Tasks of equal priority to the currently running task will share
2611:              		processing time (time slice) if preemption is on, and the application
2612:              		writer has not explicitly turned time slicing off. */
2613:              		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
2614:              		{
2615:              			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
0013E0  804280     MOV pxCurrentTCB, W0
0013E2  900830     MOV [W0+22], W0
0013E4  B9006A     MUL.SU W0, #10, W0
0013E6  21CF82     MOV #0x1CF8, W2
0013E8  780062     MOV [W2+W0], W0
0013EA  500FE1     SUB W0, #0x1, [W15]
0013EC  3E0004     BRA GTU, .L103
0013EE  370004     BRA .L99
2616:              			{
2617:              				xSwitchRequired = pdTRUE;
0013F6  20001A     MOV #0x1, W10
2618:              			}
2619:              			else
2620:              			{
2621:              				mtCOVERAGE_TEST_MARKER();
2622:              			}
2623:              		}
2624:              		#endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) ) */
2625:              
2626:              		#if ( configUSE_TICK_HOOK == 1 )
2627:              		{
2628:              			/* Guard against the tick hook being called when the pended tick
2629:              			count is being unwound (when the scheduler is being unlocked). */
2630:              			if( uxPendedTicks == ( UBaseType_t ) 0U )
2631:              			{
2632:              				vApplicationTickHook();
2633:              			}
2634:              			else
2635:              			{
2636:              				mtCOVERAGE_TEST_MARKER();
2637:              			}
2638:              		}
2639:              		#endif /* configUSE_TICK_HOOK */
2640:              	}
2641:              	else
2642:              	{
2643:              		++uxPendedTicks;
0013F0  EC285A     INC uxPendedTicks
2644:              
2645:              		/* The tick hook gets called at regular intervals, even if the
2646:              		scheduler is locked. */
2647:              		#if ( configUSE_TICK_HOOK == 1 )
2648:              		{
2649:              			vApplicationTickHook();
2650:              		}
2651:              		#endif
2652:              	}
2653:              
2654:              	#if ( configUSE_PREEMPTION == 1 )
2655:              	{
2656:              		if( xYieldPending != pdFALSE )
0013F8  E2085C     CP0 xYieldPending
0013FA  320001     BRA Z, .L100
2657:              		{
2658:              			xSwitchRequired = pdTRUE;
0013FC  20001A     MOV #0x1, W10
2659:              		}
2660:              		else
2661:              		{
2662:              			mtCOVERAGE_TEST_MARKER();
2663:              		}
2664:              	}
2665:              	#endif /* configUSE_PREEMPTION */
2666:              
2667:              	return xSwitchRequired;
2668:              }
0013FE  78000A     MOV W10, W0
001400  BE064F     MOV.D [--W15], W12
001402  BE054F     MOV.D [--W15], W10
001404  BE044F     MOV.D [--W15], W8
001406  060000     RETURN
2669:              /*-----------------------------------------------------------*/
2670:              
2671:              #if ( configUSE_APPLICATION_TASK_TAG == 1 )
2672:              
2673:              	void vTaskSetApplicationTaskTag( TaskHandle_t xTask, TaskHookFunction_t pxHookFunction )
2674:              	{
2675:              	TCB_t *xTCB;
2676:              
2677:              		/* If xTask is NULL then it is the task hook of the calling task that is
2678:              		getting set. */
2679:              		if( xTask == NULL )
2680:              		{
2681:              			xTCB = ( TCB_t * ) pxCurrentTCB;
2682:              		}
2683:              		else
2684:              		{
2685:              			xTCB = ( TCB_t * ) xTask;
2686:              		}
2687:              
2688:              		/* Save the hook function in the TCB.  A critical section is required as
2689:              		the value can be accessed from an interrupt. */
2690:              		taskENTER_CRITICAL();
2691:              			xTCB->pxTaskTag = pxHookFunction;
2692:              		taskEXIT_CRITICAL();
2693:              	}
2694:              
2695:              #endif /* configUSE_APPLICATION_TASK_TAG */
2696:              /*-----------------------------------------------------------*/
2697:              
2698:              #if ( configUSE_APPLICATION_TASK_TAG == 1 )
2699:              
2700:              	TaskHookFunction_t xTaskGetApplicationTaskTag( TaskHandle_t xTask )
2701:              	{
2702:              	TCB_t *xTCB;
2703:              	TaskHookFunction_t xReturn;
2704:              
2705:              		/* If xTask is NULL then we are setting our own task hook. */
2706:              		if( xTask == NULL )
2707:              		{
2708:              			xTCB = ( TCB_t * ) pxCurrentTCB;
2709:              		}
2710:              		else
2711:              		{
2712:              			xTCB = ( TCB_t * ) xTask;
2713:              		}
2714:              
2715:              		/* Save the hook function in the TCB.  A critical section is required as
2716:              		the value can be accessed from an interrupt. */
2717:              		taskENTER_CRITICAL();
2718:              		{
2719:              			xReturn = xTCB->pxTaskTag;
2720:              		}
2721:              		taskEXIT_CRITICAL();
2722:              
2723:              		return xReturn;
2724:              	}
2725:              
2726:              #endif /* configUSE_APPLICATION_TASK_TAG */
2727:              /*-----------------------------------------------------------*/
2728:              
2729:              #if ( configUSE_APPLICATION_TASK_TAG == 1 )
2730:              
2731:              	BaseType_t xTaskCallApplicationTaskHook( TaskHandle_t xTask, void *pvParameter )
2732:              	{
2733:              	TCB_t *xTCB;
2734:              	BaseType_t xReturn;
2735:              
2736:              		/* If xTask is NULL then we are calling our own task hook. */
2737:              		if( xTask == NULL )
2738:              		{
2739:              			xTCB = ( TCB_t * ) pxCurrentTCB;
2740:              		}
2741:              		else
2742:              		{
2743:              			xTCB = ( TCB_t * ) xTask;
2744:              		}
2745:              
2746:              		if( xTCB->pxTaskTag != NULL )
2747:              		{
2748:              			xReturn = xTCB->pxTaskTag( pvParameter );
2749:              		}
2750:              		else
2751:              		{
2752:              			xReturn = pdFAIL;
2753:              		}
2754:              
2755:              		return xReturn;
2756:              	}
2757:              
2758:              #endif /* configUSE_APPLICATION_TASK_TAG */
2759:              /*-----------------------------------------------------------*/
2760:              
2761:              void vTaskSwitchContext( void )
001112  B9116A     MUL.SU W2, #10, W2
001114  21CF81     MOV #0x1CF8, W1
001116  408082     ADD W1, W2, W1
2762:              {
0010D2  FA0014     LNK #0x14
2763:              	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
0010D4  E20866     CP0 uxSchedulerSuspended
0010D6  320003     BRA Z, .L45
2764:              	{
2765:              		/* The scheduler is currently suspended - do not allow a context
2766:              		switch. */
2767:              		xYieldPending = pdTRUE;
0010D8  200010     MOV #0x1, W0
0010DA  8842E0     MOV W0, xYieldPending
0010DC  370038     BRA .L44, .LBE4
2768:              	}
2769:              	else
2770:              	{
2771:              		xYieldPending = pdFALSE;
0010DE  EF285C     CLR xYieldPending
2772:              		traceTASK_SWITCHED_OUT();
2773:              
2774:              		#if ( configGENERATE_RUN_TIME_STATS == 1 )
2775:              		{
2776:              				#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
2777:              					portALT_GET_RUN_TIME_COUNTER_VALUE( ulTotalRunTime );
2778:              				#else
2779:              					ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
2780:              				#endif
2781:              
2782:              				/* Add the amount of time the task has been running to the
2783:              				accumulated time so far.  The time the task started running was
2784:              				stored in ulTaskSwitchedInTime.  Note that there is no overflow
2785:              				protection here so count values are only valid until the timer
2786:              				overflows.  The guard against negative values is to protect
2787:              				against suspect run time stat counter implementations - which
2788:              				are provided by the application, not the kernel. */
2789:              				if( ulTotalRunTime > ulTaskSwitchedInTime )
2790:              				{
2791:              					pxCurrentTCB->ulRunTimeCounter += ( ulTotalRunTime - ulTaskSwitchedInTime );
2792:              				}
2793:              				else
2794:              				{
2795:              					mtCOVERAGE_TEST_MARKER();
2796:              				}
2797:              				ulTaskSwitchedInTime = ulTotalRunTime;
2798:              		}
2799:              		#endif /* configGENERATE_RUN_TIME_STATS */
2800:              
2801:              		/* Check for stack overflow, if configured. */
2802:              		taskCHECK_FOR_STACK_OVERFLOW();
0010E0  804280     MOV pxCurrentTCB, W0
0010E2  900870     MOV [W0+30], W0
0010E4  5780F4     SUB W15, #0x14, W1
0010E6  28E512     MOV #0x8E51, W2
0010E8  090013     REPEAT #0x13
0010EA  7858B2     MOV.B [W2++], [W1++]
0010EC  500074     SUB W0, #0x14, W0
0010EE  200142     MOV #0x14, W2
0010F0  5780F4     SUB W15, #0x14, W1
0010F2  020CEA     CALL _memcmp
0010F4  000000     NOP
0010F6  E00000     CP0 W0
0010F8  320005     BRA Z, .L47, .LBE3, .LBB4
0010FA  804281     MOV pxCurrentTCB, W1
0010FC  804280     MOV pxCurrentTCB, W0
0010FE  4080FA     ADD W1, #0x1A, W1
001100  022964     CALL vApplicationStackOverflowHook
001102  000000     NOP
2803:              
2804:              		/* Select a new task to run using either the generic C or port
2805:              		optimised asm code. */
2806:              		taskSELECT_HIGHEST_PRIORITY_TASK();
001104  8042B0     MOV uxTopReadyPriority, W0
001106  B9016A     MUL.SU W0, #10, W2
001108  21CF81     MOV #0x1CF8, W1
00110A  7900E1     MOV [W1+W2], W1
00110C  E00001     CP0 W1
00110E  3A0009     BRA NZ, .L48, .LBB5
001110  E90100     DEC W0, W2
001118  E90000     DEC W0, W0
00111A  780111     MOV [W1], W2
00111C  5080EA     SUB W1, #0xA, W1
00111E  E00002     CP0 W2
001120  32FFFB     BRA Z, .L49
001122  B9016A     MUL.SU W0, #10, W2
001124  E88182     INC2 W2, W3
001126  21CF81     MOV #0x1CF8, W1
001128  7981E1     MOV [W1+W3], W3
00112A  900193     MOV [W3+2], W3
00112C  408202     ADD W1, W2, W4
00112E  980213     MOV W3, [W4+2]
001130  410164     ADD W2, #0x4, W2
001132  410081     ADD W2, W1, W1
001134  518F81     SUB W3, W1, [W15]
001136  3A0004     BRA NZ, .L50
001138  B9026A     MUL.SU W0, #10, W4
00113A  21CFA1     MOV #0x1CFA, W1
00113C  900193     MOV [W3+2], W3
00113E  7A3083     MOV W3, [W1+W4]
001140  B9016A     MUL.SU W0, #10, W2
001142  E88082     INC2 W2, W1
001144  21CF82     MOV #0x1CF8, W2
001146  7880E2     MOV [W2+W1], W1
001148  9000B1     MOV [W1+6], W1
00114A  884281     MOV W1, pxCurrentTCB
00114C  8842B0     MOV W0, uxTopReadyPriority
2807:              		traceTASK_SWITCHED_IN();
2808:              
2809:              		#if ( configUSE_NEWLIB_REENTRANT == 1 )
2810:              		{
2811:              			/* Switch Newlib's _impure_ptr variable to point to the _reent
2812:              			structure specific to this task. */
2813:              			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
2814:              		}
2815:              		#endif /* configUSE_NEWLIB_REENTRANT */
2816:              	}
2817:              }
00114E  FA8000     ULNK
001150  060000     RETURN
2818:              /*-----------------------------------------------------------*/
2819:              
2820:              void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
2821:              {
001852  781F88     MOV W8, [W15++]
001854  780401     MOV W1, W8
2822:              	configASSERT( pxEventList );
2823:              
2824:              	/* THIS FUNCTION MUST BE CALLED WITH EITHER INTERRUPTS DISABLED OR THE
2825:              	SCHEDULER SUSPENDED AND THE QUEUE BEING ACCESSED LOCKED. */
2826:              
2827:              	/* Place the event list item of the TCB in the appropriate event list.
2828:              	This is placed in the list in priority order so the highest priority task
2829:              	is the first to be woken by the event.  The queue that contains the event
2830:              	list is locked, preventing simultaneous access from interrupts. */
2831:              	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
001856  804281     MOV pxCurrentTCB, W1
001858  4080EC     ADD W1, #0xC, W1
00185A  022D24     CALL vListInsert
00185C  000000     NOP
2832:              
2833:              	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
00185E  200011     MOV #0x1, W1
001860  780008     MOV W8, W0
001862  07FF3A     RCALL prvAddCurrentTaskToDelayedList
2834:              }
001864  78044F     MOV [--W15], W8
001866  060000     RETURN
2835:              /*-----------------------------------------------------------*/
2836:              
2837:              void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
2838:              {
001834  781F88     MOV W8, [W15++]
001836  780402     MOV W2, W8
2839:              	configASSERT( pxEventList );
2840:              
2841:              	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
2842:              	the event groups implementation. */
2843:              	configASSERT( uxSchedulerSuspended != 0 );
2844:              
2845:              	/* Store the item value in the event list item.  It is safe to access the
2846:              	event list item here as interrupts won't access the event list item of a
2847:              	task that is not in the Blocked state. */
2848:              	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
001838  804282     MOV pxCurrentTCB, W2
00183A  280003     MOV #0x8000, W3
00183C  718081     IOR W3, W1, W1
00183E  980161     MOV W1, [W2+12]
2849:              
2850:              	/* Place the event list item of the TCB at the end of the appropriate event
2851:              	list.  It is safe to access the event list here because it is part of an
2852:              	event group implementation - and interrupts don't access event groups
2853:              	directly (instead they access them indirectly by pending function calls to
2854:              	the task level). */
2855:              	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
001840  804281     MOV pxCurrentTCB, W1
001842  4080EC     ADD W1, #0xC, W1
001844  022D10     CALL vListInsertEnd
001846  000000     NOP
2856:              
2857:              	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
001848  200011     MOV #0x1, W1
00184A  780008     MOV W8, W0
00184C  07FF45     RCALL prvAddCurrentTaskToDelayedList
2858:              }
00184E  78044F     MOV [--W15], W8
001850  060000     RETURN
2859:              /*-----------------------------------------------------------*/
2860:              
2861:              #if( configUSE_TIMERS == 1 )
2862:              
2863:              	void vTaskPlaceOnEventListRestricted( List_t * const pxEventList, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
2864:              	{
2865:              		configASSERT( pxEventList );
2866:              
2867:              		/* This function should not be called by application code hence the
2868:              		'Restricted' in its name.  It is not part of the public API.  It is
2869:              		designed for use by kernel code, and has special calling requirements -
2870:              		it should be called with the scheduler suspended. */
2871:              
2872:              
2873:              		/* Place the event list item of the TCB in the appropriate event list.
2874:              		In this case it is assume that this is the only task that is going to
2875:              		be waiting on this event list, so the faster vListInsertEnd() function
2876:              		can be used in place of vListInsert. */
2877:              		vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
2878:              
2879:              		/* If the task should block indefinitely then set the block time to a
2880:              		value that will be recognised as an indefinite delay inside the
2881:              		prvAddCurrentTaskToDelayedList() function. */
2882:              		if( xWaitIndefinitely != pdFALSE )
2883:              		{
2884:              			xTicksToWait = portMAX_DELAY;
2885:              		}
2886:              
2887:              		traceTASK_DELAY_UNTIL( ( xTickCount + xTicksToWait ) );
2888:              		prvAddCurrentTaskToDelayedList( xTicksToWait, xWaitIndefinitely );
2889:              	}
2890:              
2891:              #endif /* configUSE_TIMERS */
2892:              /*-----------------------------------------------------------*/
2893:              
2894:              BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
2895:              {
001152  BE9F88     MOV.D W8, [W15++]
2896:              TCB_t *pxUnblockedTCB;
2897:              BaseType_t xReturn;
2898:              
2899:              	/* THIS FUNCTION MUST BE CALLED FROM A CRITICAL SECTION.  It can also be
2900:              	called from a critical section within an ISR. */
2901:              
2902:              	/* The event list is sorted in priority order, so the first in the list can
2903:              	be removed as it is known to be the highest priority.  Remove the TCB from
2904:              	the delayed list, and add it to the ready list.
2905:              
2906:              	If an event is for a queue that is locked then this function will never
2907:              	get called - the lock count on the queue will get modified instead.  This
2908:              	means exclusive access to the event list is guaranteed here.
2909:              
2910:              	This function assumes that a check has already been made to ensure that
2911:              	pxEventList is not empty. */
2912:              	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
001154  900030     MOV [W0+6], W0
001156  9004B0     MOV [W0+6], W9
2913:              	configASSERT( pxUnblockedTCB );
2914:              	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
001158  44846C     ADD W9, #0xC, W8
00115A  780008     MOV W8, W0
00115C  022D4A     CALL uxListRemove
00115E  000000     NOP
2915:              
2916:              	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
001160  E20866     CP0 uxSchedulerSuspended
001162  3A000F     BRA NZ, .L53
2917:              	{
2918:              		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
001164  E88409     INC2 W9, W8
001166  780008     MOV W8, W0
001168  022D4A     CALL uxListRemove
00116A  000000     NOP
2919:              		prvAddTaskToReadyList( pxUnblockedTCB );
00116C  900839     MOV [W9+22], W0
00116E  E30856     CP uxTopReadyPriority
001170  310001     BRA C, .L54
001172  8842B0     MOV W0, uxTopReadyPriority
001174  B9006A     MUL.SU W0, #10, W0
001176  21CF82     MOV #0x1CF8, W2
001178  410000     ADD W2, W0, W0
00117A  780088     MOV W8, W1
00117C  022D10     CALL vListInsertEnd
00117E  000000     NOP
001180  370004     BRA .L55
2920:              	}
2921:              	else
2922:              	{
2923:              		/* The delayed and ready lists cannot be accessed, so hold this task
2924:              		pending until the scheduler is resumed. */
2925:              		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
001182  780088     MOV W8, W1
001184  21D340     MOV #0x1D34, W0
001186  022D10     CALL vListInsertEnd
001188  000000     NOP
2926:              	}
2927:              
2928:              	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
00118A  804280     MOV pxCurrentTCB, W0
00118C  900939     MOV [W9+22], W2
00118E  9008B0     MOV [W0+22], W1
001192  510F81     SUB W2, W1, [W15]
001194  360002     BRA LEU, .L56
2929:              	{
2930:              		/* Return true if the task removed from the event list has a higher
2931:              		priority than the calling task.  This allows the calling task to know if
2932:              		it should force a context switch now. */
2933:              		xReturn = pdTRUE;
2934:              
2935:              		/* Mark that a yield is pending in case the user is not using the
2936:              		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
2937:              		xYieldPending = pdTRUE;
001196  200010     MOV #0x1, W0
001198  8842E0     MOV W0, xYieldPending
2938:              	}
2939:              	else
2940:              	{
2941:              		xReturn = pdFALSE;
001190  EB0000     CLR W0
2942:              	}
2943:              
2944:              	#if( configUSE_TICKLESS_IDLE != 0 )
2945:              	{
2946:              		/* If a task is blocked on a kernel object then xNextTaskUnblockTime
2947:              		might be set to the blocked task's time out time.  If the task is
2948:              		unblocked for a reason other than a timeout xNextTaskUnblockTime is
2949:              		normally left unchanged, because it is automatically reset to a new
2950:              		value when the tick count equals xNextTaskUnblockTime.  However if
2951:              		tickless idling is used it might be more important to enter sleep mode
2952:              		at the earliest possible time - so reset xNextTaskUnblockTime here to
2953:              		ensure it is updated at the earliest possible time. */
2954:              		prvResetNextTaskUnblockTime();
2955:              	}
2956:              	#endif
2957:              
2958:              	return xReturn;
2959:              }
00119A  BE044F     MOV.D [--W15], W8
00119C  060000     RETURN
2960:              /*-----------------------------------------------------------*/
2961:              
2962:              BaseType_t xTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
2963:              {
00119E  BE9F88     MOV.D W8, [W15++]
2964:              TCB_t *pxUnblockedTCB;
2965:              BaseType_t xReturn;
2966:              
2967:              	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
2968:              	the event flags implementation. */
2969:              	configASSERT( uxSchedulerSuspended != pdFALSE );
2970:              
2971:              	/* Store the new item value in the event list. */
2972:              	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
0011A0  280002     MOV #0x8000, W2
0011A2  708802     IOR W1, W2, [W0]
2973:              
2974:              	/* Remove the event list form the event flag.  Interrupts do not access
2975:              	event flags. */
2976:              	pxUnblockedTCB = ( TCB_t * ) listGET_LIST_ITEM_OWNER( pxEventListItem );
0011A4  900430     MOV [W0+6], W8
2977:              	configASSERT( pxUnblockedTCB );
2978:              	( void ) uxListRemove( pxEventListItem );
0011A6  022D4A     CALL uxListRemove
0011A8  000000     NOP
2979:              
2980:              	/* Remove the task from the delayed list and add it to the ready list.  The
2981:              	scheduler is suspended so interrupts will not be accessing the ready
2982:              	lists. */
2983:              	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
0011AA  E88488     INC2 W8, W9
0011AC  780009     MOV W9, W0
0011AE  022D4A     CALL uxListRemove
0011B0  000000     NOP
2984:              	prvAddTaskToReadyList( pxUnblockedTCB );
0011B2  900838     MOV [W8+22], W0
0011B4  E30856     CP uxTopReadyPriority
0011B6  310001     BRA C, .L59
0011B8  8842B0     MOV W0, uxTopReadyPriority
0011BA  B9006A     MUL.SU W0, #10, W0
0011BC  21CF82     MOV #0x1CF8, W2
0011BE  410000     ADD W2, W0, W0
0011C0  780089     MOV W9, W1
0011C2  022D10     CALL vListInsertEnd
0011C4  000000     NOP
2985:              
2986:              	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
0011C6  804280     MOV pxCurrentTCB, W0
0011C8  900938     MOV [W8+22], W2
0011CA  9008B0     MOV [W0+22], W1
0011CE  510F81     SUB W2, W1, [W15]
0011D0  360002     BRA LEU, .L60
2987:              	{
2988:              		/* Return true if the task removed from the event list has
2989:              		a higher priority than the calling task.  This allows
2990:              		the calling task to know if it should force a context
2991:              		switch now. */
2992:              		xReturn = pdTRUE;
2993:              
2994:              		/* Mark that a yield is pending in case the user is not using the
2995:              		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
2996:              		xYieldPending = pdTRUE;
0011D2  200010     MOV #0x1, W0
0011D4  8842E0     MOV W0, xYieldPending
2997:              	}
2998:              	else
2999:              	{
3000:              		xReturn = pdFALSE;
0011CC  EB0000     CLR W0
3001:              	}
3002:              
3003:              	return xReturn;
3004:              }
0011D6  BE044F     MOV.D [--W15], W8
0011D8  060000     RETURN
3005:              /*-----------------------------------------------------------*/
3006:              
3007:              void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
3008:              {
3009:              	configASSERT( pxTimeOut );
3010:              	pxTimeOut->xOverflowCount = xNumOfOverflows;
0011DA  8042F1     MOV xNumOfOverflows, W1
0011DC  780801     MOV W1, [W0]
3011:              	pxTimeOut->xTimeOnEntering = xTickCount;
0011DE  8042A1     MOV xTickCount, W1
0011E0  980011     MOV W1, [W0+2]
3012:              }
0011E2  060000     RETURN
3013:              /*-----------------------------------------------------------*/
3014:              
3015:              BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
3016:              {
0011E4  BE9F88     MOV.D W8, [W15++]
0011E6  781F8A     MOV W10, [W15++]
0011E8  780480     MOV W0, W9
0011EA  780501     MOV W1, W10
3017:              BaseType_t xReturn;
3018:              
3019:              	configASSERT( pxTimeOut );
3020:              	configASSERT( pxTicksToWait );
3021:              
3022:              	taskENTER_CRITICAL();
0011EC  022BB0     CALL vPortEnterCritical
0011EE  000000     NOP
3023:              	{
3024:              		/* Minor optimisation.  The tick count cannot change in this block. */
3025:              		const TickType_t xConstTickCount = xTickCount;
0011F0  8042A1     MOV xTickCount, W1
3026:              
3027:              		#if( INCLUDE_xTaskAbortDelay == 1 )
3028:              			if( pxCurrentTCB->ucDelayAborted != pdFALSE )
3029:              			{
3030:              				/* The delay was aborted, which is not the same as a time out,
3031:              				but has the same result. */
3032:              				pxCurrentTCB->ucDelayAborted = pdFALSE;
3033:              				xReturn = pdTRUE;
3034:              			}
3035:              			else
3036:              		#endif
3037:              
3038:              		#if ( INCLUDE_vTaskSuspend == 1 )
3039:              			if( *pxTicksToWait == portMAX_DELAY )
0011F2  78001A     MOV [W10], W0
0011F6  400FE1     ADD W0, #0x1, [W15]
0011F8  320012     BRA Z, .L64, .LBE6
3040:              			{
3041:              				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
3042:              				specified is the maximum block time then the task should block
3043:              				indefinitely, and therefore never time out. */
3044:              				xReturn = pdFALSE;
0011F4  EB0400     CLR W8
3045:              			}
3046:              			else
3047:              		#endif
3048:              
3049:              		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
0011FA  780119     MOV [W9], W2
0011FC  8042F3     MOV xNumOfOverflows, W3
0011FE  518F82     SUB W3, W2, [W15]
001200  320004     BRA Z, .L65
001202  900119     MOV [W9+2], W2
001206  508F82     SUB W1, W2, [W15]
001208  31000A     BRA C, .L64, .LBE6
3050:              		{
3051:              			/* The tick count is greater than the time at which
3052:              			vTaskSetTimeout() was called, but has also overflowed since
3053:              			vTaskSetTimeOut() was called.  It must have wrapped all the way
3054:              			around and gone past again. This passed since vTaskSetTimeout()
3055:              			was called. */
3056:              			xReturn = pdTRUE;
001204  200018     MOV #0x1, W8
3057:              		}
3058:              		else if( ( ( TickType_t ) ( xConstTickCount - pxTimeOut->xTimeOnEntering ) ) < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
00120A  900119     MOV [W9+2], W2
00120C  508182     SUB W1, W2, W3
001210  500F83     SUB W0, W3, [W15]
001212  360005     BRA LEU, .L64, .LBE6
3059:              		{
3060:              			/* Not a genuine timeout. Adjust parameters for time remaining. */
3061:              			*pxTicksToWait -= ( xConstTickCount - pxTimeOut->xTimeOnEntering );
001214  510081     SUB W2, W1, W1
001216  408D00     ADD W1, W0, [W10]
3062:              			vTaskSetTimeOutState( pxTimeOut );
001218  780009     MOV W9, W0
00121A  07FFDF     RCALL vTaskSetTimeOutState
3063:              			xReturn = pdFALSE;
00121C  EB0400     CLR W8
3064:              		}
3065:              		else
3066:              		{
3067:              			xReturn = pdTRUE;
00120E  200018     MOV #0x1, W8
3068:              		}
3069:              	}
3070:              	taskEXIT_CRITICAL();
00121E  022BC0     CALL vPortExitCritical
001220  000000     NOP
3071:              
3072:              	return xReturn;
3073:              }
001222  780008     MOV W8, W0
001224  78054F     MOV [--W15], W10
001226  BE044F     MOV.D [--W15], W8
001228  060000     RETURN
3074:              /*-----------------------------------------------------------*/
3075:              
3076:              void vTaskMissedYield( void )
3077:              {
3078:              	xYieldPending = pdTRUE;
00122A  200010     MOV #0x1, W0
00122C  8842E0     MOV W0, xYieldPending
3079:              }
00122E  060000     RETURN
3080:              /*-----------------------------------------------------------*/
3081:              
3082:              #if ( configUSE_TRACE_FACILITY == 1 )
3083:              
3084:              	UBaseType_t uxTaskGetTaskNumber( TaskHandle_t xTask )
3085:              	{
3086:              	UBaseType_t uxReturn;
3087:              	TCB_t *pxTCB;
3088:              
3089:              		if( xTask != NULL )
3090:              		{
3091:              			pxTCB = ( TCB_t * ) xTask;
3092:              			uxReturn = pxTCB->uxTaskNumber;
3093:              		}
3094:              		else
3095:              		{
3096:              			uxReturn = 0U;
3097:              		}
3098:              
3099:              		return uxReturn;
3100:              	}
3101:              
3102:              #endif /* configUSE_TRACE_FACILITY */
3103:              /*-----------------------------------------------------------*/
3104:              
3105:              #if ( configUSE_TRACE_FACILITY == 1 )
3106:              
3107:              	void vTaskSetTaskNumber( TaskHandle_t xTask, const UBaseType_t uxHandle )
3108:              	{
3109:              	TCB_t *pxTCB;
3110:              
3111:              		if( xTask != NULL )
3112:              		{
3113:              			pxTCB = ( TCB_t * ) xTask;
3114:              			pxTCB->uxTaskNumber = uxHandle;
3115:              		}
3116:              	}
3117:              
3118:              #endif /* configUSE_TRACE_FACILITY */
3119:              
3120:              /*
3121:               * -----------------------------------------------------------
3122:               * The Idle task.
3123:               * ----------------------------------------------------------
3124:               *
3125:               * The portTASK_FUNCTION() macro is used to allow port/compiler specific
3126:               * language extensions.  The equivalent prototype for this function is:
3127:               *
3128:               * void prvIdleTask( void *pvParameters );
3129:               *
3130:               */
3131:              static portTASK_FUNCTION( prvIdleTask, pvParameters )
3132:              {
000EAE  781F88     MOV W8, [W15++]
3133:              	/* Stop warnings. */
3134:              	( void ) pvParameters;
3135:              
3136:              	/** THIS IS THE RTOS IDLE TASK - WHICH IS CREATED AUTOMATICALLY WHEN THE
3137:              	SCHEDULER IS STARTED. **/
3138:              
3139:              	for( ;; )
3140:              	{
3141:              		/* See if any tasks have deleted themselves - if so then the idle task
3142:              		is responsible for freeing the deleted task's TCB and stack. */
3143:              		prvCheckTasksWaitingTermination();
3144:              
3145:              		#if ( configUSE_PREEMPTION == 0 )
3146:              		{
3147:              			/* If we are not using preemption we keep forcing a task switch to
3148:              			see if any other task has become available.  If we are using
3149:              			preemption we don't need to do this as any task becoming available
3150:              			will automatically get the processor anyway. */
3151:              			taskYIELD();
3152:              		}
3153:              		#endif /* configUSE_PREEMPTION */
3154:              
3155:              		#if ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) )
3156:              		{
3157:              			/* When using preemption tasks of equal priority will be
3158:              			timesliced.  If a task that is sharing the idle priority is ready
3159:              			to run then the idle task should yield before the end of the
3160:              			timeslice.
3161:              
3162:              			A critical region is not required here as we are just reading from
3163:              			the list, and an occasional incorrect value will not matter.  If
3164:              			the ready list at the idle priority contains more than one task
3165:              			then a task other than the idle task is ready to execute. */
3166:              			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
000EB0  21CF88     MOV #0x1CF8, W8
000EB2  200010     MOV #0x1, W0
000EB4  100F98     SUBR W0, [W8], [W15]
000EB6  360003     BRA LEU, .L2, .LBB2
3167:              			{
3168:              				taskYIELD();
000EB8  022DC4     CALL .Letext0, .LFE2, _vPortYield
000EBA  000000     NOP
000EBC  000000     NOP
3169:              			}
3170:              			else
3171:              			{
3172:              				mtCOVERAGE_TEST_MARKER();
3173:              			}
3174:              		}
3175:              		#endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) ) */
3176:              
3177:              		#if ( configUSE_IDLE_HOOK == 1 )
3178:              		{
3179:              			extern void vApplicationIdleHook( void );
3180:              
3181:              			/* Call the user defined function from within the idle task.  This
3182:              			allows the application designer to add background functionality
3183:              			without the overhead of a separate task.
3184:              			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
3185:              			CALL A FUNCTION THAT MIGHT BLOCK. */
3186:              			vApplicationIdleHook();
000EBE  02295E     CALL vApplicationIdleHook
000EC0  000000     NOP
3187:              		}
3188:              		#endif /* configUSE_IDLE_HOOK */
3189:              
3190:              		/* This conditional compilation should use inequality to 0, not equality
3191:              		to 1.  This is to ensure portSUPPRESS_TICKS_AND_SLEEP() is called when
3192:              		user defined low power mode	implementations require
3193:              		configUSE_TICKLESS_IDLE to be set to a value other than 1. */
3194:              		#if ( configUSE_TICKLESS_IDLE != 0 )
3195:              		{
3196:              		TickType_t xExpectedIdleTime;
3197:              
3198:              			/* It is not desirable to suspend then resume the scheduler on
3199:              			each iteration of the idle task.  Therefore, a preliminary
3200:              			test of the expected idle time is performed without the
3201:              			scheduler suspended.  The result here is not necessarily
3202:              			valid. */
3203:              			xExpectedIdleTime = prvGetExpectedIdleTime();
3204:              
3205:              			if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
3206:              			{
3207:              				vTaskSuspendAll();
3208:              				{
3209:              					/* Now the scheduler is suspended, the expected idle
3210:              					time can be sampled again, and this time its value can
3211:              					be used. */
3212:              					configASSERT( xNextTaskUnblockTime >= xTickCount );
3213:              					xExpectedIdleTime = prvGetExpectedIdleTime();
3214:              
3215:              					if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
3216:              					{
3217:              						traceLOW_POWER_IDLE_BEGIN();
3218:              						portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime );
3219:              						traceLOW_POWER_IDLE_END();
3220:              					}
3221:              					else
3222:              					{
3223:              						mtCOVERAGE_TEST_MARKER();
3224:              					}
3225:              				}
3226:              				( void ) xTaskResumeAll();
3227:              			}
3228:              			else
3229:              			{
3230:              				mtCOVERAGE_TEST_MARKER();
3231:              			}
3232:              		}
3233:              		#endif /* configUSE_TICKLESS_IDLE */
3234:              	}
000EC2  37FFF7     BRA .L3
3235:              }
3236:              /*-----------------------------------------------------------*/
3237:              
3238:              #if( configUSE_TICKLESS_IDLE != 0 )
3239:              
3240:              	eSleepModeStatus eTaskConfirmSleepModeStatus( void )
3241:              	{
3242:              	/* The idle task exists in addition to the application tasks. */
3243:              	const UBaseType_t uxNonApplicationTasks = 1;
3244:              	eSleepModeStatus eReturn = eStandardSleep;
3245:              
3246:              		if( listCURRENT_LIST_LENGTH( &xPendingReadyList ) != 0 )
3247:              		{
3248:              			/* A task was made ready while the scheduler was suspended. */
3249:              			eReturn = eAbortSleep;
3250:              		}
3251:              		else if( xYieldPending != pdFALSE )
3252:              		{
3253:              			/* A yield was pended while the scheduler was suspended. */
3254:              			eReturn = eAbortSleep;
3255:              		}
3256:              		else
3257:              		{
3258:              			/* If all the tasks are in the suspended list (which might mean they
3259:              			have an infinite block time rather than actually being suspended)
3260:              			then it is safe to turn all clocks off and just wait for external
3261:              			interrupts. */
3262:              			if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == ( uxCurrentNumberOfTasks - uxNonApplicationTasks ) )
3263:              			{
3264:              				eReturn = eNoTasksWaitingTimeout;
3265:              			}
3266:              			else
3267:              			{
3268:              				mtCOVERAGE_TEST_MARKER();
3269:              			}
3270:              		}
3271:              
3272:              		return eReturn;
3273:              	}
3274:              
3275:              #endif /* configUSE_TICKLESS_IDLE */
3276:              /*-----------------------------------------------------------*/
3277:              
3278:              #if ( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
3279:              
3280:              	void vTaskSetThreadLocalStoragePointer( TaskHandle_t xTaskToSet, BaseType_t xIndex, void *pvValue )
3281:              	{
3282:              	TCB_t *pxTCB;
3283:              
3284:              		if( xIndex < configNUM_THREAD_LOCAL_STORAGE_POINTERS )
3285:              		{
3286:              			pxTCB = prvGetTCBFromHandle( xTaskToSet );
3287:              			pxTCB->pvThreadLocalStoragePointers[ xIndex ] = pvValue;
3288:              		}
3289:              	}
3290:              
3291:              #endif /* configNUM_THREAD_LOCAL_STORAGE_POINTERS */
3292:              /*-----------------------------------------------------------*/
3293:              
3294:              #if ( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
3295:              
3296:              	void *pvTaskGetThreadLocalStoragePointer( TaskHandle_t xTaskToQuery, BaseType_t xIndex )
3297:              	{
3298:              	void *pvReturn = NULL;
3299:              	TCB_t *pxTCB;
3300:              
3301:              		if( xIndex < configNUM_THREAD_LOCAL_STORAGE_POINTERS )
3302:              		{
3303:              			pxTCB = prvGetTCBFromHandle( xTaskToQuery );
3304:              			pvReturn = pxTCB->pvThreadLocalStoragePointers[ xIndex ];
3305:              		}
3306:              		else
3307:              		{
3308:              			pvReturn = NULL;
3309:              		}
3310:              
3311:              		return pvReturn;
3312:              	}
3313:              
3314:              #endif /* configNUM_THREAD_LOCAL_STORAGE_POINTERS */
3315:              /*-----------------------------------------------------------*/
3316:              
3317:              #if ( portUSING_MPU_WRAPPERS == 1 )
3318:              
3319:              	void vTaskAllocateMPURegions( TaskHandle_t xTaskToModify, const MemoryRegion_t * const xRegions )
3320:              	{
3321:              	TCB_t *pxTCB;
3322:              
3323:              		/* If null is passed in here then we are modifying the MPU settings of
3324:              		the calling task. */
3325:              		pxTCB = prvGetTCBFromHandle( xTaskToModify );
3326:              
3327:              		vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, NULL, 0 );
3328:              	}
3329:              
3330:              #endif /* portUSING_MPU_WRAPPERS */
3331:              /*-----------------------------------------------------------*/
3332:              
3333:              static void prvInitialiseTaskLists( void )
3334:              {
001230  BE9F88     MOV.D W8, [W15++]
3335:              UBaseType_t uxPriority;
3336:              
3337:              	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
001232  EB0400     CLR W8
00123E  E80408     INC W8, W8
001240  540FE4     SUB W8, #0x4, [W15]
001242  3AFFF9     BRA NZ, .L71
3338:              	{
3339:              		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
001234  21CF89     MOV #0x1CF8, W9
001236  B9406A     MUL.SU W8, #10, W0
001238  448000     ADD W9, W0, W0
00123A  022CFA     CALL vListInitialise
00123C  000000     NOP
3340:              	}
3341:              
3342:              	vListInitialise( &xDelayedTaskList1 );
001244  21D200     MOV #0x1D20, W0
001246  022CFA     CALL vListInitialise
001248  000000     NOP
3343:              	vListInitialise( &xDelayedTaskList2 );
00124A  21D2A0     MOV #0x1D2A, W0
00124C  022CFA     CALL vListInitialise
00124E  000000     NOP
3344:              	vListInitialise( &xPendingReadyList );
001250  21D340     MOV #0x1D34, W0
001252  022CFA     CALL vListInitialise
001254  000000     NOP
3345:              
3346:              	#if ( INCLUDE_vTaskDelete == 1 )
3347:              	{
3348:              		vListInitialise( &xTasksWaitingTermination );
3349:              	}
3350:              	#endif /* INCLUDE_vTaskDelete */
3351:              
3352:              	#if ( INCLUDE_vTaskSuspend == 1 )
3353:              	{
3354:              		vListInitialise( &xSuspendedTaskList );
001256  21D3E0     MOV #0x1D3E, W0
001258  022CFA     CALL vListInitialise
00125A  000000     NOP
3355:              	}
3356:              	#endif /* INCLUDE_vTaskSuspend */
3357:              
3358:              	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
3359:              	using list2. */
3360:              	pxDelayedTaskList = &xDelayedTaskList1;
00125C  21D200     MOV #0x1D20, W0
00125E  884340     MOV W0, pxDelayedTaskList
3361:              	pxOverflowDelayedTaskList = &xDelayedTaskList2;
001260  21D2A0     MOV #0x1D2A, W0
001262  884350     MOV W0, pxOverflowDelayedTaskList
3362:              }
001264  BE044F     MOV.D [--W15], W8
001266  060000     RETURN
3363:              /*-----------------------------------------------------------*/
3364:              
3365:              static void prvCheckTasksWaitingTermination( void )
3366:              {
3367:              
3368:              	/** THIS FUNCTION IS CALLED FROM THE RTOS IDLE TASK **/
3369:              
3370:              	#if ( INCLUDE_vTaskDelete == 1 )
3371:              	{
3372:              		BaseType_t xListIsEmpty;
3373:              
3374:              		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
3375:              		too often in the idle task. */
3376:              		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
3377:              		{
3378:              			vTaskSuspendAll();
3379:              			{
3380:              				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
3381:              			}
3382:              			( void ) xTaskResumeAll();
3383:              
3384:              			if( xListIsEmpty == pdFALSE )
3385:              			{
3386:              				TCB_t *pxTCB;
3387:              
3388:              				taskENTER_CRITICAL();
3389:              				{
3390:              					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
3391:              					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
3392:              					--uxCurrentNumberOfTasks;
3393:              					--uxDeletedTasksWaitingCleanUp;
3394:              				}
3395:              				taskEXIT_CRITICAL();
3396:              
3397:              				prvDeleteTCB( pxTCB );
3398:              			}
3399:              			else
3400:              			{
3401:              				mtCOVERAGE_TEST_MARKER();
3402:              			}
3403:              		}
3404:              	}
3405:              	#endif /* INCLUDE_vTaskDelete */
3406:              }
00134C  060000     RETURN
3407:              /*-----------------------------------------------------------*/
3408:              
3409:              #if( configUSE_TRACE_FACILITY == 1 )
3410:              
3411:              	void vTaskGetInfo( TaskHandle_t xTask, TaskStatus_t *pxTaskStatus, BaseType_t xGetFreeStackSpace, eTaskState eState )
3412:              	{
3413:              	TCB_t *pxTCB;
3414:              
3415:              		/* xTask is NULL then get the state of the calling task. */
3416:              		pxTCB = prvGetTCBFromHandle( xTask );
3417:              
3418:              		pxTaskStatus->xHandle = ( TaskHandle_t ) pxTCB;
3419:              		pxTaskStatus->pcTaskName = ( const char * ) &( pxTCB->pcTaskName [ 0 ] );
3420:              		pxTaskStatus->uxCurrentPriority = pxTCB->uxPriority;
3421:              		pxTaskStatus->pxStackBase = pxTCB->pxStack;
3422:              		pxTaskStatus->xTaskNumber = pxTCB->uxTCBNumber;
3423:              
3424:              		#if ( INCLUDE_vTaskSuspend == 1 )
3425:              		{
3426:              			/* If the task is in the suspended list then there is a chance it is
3427:              			actually just blocked indefinitely - so really it should be reported as
3428:              			being in the Blocked state. */
3429:              			if( pxTaskStatus->eCurrentState == eSuspended )
3430:              			{
3431:              				vTaskSuspendAll();
3432:              				{
3433:              					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
3434:              					{
3435:              						pxTaskStatus->eCurrentState = eBlocked;
3436:              					}
3437:              				}
3438:              				xTaskResumeAll();
3439:              			}
3440:              		}
3441:              		#endif /* INCLUDE_vTaskSuspend */
3442:              
3443:              		#if ( configUSE_MUTEXES == 1 )
3444:              		{
3445:              			pxTaskStatus->uxBasePriority = pxTCB->uxBasePriority;
3446:              		}
3447:              		#else
3448:              		{
3449:              			pxTaskStatus->uxBasePriority = 0;
3450:              		}
3451:              		#endif
3452:              
3453:              		#if ( configGENERATE_RUN_TIME_STATS == 1 )
3454:              		{
3455:              			pxTaskStatus->ulRunTimeCounter = pxTCB->ulRunTimeCounter;
3456:              		}
3457:              		#else
3458:              		{
3459:              			pxTaskStatus->ulRunTimeCounter = 0;
3460:              		}
3461:              		#endif
3462:              
3463:              		/* Obtaining the task state is a little fiddly, so is only done if the value
3464:              		of eState passed into this function is eInvalid - otherwise the state is
3465:              		just set to whatever is passed in. */
3466:              		if( eState != eInvalid )
3467:              		{
3468:              			pxTaskStatus->eCurrentState = eState;
3469:              		}
3470:              		else
3471:              		{
3472:              			pxTaskStatus->eCurrentState = eTaskGetState( xTask );
3473:              		}
3474:              
3475:              		/* Obtaining the stack space takes some time, so the xGetFreeStackSpace
3476:              		parameter is provided to allow it to be skipped. */
3477:              		if( xGetFreeStackSpace != pdFALSE )
3478:              		{
3479:              			#if ( portSTACK_GROWTH > 0 )
3480:              			{
3481:              				pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxTCB->pxEndOfStack );
3482:              			}
3483:              			#else
3484:              			{
3485:              				pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxTCB->pxStack );
3486:              			}
3487:              			#endif
3488:              		}
3489:              		else
3490:              		{
3491:              			pxTaskStatus->usStackHighWaterMark = 0;
3492:              		}
3493:              	}
3494:              
3495:              #endif /* configUSE_TRACE_FACILITY */
3496:              /*-----------------------------------------------------------*/
3497:              
3498:              #if ( configUSE_TRACE_FACILITY == 1 )
3499:              
3500:              	static UBaseType_t prvListTasksWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, eTaskState eState )
3501:              	{
3502:              	volatile TCB_t *pxNextTCB, *pxFirstTCB;
3503:              	UBaseType_t uxTask = 0;
3504:              
3505:              		if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
3506:              		{
3507:              			listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
3508:              
3509:              			/* Populate an TaskStatus_t structure within the
3510:              			pxTaskStatusArray array for each task that is referenced from
3511:              			pxList.  See the definition of TaskStatus_t in task.h for the
3512:              			meaning of each TaskStatus_t structure member. */
3513:              			do
3514:              			{
3515:              				listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
3516:              				vTaskGetInfo( ( TaskHandle_t ) pxNextTCB, &( pxTaskStatusArray[ uxTask ] ), pdTRUE, eState );
3517:              				uxTask++;
3518:              			} while( pxNextTCB != pxFirstTCB );
3519:              		}
3520:              		else
3521:              		{
3522:              			mtCOVERAGE_TEST_MARKER();
3523:              		}
3524:              
3525:              		return uxTask;
3526:              	}
3527:              
3528:              #endif /* configUSE_TRACE_FACILITY */
3529:              /*-----------------------------------------------------------*/
3530:              
3531:              #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
3532:              
3533:              	static uint16_t prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte )
3534:              	{
3535:              	uint32_t ulCount = 0U;
3536:              
3537:              		while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
3538:              		{
3539:              			pucStackByte -= portSTACK_GROWTH;
3540:              			ulCount++;
3541:              		}
3542:              
3543:              		ulCount /= ( uint32_t ) sizeof( StackType_t ); /*lint !e961 Casting is not redundant on smaller architectures. */
3544:              
3545:              		return ( uint16_t ) ulCount;
3546:              	}
3547:              
3548:              #endif /* ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) ) */
3549:              /*-----------------------------------------------------------*/
3550:              
3551:              #if ( INCLUDE_uxTaskGetStackHighWaterMark == 1 )
3552:              
3553:              	UBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask )
3554:              	{
3555:              	TCB_t *pxTCB;
3556:              	uint8_t *pucEndOfStack;
3557:              	UBaseType_t uxReturn;
3558:              
3559:              		pxTCB = prvGetTCBFromHandle( xTask );
3560:              
3561:              		#if portSTACK_GROWTH < 0
3562:              		{
3563:              			pucEndOfStack = ( uint8_t * ) pxTCB->pxStack;
3564:              		}
3565:              		#else
3566:              		{
3567:              			pucEndOfStack = ( uint8_t * ) pxTCB->pxEndOfStack;
3568:              		}
3569:              		#endif
3570:              
3571:              		uxReturn = ( UBaseType_t ) prvTaskCheckFreeStackSpace( pucEndOfStack );
3572:              
3573:              		return uxReturn;
3574:              	}
3575:              
3576:              #endif /* INCLUDE_uxTaskGetStackHighWaterMark */
3577:              /*-----------------------------------------------------------*/
3578:              
3579:              #if ( INCLUDE_vTaskDelete == 1 )
3580:              
3581:              	static void prvDeleteTCB( TCB_t *pxTCB )
3582:              	{
3583:              		/* This call is required specifically for the TriCore port.  It must be
3584:              		above the vPortFree() calls.  The call is also used by ports/demos that
3585:              		want to allocate and clean RAM statically. */
3586:              		portCLEAN_UP_TCB( pxTCB );
3587:              
3588:              		/* Free up the memory allocated by the scheduler for the task.  It is up
3589:              		to the task to free any memory allocated at the application level. */
3590:              		#if ( configUSE_NEWLIB_REENTRANT == 1 )
3591:              		{
3592:              			_reclaim_reent( &( pxTCB->xNewLib_reent ) );
3593:              		}
3594:              		#endif /* configUSE_NEWLIB_REENTRANT */
3595:              
3596:              		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
3597:              		{
3598:              			/* The task can only have been allocated dynamically - free both
3599:              			the stack and TCB. */
3600:              			vPortFree( pxTCB->pxStack );
3601:              			vPortFree( pxTCB );
3602:              		}
3603:              		#elif( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE == 1 )
3604:              		{
3605:              			/* The task could have been allocated statically or dynamically, so
3606:              			check what was statically allocated before trying to free the
3607:              			memory. */
3608:              			if( pxTCB->ucStaticallyAllocated == tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB )
3609:              			{
3610:              				/* Both the stack and TCB were allocated dynamically, so both
3611:              				must be freed. */
3612:              				vPortFree( pxTCB->pxStack );
3613:              				vPortFree( pxTCB );
3614:              			}
3615:              			else if( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_ONLY )
3616:              			{
3617:              				/* Only the stack was statically allocated, so the TCB is the
3618:              				only memory that must be freed. */
3619:              				vPortFree( pxTCB );
3620:              			}
3621:              			else
3622:              			{
3623:              				/* Neither the stack nor the TCB were allocated dynamically, so
3624:              				nothing needs to be freed. */
3625:              				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	)
3626:              				mtCOVERAGE_TEST_MARKER();
3627:              			}
3628:              		}
3629:              		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
3630:              	}
3631:              
3632:              #endif /* INCLUDE_vTaskDelete */
3633:              /*-----------------------------------------------------------*/
3634:              
3635:              static void prvResetNextTaskUnblockTime( void )
3636:              {
3637:              TCB_t *pxTCB;
3638:              
3639:              	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
00134E  804340     MOV pxDelayedTaskList, W0
001350  E00010     CP0 [W0]
001352  3A0002     BRA NZ, .L86
3640:              	{
3641:              		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
3642:              		the maximum possible value so it is	extremely unlikely that the
3643:              		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
3644:              		there is an item in the delayed list. */
3645:              		xNextTaskUnblockTime = portMAX_DELAY;
001354  EFA862     SETM xNextTaskUnblockTime
001356  370005     BRA .L85
3646:              	}
3647:              	else
3648:              	{
3649:              		/* The new current delayed list is not empty, get the value of
3650:              		the item at the head of the delayed list.  This is the time at
3651:              		which the task at the head of the delayed list should be removed
3652:              		from the Blocked state. */
3653:              		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
001358  804340     MOV pxDelayedTaskList, W0
00135A  900030     MOV [W0+6], W0
3654:              		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
00135C  900030     MOV [W0+6], W0
00135E  900010     MOV [W0+2], W0
001360  884310     MOV W0, xNextTaskUnblockTime
3655:              	}
3656:              }
001362  060000     RETURN
3657:              /*-----------------------------------------------------------*/
3658:              
3659:              #if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )
3660:              
3661:              	TaskHandle_t xTaskGetCurrentTaskHandle( void )
3662:              	{
3663:              	TaskHandle_t xReturn;
3664:              
3665:              		/* A critical section is not required as this is not called from
3666:              		an interrupt and the current TCB will always be the same for any
3667:              		individual execution thread. */
3668:              		xReturn = pxCurrentTCB;
3669:              
3670:              		return xReturn;
3671:              	}
3672:              
3673:              #endif /* ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) ) */
3674:              /*-----------------------------------------------------------*/
3675:              
3676:              #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
3677:              
3678:              	BaseType_t xTaskGetSchedulerState( void )
3679:              	{
3680:              	BaseType_t xReturn;
3681:              
3682:              		if( xSchedulerRunning == pdFALSE )
3683:              		{
3684:              			xReturn = taskSCHEDULER_NOT_STARTED;
3685:              		}
3686:              		else
3687:              		{
3688:              			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
3689:              			{
3690:              				xReturn = taskSCHEDULER_RUNNING;
3691:              			}
3692:              			else
3693:              			{
3694:              				xReturn = taskSCHEDULER_SUSPENDED;
3695:              			}
3696:              		}
3697:              
3698:              		return xReturn;
3699:              	}
3700:              
3701:              #endif /* ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) ) */
3702:              /*-----------------------------------------------------------*/
3703:              
3704:              #if ( configUSE_MUTEXES == 1 )
3705:              
3706:              	void vTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
3707:              	{
3708:              	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
3709:              
3710:              		/* If the mutex was given back by an interrupt while the queue was
3711:              		locked then the mutex holder might now be NULL. */
3712:              		if( pxMutexHolder != NULL )
3713:              		{
3714:              			/* If the holder of the mutex has a priority below the priority of
3715:              			the task attempting to obtain the mutex then it will temporarily
3716:              			inherit the priority of the task attempting to obtain the mutex. */
3717:              			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
3718:              			{
3719:              				/* Adjust the mutex holder state to account for its new
3720:              				priority.  Only reset the event list item value if the value is
3721:              				not	being used for anything else. */
3722:              				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
3723:              				{
3724:              					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
3725:              				}
3726:              				else
3727:              				{
3728:              					mtCOVERAGE_TEST_MARKER();
3729:              				}
3730:              
3731:              				/* If the task being modified is in the ready state it will need
3732:              				to be moved into a new list. */
3733:              				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
3734:              				{
3735:              					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
3736:              					{
3737:              						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
3738:              					}
3739:              					else
3740:              					{
3741:              						mtCOVERAGE_TEST_MARKER();
3742:              					}
3743:              
3744:              					/* Inherit the priority before being moved into the new list. */
3745:              					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
3746:              					prvAddTaskToReadyList( pxTCB );
3747:              				}
3748:              				else
3749:              				{
3750:              					/* Just inherit the priority. */
3751:              					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
3752:              				}
3753:              
3754:              				traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
3755:              			}
3756:              			else
3757:              			{
3758:              				mtCOVERAGE_TEST_MARKER();
3759:              			}
3760:              		}
3761:              		else
3762:              		{
3763:              			mtCOVERAGE_TEST_MARKER();
3764:              		}
3765:              	}
3766:              
3767:              #endif /* configUSE_MUTEXES */
3768:              /*-----------------------------------------------------------*/
3769:              
3770:              #if ( configUSE_MUTEXES == 1 )
3771:              
3772:              	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
3773:              	{
3774:              	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
3775:              	BaseType_t xReturn = pdFALSE;
3776:              
3777:              		if( pxMutexHolder != NULL )
3778:              		{
3779:              			/* A task can only have an inherited priority if it holds the mutex.
3780:              			If the mutex is held by a task then it cannot be given from an
3781:              			interrupt, and if a mutex is given by the holding task then it must
3782:              			be the running state task. */
3783:              			configASSERT( pxTCB == pxCurrentTCB );
3784:              
3785:              			configASSERT( pxTCB->uxMutexesHeld );
3786:              			( pxTCB->uxMutexesHeld )--;
3787:              
3788:              			/* Has the holder of the mutex inherited the priority of another
3789:              			task? */
3790:              			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
3791:              			{
3792:              				/* Only disinherit if no other mutexes are held. */
3793:              				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
3794:              				{
3795:              					/* A task can only have an inherited priority if it holds
3796:              					the mutex.  If the mutex is held by a task then it cannot be
3797:              					given from an interrupt, and if a mutex is given by the
3798:              					holding	task then it must be the running state task.  Remove
3799:              					the	holding task from the ready	list. */
3800:              					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
3801:              					{
3802:              						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
3803:              					}
3804:              					else
3805:              					{
3806:              						mtCOVERAGE_TEST_MARKER();
3807:              					}
3808:              
3809:              					/* Disinherit the priority before adding the task into the
3810:              					new	ready list. */
3811:              					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
3812:              					pxTCB->uxPriority = pxTCB->uxBasePriority;
3813:              
3814:              					/* Reset the event list item value.  It cannot be in use for
3815:              					any other purpose if this task is running, and it must be
3816:              					running to give back the mutex. */
3817:              					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
3818:              					prvAddTaskToReadyList( pxTCB );
3819:              
3820:              					/* Return true to indicate that a context switch is required.
3821:              					This is only actually required in the corner case whereby
3822:              					multiple mutexes were held and the mutexes were given back
3823:              					in an order different to that in which they were taken.
3824:              					If a context switch did not occur when the first mutex was
3825:              					returned, even if a task was waiting on it, then a context
3826:              					switch should occur when the last mutex is returned whether
3827:              					a task is waiting on it or not. */
3828:              					xReturn = pdTRUE;
3829:              				}
3830:              				else
3831:              				{
3832:              					mtCOVERAGE_TEST_MARKER();
3833:              				}
3834:              			}
3835:              			else
3836:              			{
3837:              				mtCOVERAGE_TEST_MARKER();
3838:              			}
3839:              		}
3840:              		else
3841:              		{
3842:              			mtCOVERAGE_TEST_MARKER();
3843:              		}
3844:              
3845:              		return xReturn;
3846:              	}
3847:              
3848:              #endif /* configUSE_MUTEXES */
3849:              /*-----------------------------------------------------------*/
3850:              
3851:              #if ( portCRITICAL_NESTING_IN_TCB == 1 )
3852:              
3853:              	void vTaskEnterCritical( void )
3854:              	{
3855:              		portDISABLE_INTERRUPTS();
3856:              
3857:              		if( xSchedulerRunning != pdFALSE )
3858:              		{
3859:              			( pxCurrentTCB->uxCriticalNesting )++;
3860:              
3861:              			/* This is not the interrupt safe version of the enter critical
3862:              			function so	assert() if it is being called from an interrupt
3863:              			context.  Only API functions that end in "FromISR" can be used in an
3864:              			interrupt.  Only assert if the critical nesting count is 1 to
3865:              			protect against recursive calls if the assert function also uses a
3866:              			critical section. */
3867:              			if( pxCurrentTCB->uxCriticalNesting == 1 )
3868:              			{
3869:              				portASSERT_IF_IN_ISR();
3870:              			}
3871:              		}
3872:              		else
3873:              		{
3874:              			mtCOVERAGE_TEST_MARKER();
3875:              		}
3876:              	}
3877:              
3878:              #endif /* portCRITICAL_NESTING_IN_TCB */
3879:              /*-----------------------------------------------------------*/
3880:              
3881:              #if ( portCRITICAL_NESTING_IN_TCB == 1 )
3882:              
3883:              	void vTaskExitCritical( void )
3884:              	{
3885:              		if( xSchedulerRunning != pdFALSE )
3886:              		{
3887:              			if( pxCurrentTCB->uxCriticalNesting > 0U )
3888:              			{
3889:              				( pxCurrentTCB->uxCriticalNesting )--;
3890:              
3891:              				if( pxCurrentTCB->uxCriticalNesting == 0U )
3892:              				{
3893:              					portENABLE_INTERRUPTS();
3894:              				}
3895:              				else
3896:              				{
3897:              					mtCOVERAGE_TEST_MARKER();
3898:              				}
3899:              			}
3900:              			else
3901:              			{
3902:              				mtCOVERAGE_TEST_MARKER();
3903:              			}
3904:              		}
3905:              		else
3906:              		{
3907:              			mtCOVERAGE_TEST_MARKER();
3908:              		}
3909:              	}
3910:              
3911:              #endif /* portCRITICAL_NESTING_IN_TCB */
3912:              /*-----------------------------------------------------------*/
3913:              
3914:              #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) )
3915:              
3916:              	static char *prvWriteNameToBuffer( char *pcBuffer, const char *pcTaskName )
3917:              	{
3918:              	size_t x;
3919:              
3920:              		/* Start by copying the entire string. */
3921:              		strcpy( pcBuffer, pcTaskName );
3922:              
3923:              		/* Pad the end of the string with spaces to ensure columns line up when
3924:              		printed out. */
3925:              		for( x = strlen( pcBuffer ); x < ( size_t ) ( configMAX_TASK_NAME_LEN - 1 ); x++ )
3926:              		{
3927:              			pcBuffer[ x ] = ' ';
3928:              		}
3929:              
3930:              		/* Terminate. */
3931:              		pcBuffer[ x ] = 0x00;
3932:              
3933:              		/* Return the new end of string. */
3934:              		return &( pcBuffer[ x ] );
3935:              	}
3936:              
3937:              #endif /* ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) */
3938:              /*-----------------------------------------------------------*/
3939:              
3940:              #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) )
3941:              
3942:              	void vTaskList( char * pcWriteBuffer )
3943:              	{
3944:              	TaskStatus_t *pxTaskStatusArray;
3945:              	volatile UBaseType_t uxArraySize, x;
3946:              	char cStatus;
3947:              
3948:              		/*
3949:              		 * PLEASE NOTE:
3950:              		 *
3951:              		 * This function is provided for convenience only, and is used by many
3952:              		 * of the demo applications.  Do not consider it to be part of the
3953:              		 * scheduler.
3954:              		 *
3955:              		 * vTaskList() calls uxTaskGetSystemState(), then formats part of the
3956:              		 * uxTaskGetSystemState() output into a human readable table that
3957:              		 * displays task names, states and stack usage.
3958:              		 *
3959:              		 * vTaskList() has a dependency on the sprintf() C library function that
3960:              		 * might bloat the code size, use a lot of stack, and provide different
3961:              		 * results on different platforms.  An alternative, tiny, third party,
3962:              		 * and limited functionality implementation of sprintf() is provided in
3963:              		 * many of the FreeRTOS/Demo sub-directories in a file called
3964:              		 * printf-stdarg.c (note printf-stdarg.c does not provide a full
3965:              		 * snprintf() implementation!).
3966:              		 *
3967:              		 * It is recommended that production systems call uxTaskGetSystemState()
3968:              		 * directly to get access to raw stats data, rather than indirectly
3969:              		 * through a call to vTaskList().
3970:              		 */
3971:              
3972:              
3973:              		/* Make sure the write buffer does not contain a string. */
3974:              		*pcWriteBuffer = 0x00;
3975:              
3976:              		/* Take a snapshot of the number of tasks in case it changes while this
3977:              		function is executing. */
3978:              		uxArraySize = uxCurrentNumberOfTasks;
3979:              
3980:              		/* Allocate an array index for each task.  NOTE!  if
3981:              		configSUPPORT_DYNAMIC_ALLOCATION is set to 0 then pvPortMalloc() will
3982:              		equate to NULL. */
3983:              		pxTaskStatusArray = pvPortMalloc( uxCurrentNumberOfTasks * sizeof( TaskStatus_t ) );
3984:              
3985:              		if( pxTaskStatusArray != NULL )
3986:              		{
3987:              			/* Generate the (binary) data. */
3988:              			uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, NULL );
3989:              
3990:              			/* Create a human readable table from the binary data. */
3991:              			for( x = 0; x < uxArraySize; x++ )
3992:              			{
3993:              				switch( pxTaskStatusArray[ x ].eCurrentState )
3994:              				{
3995:              					case eReady:		cStatus = tskREADY_CHAR;
3996:              										break;
3997:              
3998:              					case eBlocked:		cStatus = tskBLOCKED_CHAR;
3999:              										break;
4000:              
4001:              					case eSuspended:	cStatus = tskSUSPENDED_CHAR;
4002:              										break;
4003:              
4004:              					case eDeleted:		cStatus = tskDELETED_CHAR;
4005:              										break;
4006:              
4007:              					default:			/* Should not get here, but it is included
4008:              										to prevent static checking errors. */
4009:              										cStatus = 0x00;
4010:              										break;
4011:              				}
4012:              
4013:              				/* Write the task name to the string, padding with spaces so it
4014:              				can be printed in tabular form more easily. */
4015:              				pcWriteBuffer = prvWriteNameToBuffer( pcWriteBuffer, pxTaskStatusArray[ x ].pcTaskName );
4016:              
4017:              				/* Write the rest of the string. */
4018:              				sprintf( pcWriteBuffer, "\t%c\t%u\t%u\t%u\r\n", cStatus, ( unsigned int ) pxTaskStatusArray[ x ].uxCurrentPriority, ( unsigned int ) pxTaskStatusArray[ x ].usStackHighWaterMark, ( unsigned int ) pxTaskStatusArray[ x ].xTaskNumber );
4019:              				pcWriteBuffer += strlen( pcWriteBuffer );
4020:              			}
4021:              
4022:              			/* Free the array again.  NOTE!  If configSUPPORT_DYNAMIC_ALLOCATION
4023:              			is 0 then vPortFree() will be #defined to nothing. */
4024:              			vPortFree( pxTaskStatusArray );
4025:              		}
4026:              		else
4027:              		{
4028:              			mtCOVERAGE_TEST_MARKER();
4029:              		}
4030:              	}
4031:              
4032:              #endif /* ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) ) */
4033:              /*----------------------------------------------------------*/
4034:              
4035:              #if ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) )
4036:              
4037:              	void vTaskGetRunTimeStats( char *pcWriteBuffer )
4038:              	{
4039:              	TaskStatus_t *pxTaskStatusArray;
4040:              	volatile UBaseType_t uxArraySize, x;
4041:              	uint32_t ulTotalTime, ulStatsAsPercentage;
4042:              
4043:              		#if( configUSE_TRACE_FACILITY != 1 )
4044:              		{
4045:              			#error configUSE_TRACE_FACILITY must also be set to 1 in FreeRTOSConfig.h to use vTaskGetRunTimeStats().
4046:              		}
4047:              		#endif
4048:              
4049:              		/*
4050:              		 * PLEASE NOTE:
4051:              		 *
4052:              		 * This function is provided for convenience only, and is used by many
4053:              		 * of the demo applications.  Do not consider it to be part of the
4054:              		 * scheduler.
4055:              		 *
4056:              		 * vTaskGetRunTimeStats() calls uxTaskGetSystemState(), then formats part
4057:              		 * of the uxTaskGetSystemState() output into a human readable table that
4058:              		 * displays the amount of time each task has spent in the Running state
4059:              		 * in both absolute and percentage terms.
4060:              		 *
4061:              		 * vTaskGetRunTimeStats() has a dependency on the sprintf() C library
4062:              		 * function that might bloat the code size, use a lot of stack, and
4063:              		 * provide different results on different platforms.  An alternative,
4064:              		 * tiny, third party, and limited functionality implementation of
4065:              		 * sprintf() is provided in many of the FreeRTOS/Demo sub-directories in
4066:              		 * a file called printf-stdarg.c (note printf-stdarg.c does not provide
4067:              		 * a full snprintf() implementation!).
4068:              		 *
4069:              		 * It is recommended that production systems call uxTaskGetSystemState()
4070:              		 * directly to get access to raw stats data, rather than indirectly
4071:              		 * through a call to vTaskGetRunTimeStats().
4072:              		 */
4073:              
4074:              		/* Make sure the write buffer does not contain a string. */
4075:              		*pcWriteBuffer = 0x00;
4076:              
4077:              		/* Take a snapshot of the number of tasks in case it changes while this
4078:              		function is executing. */
4079:              		uxArraySize = uxCurrentNumberOfTasks;
4080:              
4081:              		/* Allocate an array index for each task.  NOTE!  If
4082:              		configSUPPORT_DYNAMIC_ALLOCATION is set to 0 then pvPortMalloc() will
4083:              		equate to NULL. */
4084:              		pxTaskStatusArray = pvPortMalloc( uxCurrentNumberOfTasks * sizeof( TaskStatus_t ) );
4085:              
4086:              		if( pxTaskStatusArray != NULL )
4087:              		{
4088:              			/* Generate the (binary) data. */
4089:              			uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, &ulTotalTime );
4090:              
4091:              			/* For percentage calculations. */
4092:              			ulTotalTime /= 100UL;
4093:              
4094:              			/* Avoid divide by zero errors. */
4095:              			if( ulTotalTime > 0 )
4096:              			{
4097:              				/* Create a human readable table from the binary data. */
4098:              				for( x = 0; x < uxArraySize; x++ )
4099:              				{
4100:              					/* What percentage of the total run time has the task used?
4101:              					This will always be rounded down to the nearest integer.
4102:              					ulTotalRunTimeDiv100 has already been divided by 100. */
4103:              					ulStatsAsPercentage = pxTaskStatusArray[ x ].ulRunTimeCounter / ulTotalTime;
4104:              
4105:              					/* Write the task name to the string, padding with
4106:              					spaces so it can be printed in tabular form more
4107:              					easily. */
4108:              					pcWriteBuffer = prvWriteNameToBuffer( pcWriteBuffer, pxTaskStatusArray[ x ].pcTaskName );
4109:              
4110:              					if( ulStatsAsPercentage > 0UL )
4111:              					{
4112:              						#ifdef portLU_PRINTF_SPECIFIER_REQUIRED
4113:              						{
4114:              							sprintf( pcWriteBuffer, "\t%lu\t\t%lu%%\r\n", pxTaskStatusArray[ x ].ulRunTimeCounter, ulStatsAsPercentage );
4115:              						}
4116:              						#else
4117:              						{
4118:              							/* sizeof( int ) == sizeof( long ) so a smaller
4119:              							printf() library can be used. */
4120:              							sprintf( pcWriteBuffer, "\t%u\t\t%u%%\r\n", ( unsigned int ) pxTaskStatusArray[ x ].ulRunTimeCounter, ( unsigned int ) ulStatsAsPercentage );
4121:              						}
4122:              						#endif
4123:              					}
4124:              					else
4125:              					{
4126:              						/* If the percentage is zero here then the task has
4127:              						consumed less than 1% of the total run time. */
4128:              						#ifdef portLU_PRINTF_SPECIFIER_REQUIRED
4129:              						{
4130:              							sprintf( pcWriteBuffer, "\t%lu\t\t<1%%\r\n", pxTaskStatusArray[ x ].ulRunTimeCounter );
4131:              						}
4132:              						#else
4133:              						{
4134:              							/* sizeof( int ) == sizeof( long ) so a smaller
4135:              							printf() library can be used. */
4136:              							sprintf( pcWriteBuffer, "\t%u\t\t<1%%\r\n", ( unsigned int ) pxTaskStatusArray[ x ].ulRunTimeCounter );
4137:              						}
4138:              						#endif
4139:              					}
4140:              
4141:              					pcWriteBuffer += strlen( pcWriteBuffer );
4142:              				}
4143:              			}
4144:              			else
4145:              			{
4146:              				mtCOVERAGE_TEST_MARKER();
4147:              			}
4148:              
4149:              			/* Free the array again.  NOTE!  If configSUPPORT_DYNAMIC_ALLOCATION
4150:              			is 0 then vPortFree() will be #defined to nothing. */
4151:              			vPortFree( pxTaskStatusArray );
4152:              		}
4153:              		else
4154:              		{
4155:              			mtCOVERAGE_TEST_MARKER();
4156:              		}
4157:              	}
4158:              
4159:              #endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) ) */
4160:              /*-----------------------------------------------------------*/
4161:              
4162:              TickType_t uxTaskResetEventItemValue( void )
4163:              {
4164:              TickType_t uxReturn;
4165:              
4166:              	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
0014EE  804280     MOV pxCurrentTCB, W0
0014F0  900060     MOV [W0+12], W0
4167:              
4168:              	/* Reset the event list item to its normal value - so it can be used with
4169:              	queues and semaphores. */
4170:              	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
0014F2  804281     MOV pxCurrentTCB, W1
0014F4  804282     MOV pxCurrentTCB, W2
0014F6  900932     MOV [W2+22], W2
0014F8  110164     SUBR W2, #0x4, W2
0014FA  9800E2     MOV W2, [W1+12]
4171:              
4172:              	return uxReturn;
4173:              }
0014FC  060000     RETURN
4174:              /*-----------------------------------------------------------*/
4175:              
4176:              #if ( configUSE_MUTEXES == 1 )
4177:              
4178:              	void *pvTaskIncrementMutexHeldCount( void )
4179:              	{
4180:              		/* If xSemaphoreCreateMutex() is called before any tasks have been created
4181:              		then pxCurrentTCB will be NULL. */
4182:              		if( pxCurrentTCB != NULL )
4183:              		{
4184:              			( pxCurrentTCB->uxMutexesHeld )++;
4185:              		}
4186:              
4187:              		return pxCurrentTCB;
4188:              	}
4189:              
4190:              #endif /* configUSE_MUTEXES */
4191:              /*-----------------------------------------------------------*/
4192:              
4193:              #if( configUSE_TASK_NOTIFICATIONS == 1 )
4194:              
4195:              	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
4196:              	{
0017C8  BE9F88     MOV.D W8, [W15++]
0017CA  781F8A     MOV W10, [W15++]
0017CC  780500     MOV W0, W10
0017CE  780401     MOV W1, W8
4197:              	uint32_t ulReturn;
4198:              
4199:              		taskENTER_CRITICAL();
0017D0  022BB0     CALL vPortEnterCritical
0017D2  000000     NOP
4200:              		{
4201:              			/* Only block if the notification count is not already non-zero. */
4202:              			if( pxCurrentTCB->ulNotifiedValue == 0UL )
0017D4  804280     MOV pxCurrentTCB, W0
0017D6  901090     MOV [W0+34], W1
0017D8  901000     MOV [W0+32], W0
0017DA  500FE0     SUB W0, #0x0, [W15]
0017DC  588FE0     SUBB W1, #0x0, [W15]
0017DE  3A000B     BRA NZ, .L190
4203:              			{
4204:              				/* Mark this task as waiting for a notification. */
4205:              				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
0017E0  804280     MOV pxCurrentTCB, W0
0017E2  B3C011     MOV.B #0x1, W1
0017E4  986041     MOV.B W1, [W0+36]
4206:              
4207:              				if( xTicksToWait > ( TickType_t ) 0 )
0017E6  E00008     CP0 W8
0017E8  320006     BRA Z, .L190
4208:              				{
4209:              					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
0017EA  200011     MOV #0x1, W1
0017EC  780008     MOV W8, W0
0017EE  07FF74     RCALL prvAddCurrentTaskToDelayedList
4210:              					traceTASK_NOTIFY_TAKE_BLOCK();
4211:              
4212:              					/* All ports are written to allow a yield in a critical
4213:              					section (some will yield immediately, others wait until the
4214:              					critical section exits) - but it is not something that
4215:              					application code should ever do. */
4216:              					portYIELD_WITHIN_API();
0017F0  022DC4     CALL .Letext0, .LFE2, _vPortYield
0017F2  000000     NOP
0017F4  000000     NOP
4217:              				}
4218:              				else
4219:              				{
4220:              					mtCOVERAGE_TEST_MARKER();
4221:              				}
4222:              			}
4223:              			else
4224:              			{
4225:              				mtCOVERAGE_TEST_MARKER();
4226:              			}
4227:              		}
4228:              		taskEXIT_CRITICAL();
0017F6  022BC0     CALL vPortExitCritical
0017F8  000000     NOP
4229:              
4230:              		taskENTER_CRITICAL();
0017FA  022BB0     CALL vPortEnterCritical
0017FC  000000     NOP
4231:              		{
4232:              			traceTASK_NOTIFY_TAKE();
4233:              			ulReturn = pxCurrentTCB->ulNotifiedValue;
0017FE  804280     MOV pxCurrentTCB, W0
001800  901400     MOV [W0+32], W8
001802  901490     MOV [W0+34], W9
4234:              
4235:              			if( ulReturn != 0UL )
001804  540FE0     SUB W8, #0x0, [W15]
001806  5C8FE0     SUBB W9, #0x0, [W15]
001808  32000C     BRA Z, .L191
4236:              			{
4237:              				if( xClearCountOnExit != pdFALSE )
00180A  E0000A     CP0 W10
00180C  320005     BRA Z, .L192
4238:              				{
4239:              					pxCurrentTCB->ulNotifiedValue = 0UL;
00180E  804280     MOV pxCurrentTCB, W0
001810  B81160     MUL.UU W2, #0, W2
001812  981002     MOV W2, [W0+32]
001814  981013     MOV W3, [W0+34]
001816  370005     BRA .L191
4240:              				}
4241:              				else
4242:              				{
4243:              					pxCurrentTCB->ulNotifiedValue = ulReturn - 1;
001818  804280     MOV pxCurrentTCB, W0
00181A  540161     SUB W8, #0x1, W2
00181C  5C81E0     SUBB W9, #0x0, W3
00181E  981002     MOV W2, [W0+32]
001820  981013     MOV W3, [W0+34]
4244:              				}
4245:              			}
4246:              			else
4247:              			{
4248:              				mtCOVERAGE_TEST_MARKER();
4249:              			}
4250:              
4251:              			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
001822  804280     MOV pxCurrentTCB, W0
001824  EB4080     CLR.B W1
001826  986041     MOV.B W1, [W0+36]
4252:              		}
4253:              		taskEXIT_CRITICAL();
001828  022BC0     CALL vPortExitCritical
00182A  000000     NOP
4254:              
4255:              		return ulReturn;
4256:              	}
00182C  BE0008     MOV.D W8, W0
00182E  78054F     MOV [--W15], W10
001830  BE044F     MOV.D [--W15], W8
001832  060000     RETURN
4257:              
4258:              #endif /* configUSE_TASK_NOTIFICATIONS */
4259:              /*-----------------------------------------------------------*/
4260:              
4261:              #if( configUSE_TASK_NOTIFICATIONS == 1 )
4262:              
4263:              	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
4264:              	{
00172A  BE9F88     MOV.D W8, [W15++]
00172C  BE9F8A     MOV.D W10, [W15++]
00172E  BE9F8C     MOV.D W12, [W15++]
001730  BE0400     MOV.D W0, W8
001732  BE0502     MOV.D W2, W10
001734  BE0604     MOV.D W4, W12
4265:              	BaseType_t xReturn;
4266:              
4267:              		taskENTER_CRITICAL();
001736  022BB0     CALL vPortEnterCritical
001738  000000     NOP
4268:              		{
4269:              			/* Only block if a notification is not already pending. */
4270:              			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
00173A  804280     MOV pxCurrentTCB, W0
00173C  906040     MOV.B [W0+36], W0
00173E  504FE2     SUB.B W0, #0x2, [W15]
001740  32001A     BRA Z, .L185
4271:              			{
4272:              				/* Clear bits in the task's notification value as bits may get
4273:              				set	by the notifying task or interrupt.  This can be used to
4274:              				clear the value to zero. */
4275:              				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
001742  804284     MOV pxCurrentTCB, W4
001744  901004     MOV [W4+32], W0
001746  901094     MOV [W4+34], W1
001748  EA8408     COM W8, W8
00174A  EA8489     COM W9, W9
00174C  600288     AND W0, W8, W5
00174E  608109     AND W1, W9, W2
001750  EB0180     CLR W3
001752  DD10C0     SL W2, #0, W1
001754  200000     MOV #0x0, W0
001756  B82961     MUL.UU W5, #1, W2
001758  700002     IOR W0, W2, W0
00175A  708083     IOR W1, W3, W1
00175C  981200     MOV W0, [W4+32]
00175E  981211     MOV W1, [W4+34]
4276:              
4277:              				/* Mark this task as waiting for a notification. */
4278:              				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
001760  804280     MOV pxCurrentTCB, W0
001762  B3C011     MOV.B #0x1, W1
001764  986041     MOV.B W1, [W0+36]
4279:              
4280:              				if( xTicksToWait > ( TickType_t ) 0 )
001766  E0000D     CP0 W13
001768  320006     BRA Z, .L185
4281:              				{
4282:              					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
00176A  200011     MOV #0x1, W1
00176C  78000D     MOV W13, W0
00176E  07FFB4     RCALL prvAddCurrentTaskToDelayedList
4283:              					traceTASK_NOTIFY_WAIT_BLOCK();
4284:              
4285:              					/* All ports are written to allow a yield in a critical
4286:              					section (some will yield immediately, others wait until the
4287:              					critical section exits) - but it is not something that
4288:              					application code should ever do. */
4289:              					portYIELD_WITHIN_API();
001770  022DC4     CALL .Letext0, .LFE2, _vPortYield
001772  000000     NOP
001774  000000     NOP
4290:              				}
4291:              				else
4292:              				{
4293:              					mtCOVERAGE_TEST_MARKER();
4294:              				}
4295:              			}
4296:              			else
4297:              			{
4298:              				mtCOVERAGE_TEST_MARKER();
4299:              			}
4300:              		}
4301:              		taskEXIT_CRITICAL();
001776  022BC0     CALL vPortExitCritical
001778  000000     NOP
4302:              
4303:              		taskENTER_CRITICAL();
00177A  022BB0     CALL vPortEnterCritical
00177C  000000     NOP
4304:              		{
4305:              			traceTASK_NOTIFY_WAIT();
4306:              
4307:              			if( pulNotificationValue != NULL )
00177E  E0000C     CP0 W12
001780  320004     BRA Z, .L186
4308:              			{
4309:              				/* Output the current notification value, which may or may not
4310:              				have changed. */
4311:              				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
001782  804280     MOV pxCurrentTCB, W0
001784  901100     MOV [W0+32], W2
001786  901190     MOV [W0+34], W3
001788  BE8E02     MOV.D W2, [W12]
4312:              			}
4313:              
4314:              			/* If ucNotifyValue is set then either the task never entered the
4315:              			blocked state (because a notification was already pending) or the
4316:              			task unblocked because of a notification.  Otherwise the task
4317:              			unblocked because of a timeout. */
4318:              			if( pxCurrentTCB->ucNotifyState == taskWAITING_NOTIFICATION )
00178A  804280     MOV pxCurrentTCB, W0
00178C  906040     MOV.B [W0+36], W0
001790  504FE1     SUB.B W0, #0x1, [W15]
001792  320010     BRA Z, .L187
4319:              			{
4320:              				/* A notification was not received. */
4321:              				xReturn = pdFALSE;
00178E  EB0400     CLR W8
4322:              			}
4323:              			else
4324:              			{
4325:              				/* A notification was already pending or a notification was
4326:              				received while the task was waiting. */
4327:              				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
001794  804284     MOV pxCurrentTCB, W4
001796  901004     MOV [W4+32], W0
001798  901094     MOV [W4+34], W1
00179A  EA850A     COM W10, W10
00179C  EA858B     COM W11, W11
00179E  60028A     AND W0, W10, W5
0017A0  60810B     AND W1, W11, W2
0017A2  EB0180     CLR W3
0017A4  DD10C0     SL W2, #0, W1
0017A6  200000     MOV #0x0, W0
0017A8  B82961     MUL.UU W5, #1, W2
0017AA  700002     IOR W0, W2, W0
0017AC  708083     IOR W1, W3, W1
0017AE  981200     MOV W0, [W4+32]
0017B0  981211     MOV W1, [W4+34]
4328:              				xReturn = pdTRUE;
0017B2  200018     MOV #0x1, W8
4329:              			}
4330:              
4331:              			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
0017B4  804280     MOV pxCurrentTCB, W0
0017B6  EB4080     CLR.B W1
0017B8  986041     MOV.B W1, [W0+36]
4332:              		}
4333:              		taskEXIT_CRITICAL();
0017BA  022BC0     CALL vPortExitCritical
0017BC  000000     NOP
4334:              
4335:              		return xReturn;
4336:              	}
0017BE  780008     MOV W8, W0
0017C0  BE064F     MOV.D [--W15], W12
0017C2  BE054F     MOV.D [--W15], W10
0017C4  BE044F     MOV.D [--W15], W8
0017C6  060000     RETURN
4337:              
4338:              #endif /* configUSE_TASK_NOTIFICATIONS */
4339:              /*-----------------------------------------------------------*/
4340:              
4341:              #if( configUSE_TASK_NOTIFICATIONS == 1 )
4342:              
4343:              	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
4344:              	{
0014FE  BE9F88     MOV.D W8, [W15++]
001500  BE9F8A     MOV.D W10, [W15++]
001502  781F8C     MOV W12, [W15++]
001504  BE0502     MOV.D W2, W10
001506  780401     MOV W1, W8
001508  780604     MOV W4, W12
4345:              	TCB_t * pxTCB;
4346:              	BaseType_t xReturn = pdPASS;
4347:              	uint8_t ucOriginalNotifyState;
4348:              
4349:              		configASSERT( xTaskToNotify );
4350:              		pxTCB = ( TCB_t * ) xTaskToNotify;
00150A  780480     MOV W0, W9
4351:              
4352:              		taskENTER_CRITICAL();
00150C  022BB0     CALL vPortEnterCritical
00150E  000000     NOP
4353:              		{
4354:              			if( pulPreviousNotificationValue != NULL )
001510  E0000C     CP0 W12
001512  320003     BRA Z, .L137
4355:              			{
4356:              				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
001514  901009     MOV [W9+32], W0
001516  901099     MOV [W9+34], W1
001518  BE8E00     MOV.D W0, [W12]
4357:              			}
4358:              
4359:              			ucOriginalNotifyState = pxTCB->ucNotifyState;
00151A  906049     MOV.B [W9+36], W0
4360:              
4361:              			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
00151C  B3C021     MOV.B #0x2, W1
00151E  9864C1     MOV.B W1, [W9+36]
4362:              
4363:              			switch( eAction )
001520  540FE2     SUB W8, #0x2, [W15]
001522  320010     BRA Z, .L140
001524  3E0003     BRA GTU, .L143
001526  540FE1     SUB W8, #0x1, [W15]
001528  3A001C     BRA NZ, .L138
00152A  370005     BRA .L149
00152C  540FE3     SUB W8, #0x3, [W15]
00152E  320011     BRA Z, .L141
001530  540FE4     SUB W8, #0x4, [W15]
001532  3A0017     BRA NZ, .L138
001534  370011     BRA .L150
4364:              			{
4365:              				case eSetBits	:
4366:              					pxTCB->ulNotifiedValue |= ulValue;
001536  901109     MOV [W9+32], W2
001538  901199     MOV [W9+34], W3
00153A  750502     IOR W10, W2, W10
00153C  758583     IOR W11, W3, W11
00153E  98148A     MOV W10, [W9+32]
001540  98149B     MOV W11, [W9+34]
4367:              					break;
001542  37000F     BRA .L138
4368:              
4369:              				case eIncrement	:
4370:              					( pxTCB->ulNotifiedValue )++;
001544  901109     MOV [W9+32], W2
001546  901199     MOV [W9+34], W3
001548  410161     ADD W2, #0x1, W2
00154A  4981E0     ADDC W3, #0x0, W3
00154C  981482     MOV W2, [W9+32]
00154E  981493     MOV W3, [W9+34]
4371:              					break;
001550  370008     BRA .L138
4372:              
4373:              				case eSetValueWithOverwrite	:
4374:              					pxTCB->ulNotifiedValue = ulValue;
001552  98148A     MOV W10, [W9+32]
001554  98149B     MOV W11, [W9+34]
4375:              					break;
001556  370005     BRA .L138
4376:              
4377:              				case eSetValueWithoutOverwrite :
4378:              					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
00155A  504FE2     SUB.B W0, #0x2, [W15]
00155C  32001C     BRA Z, .L144
4379:              					{
4380:              						pxTCB->ulNotifiedValue = ulValue;
00155E  98148A     MOV W10, [W9+32]
001560  98149B     MOV W11, [W9+34]
4381:              					}
4382:              					else
4383:              					{
4384:              						/* The value could not be written to the task. */
4385:              						xReturn = pdFAIL;
001558  EB0400     CLR W8
4386:              					}
4387:              					break;
4388:              
4389:              				case eNoAction:
4390:              					/* The task is being notified without its notify value being
4391:              					updated. */
4392:              					break;
4393:              			}
4394:              
4395:              			traceTASK_NOTIFY();
4396:              
4397:              			/* If the task is in the blocked state specifically to wait for a
4398:              			notification then unblock it now. */
4399:              			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
001562  200018     MOV #0x1, W8
001564  504FE1     SUB.B W0, #0x1, [W15]
001566  3A0017     BRA NZ, .L144
4400:              			{
4401:              				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
001568  E88409     INC2 W9, W8
00156A  780008     MOV W8, W0
00156C  022D4A     CALL uxListRemove
00156E  000000     NOP
4402:              				prvAddTaskToReadyList( pxTCB );
001570  900839     MOV [W9+22], W0
001572  E30856     CP uxTopReadyPriority
001574  310001     BRA C, .L145
001576  8842B0     MOV W0, uxTopReadyPriority
001578  B9006A     MUL.SU W0, #10, W0
00157A  21CF82     MOV #0x1CF8, W2
00157C  410000     ADD W2, W0, W0
00157E  780088     MOV W8, W1
001580  022D10     CALL vListInsertEnd
001582  000000     NOP
4403:              
4404:              				/* The task should not have been on an event list. */
4405:              				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
4406:              
4407:              				#if( configUSE_TICKLESS_IDLE != 0 )
4408:              				{
4409:              					/* If a task is blocked waiting for a notification then
4410:              					xNextTaskUnblockTime might be set to the blocked task's time
4411:              					out time.  If the task is unblocked for a reason other than
4412:              					a timeout xNextTaskUnblockTime is normally left unchanged,
4413:              					because it will automatically get reset to a new value when
4414:              					the tick count equals xNextTaskUnblockTime.  However if
4415:              					tickless idling is used it might be more important to enter
4416:              					sleep mode at the earliest possible time - so reset
4417:              					xNextTaskUnblockTime here to ensure it is updated at the
4418:              					earliest possible time. */
4419:              					prvResetNextTaskUnblockTime();
4420:              				}
4421:              				#endif
4422:              
4423:              				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
001584  804280     MOV pxCurrentTCB, W0
001586  9008B9     MOV [W9+22], W1
001588  900830     MOV [W0+22], W0
00158A  200018     MOV #0x1, W8
00158C  508F80     SUB W1, W0, [W15]
00158E  360003     BRA LEU, .L144
4424:              				{
4425:              					/* The notified task has a priority above the currently
4426:              					executing task so a yield is required. */
4427:              					taskYIELD_IF_USING_PREEMPTION();
001590  022DC4     CALL .Letext0, .LFE2, _vPortYield
001592  000000     NOP
001594  000000     NOP
4428:              				}
4429:              				else
4430:              				{
4431:              					mtCOVERAGE_TEST_MARKER();
4432:              				}
4433:              			}
4434:              			else
4435:              			{
4436:              				mtCOVERAGE_TEST_MARKER();
4437:              			}
4438:              		}
4439:              		taskEXIT_CRITICAL();
001596  022BC0     CALL vPortExitCritical
001598  000000     NOP
4440:              
4441:              		return xReturn;
4442:              	}
00159A  780008     MOV W8, W0
00159C  78064F     MOV [--W15], W12
00159E  BE054F     MOV.D [--W15], W10
0015A0  BE044F     MOV.D [--W15], W8
0015A2  060000     RETURN
4443:              
4444:              #endif /* configUSE_TASK_NOTIFICATIONS */
4445:              /*-----------------------------------------------------------*/
4446:              
4447:              #if( configUSE_TASK_NOTIFICATIONS == 1 )
4448:              
4449:              	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
4450:              	{
0015A4  BE9F88     MOV.D W8, [W15++]
0015A6  781F8A     MOV W10, [W15++]
0015A8  780485     MOV W5, W9
4451:              	TCB_t * pxTCB;
4452:              	uint8_t ucOriginalNotifyState;
4453:              	BaseType_t xReturn = pdPASS;
4454:              	UBaseType_t uxSavedInterruptStatus;
4455:              
4456:              		configASSERT( xTaskToNotify );
4457:              
4458:              		/* RTOS ports that support interrupt nesting have the concept of a
4459:              		maximum	system call (or maximum API call) interrupt priority.
4460:              		Interrupts that are	above the maximum system call priority are keep
4461:              		permanently enabled, even when the RTOS kernel is in a critical section,
4462:              		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
4463:              		is defined in FreeRTOSConfig.h then
4464:              		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
4465:              		failure if a FreeRTOS API function is called from an interrupt that has
4466:              		been assigned a priority above the configured maximum system call
4467:              		priority.  Only FreeRTOS functions that end in FromISR can be called
4468:              		from interrupts	that have been assigned a priority at or (logically)
4469:              		below the maximum system call interrupt priority.  FreeRTOS maintains a
4470:              		separate interrupt safe API to ensure interrupt entry is as fast and as
4471:              		simple as possible.  More information (albeit Cortex-M specific) is
4472:              		provided on the following link:
4473:              		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
4474:              		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
4475:              
4476:              		pxTCB = ( TCB_t * ) xTaskToNotify;
0015AA  780400     MOV W0, W8
4477:              
4478:              		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
4479:              		{
4480:              			if( pulPreviousNotificationValue != NULL )
0015AC  E00004     CP0 W4
0015AE  320003     BRA Z, .L152
4481:              			{
4482:              				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
0015B0  901308     MOV [W8+32], W6
0015B2  901398     MOV [W8+34], W7
0015B4  BE8A06     MOV.D W6, [W4]
4483:              			}
4484:              
4485:              			ucOriginalNotifyState = pxTCB->ucNotifyState;
0015B6  906248     MOV.B [W8+36], W4
4486:              			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
0015B8  B3C020     MOV.B #0x2, W0
0015BA  986440     MOV.B W0, [W8+36]
4487:              
4488:              			switch( eAction )
0015BC  508FE2     SUB W1, #0x2, [W15]
0015BE  320010     BRA Z, .L155
0015C0  3E0003     BRA GTU, .L158
0015C2  508FE1     SUB W1, #0x1, [W15]
0015C4  3A001C     BRA NZ, .L153
0015C6  370005     BRA .L167
0015C8  508FE3     SUB W1, #0x3, [W15]
0015CA  320011     BRA Z, .L156
0015CC  508FE4     SUB W1, #0x4, [W15]
0015CE  3A0017     BRA NZ, .L153
0015D0  370011     BRA .L168
4489:              			{
4490:              				case eSetBits	:
4491:              					pxTCB->ulNotifiedValue |= ulValue;
0015D2  901008     MOV [W8+32], W0
0015D4  901098     MOV [W8+34], W1
0015D6  710100     IOR W2, W0, W2
0015D8  718181     IOR W3, W1, W3
0015DA  981402     MOV W2, [W8+32]
0015DC  981413     MOV W3, [W8+34]
4492:              					break;
0015DE  37000F     BRA .L153
4493:              
4494:              				case eIncrement	:
4495:              					( pxTCB->ulNotifiedValue )++;
0015E0  901008     MOV [W8+32], W0
0015E2  901098     MOV [W8+34], W1
0015E4  400061     ADD W0, #0x1, W0
0015E6  4880E0     ADDC W1, #0x0, W1
0015E8  981400     MOV W0, [W8+32]
0015EA  981411     MOV W1, [W8+34]
4496:              					break;
0015EC  370008     BRA .L153
4497:              
4498:              				case eSetValueWithOverwrite	:
4499:              					pxTCB->ulNotifiedValue = ulValue;
0015EE  981402     MOV W2, [W8+32]
0015F0  981413     MOV W3, [W8+34]
4500:              					break;
0015F2  370005     BRA .L153
4501:              
4502:              				case eSetValueWithoutOverwrite :
4503:              					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
0015F6  524FE2     SUB.B W4, #0x2, [W15]
0015F8  320026     BRA Z, .L159
4504:              					{
4505:              						pxTCB->ulNotifiedValue = ulValue;
0015FA  981402     MOV W2, [W8+32]
0015FC  981413     MOV W3, [W8+34]
4506:              					}
4507:              					else
4508:              					{
4509:              						/* The value could not be written to the task. */
4510:              						xReturn = pdFAIL;
0015F4  EB0000     CLR W0
4511:              					}
4512:              					break;
4513:              
4514:              				case eNoAction :
4515:              					/* The task is being notified without its notify value being
4516:              					updated. */
4517:              					break;
4518:              			}
4519:              
4520:              			traceTASK_NOTIFY_FROM_ISR();
4521:              
4522:              			/* If the task is in the blocked state specifically to wait for a
4523:              			notification then unblock it now. */
4524:              			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
0015FE  200010     MOV #0x1, W0
001600  524FE1     SUB.B W4, #0x1, [W15]
001602  3A0021     BRA NZ, .L159
4525:              			{
4526:              				/* The task should not have been on an event list. */
4527:              				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
4528:              
4529:              				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
001604  E20866     CP0 uxSchedulerSuspended
001606  3A000F     BRA NZ, .L160
4530:              				{
4531:              					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
001608  E88508     INC2 W8, W10
00160A  78000A     MOV W10, W0
00160C  022D4A     CALL uxListRemove
00160E  000000     NOP
4532:              					prvAddTaskToReadyList( pxTCB );
001610  900838     MOV [W8+22], W0
001612  E30856     CP uxTopReadyPriority
001614  310001     BRA C, .L161
001616  8842B0     MOV W0, uxTopReadyPriority
001618  B9006A     MUL.SU W0, #10, W0
00161A  21CF82     MOV #0x1CF8, W2
00161C  410000     ADD W2, W0, W0
00161E  78008A     MOV W10, W1
001620  022D10     CALL vListInsertEnd
001622  000000     NOP
001624  370004     BRA .L162
4533:              				}
4534:              				else
4535:              				{
4536:              					/* The delayed and ready lists cannot be accessed, so hold
4537:              					this task pending until the scheduler is resumed. */
4538:              					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
001626  4400EC     ADD W8, #0xC, W1
001628  21D340     MOV #0x1D34, W0
00162A  022D10     CALL vListInsertEnd
00162C  000000     NOP
4539:              				}
4540:              
4541:              				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
00162E  804280     MOV pxCurrentTCB, W0
001630  900938     MOV [W8+22], W2
001632  9008B0     MOV [W0+22], W1
001634  200010     MOV #0x1, W0
001636  510F81     SUB W2, W1, [W15]
001638  360006     BRA LEU, .L159
4542:              				{
4543:              					/* The notified task has a priority above the currently
4544:              					executing task so a yield is required. */
4545:              					if( pxHigherPriorityTaskWoken != NULL )
00163A  E00009     CP0 W9
00163C  320002     BRA Z, .L163
4546:              					{
4547:              						*pxHigherPriorityTaskWoken = pdTRUE;
00163E  780C80     MOV W0, [W9]
001640  370002     BRA .L159
4548:              					}
4549:              					else
4550:              					{
4551:              						/* Mark that a yield is pending in case the user is not
4552:              						using the "xHigherPriorityTaskWoken" parameter to an ISR
4553:              						safe FreeRTOS function. */
4554:              						xYieldPending = pdTRUE;
001642  200010     MOV #0x1, W0
001644  8842E0     MOV W0, xYieldPending
4555:              					}
4556:              				}
4557:              				else
4558:              				{
4559:              					mtCOVERAGE_TEST_MARKER();
4560:              				}
4561:              			}
4562:              		}
4563:              		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
4564:              
4565:              		return xReturn;
4566:              	}
001646  78054F     MOV [--W15], W10
001648  BE044F     MOV.D [--W15], W8
00164A  060000     RETURN
4567:              
4568:              #endif /* configUSE_TASK_NOTIFICATIONS */
4569:              /*-----------------------------------------------------------*/
4570:              
4571:              #if( configUSE_TASK_NOTIFICATIONS == 1 )
4572:              
4573:              	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
4574:              	{
00164C  BE9F88     MOV.D W8, [W15++]
00164E  781F8A     MOV W10, [W15++]
001650  BE0400     MOV.D W0, W8
4575:              	TCB_t * pxTCB;
4576:              	uint8_t ucOriginalNotifyState;
4577:              	UBaseType_t uxSavedInterruptStatus;
4578:              
4579:              		configASSERT( xTaskToNotify );
4580:              
4581:              		/* RTOS ports that support interrupt nesting have the concept of a
4582:              		maximum	system call (or maximum API call) interrupt priority.
4583:              		Interrupts that are	above the maximum system call priority are keep
4584:              		permanently enabled, even when the RTOS kernel is in a critical section,
4585:              		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
4586:              		is defined in FreeRTOSConfig.h then
4587:              		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
4588:              		failure if a FreeRTOS API function is called from an interrupt that has
4589:              		been assigned a priority above the configured maximum system call
4590:              		priority.  Only FreeRTOS functions that end in FromISR can be called
4591:              		from interrupts	that have been assigned a priority at or (logically)
4592:              		below the maximum system call interrupt priority.  FreeRTOS maintains a
4593:              		separate interrupt safe API to ensure interrupt entry is as fast and as
4594:              		simple as possible.  More information (albeit Cortex-M specific) is
4595:              		provided on the following link:
4596:              		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
4597:              		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
4598:              
4599:              		pxTCB = ( TCB_t * ) xTaskToNotify;
4600:              
4601:              		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
4602:              		{
4603:              			ucOriginalNotifyState = pxTCB->ucNotifyState;
001652  906048     MOV.B [W8+36], W0
4604:              			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
001654  B3C021     MOV.B #0x2, W1
001656  986441     MOV.B W1, [W8+36]
4605:              
4606:              			/* 'Giving' is equivalent to incrementing a count in a counting
4607:              			semaphore. */
4608:              			( pxTCB->ulNotifiedValue )++;
001658  901108     MOV [W8+32], W2
00165A  901198     MOV [W8+34], W3
00165C  410161     ADD W2, #0x1, W2
00165E  4981E0     ADDC W3, #0x0, W3
001660  981402     MOV W2, [W8+32]
001662  981413     MOV W3, [W8+34]
4609:              
4610:              			traceTASK_NOTIFY_GIVE_FROM_ISR();
4611:              
4612:              			/* If the task is in the blocked state specifically to wait for a
4613:              			notification then unblock it now. */
4614:              			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
001664  504FE1     SUB.B W0, #0x1, [W15]
001666  3A0021     BRA NZ, .L169
4615:              			{
4616:              				/* The task should not have been on an event list. */
4617:              				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
4618:              
4619:              				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
001668  E20866     CP0 uxSchedulerSuspended
00166A  3A000F     BRA NZ, .L171
4620:              				{
4621:              					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
00166C  E88508     INC2 W8, W10
00166E  78000A     MOV W10, W0
001670  022D4A     CALL uxListRemove
001672  000000     NOP
4622:              					prvAddTaskToReadyList( pxTCB );
001674  900838     MOV [W8+22], W0
001676  E30856     CP uxTopReadyPriority
001678  310001     BRA C, .L172
00167A  8842B0     MOV W0, uxTopReadyPriority
00167C  B9006A     MUL.SU W0, #10, W0
00167E  21CF82     MOV #0x1CF8, W2
001680  410000     ADD W2, W0, W0
001682  78008A     MOV W10, W1
001684  022D10     CALL vListInsertEnd
001686  000000     NOP
001688  370004     BRA .L173
4623:              				}
4624:              				else
4625:              				{
4626:              					/* The delayed and ready lists cannot be accessed, so hold
4627:              					this task pending until the scheduler is resumed. */
4628:              					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
00168A  4400EC     ADD W8, #0xC, W1
00168C  21D340     MOV #0x1D34, W0
00168E  022D10     CALL vListInsertEnd
001690  000000     NOP
4629:              				}
4630:              
4631:              				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
001692  804280     MOV pxCurrentTCB, W0
001694  9008B8     MOV [W8+22], W1
001696  900830     MOV [W0+22], W0
001698  508F80     SUB W1, W0, [W15]
00169A  360007     BRA LEU, .L169
4632:              				{
4633:              					/* The notified task has a priority above the currently
4634:              					executing task so a yield is required. */
4635:              					if( pxHigherPriorityTaskWoken != NULL )
00169C  E00009     CP0 W9
00169E  320003     BRA Z, .L174
4636:              					{
4637:              						*pxHigherPriorityTaskWoken = pdTRUE;
0016A0  200010     MOV #0x1, W0
0016A2  780C80     MOV W0, [W9]
0016A4  370002     BRA .L169
4638:              					}
4639:              					else
4640:              					{
4641:              						/* Mark that a yield is pending in case the user is not
4642:              						using the "xHigherPriorityTaskWoken" parameter in an ISR
4643:              						safe FreeRTOS function. */
4644:              						xYieldPending = pdTRUE;
0016A6  200010     MOV #0x1, W0
0016A8  8842E0     MOV W0, xYieldPending
4645:              					}
4646:              				}
4647:              				else
4648:              				{
4649:              					mtCOVERAGE_TEST_MARKER();
4650:              				}
4651:              			}
4652:              		}
4653:              		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
4654:              	}
0016AA  78054F     MOV [--W15], W10
0016AC  BE044F     MOV.D [--W15], W8
0016AE  060000     RETURN
4655:              
4656:              #endif /* configUSE_TASK_NOTIFICATIONS */
4657:              
4658:              /*-----------------------------------------------------------*/
4659:              
4660:              #if( configUSE_TASK_NOTIFICATIONS == 1 )
4661:              
4662:              	BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask )
4663:              	{
0016B0  BE9F88     MOV.D W8, [W15++]
4664:              	TCB_t *pxTCB;
4665:              	BaseType_t xReturn;
4666:              
4667:              		/* If null is passed in here then it is the calling task that is having
4668:              		its notification state cleared. */
4669:              		pxTCB = prvGetTCBFromHandle( xTask );
0016B2  E00000     CP0 W0
0016B4  3A0002     BRA NZ, .L176
0016B6  804289     MOV pxCurrentTCB, W9
0016B8  370001     BRA .L177
0016BA  780480     MOV W0, W9
4670:              
4671:              		taskENTER_CRITICAL();
0016BC  022BB0     CALL vPortEnterCritical
0016BE  000000     NOP
4672:              		{
4673:              			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
0016C0  906049     MOV.B [W9+36], W0
0016C4  504FE2     SUB.B W0, #0x2, [W15]
0016C6  3A0003     BRA NZ, .L178
4674:              			{
4675:              				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
0016C8  EB4000     CLR.B W0
0016CA  9864C0     MOV.B W0, [W9+36]
4676:              				xReturn = pdPASS;
0016CC  200018     MOV #0x1, W8
4677:              			}
4678:              			else
4679:              			{
4680:              				xReturn = pdFAIL;
0016C2  EB0400     CLR W8
4681:              			}
4682:              		}
4683:              		taskEXIT_CRITICAL();
0016CE  022BC0     CALL vPortExitCritical
0016D0  000000     NOP
4684:              
4685:              		return xReturn;
4686:              	}
0016D2  780008     MOV W8, W0
0016D4  BE044F     MOV.D [--W15], W8
0016D6  060000     RETURN
4687:              
4688:              #endif /* configUSE_TASK_NOTIFICATIONS */
4689:              /*-----------------------------------------------------------*/
4690:              
4691:              
4692:              static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
4693:              {
0016D8  BE9F88     MOV.D W8, [W15++]
0016DA  781F8A     MOV W10, [W15++]
0016DC  780400     MOV W0, W8
0016DE  780501     MOV W1, W10
4694:              TickType_t xTimeToWake;
4695:              const TickType_t xConstTickCount = xTickCount;
0016E0  8042A9     MOV xTickCount, W9
4696:              
4697:              	#if( INCLUDE_xTaskAbortDelay == 1 )
4698:              	{
4699:              		/* About to enter a delayed list, so ensure the ucDelayAborted flag is
4700:              		reset to pdFALSE so it can be detected as having been set to pdTRUE
4701:              		when the task leaves the Blocked state. */
4702:              		pxCurrentTCB->ucDelayAborted = pdFALSE;
4703:              	}
4704:              	#endif
4705:              
4706:              	/* Remove the task from the ready list before adding it to the blocked list
4707:              	as the same list item is used for both lists. */
4708:              	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
0016E2  EC8850     INC2 pxCurrentTCB, WREG
0016E4  022D4A     CALL uxListRemove
0016E6  000000     NOP
4709:              	{
4710:              		/* The current task must be in a ready list, so there is no need to
4711:              		check, and the port reset macro can be called directly. */
4712:              		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
4713:              	}
4714:              	else
4715:              	{
4716:              		mtCOVERAGE_TEST_MARKER();
4717:              	}
4718:              
4719:              	#if ( INCLUDE_vTaskSuspend == 1 )
4720:              	{
4721:              		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
0016E8  440FE1     ADD W8, #0x1, [W15]
0016EA  3A0008     BRA NZ, .L181
0016EC  E0000A     CP0 W10
0016EE  320006     BRA Z, .L181
4722:              		{
4723:              			/* Add the task to the suspended task list instead of a delayed task
4724:              			list to ensure it is not woken by a timing event.  It will block
4725:              			indefinitely. */
4726:              			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
0016F0  804281     MOV pxCurrentTCB, W1
0016F2  E88081     INC2 W1, W1
0016F4  21D3E0     MOV #0x1D3E, W0
0016F6  022D10     CALL vListInsertEnd
0016F8  000000     NOP
0016FA  370014     BRA .L180
4727:              		}
4728:              		else
4729:              		{
4730:              			/* Calculate the time at which the task should be woken if the event
4731:              			does not occur.  This may overflow but this doesn't matter, the
4732:              			kernel will manage it correctly. */
4733:              			xTimeToWake = xConstTickCount + xTicksToWait;
0016FC  440409     ADD W8, W9, W8
4734:              
4735:              			/* The list item will be inserted in wake time order. */
4736:              			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
0016FE  804280     MOV pxCurrentTCB, W0
001700  980018     MOV W8, [W0+2]
4737:              
4738:              			if( xTimeToWake < xConstTickCount )
001702  548F88     SUB W9, W8, [W15]
001704  360006     BRA LEU, .L183
4739:              			{
4740:              				/* Wake time has overflowed.  Place this item in the overflow
4741:              				list. */
4742:              				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
001706  804281     MOV pxCurrentTCB, W1
001708  804350     MOV pxOverflowDelayedTaskList, W0
00170A  E88081     INC2 W1, W1
00170C  022D24     CALL vListInsert
00170E  000000     NOP
001710  370009     BRA .L180
4743:              			}
4744:              			else
4745:              			{
4746:              				/* The wake time has not overflowed, so the current block list
4747:              				is used. */
4748:              				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
001712  804281     MOV pxCurrentTCB, W1
001714  804340     MOV pxDelayedTaskList, W0
001716  E88081     INC2 W1, W1
001718  022D24     CALL vListInsert
00171A  000000     NOP
4749:              
4750:              				/* If the task entering the blocked state was placed at the
4751:              				head of the list of blocked tasks then xNextTaskUnblockTime
4752:              				needs to be updated too. */
4753:              				if( xTimeToWake < xNextTaskUnblockTime )
00171C  804310     MOV xNextTaskUnblockTime, W0
00171E  500F88     SUB W0, W8, [W15]
001720  360001     BRA LEU, .L180
4754:              				{
4755:              					xNextTaskUnblockTime = xTimeToWake;
001722  884318     MOV W8, xNextTaskUnblockTime
4756:              				}
4757:              				else
4758:              				{
4759:              					mtCOVERAGE_TEST_MARKER();
4760:              				}
4761:              			}
4762:              		}
4763:              	}
4764:              	#else /* INCLUDE_vTaskSuspend */
4765:              	{
4766:              		/* Calculate the time at which the task should be woken if the event
4767:              		does not occur.  This may overflow but this doesn't matter, the kernel
4768:              		will manage it correctly. */
4769:              		xTimeToWake = xConstTickCount + xTicksToWait;
4770:              
4771:              		/* The list item will be inserted in wake time order. */
4772:              		listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
4773:              
4774:              		if( xTimeToWake < xConstTickCount )
4775:              		{
4776:              			/* Wake time has overflowed.  Place this item in the overflow list. */
4777:              			vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
4778:              		}
4779:              		else
4780:              		{
4781:              			/* The wake time has not overflowed, so the current block list is used. */
4782:              			vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
4783:              
4784:              			/* If the task entering the blocked state was placed at the head of the
4785:              			list of blocked tasks then xNextTaskUnblockTime needs to be updated
4786:              			too. */
4787:              			if( xTimeToWake < xNextTaskUnblockTime )
4788:              			{
4789:              				xNextTaskUnblockTime = xTimeToWake;
4790:              			}
4791:              			else
4792:              			{
4793:              				mtCOVERAGE_TEST_MARKER();
4794:              			}
4795:              		}
4796:              
4797:              		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
4798:              		( void ) xCanBlockIndefinitely;
4799:              	}
4800:              	#endif /* INCLUDE_vTaskSuspend */
4801:              }
001724  78054F     MOV [--W15], W10
001726  BE044F     MOV.D [--W15], W8
001728  060000     RETURN
4802:              
4803:              
4804:              #ifdef FREERTOS_MODULE_TEST
4805:              	#include "tasks_test_access_functions.h"
4806:              #endif
4807:              
---  D:/code/FreeRTOS/Source/queue.c  -------------------------------------------------------------------
1:                 /*
2:                     FreeRTOS V9.0.0 - Copyright (C) 2016 Real Time Engineers Ltd.
3:                     All rights reserved
4:                 
5:                     VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
6:                 
7:                     This file is part of the FreeRTOS distribution.
8:                 
9:                     FreeRTOS is free software; you can redistribute it and/or modify it under
10:                    the terms of the GNU General Public License (version 2) as published by the
11:                    Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
12:                
13:                    ***************************************************************************
14:                    >>!   NOTE: The modification to the GPL is included to allow you to     !<<
15:                    >>!   distribute a combined work that includes FreeRTOS without being   !<<
16:                    >>!   obliged to provide the source code for proprietary components     !<<
17:                    >>!   outside of the FreeRTOS kernel.                                   !<<
18:                    ***************************************************************************
19:                
20:                    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
21:                    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
22:                    FOR A PARTICULAR PURPOSE.  Full license text is available on the following
23:                    link: http://www.freertos.org/a00114.html
24:                
25:                    ***************************************************************************
26:                     *                                                                       *
27:                     *    FreeRTOS provides completely free yet professionally developed,    *
28:                     *    robust, strictly quality controlled, supported, and cross          *
29:                     *    platform software that is more than just the market leader, it     *
30:                     *    is the industry's de facto standard.                               *
31:                     *                                                                       *
32:                     *    Help yourself get started quickly while simultaneously helping     *
33:                     *    to support the FreeRTOS project by purchasing a FreeRTOS           *
34:                     *    tutorial book, reference manual, or both:                          *
35:                     *    http://www.FreeRTOS.org/Documentation                              *
36:                     *                                                                       *
37:                    ***************************************************************************
38:                
39:                    http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
40:                    the FAQ page "My application does not run, what could be wrong?".  Have you
41:                    defined configASSERT()?
42:                
43:                    http://www.FreeRTOS.org/support - In return for receiving this top quality
44:                    embedded software for free we request you assist our global community by
45:                    participating in the support forum.
46:                
47:                    http://www.FreeRTOS.org/training - Investing in training allows your team to
48:                    be as productive as possible as early as possible.  Now you can receive
49:                    FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
50:                    Ltd, and the world's leading authority on the world's leading RTOS.
51:                
52:                    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
53:                    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
54:                    compatible FAT file system, and our tiny thread aware UDP/IP stack.
55:                
56:                    http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
57:                    Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
58:                
59:                    http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
60:                    Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
61:                    licenses offer ticketed support, indemnification and commercial middleware.
62:                
63:                    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
64:                    engineered and independently SIL3 certified version for use in safety and
65:                    mission critical applications that require provable dependability.
66:                
67:                    1 tab == 4 spaces!
68:                */
69:                
70:                #include <stdlib.h>
71:                #include <string.h>
72:                
73:                /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
74:                all the API functions to use the MPU wrappers.  That should only be done when
75:                task.h is included from an application file. */
76:                #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
77:                
78:                #include "FreeRTOS.h"
79:                #include "task.h"
80:                #include "queue.h"
81:                
82:                #if ( configUSE_CO_ROUTINES == 1 )
83:                	#include "croutine.h"
84:                #endif
85:                
86:                /* Lint e961 and e750 are suppressed as a MISRA exception justified because the
87:                MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined for the
88:                header files above, but not in this file, in order to generate the correct
89:                privileged Vs unprivileged linkage and placement. */
90:                #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750. */
91:                
92:                
93:                /* Constants used with the cRxLock and cTxLock structure members. */
94:                #define queueUNLOCKED					( ( int8_t ) -1 )
95:                #define queueLOCKED_UNMODIFIED			( ( int8_t ) 0 )
96:                
97:                /* When the Queue_t structure is used to represent a base queue its pcHead and
98:                pcTail members are used as pointers into the queue storage area.  When the
99:                Queue_t structure is used to represent a mutex pcHead and pcTail pointers are
100:               not necessary, and the pcHead pointer is set to NULL to indicate that the
101:               pcTail pointer actually points to the mutex holder (if any).  Map alternative
102:               names to the pcHead and pcTail structure members to ensure the readability of
103:               the code is maintained despite this dual use of two structure members.  An
104:               alternative implementation would be to use a union, but use of a union is
105:               against the coding standard (although an exception to the standard has been
106:               permitted where the dual use also significantly changes the type of the
107:               structure member). */
108:               #define pxMutexHolder					pcTail
109:               #define uxQueueType						pcHead
110:               #define queueQUEUE_IS_MUTEX				NULL
111:               
112:               /* Semaphores do not actually store or copy data, so have an item size of
113:               zero. */
114:               #define queueSEMAPHORE_QUEUE_ITEM_LENGTH ( ( UBaseType_t ) 0 )
115:               #define queueMUTEX_GIVE_BLOCK_TIME		 ( ( TickType_t ) 0U )
116:               
117:               #if( configUSE_PREEMPTION == 0 )
118:               	/* If the cooperative scheduler is being used then a yield should not be
119:               	performed just because a higher priority task has been woken. */
120:               	#define queueYIELD_IF_USING_PREEMPTION()
121:               #else
122:               	#define queueYIELD_IF_USING_PREEMPTION() portYIELD_WITHIN_API()
123:               #endif
124:               
125:               /*
126:                * Definition of the queue used by the scheduler.
127:                * Items are queued by copy, not reference.  See the following link for the
128:                * rationale: http://www.freertos.org/Embedded-RTOS-Queues.html
129:                */
130:               typedef struct QueueDefinition
131:               {
132:               	int8_t *pcHead;					/*< Points to the beginning of the queue storage area. */
133:               	int8_t *pcTail;					/*< Points to the byte at the end of the queue storage area.  Once more byte is allocated than necessary to store the queue items, this is used as a marker. */
134:               	int8_t *pcWriteTo;				/*< Points to the free next place in the storage area. */
135:               
136:               	union							/* Use of a union is an exception to the coding standard to ensure two mutually exclusive structure members don't appear simultaneously (wasting RAM). */
137:               	{
138:               		int8_t *pcReadFrom;			/*< Points to the last place that a queued item was read from when the structure is used as a queue. */
139:               		UBaseType_t uxRecursiveCallCount;/*< Maintains a count of the number of times a recursive mutex has been recursively 'taken' when the structure is used as a mutex. */
140:               	} u;
141:               
142:               	List_t xTasksWaitingToSend;		/*< List of tasks that are blocked waiting to post onto this queue.  Stored in priority order. */
143:               	List_t xTasksWaitingToReceive;	/*< List of tasks that are blocked waiting to read from this queue.  Stored in priority order. */
144:               
145:               	volatile UBaseType_t uxMessagesWaiting;/*< The number of items currently in the queue. */
146:               	UBaseType_t uxLength;			/*< The length of the queue defined as the number of items it will hold, not the number of bytes. */
147:               	UBaseType_t uxItemSize;			/*< The size of each items that the queue will hold. */
148:               
149:               	volatile int8_t cRxLock;		/*< Stores the number of items received from the queue (removed from the queue) while the queue was locked.  Set to queueUNLOCKED when the queue is not locked. */
150:               	volatile int8_t cTxLock;		/*< Stores the number of items transmitted to the queue (added to the queue) while the queue was locked.  Set to queueUNLOCKED when the queue is not locked. */
151:               
152:               	#if( ( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
153:               		uint8_t ucStaticallyAllocated;	/*< Set to pdTRUE if the memory used by the queue was statically allocated to ensure no attempt is made to free the memory. */
154:               	#endif
155:               
156:               	#if ( configUSE_QUEUE_SETS == 1 )
157:               		struct QueueDefinition *pxQueueSetContainer;
158:               	#endif
159:               
160:               	#if ( configUSE_TRACE_FACILITY == 1 )
161:               		UBaseType_t uxQueueNumber;
162:               		uint8_t ucQueueType;
163:               	#endif
164:               
165:               } xQUEUE;
166:               
167:               /* The old xQUEUE name is maintained above then typedefed to the new Queue_t
168:               name below to enable the use of older kernel aware debuggers. */
169:               typedef xQUEUE Queue_t;
170:               
171:               /*-----------------------------------------------------------*/
172:               
173:               /*
174:                * The queue registry is just a means for kernel aware debuggers to locate
175:                * queue structures.  It has no other purpose so is an optional component.
176:                */
177:               #if ( configQUEUE_REGISTRY_SIZE > 0 )
178:               
179:               	/* The type stored within the queue registry array.  This allows a name
180:               	to be assigned to each queue making kernel aware debugging a little
181:               	more user friendly. */
182:               	typedef struct QUEUE_REGISTRY_ITEM
183:               	{
184:               		const char *pcQueueName; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
185:               		QueueHandle_t xHandle;
186:               	} xQueueRegistryItem;
187:               
188:               	/* The old xQueueRegistryItem name is maintained above then typedefed to the
189:               	new xQueueRegistryItem name below to enable the use of older kernel aware
190:               	debuggers. */
191:               	typedef xQueueRegistryItem QueueRegistryItem_t;
192:               
193:               	/* The queue registry is simply an array of QueueRegistryItem_t structures.
194:               	The pcQueueName member of a structure being NULL is indicative of the
195:               	array position being vacant. */
196:               	PRIVILEGED_DATA QueueRegistryItem_t xQueueRegistry[ configQUEUE_REGISTRY_SIZE ];
197:               
198:               #endif /* configQUEUE_REGISTRY_SIZE */
199:               
200:               /*
201:                * Unlocks a queue locked by a call to prvLockQueue.  Locking a queue does not
202:                * prevent an ISR from adding or removing items to the queue, but does prevent
203:                * an ISR from removing tasks from the queue event lists.  If an ISR finds a
204:                * queue is locked it will instead increment the appropriate queue lock count
205:                * to indicate that a task may require unblocking.  When the queue in unlocked
206:                * these lock counts are inspected, and the appropriate action taken.
207:                */
208:               static void prvUnlockQueue( Queue_t * const pxQueue ) PRIVILEGED_FUNCTION;
209:               
210:               /*
211:                * Uses a critical section to determine if there is any data in a queue.
212:                *
213:                * @return pdTRUE if the queue contains no items, otherwise pdFALSE.
214:                */
215:               static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue ) PRIVILEGED_FUNCTION;
216:               
217:               /*
218:                * Uses a critical section to determine if there is any space in a queue.
219:                *
220:                * @return pdTRUE if there is no space, otherwise pdFALSE;
221:                */
222:               static BaseType_t prvIsQueueFull( const Queue_t *pxQueue ) PRIVILEGED_FUNCTION;
223:               
224:               /*
225:                * Copies an item into the queue, either at the front of the queue or the
226:                * back of the queue.
227:                */
228:               static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition ) PRIVILEGED_FUNCTION;
229:               
230:               /*
231:                * Copies an item out of a queue.
232:                */
233:               static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer ) PRIVILEGED_FUNCTION;
234:               
235:               #if ( configUSE_QUEUE_SETS == 1 )
236:               	/*
237:               	 * Checks to see if a queue is a member of a queue set, and if so, notifies
238:               	 * the queue set that the queue contains data.
239:               	 */
240:               	static BaseType_t prvNotifyQueueSetContainer( const Queue_t * const pxQueue, const BaseType_t xCopyPosition ) PRIVILEGED_FUNCTION;
241:               #endif
242:               
243:               /*
244:                * Called after a Queue_t structure has been allocated either statically or
245:                * dynamically to fill in the structure's members.
246:                */
247:               static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, const uint8_t ucQueueType, Queue_t *pxNewQueue ) PRIVILEGED_FUNCTION;
248:               
249:               /*
250:                * Mutexes are a special type of queue.  When a mutex is created, first the
251:                * queue is created, then prvInitialiseMutex() is called to configure the queue
252:                * as a mutex.
253:                */
254:               #if( configUSE_MUTEXES == 1 )
255:               	static void prvInitialiseMutex( Queue_t *pxNewQueue ) PRIVILEGED_FUNCTION;
256:               #endif
257:               
258:               /*-----------------------------------------------------------*/
259:               
260:               /*
261:                * Macro to mark a queue as locked.  Locking a queue prevents an ISR from
262:                * accessing the queue event lists.
263:                */
264:               #define prvLockQueue( pxQueue )								\
265:               	taskENTER_CRITICAL();									\
266:               	{														\
267:               		if( ( pxQueue )->cRxLock == queueUNLOCKED )			\
268:               		{													\
269:               			( pxQueue )->cRxLock = queueLOCKED_UNMODIFIED;	\
270:               		}													\
271:               		if( ( pxQueue )->cTxLock == queueUNLOCKED )			\
272:               		{													\
273:               			( pxQueue )->cTxLock = queueLOCKED_UNMODIFIED;	\
274:               		}													\
275:               	}														\
276:               	taskEXIT_CRITICAL()
277:               /*-----------------------------------------------------------*/
278:               
279:               BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
280:               {
001A04  BE9F88     MOV.D W8, [W15++]
001A06  BE0400     MOV.D W0, W8
281:               Queue_t * const pxQueue = ( Queue_t * ) xQueue;
282:               
283:               	configASSERT( pxQueue );
284:               
285:               	taskENTER_CRITICAL();
001A08  022BB0     CALL vPortEnterCritical
001A0A  000000     NOP
286:               	{
287:               		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
001A0C  780018     MOV [W8], W0
001A0E  900978     MOV [W8+30], W2
001A10  901088     MOV [W8+32], W1
001A12  B98A02     MUL.SS W1, W2, W4
001A14  400184     ADD W0, W4, W3
001A16  980413     MOV W3, [W8+2]
288:               		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
001A18  EB0180     CLR W3
001A1A  980C63     MOV W3, [W8+28]
289:               		pxQueue->pcWriteTo = pxQueue->pcHead;
001A1C  980420     MOV W0, [W8+4]
290:               		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
001A1E  E90102     DEC W2, W2
001A20  B99101     MUL.SS W2, W1, W2
001A22  400082     ADD W0, W2, W1
001A24  980431     MOV W1, [W8+6]
291:               		pxQueue->cRxLock = queueUNLOCKED;
001A26  EBC000     SETM.B W0
001A28  986420     MOV.B W0, [W8+34]
292:               		pxQueue->cTxLock = queueUNLOCKED;
001A2A  986430     MOV.B W0, [W8+35]
293:               
294:               		if( xNewQueue == pdFALSE )
001A2C  E00009     CP0 W9
001A2E  3A000C     BRA NZ, .L22
295:               		{
296:               			/* If there are tasks blocked waiting to read from the queue, then
297:               			the tasks will remain blocked as after this function exits the queue
298:               			will still be empty.  If there are tasks blocked waiting to write to
299:               			the queue, then one should be unblocked as after this function exits
300:               			it will be possible to write to it. */
301:               			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
001A30  900048     MOV [W8+8], W0
001A32  E00000     CP0 W0
001A34  32000F     BRA Z, .L23
302:               			{
303:               				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
001A36  440068     ADD W8, #0x8, W0
001A38  021152     CALL xTaskRemoveFromEventList
001A3A  000000     NOP
001A3C  E00000     CP0 W0
001A3E  32000A     BRA Z, .L23
304:               				{
305:               					queueYIELD_IF_USING_PREEMPTION();
001A40  022DC4     CALL .Letext0, .LFE2, _vPortYield
001A42  000000     NOP
001A44  000000     NOP
001A46  370006     BRA .L23
306:               				}
307:               				else
308:               				{
309:               					mtCOVERAGE_TEST_MARKER();
310:               				}
311:               			}
312:               			else
313:               			{
314:               				mtCOVERAGE_TEST_MARKER();
315:               			}
316:               		}
317:               		else
318:               		{
319:               			/* Ensure the event queues start in the correct state. */
320:               			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
001A48  440068     ADD W8, #0x8, W0
001A4A  022CFA     CALL vListInitialise
001A4C  000000     NOP
321:               			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
001A4E  440072     ADD W8, #0x12, W0
001A50  022CFA     CALL vListInitialise
001A52  000000     NOP
322:               		}
323:               	}
324:               	taskEXIT_CRITICAL();
001A54  022BC0     CALL vPortExitCritical
001A56  000000     NOP
325:               
326:               	/* A value is returned for calling semantic consistency with previous
327:               	versions. */
328:               	return pdPASS;
329:               }
001A58  200010     MOV #0x1, W0
001A5A  BE044F     MOV.D [--W15], W8
001A5C  060000     RETURN
330:               /*-----------------------------------------------------------*/
331:               
332:               #if( configSUPPORT_STATIC_ALLOCATION == 1 )
333:               
334:               	QueueHandle_t xQueueGenericCreateStatic( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, StaticQueue_t *pxStaticQueue, const uint8_t ucQueueType )
335:               	{
336:               	Queue_t *pxNewQueue;
337:               
338:               		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
339:               
340:               		/* The StaticQueue_t structure and the queue storage area must be
341:               		supplied. */
342:               		configASSERT( pxStaticQueue != NULL );
343:               
344:               		/* A queue storage area should be provided if the item size is not 0, and
345:               		should not be provided if the item size is 0. */
346:               		configASSERT( !( ( pucQueueStorage != NULL ) && ( uxItemSize == 0 ) ) );
347:               		configASSERT( !( ( pucQueueStorage == NULL ) && ( uxItemSize != 0 ) ) );
348:               
349:               		#if( configASSERT_DEFINED == 1 )
350:               		{
351:               			/* Sanity check that the size of the structure used to declare a
352:               			variable of type StaticQueue_t or StaticSemaphore_t equals the size of
353:               			the real queue and semaphore structures. */
354:               			volatile size_t xSize = sizeof( StaticQueue_t );
355:               			configASSERT( xSize == sizeof( Queue_t ) );
356:               		}
357:               		#endif /* configASSERT_DEFINED */
358:               
359:               		/* The address of a statically allocated queue was passed in, use it.
360:               		The address of a statically allocated storage area was also passed in
361:               		but is already set. */
362:               		pxNewQueue = ( Queue_t * ) pxStaticQueue; /*lint !e740 Unusual cast is ok as the structures are designed to have the same alignment, and the size is checked by an assert. */
363:               
364:               		if( pxNewQueue != NULL )
365:               		{
366:               			#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
367:               			{
368:               				/* Queues can be allocated wither statically or dynamically, so
369:               				note this queue was allocated statically in case the queue is
370:               				later deleted. */
371:               				pxNewQueue->ucStaticallyAllocated = pdTRUE;
372:               			}
373:               			#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
374:               
375:               			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
376:               		}
377:               
378:               		return pxNewQueue;
379:               	}
380:               
381:               #endif /* configSUPPORT_STATIC_ALLOCATION */
382:               /*-----------------------------------------------------------*/
383:               
384:               #if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
385:               
386:               	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
387:               	{
001A74  BE9F88     MOV.D W8, [W15++]
001A76  BE9F8A     MOV.D W10, [W15++]
001A78  780500     MOV W0, W10
001A7A  780481     MOV W1, W9
001A7C  784582     MOV.B W2, W11
388:               	Queue_t *pxNewQueue;
389:               	size_t xQueueSizeInBytes;
390:               	uint8_t *pucQueueStorage;
391:               
392:               		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
393:               
394:               		if( uxItemSize == ( UBaseType_t ) 0 )
001A80  E00009     CP0 W9
001A82  320001     BRA Z, .L28
395:               		{
396:               			/* There is not going to be a queue storage area. */
397:               			xQueueSizeInBytes = ( size_t ) 0;
001A7E  EB0000     CLR W0
398:               		}
399:               		else
400:               		{
401:               			/* Allocate enough space to hold the maximum number of items that
402:               			can be in the queue at any time. */
403:               			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
001A84  B9C80A     MUL.SS W9, W10, W0
404:               		}
405:               
406:               		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
001A86  B00240     ADD #0x24, W0
001A88  022E18     CALL pvPortMalloc
001A8A  000000     NOP
001A8C  780400     MOV W0, W8
407:               
408:               		if( pxNewQueue != NULL )
001A8E  E00008     CP0 W8
001A90  320007     BRA Z, .L29
409:               		{
410:               			/* Jump past the queue structure to find the location of the queue
411:               			storage area. */
412:               			pucQueueStorage = ( ( uint8_t * ) pxNewQueue ) + sizeof( Queue_t );
001A92  200242     MOV #0x24, W2
001A94  410108     ADD W2, W8, W2
413:               
414:               			#if( configSUPPORT_STATIC_ALLOCATION == 1 )
415:               			{
416:               				/* Queues can be created either statically or dynamically, so
417:               				note this task was created dynamically in case it is later
418:               				deleted. */
419:               				pxNewQueue->ucStaticallyAllocated = pdFALSE;
420:               			}
421:               			#endif /* configSUPPORT_STATIC_ALLOCATION */
422:               
423:               			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
001A96  780208     MOV W8, W4
001A98  78418B     MOV.B W11, W3
001A9A  780089     MOV W9, W1
001A9C  78000A     MOV W10, W0
001A9E  07FFDF     RCALL _prvInitialiseNewQueue, .LFE0, .LFB2
424:               		}
425:               
426:               		return pxNewQueue;
427:               	}
001AA0  780008     MOV W8, W0
001AA2  BE054F     MOV.D [--W15], W10
001AA4  BE044F     MOV.D [--W15], W8
001AA6  060000     RETURN
428:               
429:               #endif /* configSUPPORT_STATIC_ALLOCATION */
430:               /*-----------------------------------------------------------*/
431:               
432:               static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, const uint8_t ucQueueType, Queue_t *pxNewQueue )
433:               {
434:               	/* Remove compiler warnings about unused parameters should
435:               	configUSE_TRACE_FACILITY not be set to 1. */
436:               	( void ) ucQueueType;
437:               
438:               	if( uxItemSize == ( UBaseType_t ) 0 )
001A5E  E00001     CP0 W1
001A60  3A0002     BRA NZ, .L25
439:               	{
440:               		/* No RAM was allocated for the queue storage area, but PC head cannot
441:               		be set to NULL because NULL is used as a key to say the queue is used as
442:               		a mutex.  Therefore just set pcHead to point to the queue as a benign
443:               		value that is known to be within the memory map. */
444:               		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
001A62  780A04     MOV W4, [W4]
001A64  370001     BRA .L26
445:               	}
446:               	else
447:               	{
448:               		/* Set the head to the start of the queue storage area. */
449:               		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
001A66  780A02     MOV W2, [W4]
450:               	}
451:               
452:               	/* Initialise the queue members as described where the queue type is
453:               	defined. */
454:               	pxNewQueue->uxLength = uxQueueLength;
001A68  980A70     MOV W0, [W4+30]
455:               	pxNewQueue->uxItemSize = uxItemSize;
001A6A  981201     MOV W1, [W4+32]
456:               	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
001A6C  200011     MOV #0x1, W1
001A6E  780004     MOV W4, W0
001A70  07FFC9     RCALL xQueueGenericReset
457:               
458:               	#if ( configUSE_TRACE_FACILITY == 1 )
459:               	{
460:               		pxNewQueue->ucQueueType = ucQueueType;
461:               	}
462:               	#endif /* configUSE_TRACE_FACILITY */
463:               
464:               	#if( configUSE_QUEUE_SETS == 1 )
465:               	{
466:               		pxNewQueue->pxQueueSetContainer = NULL;
467:               	}
468:               	#endif /* configUSE_QUEUE_SETS */
469:               
470:               	traceQUEUE_CREATE( pxNewQueue );
471:               }
001A72  060000     RETURN
472:               /*-----------------------------------------------------------*/
473:               
474:               #if( configUSE_MUTEXES == 1 )
475:               
476:               	static void prvInitialiseMutex( Queue_t *pxNewQueue )
477:               	{
478:               		if( pxNewQueue != NULL )
479:               		{
480:               			/* The queue create function will set all the queue structure members
481:               			correctly for a generic queue, but this function is creating a
482:               			mutex.  Overwrite those members that need to be set differently -
483:               			in particular the information required for priority inheritance. */
484:               			pxNewQueue->pxMutexHolder = NULL;
485:               			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
486:               
487:               			/* In case this is a recursive mutex. */
488:               			pxNewQueue->u.uxRecursiveCallCount = 0;
489:               
490:               			traceCREATE_MUTEX( pxNewQueue );
491:               
492:               			/* Start with the semaphore in the expected state. */
493:               			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
494:               		}
495:               		else
496:               		{
497:               			traceCREATE_MUTEX_FAILED();
498:               		}
499:               	}
500:               
501:               #endif /* configUSE_MUTEXES */
502:               /*-----------------------------------------------------------*/
503:               
504:               #if( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
505:               
506:               	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
507:               	{
508:               	Queue_t *pxNewQueue;
509:               	const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;
510:               
511:               		pxNewQueue = ( Queue_t * ) xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
512:               		prvInitialiseMutex( pxNewQueue );
513:               
514:               		return pxNewQueue;
515:               	}
516:               
517:               #endif /* configUSE_MUTEXES */
518:               /*-----------------------------------------------------------*/
519:               
520:               #if( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
521:               
522:               	QueueHandle_t xQueueCreateMutexStatic( const uint8_t ucQueueType, StaticQueue_t *pxStaticQueue )
523:               	{
524:               	Queue_t *pxNewQueue;
525:               	const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;
526:               
527:               		/* Prevent compiler warnings about unused parameters if
528:               		configUSE_TRACE_FACILITY does not equal 1. */
529:               		( void ) ucQueueType;
530:               
531:               		pxNewQueue = ( Queue_t * ) xQueueGenericCreateStatic( uxMutexLength, uxMutexSize, NULL, pxStaticQueue, ucQueueType );
532:               		prvInitialiseMutex( pxNewQueue );
533:               
534:               		return pxNewQueue;
535:               	}
536:               
537:               #endif /* configUSE_MUTEXES */
538:               /*-----------------------------------------------------------*/
539:               
540:               #if ( ( configUSE_MUTEXES == 1 ) && ( INCLUDE_xSemaphoreGetMutexHolder == 1 ) )
541:               
542:               	void* xQueueGetMutexHolder( QueueHandle_t xSemaphore )
543:               	{
544:               	void *pxReturn;
545:               
546:               		/* This function is called by xSemaphoreGetMutexHolder(), and should not
547:               		be called directly.  Note:  This is a good way of determining if the
548:               		calling task is the mutex holder, but not a good way of determining the
549:               		identity of the mutex holder, as the holder may change between the
550:               		following critical section exiting and the function returning. */
551:               		taskENTER_CRITICAL();
552:               		{
553:               			if( ( ( Queue_t * ) xSemaphore )->uxQueueType == queueQUEUE_IS_MUTEX )
554:               			{
555:               				pxReturn = ( void * ) ( ( Queue_t * ) xSemaphore )->pxMutexHolder;
556:               			}
557:               			else
558:               			{
559:               				pxReturn = NULL;
560:               			}
561:               		}
562:               		taskEXIT_CRITICAL();
563:               
564:               		return pxReturn;
565:               	} /*lint !e818 xSemaphore cannot be a pointer to const because it is a typedef. */
566:               
567:               #endif
568:               /*-----------------------------------------------------------*/
569:               
570:               #if ( configUSE_RECURSIVE_MUTEXES == 1 )
571:               
572:               	BaseType_t xQueueGiveMutexRecursive( QueueHandle_t xMutex )
573:               	{
574:               	BaseType_t xReturn;
575:               	Queue_t * const pxMutex = ( Queue_t * ) xMutex;
576:               
577:               		configASSERT( pxMutex );
578:               
579:               		/* If this is the task that holds the mutex then pxMutexHolder will not
580:               		change outside of this task.  If this task does not hold the mutex then
581:               		pxMutexHolder can never coincidentally equal the tasks handle, and as
582:               		this is the only condition we are interested in it does not matter if
583:               		pxMutexHolder is accessed simultaneously by another task.  Therefore no
584:               		mutual exclusion is required to test the pxMutexHolder variable. */
585:               		if( pxMutex->pxMutexHolder == ( void * ) xTaskGetCurrentTaskHandle() ) /*lint !e961 Not a redundant cast as TaskHandle_t is a typedef. */
586:               		{
587:               			traceGIVE_MUTEX_RECURSIVE( pxMutex );
588:               
589:               			/* uxRecursiveCallCount cannot be zero if pxMutexHolder is equal to
590:               			the task handle, therefore no underflow check is required.  Also,
591:               			uxRecursiveCallCount is only modified by the mutex holder, and as
592:               			there can only be one, no mutual exclusion is required to modify the
593:               			uxRecursiveCallCount member. */
594:               			( pxMutex->u.uxRecursiveCallCount )--;
595:               
596:               			/* Has the recursive call count unwound to 0? */
597:               			if( pxMutex->u.uxRecursiveCallCount == ( UBaseType_t ) 0 )
598:               			{
599:               				/* Return the mutex.  This will automatically unblock any other
600:               				task that might be waiting to access the mutex. */
601:               				( void ) xQueueGenericSend( pxMutex, NULL, queueMUTEX_GIVE_BLOCK_TIME, queueSEND_TO_BACK );
602:               			}
603:               			else
604:               			{
605:               				mtCOVERAGE_TEST_MARKER();
606:               			}
607:               
608:               			xReturn = pdPASS;
609:               		}
610:               		else
611:               		{
612:               			/* The mutex cannot be given because the calling task is not the
613:               			holder. */
614:               			xReturn = pdFAIL;
615:               
616:               			traceGIVE_MUTEX_RECURSIVE_FAILED( pxMutex );
617:               		}
618:               
619:               		return xReturn;
620:               	}
621:               
622:               #endif /* configUSE_RECURSIVE_MUTEXES */
623:               /*-----------------------------------------------------------*/
624:               
625:               #if ( configUSE_RECURSIVE_MUTEXES == 1 )
626:               
627:               	BaseType_t xQueueTakeMutexRecursive( QueueHandle_t xMutex, TickType_t xTicksToWait )
628:               	{
629:               	BaseType_t xReturn;
630:               	Queue_t * const pxMutex = ( Queue_t * ) xMutex;
631:               
632:               		configASSERT( pxMutex );
633:               
634:               		/* Comments regarding mutual exclusion as per those within
635:               		xQueueGiveMutexRecursive(). */
636:               
637:               		traceTAKE_MUTEX_RECURSIVE( pxMutex );
638:               
639:               		if( pxMutex->pxMutexHolder == ( void * ) xTaskGetCurrentTaskHandle() ) /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
640:               		{
641:               			( pxMutex->u.uxRecursiveCallCount )++;
642:               			xReturn = pdPASS;
643:               		}
644:               		else
645:               		{
646:               			xReturn = xQueueGenericReceive( pxMutex, NULL, xTicksToWait, pdFALSE );
647:               
648:               			/* pdPASS will only be returned if the mutex was successfully
649:               			obtained.  The calling task may have entered the Blocked state
650:               			before reaching here. */
651:               			if( xReturn != pdFAIL )
652:               			{
653:               				( pxMutex->u.uxRecursiveCallCount )++;
654:               			}
655:               			else
656:               			{
657:               				traceTAKE_MUTEX_RECURSIVE_FAILED( pxMutex );
658:               			}
659:               		}
660:               
661:               		return xReturn;
662:               	}
663:               
664:               #endif /* configUSE_RECURSIVE_MUTEXES */
665:               /*-----------------------------------------------------------*/
666:               
667:               #if( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
668:               
669:               	QueueHandle_t xQueueCreateCountingSemaphoreStatic( const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount, StaticQueue_t *pxStaticQueue )
670:               	{
671:               	QueueHandle_t xHandle;
672:               
673:               		configASSERT( uxMaxCount != 0 );
674:               		configASSERT( uxInitialCount <= uxMaxCount );
675:               
676:               		xHandle = xQueueGenericCreateStatic( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, NULL, pxStaticQueue, queueQUEUE_TYPE_COUNTING_SEMAPHORE );
677:               
678:               		if( xHandle != NULL )
679:               		{
680:               			( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
681:               
682:               			traceCREATE_COUNTING_SEMAPHORE();
683:               		}
684:               		else
685:               		{
686:               			traceCREATE_COUNTING_SEMAPHORE_FAILED();
687:               		}
688:               
689:               		return xHandle;
690:               	}
691:               
692:               #endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
693:               /*-----------------------------------------------------------*/
694:               
695:               #if( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
696:               
697:               	QueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount )
698:               	{
699:               	QueueHandle_t xHandle;
700:               
701:               		configASSERT( uxMaxCount != 0 );
702:               		configASSERT( uxInitialCount <= uxMaxCount );
703:               
704:               		xHandle = xQueueGenericCreate( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUNTING_SEMAPHORE );
705:               
706:               		if( xHandle != NULL )
707:               		{
708:               			( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
709:               
710:               			traceCREATE_COUNTING_SEMAPHORE();
711:               		}
712:               		else
713:               		{
714:               			traceCREATE_COUNTING_SEMAPHORE_FAILED();
715:               		}
716:               
717:               		return xHandle;
718:               	}
719:               
720:               #endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
721:               /*-----------------------------------------------------------*/
722:               
723:               BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
724:               {
001AA8  FA0006     LNK #0x6
001AAA  BE9F88     MOV.D W8, [W15++]
001AAC  BE9F8A     MOV.D W10, [W15++]
001AAE  781F8C     MOV W12, [W15++]
001AB0  780601     MOV W1, W12
001AB2  9FBFA2     MOV W2, [W15-12]
001AB4  780503     MOV W3, W10
725:               BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
001AB8  EB0480     CLR W9
726:               TimeOut_t xTimeOut;
727:               Queue_t * const pxQueue = ( Queue_t * ) xQueue;
001AB6  780400     MOV W0, W8
728:               
729:               	configASSERT( pxQueue );
730:               	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
731:               	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
732:               	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
733:               	{
734:               		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
735:               	}
736:               	#endif
737:               
738:               
739:               	/* This function relaxes the coding standard somewhat to allow return
740:               	statements within the function itself.  This is done in the interest
741:               	of execution time efficiency. */
742:               	for( ;; )
743:               	{
744:               		taskENTER_CRITICAL();
001ABC  022BB0     CALL vPortEnterCritical
001ABE  000000     NOP
745:               		{
746:               			/* Is there room on the queue now?  The running task must be the
747:               			highest priority task wanting to access the queue.  If the head item
748:               			in the queue is to be overwritten then it does not matter if the
749:               			queue is full. */
750:               			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
001AC0  9008E8     MOV [W8+28], W1
001AC2  900878     MOV [W8+30], W0
001AC4  508F80     SUB W1, W0, [W15]
001AC6  390002     BRA NC, .L33
001AC8  550FE2     SUB W10, #0x2, [W15]
001ACA  3A0019     BRA NZ, .L34
751:               			{
752:               				traceQUEUE_SEND( pxQueue );
753:               				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
001ACC  78010A     MOV W10, W2
001ACE  78008C     MOV W12, W1
001AD0  780008     MOV W8, W0
001AD2  07FEFD     RCALL .Letext0, .LFE3, _prvCopyDataToQueue, .Ltext0, .LFB13
754:               
755:               				#if ( configUSE_QUEUE_SETS == 1 )
756:               				{
757:               					if( pxQueue->pxQueueSetContainer != NULL )
758:               					{
759:               						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) != pdFALSE )
760:               						{
761:               							/* The queue is a member of a queue set, and posting
762:               							to the queue set caused a higher priority task to
763:               							unblock. A context switch is required. */
764:               							queueYIELD_IF_USING_PREEMPTION();
765:               						}
766:               						else
767:               						{
768:               							mtCOVERAGE_TEST_MARKER();
769:               						}
770:               					}
771:               					else
772:               					{
773:               						/* If there was a task waiting for data to arrive on the
774:               						queue then unblock it now. */
775:               						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
776:               						{
777:               							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
778:               							{
779:               								/* The unblocked task has a priority higher than
780:               								our own so yield immediately.  Yes it is ok to
781:               								do this from within the critical section - the
782:               								kernel takes care of that. */
783:               								queueYIELD_IF_USING_PREEMPTION();
784:               							}
785:               							else
786:               							{
787:               								mtCOVERAGE_TEST_MARKER();
788:               							}
789:               						}
790:               						else if( xYieldRequired != pdFALSE )
791:               						{
792:               							/* This path is a special case that will only get
793:               							executed if the task was holding multiple mutexes
794:               							and the mutexes were given back in an order that is
795:               							different to that in which they were taken. */
796:               							queueYIELD_IF_USING_PREEMPTION();
797:               						}
798:               						else
799:               						{
800:               							mtCOVERAGE_TEST_MARKER();
801:               						}
802:               					}
803:               				}
804:               				#else /* configUSE_QUEUE_SETS */
805:               				{
806:               					/* If there was a task waiting for data to arrive on the
807:               					queue then unblock it now. */
808:               					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
001AD4  900898     MOV [W8+18], W1
001AD6  E00001     CP0 W1
001AD8  320009     BRA Z, .L35
809:               					{
810:               						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
001ADA  440072     ADD W8, #0x12, W0
001ADC  021152     CALL xTaskRemoveFromEventList
001ADE  000000     NOP
001AE0  E00000     CP0 W0
001AE2  320009     BRA Z, .L36
811:               						{
812:               							/* The unblocked task has a priority higher than
813:               							our own so yield immediately.  Yes it is ok to do
814:               							this from within the critical section - the kernel
815:               							takes care of that. */
816:               							queueYIELD_IF_USING_PREEMPTION();
001AE4  022DC4     CALL .Letext0, .LFE2, _vPortYield
001AE6  000000     NOP
001AE8  000000     NOP
001AEA  370005     BRA .L36
817:               						}
818:               						else
819:               						{
820:               							mtCOVERAGE_TEST_MARKER();
821:               						}
822:               					}
823:               					else if( xYieldRequired != pdFALSE )
001AEC  E00000     CP0 W0
001AEE  320003     BRA Z, .L36
824:               					{
825:               						/* This path is a special case that will only get
826:               						executed if the task was holding multiple mutexes and
827:               						the mutexes were given back in an order that is
828:               						different to that in which they were taken. */
829:               						queueYIELD_IF_USING_PREEMPTION();
001AF0  022DC4     CALL .Letext0, .LFE2, _vPortYield
001AF2  000000     NOP
001AF4  000000     NOP
830:               					}
831:               					else
832:               					{
833:               						mtCOVERAGE_TEST_MARKER();
834:               					}
835:               				}
836:               				#endif /* configUSE_QUEUE_SETS */
837:               
838:               				taskEXIT_CRITICAL();
001AF6  022BC0     CALL vPortExitCritical
001AF8  000000     NOP
839:               				return pdPASS;
001AFA  200010     MOV #0x1, W0
001AFC  370041     BRA .L37
840:               			}
841:               			else
842:               			{
843:               				if( xTicksToWait == ( TickType_t ) 0 )
001AFE  97B82F     MOV [W15-12], W0
001B00  E00000     CP0 W0
001B02  3A0004     BRA NZ, .L38
844:               				{
845:               					/* The queue was full and no block time is specified (or
846:               					the block time has expired) so leave now. */
847:               					taskEXIT_CRITICAL();
001B04  022BC0     CALL vPortExitCritical
001B06  000000     NOP
848:               
849:               					/* Return to the original privilege level before exiting
850:               					the function. */
851:               					traceQUEUE_SEND_FAILED( pxQueue );
852:               					return errQUEUE_FULL;
001B08  EB0000     CLR W0
001B0A  37003A     BRA .L37
853:               				}
854:               				else if( xEntryTimeSet == pdFALSE )
001B0C  E00009     CP0 W9
001B0E  3A0004     BRA NZ, .L39
855:               				{
856:               					/* The queue was full and a block time was specified so
857:               					configure the timeout structure. */
858:               					vTaskSetTimeOutState( &xTimeOut );
001B10  578070     SUB W15, #0x10, W0
001B12  0211DA     CALL vTaskSetTimeOutState
001B14  000000     NOP
859:               					xEntryTimeSet = pdTRUE;
001B16  200019     MOV #0x1, W9
860:               				}
861:               				else
862:               				{
863:               					/* Entry time was already set. */
864:               					mtCOVERAGE_TEST_MARKER();
865:               				}
866:               			}
867:               		}
868:               		taskEXIT_CRITICAL();
001B18  022BC0     CALL vPortExitCritical
001B1A  000000     NOP
869:               
870:               		/* Interrupts and other tasks can send to and receive from the queue
871:               		now the critical section has been exited. */
872:               
873:               		vTaskSuspendAll();
001B1C  0210AA     CALL vTaskSuspendAll
001B1E  000000     NOP
874:               		prvLockQueue( pxQueue );
001B20  022BB0     CALL vPortEnterCritical
001B22  000000     NOP
001B24  906028     MOV.B [W8+34], W0
001B26  404FE1     ADD.B W0, #0x1, [W15]
001B28  3A0002     BRA NZ, .L40
001B2A  EB4000     CLR.B W0
001B2C  986420     MOV.B W0, [W8+34]
001B2E  906038     MOV.B [W8+35], W0
001B30  404FE1     ADD.B W0, #0x1, [W15]
001B32  3A0002     BRA NZ, .L41
001B34  EB4000     CLR.B W0
001B36  986430     MOV.B W0, [W8+35]
001B38  022BC0     CALL vPortExitCritical
001B3A  000000     NOP
875:               
876:               		/* Update the timeout state to see if it has expired yet. */
877:               		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
001B3C  5780EC     SUB W15, #0xC, W1
001B3E  578070     SUB W15, #0x10, W0
001B40  0211E4     CALL xTaskCheckForTimeOut
001B42  000000     NOP
001B44  E00000     CP0 W0
001B46  3A0017     BRA NZ, .L42
878:               		{
879:               			if( prvIsQueueFull( pxQueue ) != pdFALSE )
001B48  780008     MOV W8, W0
001B4A  07FF01     RCALL _prvIsQueueFull, .LFE14, .LFB18
001B4C  E00000     CP0 W0
001B4E  32000E     BRA Z, .L43
880:               			{
881:               				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
882:               				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
001ABA  4405E8     ADD W8, #0x8, W11
001B50  97B8AF     MOV [W15-12], W1
001B52  78000B     MOV W11, W0
001B54  021852     CALL vTaskPlaceOnEventList
001B56  000000     NOP
883:               
884:               				/* Unlocking the queue means queue events can effect the
885:               				event list.  It is possible	that interrupts occurring now
886:               				remove this task from the event	list again - but as the
887:               				scheduler is suspended the task will go onto the pending
888:               				ready last instead of the actual ready list. */
889:               				prvUnlockQueue( pxQueue );
001B58  780008     MOV W8, W0
001B5A  07FF16     RCALL _prvUnlockQueue, .LFE16, .LFB15
890:               
891:               				/* Resuming the scheduler will move tasks from the pending
892:               				ready list into the ready list - so it is feasible that this
893:               				task is already in a ready list before it yields - in which
894:               				case the yield will not cause a context switch unless there
895:               				is also a higher priority task in the pending ready list. */
896:               				if( xTaskResumeAll() == pdFALSE )
001B5C  021408     CALL xTaskResumeAll
001B5E  000000     NOP
001B60  E00000     CP0 W0
001B62  3AFFAC     BRA NZ, .L47
897:               				{
898:               					portYIELD_WITHIN_API();
001B64  022DC4     CALL .Letext0, .LFE2, _vPortYield
001B66  000000     NOP
001B68  000000     NOP
001B6A  37FFA8     BRA .L47
899:               				}
900:               			}
901:               			else
902:               			{
903:               				/* Try again. */
904:               				prvUnlockQueue( pxQueue );
001B6C  780008     MOV W8, W0
001B6E  07FF0C     RCALL _prvUnlockQueue, .LFE16, .LFB15
905:               				( void ) xTaskResumeAll();
001B70  021408     CALL xTaskResumeAll
001B72  000000     NOP
001B74  37FFA3     BRA .L47
906:               			}
907:               		}
908:               		else
909:               		{
910:               			/* The timeout has expired. */
911:               			prvUnlockQueue( pxQueue );
001B76  780008     MOV W8, W0
001B78  07FF07     RCALL _prvUnlockQueue, .LFE16, .LFB15
912:               			( void ) xTaskResumeAll();
001B7A  021408     CALL xTaskResumeAll
001B7C  000000     NOP
913:               
914:               			traceQUEUE_SEND_FAILED( pxQueue );
915:               			return errQUEUE_FULL;
001B7E  EB0000     CLR W0
916:               		}
917:               	}
918:               }
001B80  78064F     MOV [--W15], W12
001B82  BE054F     MOV.D [--W15], W10
001B84  BE044F     MOV.D [--W15], W8
001B86  FA8000     ULNK
001B88  060000     RETURN
919:               /*-----------------------------------------------------------*/
920:               
921:               BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
922:               {
001B8A  BE9F88     MOV.D W8, [W15++]
001B8C  781F8A     MOV W10, [W15++]
001B8E  780502     MOV W2, W10
923:               BaseType_t xReturn;
924:               UBaseType_t uxSavedInterruptStatus;
925:               Queue_t * const pxQueue = ( Queue_t * ) xQueue;
001B90  780480     MOV W0, W9
926:               
927:               	configASSERT( pxQueue );
928:               	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
929:               	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
930:               
931:               	/* RTOS ports that support interrupt nesting have the concept of a maximum
932:               	system call (or maximum API call) interrupt priority.  Interrupts that are
933:               	above the maximum system call priority are kept permanently enabled, even
934:               	when the RTOS kernel is in a critical section, but cannot make any calls to
935:               	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
936:               	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
937:               	failure if a FreeRTOS API function is called from an interrupt that has been
938:               	assigned a priority above the configured maximum system call priority.
939:               	Only FreeRTOS functions that end in FromISR can be called from interrupts
940:               	that have been assigned a priority at or (logically) below the maximum
941:               	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
942:               	safe API to ensure interrupt entry is as fast and as simple as possible.
943:               	More information (albeit Cortex-M specific) is provided on the following
944:               	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
945:               	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
946:               
947:               	/* Similar to xQueueGenericSend, except without blocking if there is no room
948:               	in the queue.  Also don't directly wake a task that was blocked on a queue
949:               	read, instead return a flag to say whether a context switch is required or
950:               	not (i.e. has a task with a higher priority than us been woken by this
951:               	post). */
952:               	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
953:               	{
954:               		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
001B92  900969     MOV [W9+28], W2
001B94  900879     MOV [W9+30], W0
001B96  510F80     SUB W2, W0, [W15]
001B98  390003     BRA NC, .L49, .LBB4
001B9C  518FE2     SUB W3, #0x2, [W15]
001B9E  3A0018     BRA NZ, .L50, .LBE4
955:               		{
956:               			const int8_t cTxLock = pxQueue->cTxLock;
001BA0  906439     MOV.B [W9+35], W8
957:               
958:               			traceQUEUE_SEND_FROM_ISR( pxQueue );
959:               
960:               			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
961:               			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
962:               			in a task disinheriting a priority and prvCopyDataToQueue() can be
963:               			called here even though the disinherit function does not check if
964:               			the scheduler is suspended before accessing the ready lists. */
965:               			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
001BA2  780103     MOV W3, W2
001BA4  780009     MOV W9, W0
001BA6  07FE93     RCALL .Letext0, .LFE3, _prvCopyDataToQueue, .Ltext0, .LFB13
966:               
967:               			/* The event list is not altered if the queue is locked.  This will
968:               			be done when the queue is unlocked later. */
969:               			if( cTxLock == queueUNLOCKED )
001BA8  444FE1     ADD.B W8, #0x1, [W15]
001BAA  3A000F     BRA NZ, .L51
970:               			{
971:               				#if ( configUSE_QUEUE_SETS == 1 )
972:               				{
973:               					if( pxQueue->pxQueueSetContainer != NULL )
974:               					{
975:               						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) != pdFALSE )
976:               						{
977:               							/* The queue is a member of a queue set, and posting
978:               							to the queue set caused a higher priority task to
979:               							unblock.  A context switch is required. */
980:               							if( pxHigherPriorityTaskWoken != NULL )
981:               							{
982:               								*pxHigherPriorityTaskWoken = pdTRUE;
983:               							}
984:               							else
985:               							{
986:               								mtCOVERAGE_TEST_MARKER();
987:               							}
988:               						}
989:               						else
990:               						{
991:               							mtCOVERAGE_TEST_MARKER();
992:               						}
993:               					}
994:               					else
995:               					{
996:               						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
997:               						{
998:               							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
999:               							{
1000:              								/* The task waiting has a higher priority so
1001:              								record that a context switch is required. */
1002:              								if( pxHigherPriorityTaskWoken != NULL )
1003:              								{
1004:              									*pxHigherPriorityTaskWoken = pdTRUE;
1005:              								}
1006:              								else
1007:              								{
1008:              									mtCOVERAGE_TEST_MARKER();
1009:              								}
1010:              							}
1011:              							else
1012:              							{
1013:              								mtCOVERAGE_TEST_MARKER();
1014:              							}
1015:              						}
1016:              						else
1017:              						{
1018:              							mtCOVERAGE_TEST_MARKER();
1019:              						}
1020:              					}
1021:              				}
1022:              				#else /* configUSE_QUEUE_SETS */
1023:              				{
1024:              					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
001BAC  900899     MOV [W9+18], W1
001BB0  E00001     CP0 W1
001BB2  32000E     BRA Z, .L50, .LBE4
1025:              					{
1026:              						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
001BB4  448072     ADD W9, #0x12, W0
001BB6  021152     CALL xTaskRemoveFromEventList
001BB8  000000     NOP
001BBA  780080     MOV W0, W1
001BBE  E00001     CP0 W1
001BC0  320007     BRA Z, .L50, .LBE4
1027:              						{
1028:              							/* The task waiting has a higher priority so record that a
1029:              							context	switch is required. */
1030:              							if( pxHigherPriorityTaskWoken != NULL )
001BC2  E0000A     CP0 W10
001BC4  320005     BRA Z, .L50, .LBE4
1031:              							{
1032:              								*pxHigherPriorityTaskWoken = pdTRUE;
001BC6  780D00     MOV W0, [W10]
001BC8  370003     BRA .L50, .LBE4
1033:              							}
1034:              							else
1035:              							{
1036:              								mtCOVERAGE_TEST_MARKER();
1037:              							}
1038:              						}
1039:              						else
1040:              						{
1041:              							mtCOVERAGE_TEST_MARKER();
1042:              						}
1043:              					}
1044:              					else
1045:              					{
1046:              						mtCOVERAGE_TEST_MARKER();
1047:              					}
1048:              				}
1049:              				#endif /* configUSE_QUEUE_SETS */
1050:              			}
1051:              			else
1052:              			{
1053:              				/* Increment the lock count so the task that unlocks the queue
1054:              				knows that data was posted while it was locked. */
1055:              				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
001BCA  E84408     INC.B W8, W8
001BCC  9864B8     MOV.B W8, [W9+35]
1056:              			}
1057:              
1058:              			xReturn = pdPASS;
001BAE  200010     MOV #0x1, W0
001BBC  200010     MOV #0x1, W0
001BCE  200010     MOV #0x1, W0
1059:              		}
1060:              		else
1061:              		{
1062:              			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
1063:              			xReturn = errQUEUE_FULL;
001B9A  EB0000     CLR W0
1064:              		}
1065:              	}
1066:              	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1067:              
1068:              	return xReturn;
1069:              }
001BD0  78054F     MOV [--W15], W10
001BD2  BE044F     MOV.D [--W15], W8
001BD4  060000     RETURN
1070:              /*-----------------------------------------------------------*/
1071:              
1072:              BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
1073:              {
001BD6  781F88     MOV W8, [W15++]
001BD8  780401     MOV W1, W8
1074:              BaseType_t xReturn;
1075:              UBaseType_t uxSavedInterruptStatus;
1076:              Queue_t * const pxQueue = ( Queue_t * ) xQueue;
1077:              
1078:              	/* Similar to xQueueGenericSendFromISR() but used with semaphores where the
1079:              	item size is 0.  Don't directly wake a task that was blocked on a queue
1080:              	read, instead return a flag to say whether a context switch is required or
1081:              	not (i.e. has a task with a higher priority than us been woken by this
1082:              	post). */
1083:              
1084:              	configASSERT( pxQueue );
1085:              
1086:              	/* xQueueGenericSendFromISR() should be used instead of xQueueGiveFromISR()
1087:              	if the item size is not 0. */
1088:              	configASSERT( pxQueue->uxItemSize == 0 );
1089:              
1090:              	/* Normally a mutex would not be given from an interrupt, especially if
1091:              	there is a mutex holder, as priority inheritance makes no sense for an
1092:              	interrupts, only tasks. */
1093:              	configASSERT( !( ( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX ) && ( pxQueue->pxMutexHolder != NULL ) ) );
1094:              
1095:              	/* RTOS ports that support interrupt nesting have the concept of a maximum
1096:              	system call (or maximum API call) interrupt priority.  Interrupts that are
1097:              	above the maximum system call priority are kept permanently enabled, even
1098:              	when the RTOS kernel is in a critical section, but cannot make any calls to
1099:              	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
1100:              	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1101:              	failure if a FreeRTOS API function is called from an interrupt that has been
1102:              	assigned a priority above the configured maximum system call priority.
1103:              	Only FreeRTOS functions that end in FromISR can be called from interrupts
1104:              	that have been assigned a priority at or (logically) below the maximum
1105:              	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
1106:              	safe API to ensure interrupt entry is as fast and as simple as possible.
1107:              	More information (albeit Cortex-M specific) is provided on the following
1108:              	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1109:              	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1110:              
1111:              	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
1112:              	{
1113:              		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
001BDA  900960     MOV [W0+28], W2
1114:              
1115:              		/* When the queue is used to implement a semaphore no data is ever
1116:              		moved through the queue but it is still valid to see if the queue 'has
1117:              		space'. */
1118:              		if( uxMessagesWaiting < pxQueue->uxLength )
001BDC  9009F0     MOV [W0+30], W3
001BE0  510F83     SUB W2, W3, [W15]
001BE2  310016     BRA C, .L57, .LBE5, .LBE6
1119:              		{
1120:              			const int8_t cTxLock = pxQueue->cTxLock;
001BE4  9060B0     MOV.B [W0+35], W1
1121:              
1122:              			traceQUEUE_SEND_FROM_ISR( pxQueue );
1123:              
1124:              			/* A task can only have an inherited priority if it is a mutex
1125:              			holder - and if there is a mutex holder then the mutex cannot be
1126:              			given from an ISR.  As this is the ISR version of the function it
1127:              			can be assumed there is no mutex holder and no need to determine if
1128:              			priority disinheritance is needed.  Simply increase the count of
1129:              			messages (semaphores) available. */
1130:              			pxQueue->uxMessagesWaiting = uxMessagesWaiting + 1;
001BE6  E80102     INC W2, W2
001BE8  980862     MOV W2, [W0+28]
1131:              
1132:              			/* The event list is not altered if the queue is locked.  This will
1133:              			be done when the queue is unlocked later. */
1134:              			if( cTxLock == queueUNLOCKED )
001BEA  40CFE1     ADD.B W1, #0x1, [W15]
001BEC  3A000E     BRA NZ, .L58
1135:              			{
1136:              				#if ( configUSE_QUEUE_SETS == 1 )
1137:              				{
1138:              					if( pxQueue->pxQueueSetContainer != NULL )
1139:              					{
1140:              						if( prvNotifyQueueSetContainer( pxQueue, queueSEND_TO_BACK ) != pdFALSE )
1141:              						{
1142:              							/* The semaphore is a member of a queue set, and
1143:              							posting	to the queue set caused a higher priority
1144:              							task to	unblock.  A context switch is required. */
1145:              							if( pxHigherPriorityTaskWoken != NULL )
1146:              							{
1147:              								*pxHigherPriorityTaskWoken = pdTRUE;
1148:              							}
1149:              							else
1150:              							{
1151:              								mtCOVERAGE_TEST_MARKER();
1152:              							}
1153:              						}
1154:              						else
1155:              						{
1156:              							mtCOVERAGE_TEST_MARKER();
1157:              						}
1158:              					}
1159:              					else
1160:              					{
1161:              						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1162:              						{
1163:              							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
1164:              							{
1165:              								/* The task waiting has a higher priority so
1166:              								record that a context switch is required. */
1167:              								if( pxHigherPriorityTaskWoken != NULL )
1168:              								{
1169:              									*pxHigherPriorityTaskWoken = pdTRUE;
1170:              								}
1171:              								else
1172:              								{
1173:              									mtCOVERAGE_TEST_MARKER();
1174:              								}
1175:              							}
1176:              							else
1177:              							{
1178:              								mtCOVERAGE_TEST_MARKER();
1179:              							}
1180:              						}
1181:              						else
1182:              						{
1183:              							mtCOVERAGE_TEST_MARKER();
1184:              						}
1185:              					}
1186:              				}
1187:              				#else /* configUSE_QUEUE_SETS */
1188:              				{
1189:              					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
001BEE  900910     MOV [W0+18], W2
001BF2  E00002     CP0 W2
001BF4  32000D     BRA Z, .L57, .LBE5, .LBE6
1190:              					{
1191:              						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
001BF6  400072     ADD W0, #0x12, W0
001BF8  021152     CALL xTaskRemoveFromEventList
001BFA  000000     NOP
001BFE  E00000     CP0 W0
001C00  320007     BRA Z, .L57, .LBE5, .LBE6
1192:              						{
1193:              							/* The task waiting has a higher priority so record that a
1194:              							context	switch is required. */
1195:              							if( pxHigherPriorityTaskWoken != NULL )
001C02  E00008     CP0 W8
001C04  320005     BRA Z, .L57, .LBE5, .LBE6
1196:              							{
1197:              								*pxHigherPriorityTaskWoken = pdTRUE;
001C06  780C01     MOV W1, [W8]
001C08  370003     BRA .L57, .LBE5, .LBE6
1198:              							}
1199:              							else
1200:              							{
1201:              								mtCOVERAGE_TEST_MARKER();
1202:              							}
1203:              						}
1204:              						else
1205:              						{
1206:              							mtCOVERAGE_TEST_MARKER();
1207:              						}
1208:              					}
1209:              					else
1210:              					{
1211:              						mtCOVERAGE_TEST_MARKER();
1212:              					}
1213:              				}
1214:              				#endif /* configUSE_QUEUE_SETS */
1215:              			}
1216:              			else
1217:              			{
1218:              				/* Increment the lock count so the task that unlocks the queue
1219:              				knows that data was posted while it was locked. */
1220:              				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
001C0A  E84081     INC.B W1, W1
001C0C  986031     MOV.B W1, [W0+35]
1221:              			}
1222:              
1223:              			xReturn = pdPASS;
001BF0  200011     MOV #0x1, W1
001BFC  200011     MOV #0x1, W1
001C0E  200011     MOV #0x1, W1
1224:              		}
1225:              		else
1226:              		{
1227:              			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
1228:              			xReturn = errQUEUE_FULL;
001BDE  EB0080     CLR W1
1229:              		}
1230:              	}
1231:              	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1232:              
1233:              	return xReturn;
1234:              }
001C10  780001     MOV W1, W0
001C12  78044F     MOV [--W15], W8
001C14  060000     RETURN
1235:              /*-----------------------------------------------------------*/
1236:              
1237:              BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
1238:              {
001C16  FA0006     LNK #0x6
001C18  BE9F88     MOV.D W8, [W15++]
001C1A  BE9F8A     MOV.D W10, [W15++]
001C1C  BE9F8C     MOV.D W12, [W15++]
001C1E  780601     MOV W1, W12
001C20  9FBF92     MOV W2, [W15-14]
001C22  780683     MOV W3, W13
1239:              BaseType_t xEntryTimeSet = pdFALSE;
001C26  EB0500     CLR W10
1240:              TimeOut_t xTimeOut;
1241:              int8_t *pcOriginalReadPosition;
1242:              Queue_t * const pxQueue = ( Queue_t * ) xQueue;
001C24  780400     MOV W0, W8
1243:              
1244:              	configASSERT( pxQueue );
1245:              	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
1246:              	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
1247:              	{
1248:              		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
1249:              	}
1250:              	#endif
1251:              
1252:              	/* This function relaxes the coding standard somewhat to allow return
1253:              	statements within the function itself.  This is done in the interest
1254:              	of execution time efficiency. */
1255:              
1256:              	for( ;; )
1257:              	{
1258:              		taskENTER_CRITICAL();
001C2A  022BB0     CALL vPortEnterCritical
001C2C  000000     NOP
1259:              		{
1260:              			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
001C2E  900CE8     MOV [W8+28], W9
1261:              
1262:              			/* Is there data in the queue now?  To be running the calling task
1263:              			must be the highest priority task wanting to access the queue. */
1264:              			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
001C30  E00009     CP0 W9
001C32  320024     BRA Z, .L65
1265:              			{
1266:              				/* Remember the read position in case the queue is only being
1267:              				peeked. */
1268:              				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
001C34  900538     MOV [W8+6], W10
1269:              
1270:              				prvCopyDataFromQueue( pxQueue, pvBuffer );
001C36  78008C     MOV W12, W1
001C38  780008     MOV W8, W0
001C3A  07FE78     RCALL _prvCopyDataFromQueue, .LFE13, .LFB14
1271:              
1272:              				if( xJustPeeking == pdFALSE )
001C3C  E0000D     CP0 W13
001C3E  3A000E     BRA NZ, .L66
1273:              				{
1274:              					traceQUEUE_RECEIVE( pxQueue );
1275:              
1276:              					/* Actually removing data, not just peeking. */
1277:              					pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
001C40  E90489     DEC W9, W9
001C42  980C69     MOV W9, [W8+28]
1278:              
1279:              					#if ( configUSE_MUTEXES == 1 )
1280:              					{
1281:              						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
1282:              						{
1283:              							/* Record the information required to implement
1284:              							priority inheritance should it become necessary. */
1285:              							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
1286:              						}
1287:              						else
1288:              						{
1289:              							mtCOVERAGE_TEST_MARKER();
1290:              						}
1291:              					}
1292:              					#endif /* configUSE_MUTEXES */
1293:              
1294:              					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
001C44  900048     MOV [W8+8], W0
001C46  E00000     CP0 W0
001C48  320015     BRA Z, .L67
1295:              					{
1296:              						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
001C4A  440068     ADD W8, #0x8, W0
001C4C  021152     CALL xTaskRemoveFromEventList
001C4E  000000     NOP
001C50  E00000     CP0 W0
001C52  320010     BRA Z, .L67
1297:              						{
1298:              							queueYIELD_IF_USING_PREEMPTION();
001C54  022DC4     CALL .Letext0, .LFE2, _vPortYield
001C56  000000     NOP
001C58  000000     NOP
001C5A  37000C     BRA .L67
1299:              						}
1300:              						else
1301:              						{
1302:              							mtCOVERAGE_TEST_MARKER();
1303:              						}
1304:              					}
1305:              					else
1306:              					{
1307:              						mtCOVERAGE_TEST_MARKER();
1308:              					}
1309:              				}
1310:              				else
1311:              				{
1312:              					traceQUEUE_PEEK( pxQueue );
1313:              
1314:              					/* The data is not being removed, so reset the read
1315:              					pointer. */
1316:              					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
001C5C  98043A     MOV W10, [W8+6]
1317:              
1318:              					/* The data is being left in the queue, so see if there are
1319:              					any other tasks waiting for the data. */
1320:              					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
001C5E  900818     MOV [W8+18], W0
001C60  E00000     CP0 W0
001C62  320008     BRA Z, .L67
1321:              					{
1322:              						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
001C64  440072     ADD W8, #0x12, W0
001C66  021152     CALL xTaskRemoveFromEventList
001C68  000000     NOP
001C6A  E00000     CP0 W0
001C6C  320003     BRA Z, .L67
1323:              						{
1324:              							/* The task waiting has a higher priority than this task. */
1325:              							queueYIELD_IF_USING_PREEMPTION();
001C6E  022DC4     CALL .Letext0, .LFE2, _vPortYield
001C70  000000     NOP
001C72  000000     NOP
1326:              						}
1327:              						else
1328:              						{
1329:              							mtCOVERAGE_TEST_MARKER();
1330:              						}
1331:              					}
1332:              					else
1333:              					{
1334:              						mtCOVERAGE_TEST_MARKER();
1335:              					}
1336:              				}
1337:              
1338:              				taskEXIT_CRITICAL();
001C74  022BC0     CALL vPortExitCritical
001C76  000000     NOP
1339:              				return pdPASS;
001C78  200010     MOV #0x1, W0
001C7A  370045     BRA .L68
1340:              			}
1341:              			else
1342:              			{
1343:              				if( xTicksToWait == ( TickType_t ) 0 )
001C7C  97B81F     MOV [W15-14], W0
001C7E  E00000     CP0 W0
001C80  3A0004     BRA NZ, .L69
1344:              				{
1345:              					/* The queue was empty and no block time is specified (or
1346:              					the block time has expired) so leave now. */
1347:              					taskEXIT_CRITICAL();
001C82  022BC0     CALL vPortExitCritical
001C84  000000     NOP
1348:              					traceQUEUE_RECEIVE_FAILED( pxQueue );
1349:              					return errQUEUE_EMPTY;
001C86  EB0000     CLR W0
001C88  37003E     BRA .L68
1350:              				}
1351:              				else if( xEntryTimeSet == pdFALSE )
001C8A  E0000A     CP0 W10
001C8C  3A0004     BRA NZ, .L70, .LBE7
1352:              				{
1353:              					/* The queue was empty and a block time was specified so
1354:              					configure the timeout structure. */
1355:              					vTaskSetTimeOutState( &xTimeOut );
001C8E  578072     SUB W15, #0x12, W0
001C90  0211DA     CALL vTaskSetTimeOutState
001C92  000000     NOP
1356:              					xEntryTimeSet = pdTRUE;
001C94  20001A     MOV #0x1, W10
1357:              				}
1358:              				else
1359:              				{
1360:              					/* Entry time was already set. */
1361:              					mtCOVERAGE_TEST_MARKER();
1362:              				}
1363:              			}
1364:              		}
1365:              		taskEXIT_CRITICAL();
001C96  022BC0     CALL vPortExitCritical
001C98  000000     NOP
1366:              
1367:              		/* Interrupts and other tasks can send to and receive from the queue
1368:              		now the critical section has been exited. */
1369:              
1370:              		vTaskSuspendAll();
001C9A  0210AA     CALL vTaskSuspendAll
001C9C  000000     NOP
1371:              		prvLockQueue( pxQueue );
001C9E  022BB0     CALL vPortEnterCritical
001CA0  000000     NOP
001CA2  906028     MOV.B [W8+34], W0
001CA4  404FE1     ADD.B W0, #0x1, [W15]
001CA6  3A0002     BRA NZ, .L71
001CA8  EB4000     CLR.B W0
001CAA  986420     MOV.B W0, [W8+34]
001CAC  906038     MOV.B [W8+35], W0
001CAE  404FE1     ADD.B W0, #0x1, [W15]
001CB0  3A0002     BRA NZ, .L72
001CB2  EB4000     CLR.B W0
001CB4  986430     MOV.B W0, [W8+35]
001CB6  022BC0     CALL vPortExitCritical
001CB8  000000     NOP
1372:              
1373:              		/* Update the timeout state to see if it has expired yet. */
1374:              		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
001CBA  5780EE     SUB W15, #0xE, W1
001CBC  578072     SUB W15, #0x12, W0
001CBE  0211E4     CALL xTaskCheckForTimeOut
001CC0  000000     NOP
001CC2  E00000     CP0 W0
001CC4  3A0017     BRA NZ, .L73
1375:              		{
1376:              			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
001CC6  780008     MOV W8, W0
001CC8  07FE52     RCALL _prvIsQueueEmpty, .LFE18, .LFB16
001CCA  E00000     CP0 W0
001CCC  32000E     BRA Z, .L74
1377:              			{
1378:              				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
1379:              
1380:              				#if ( configUSE_MUTEXES == 1 )
1381:              				{
1382:              					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
1383:              					{
1384:              						taskENTER_CRITICAL();
1385:              						{
1386:              							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
1387:              						}
1388:              						taskEXIT_CRITICAL();
1389:              					}
1390:              					else
1391:              					{
1392:              						mtCOVERAGE_TEST_MARKER();
1393:              					}
1394:              				}
1395:              				#endif
1396:              
1397:              				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
001C28  4405F2     ADD W8, #0x12, W11
001CCE  97B89F     MOV [W15-14], W1
001CD0  78000B     MOV W11, W0
001CD2  021852     CALL vTaskPlaceOnEventList
001CD4  000000     NOP
1398:              				prvUnlockQueue( pxQueue );
001CD6  780008     MOV W8, W0
001CD8  07FE57     RCALL _prvUnlockQueue, .LFE16, .LFB15
1399:              				if( xTaskResumeAll() == pdFALSE )
001CDA  021408     CALL xTaskResumeAll
001CDC  000000     NOP
001CDE  E00000     CP0 W0
001CE0  3AFFA4     BRA NZ, .L78
1400:              				{
1401:              					portYIELD_WITHIN_API();
001CE2  022DC4     CALL .Letext0, .LFE2, _vPortYield
001CE4  000000     NOP
001CE6  000000     NOP
001CE8  37FFA0     BRA .L78
1402:              				}
1403:              				else
1404:              				{
1405:              					mtCOVERAGE_TEST_MARKER();
1406:              				}
1407:              			}
1408:              			else
1409:              			{
1410:              				/* Try again. */
1411:              				prvUnlockQueue( pxQueue );
001CEA  780008     MOV W8, W0
001CEC  07FE4D     RCALL _prvUnlockQueue, .LFE16, .LFB15
1412:              				( void ) xTaskResumeAll();
001CEE  021408     CALL xTaskResumeAll
001CF0  000000     NOP
001CF2  37FF9B     BRA .L78
1413:              			}
1414:              		}
1415:              		else
1416:              		{
1417:              			prvUnlockQueue( pxQueue );
001CF4  780008     MOV W8, W0
001CF6  07FE48     RCALL _prvUnlockQueue, .LFE16, .LFB15
1418:              			( void ) xTaskResumeAll();
001CF8  021408     CALL xTaskResumeAll
001CFA  000000     NOP
1419:              
1420:              			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
001CFC  780008     MOV W8, W0
001CFE  07FE37     RCALL _prvIsQueueEmpty, .LFE18, .LFB16
001D00  E00000     CP0 W0
001D02  32FF93     BRA Z, .L78
1421:              			{
1422:              				traceQUEUE_RECEIVE_FAILED( pxQueue );
1423:              				return errQUEUE_EMPTY;
001D04  EB0000     CLR W0
1424:              			}
1425:              			else
1426:              			{
1427:              				mtCOVERAGE_TEST_MARKER();
1428:              			}
1429:              		}
1430:              	}
1431:              }
001D06  BE064F     MOV.D [--W15], W12
001D08  BE054F     MOV.D [--W15], W10
001D0A  BE044F     MOV.D [--W15], W8
001D0C  FA8000     ULNK
001D0E  060000     RETURN
1432:              /*-----------------------------------------------------------*/
1433:              
1434:              BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
1435:              {
001D10  BE9F88     MOV.D W8, [W15++]
001D12  BE9F8A     MOV.D W10, [W15++]
001D14  780582     MOV W2, W11
1436:              BaseType_t xReturn;
1437:              UBaseType_t uxSavedInterruptStatus;
1438:              Queue_t * const pxQueue = ( Queue_t * ) xQueue;
001D16  780400     MOV W0, W8
1439:              
1440:              	configASSERT( pxQueue );
1441:              	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
1442:              
1443:              	/* RTOS ports that support interrupt nesting have the concept of a maximum
1444:              	system call (or maximum API call) interrupt priority.  Interrupts that are
1445:              	above the maximum system call priority are kept permanently enabled, even
1446:              	when the RTOS kernel is in a critical section, but cannot make any calls to
1447:              	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
1448:              	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1449:              	failure if a FreeRTOS API function is called from an interrupt that has been
1450:              	assigned a priority above the configured maximum system call priority.
1451:              	Only FreeRTOS functions that end in FromISR can be called from interrupts
1452:              	that have been assigned a priority at or (logically) below the maximum
1453:              	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
1454:              	safe API to ensure interrupt entry is as fast and as simple as possible.
1455:              	More information (albeit Cortex-M specific) is provided on the following
1456:              	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1457:              	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1458:              
1459:              	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
1460:              	{
1461:              		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
001D18  900CE8     MOV [W8+28], W9
1462:              
1463:              		/* Cannot block in an ISR, so check there is data available. */
1464:              		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
001D1C  E00009     CP0 W9
001D1E  320019     BRA Z, .L80, .LBE8, .LBE9
1465:              		{
1466:              			const int8_t cRxLock = pxQueue->cRxLock;
001D20  906528     MOV.B [W8+34], W10
1467:              
1468:              			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );
1469:              
1470:              			prvCopyDataFromQueue( pxQueue, pvBuffer );
001D22  780008     MOV W8, W0
001D24  07FE03     RCALL _prvCopyDataFromQueue, .LFE13, .LFB14
1471:              			pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
001D26  E90489     DEC W9, W9
001D28  980C69     MOV W9, [W8+28]
1472:              
1473:              			/* If the queue is locked the event list will not be modified.
1474:              			Instead update the lock count so the task that unlocks the queue
1475:              			will know that an ISR has removed data while the queue was
1476:              			locked. */
1477:              			if( cRxLock == queueUNLOCKED )
001D2A  454FE1     ADD.B W10, #0x1, [W15]
001D2C  3A000F     BRA NZ, .L81
1478:              			{
1479:              				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
001D2E  9000C8     MOV [W8+8], W1
001D32  E00001     CP0 W1
001D34  32000E     BRA Z, .L80, .LBE8, .LBE9
1480:              				{
1481:              					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
001D36  440068     ADD W8, #0x8, W0
001D38  021152     CALL xTaskRemoveFromEventList
001D3A  000000     NOP
001D3C  780080     MOV W0, W1
001D40  E00001     CP0 W1
001D42  320007     BRA Z, .L80, .LBE8, .LBE9
1482:              					{
1483:              						/* The task waiting has a higher priority than us so
1484:              						force a context switch. */
1485:              						if( pxHigherPriorityTaskWoken != NULL )
001D44  E0000B     CP0 W11
001D46  320005     BRA Z, .L80, .LBE8, .LBE9
1486:              						{
1487:              							*pxHigherPriorityTaskWoken = pdTRUE;
001D48  780D80     MOV W0, [W11]
001D4A  370003     BRA .L80, .LBE8, .LBE9
1488:              						}
1489:              						else
1490:              						{
1491:              							mtCOVERAGE_TEST_MARKER();
1492:              						}
1493:              					}
1494:              					else
1495:              					{
1496:              						mtCOVERAGE_TEST_MARKER();
1497:              					}
1498:              				}
1499:              				else
1500:              				{
1501:              					mtCOVERAGE_TEST_MARKER();
1502:              				}
1503:              			}
1504:              			else
1505:              			{
1506:              				/* Increment the lock count so the task that unlocks the queue
1507:              				knows that data was removed while it was locked. */
1508:              				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
001D4C  E8450A     INC.B W10, W10
001D4E  98642A     MOV.B W10, [W8+34]
1509:              			}
1510:              
1511:              			xReturn = pdPASS;
001D30  200010     MOV #0x1, W0
001D3E  200010     MOV #0x1, W0
001D50  200010     MOV #0x1, W0
1512:              		}
1513:              		else
1514:              		{
1515:              			xReturn = pdFAIL;
001D1A  EB0000     CLR W0
1516:              			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
1517:              		}
1518:              	}
1519:              	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1520:              
1521:              	return xReturn;
1522:              }
001D52  BE054F     MOV.D [--W15], W10
001D54  BE044F     MOV.D [--W15], W8
001D56  060000     RETURN
1523:              /*-----------------------------------------------------------*/
1524:              
1525:              BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
1526:              {
001D58  BE9F88     MOV.D W8, [W15++]
1527:              BaseType_t xReturn;
1528:              UBaseType_t uxSavedInterruptStatus;
1529:              int8_t *pcOriginalReadPosition;
1530:              Queue_t * const pxQueue = ( Queue_t * ) xQueue;
001D5A  780400     MOV W0, W8
1531:              
1532:              	configASSERT( pxQueue );
1533:              	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
1534:              	configASSERT( pxQueue->uxItemSize != 0 ); /* Can't peek a semaphore. */
1535:              
1536:              	/* RTOS ports that support interrupt nesting have the concept of a maximum
1537:              	system call (or maximum API call) interrupt priority.  Interrupts that are
1538:              	above the maximum system call priority are kept permanently enabled, even
1539:              	when the RTOS kernel is in a critical section, but cannot make any calls to
1540:              	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
1541:              	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1542:              	failure if a FreeRTOS API function is called from an interrupt that has been
1543:              	assigned a priority above the configured maximum system call priority.
1544:              	Only FreeRTOS functions that end in FromISR can be called from interrupts
1545:              	that have been assigned a priority at or (logically) below the maximum
1546:              	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
1547:              	safe API to ensure interrupt entry is as fast and as simple as possible.
1548:              	More information (albeit Cortex-M specific) is provided on the following
1549:              	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1550:              	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1551:              
1552:              	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
1553:              	{
1554:              		/* Cannot block in an ISR, so check there is data available. */
1555:              		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
001D5C  900968     MOV [W8+28], W2
001D60  E00002     CP0 W2
001D62  320005     BRA Z, .L87
1556:              		{
1557:              			traceQUEUE_PEEK_FROM_ISR( pxQueue );
1558:              
1559:              			/* Remember the read position so it can be reset as nothing is
1560:              			actually being removed from the queue. */
1561:              			pcOriginalReadPosition = pxQueue->u.pcReadFrom;
001D64  9004B8     MOV [W8+6], W9
1562:              			prvCopyDataFromQueue( pxQueue, pvBuffer );
001D66  780008     MOV W8, W0
001D68  07FDE1     RCALL _prvCopyDataFromQueue, .LFE13, .LFB14
1563:              			pxQueue->u.pcReadFrom = pcOriginalReadPosition;
001D6A  980439     MOV W9, [W8+6]
1564:              
1565:              			xReturn = pdPASS;
001D6C  200010     MOV #0x1, W0
1566:              		}
1567:              		else
1568:              		{
1569:              			xReturn = pdFAIL;
001D5E  EB0000     CLR W0
1570:              			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
1571:              		}
1572:              	}
1573:              	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1574:              
1575:              	return xReturn;
1576:              }
001D6E  BE044F     MOV.D [--W15], W8
001D70  060000     RETURN
1577:              /*-----------------------------------------------------------*/
1578:              
1579:              UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
1580:              {
001D72  781F88     MOV W8, [W15++]
001D74  780400     MOV W0, W8
1581:              UBaseType_t uxReturn;
1582:              
1583:              	configASSERT( xQueue );
1584:              
1585:              	taskENTER_CRITICAL();
001D76  022BB0     CALL vPortEnterCritical
001D78  000000     NOP
1586:              	{
1587:              		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
001D7A  900C68     MOV [W8+28], W8
1588:              	}
1589:              	taskEXIT_CRITICAL();
001D7C  022BC0     CALL vPortExitCritical
001D7E  000000     NOP
1590:              
1591:              	return uxReturn;
1592:              } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
001D80  780008     MOV W8, W0
001D82  78044F     MOV [--W15], W8
001D84  060000     RETURN
1593:              /*-----------------------------------------------------------*/
1594:              
1595:              UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
1596:              {
001D86  BE9F88     MOV.D W8, [W15++]
001D88  780480     MOV W0, W9
1597:              UBaseType_t uxReturn;
1598:              Queue_t *pxQueue;
1599:              
1600:              	pxQueue = ( Queue_t * ) xQueue;
1601:              	configASSERT( pxQueue );
1602:              
1603:              	taskENTER_CRITICAL();
001D8A  022BB0     CALL vPortEnterCritical
001D8C  000000     NOP
1604:              	{
1605:              		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
001D8E  900869     MOV [W9+28], W0
001D90  900C79     MOV [W9+30], W8
001D92  540400     SUB W8, W0, W8
1606:              	}
1607:              	taskEXIT_CRITICAL();
001D94  022BC0     CALL vPortExitCritical
001D96  000000     NOP
1608:              
1609:              	return uxReturn;
1610:              } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
001D98  780008     MOV W8, W0
001D9A  BE044F     MOV.D [--W15], W8
001D9C  060000     RETURN
1611:              /*-----------------------------------------------------------*/
1612:              
1613:              UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
1614:              {
1615:              UBaseType_t uxReturn;
1616:              
1617:              	configASSERT( xQueue );
1618:              
1619:              	uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
001D9E  900860     MOV [W0+28], W0
1620:              
1621:              	return uxReturn;
1622:              } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
001DA0  060000     RETURN
1623:              /*-----------------------------------------------------------*/
1624:              
1625:              void vQueueDelete( QueueHandle_t xQueue )
1626:              {
1627:              Queue_t * const pxQueue = ( Queue_t * ) xQueue;
1628:              
1629:              	configASSERT( pxQueue );
1630:              	traceQUEUE_DELETE( pxQueue );
1631:              
1632:              	#if ( configQUEUE_REGISTRY_SIZE > 0 )
1633:              	{
1634:              		vQueueUnregisterQueue( pxQueue );
1635:              	}
1636:              	#endif
1637:              
1638:              	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
1639:              	{
1640:              		/* The queue can only have been allocated dynamically - free it
1641:              		again. */
1642:              		vPortFree( pxQueue );
001DA2  022E52     CALL vPortFree
001DA4  000000     NOP
1643:              	}
1644:              	#elif( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
1645:              	{
1646:              		/* The queue could have been allocated statically or dynamically, so
1647:              		check before attempting to free the memory. */
1648:              		if( pxQueue->ucStaticallyAllocated == ( uint8_t ) pdFALSE )
1649:              		{
1650:              			vPortFree( pxQueue );
1651:              		}
1652:              		else
1653:              		{
1654:              			mtCOVERAGE_TEST_MARKER();
1655:              		}
1656:              	}
1657:              	#else
1658:              	{
1659:              		/* The queue must have been statically allocated, so is not going to be
1660:              		deleted.  Avoid compiler warnings about the unused parameter. */
1661:              		( void ) pxQueue;
1662:              	}
1663:              	#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
1664:              }
001DA6  060000     RETURN
1665:              /*-----------------------------------------------------------*/
1666:              
1667:              #if ( configUSE_TRACE_FACILITY == 1 )
1668:              
1669:              	UBaseType_t uxQueueGetQueueNumber( QueueHandle_t xQueue )
1670:              	{
1671:              		return ( ( Queue_t * ) xQueue )->uxQueueNumber;
1672:              	}
1673:              
1674:              #endif /* configUSE_TRACE_FACILITY */
1675:              /*-----------------------------------------------------------*/
1676:              
1677:              #if ( configUSE_TRACE_FACILITY == 1 )
1678:              
1679:              	void vQueueSetQueueNumber( QueueHandle_t xQueue, UBaseType_t uxQueueNumber )
1680:              	{
1681:              		( ( Queue_t * ) xQueue )->uxQueueNumber = uxQueueNumber;
1682:              	}
1683:              
1684:              #endif /* configUSE_TRACE_FACILITY */
1685:              /*-----------------------------------------------------------*/
1686:              
1687:              #if ( configUSE_TRACE_FACILITY == 1 )
1688:              
1689:              	uint8_t ucQueueGetQueueType( QueueHandle_t xQueue )
1690:              	{
1691:              		return ( ( Queue_t * ) xQueue )->ucQueueType;
1692:              	}
1693:              
1694:              #endif /* configUSE_TRACE_FACILITY */
1695:              /*-----------------------------------------------------------*/
1696:              
1697:              static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
1698:              {
0018CE  BE9F88     MOV.D W8, [W15++]
0018D0  781F8A     MOV W10, [W15++]
0018D2  780400     MOV W0, W8
0018D4  780502     MOV W2, W10
1699:              BaseType_t xReturn = pdFALSE;
1700:              UBaseType_t uxMessagesWaiting;
1701:              
1702:              	/* This function is called from a critical section. */
1703:              
1704:              	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
0018D6  900CE8     MOV [W8+28], W9
1705:              
1706:              	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
0018D8  901108     MOV [W8+32], W2
0018DA  E00002     CP0 W2
0018DC  320021     BRA Z, .L2
1707:              	{
1708:              		#if ( configUSE_MUTEXES == 1 )
1709:              		{
1710:              			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
1711:              			{
1712:              				/* The mutex is no longer being held. */
1713:              				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
1714:              				pxQueue->pxMutexHolder = NULL;
1715:              			}
1716:              			else
1717:              			{
1718:              				mtCOVERAGE_TEST_MARKER();
1719:              			}
1720:              		}
1721:              		#endif /* configUSE_MUTEXES */
1722:              	}
1723:              	else if( xPosition == queueSEND_TO_BACK )
0018DE  E0000A     CP0 W10
0018E0  3A000D     BRA NZ, .L3
1724:              	{
1725:              		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
0018E2  900028     MOV [W8+4], W0
0018E4  020D1C     CALL _memcpy
0018E6  000000     NOP
1726:              		pxQueue->pcWriteTo += pxQueue->uxItemSize;
0018E8  9000A8     MOV [W8+4], W1
0018EA  901008     MOV [W8+32], W0
0018EC  408000     ADD W1, W0, W0
0018EE  980420     MOV W0, [W8+4]
1727:              		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
0018F0  900098     MOV [W8+2], W1
0018F2  500F81     SUB W0, W1, [W15]
0018F4  390015     BRA NC, .L2
1728:              		{
1729:              			pxQueue->pcWriteTo = pxQueue->pcHead;
0018F6  780018     MOV [W8], W0
0018F8  980420     MOV W0, [W8+4]
0018FA  370012     BRA .L2
1730:              		}
1731:              		else
1732:              		{
1733:              			mtCOVERAGE_TEST_MARKER();
1734:              		}
1735:              	}
1736:              	else
1737:              	{
1738:              		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
0018FC  900038     MOV [W8+6], W0
0018FE  020D1C     CALL _memcpy
001900  000000     NOP
1739:              		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
001902  901088     MOV [W8+32], W1
001904  EA0081     NEG W1, W1
001906  900038     MOV [W8+6], W0
001908  400001     ADD W0, W1, W0
00190A  980430     MOV W0, [W8+6]
1740:              		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
00190C  500F98     SUB W0, [W8], [W15]
00190E  310003     BRA C, .L4
1741:              		{
1742:              			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
001910  900018     MOV [W8+2], W0
001912  400081     ADD W0, W1, W1
001914  980431     MOV W1, [W8+6]
1743:              		}
1744:              		else
1745:              		{
1746:              			mtCOVERAGE_TEST_MARKER();
1747:              		}
1748:              
1749:              		if( xPosition == queueOVERWRITE )
001916  550FE2     SUB W10, #0x2, [W15]
001918  3A0003     BRA NZ, .L2
1750:              		{
1751:              			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
00191A  E00009     CP0 W9
00191C  320001     BRA Z, .L2
1752:              			{
1753:              				/* An item is not being added but overwritten, so subtract
1754:              				one from the recorded number of items in the queue so when
1755:              				one is added again below the number of recorded items remains
1756:              				correct. */
1757:              				--uxMessagesWaiting;
00191E  E90489     DEC W9, W9
1758:              			}
1759:              			else
1760:              			{
1761:              				mtCOVERAGE_TEST_MARKER();
1762:              			}
1763:              		}
1764:              		else
1765:              		{
1766:              			mtCOVERAGE_TEST_MARKER();
1767:              		}
1768:              	}
1769:              
1770:              	pxQueue->uxMessagesWaiting = uxMessagesWaiting + 1;
001920  E80489     INC W9, W9
001922  980C69     MOV W9, [W8+28]
1771:              
1772:              	return xReturn;
1773:              }
001924  EB0000     CLR W0
001926  78054F     MOV [--W15], W10
001928  BE044F     MOV.D [--W15], W8
00192A  060000     RETURN
1774:              /*-----------------------------------------------------------*/
1775:              
1776:              static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
1777:              {
00192C  780181     MOV W1, W3
1778:              	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
00192E  901100     MOV [W0+32], W2
001930  E00002     CP0 W2
001932  32000C     BRA Z, .L5
1779:              	{
1780:              		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
001934  9000B0     MOV [W0+6], W1
001936  408082     ADD W1, W2, W1
001938  980031     MOV W1, [W0+6]
1781:              		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
00193A  900210     MOV [W0+2], W4
00193C  508F84     SUB W1, W4, [W15]
00193E  390002     BRA NC, .L7
1782:              		{
1783:              			pxQueue->u.pcReadFrom = pxQueue->pcHead;
001940  780090     MOV [W0], W1
001942  980031     MOV W1, [W0+6]
1784:              		}
1785:              		else
1786:              		{
1787:              			mtCOVERAGE_TEST_MARKER();
1788:              		}
1789:              		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
001944  9000B0     MOV [W0+6], W1
001946  780003     MOV W3, W0
001948  020D1C     CALL _memcpy
00194A  000000     NOP
1790:              	}
1791:              }
00194C  060000     RETURN
1792:              /*-----------------------------------------------------------*/
1793:              
1794:              static void prvUnlockQueue( Queue_t * const pxQueue )
1795:              {
001988  BE9F88     MOV.D W8, [W15++]
00198A  781F8A     MOV W10, [W15++]
00198C  780400     MOV W0, W8
1796:              	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED. */
1797:              
1798:              	/* The lock counts contains the number of extra data items placed or
1799:              	removed from the queue while the queue was locked.  When a queue is
1800:              	locked items can be added or removed, but the event lists cannot be
1801:              	updated. */
1802:              	taskENTER_CRITICAL();
00198E  022BB0     CALL vPortEnterCritical
001990  000000     NOP
1803:              	{
1804:              		int8_t cTxLock = pxQueue->cTxLock;
001992  9064B8     MOV.B [W8+35], W9
1805:              
1806:              		/* See if data was added to the queue while it was locked. */
1807:              		while( cTxLock > queueLOCKED_UNMODIFIED )
001994  E00409     CP0.B W9
001996  340013     BRA LE, .L11
0019BA  A94042     BCLR SR, #2
0019BC  3CFFF1     BRA GT, .L14
1808:              		{
1809:              			/* Data was posted while the queue was locked.  Are any tasks
1810:              			blocked waiting for data to become available? */
1811:              			#if ( configUSE_QUEUE_SETS == 1 )
1812:              			{
1813:              				if( pxQueue->pxQueueSetContainer != NULL )
1814:              				{
1815:              					if( prvNotifyQueueSetContainer( pxQueue, queueSEND_TO_BACK ) != pdFALSE )
1816:              					{
1817:              						/* The queue is a member of a queue set, and posting to
1818:              						the queue set caused a higher priority task to unblock.
1819:              						A context switch is required. */
1820:              						vTaskMissedYield();
1821:              					}
1822:              					else
1823:              					{
1824:              						mtCOVERAGE_TEST_MARKER();
1825:              					}
1826:              				}
1827:              				else
1828:              				{
1829:              					/* Tasks that are removed from the event list will get
1830:              					added to the pending ready list as the scheduler is still
1831:              					suspended. */
1832:              					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1833:              					{
1834:              						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
1835:              						{
1836:              							/* The task waiting has a higher priority so record that a
1837:              							context	switch is required. */
1838:              							vTaskMissedYield();
1839:              						}
1840:              						else
1841:              						{
1842:              							mtCOVERAGE_TEST_MARKER();
1843:              						}
1844:              					}
1845:              					else
1846:              					{
1847:              						break;
1848:              					}
1849:              				}
1850:              			}
1851:              			#else /* configUSE_QUEUE_SETS */
1852:              			{
1853:              				/* Tasks that are removed from the event list will get added to
1854:              				the pending ready list as the scheduler is still suspended. */
1855:              				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
001998  900818     MOV [W8+18], W0
00199A  E00000     CP0 W0
00199C  3A0005     BRA NZ, .L12
00199E  37000F     BRA .L11
0019A0  900818     MOV [W8+18], W0
0019A2  E00000     CP0 W0
0019A4  3A0002     BRA NZ, .L19
0019A6  37000B     BRA .L11
1856:              				{
1857:              					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
0019A8  440572     ADD W8, #0x12, W10
0019AA  78000A     MOV W10, W0
0019AC  021152     CALL xTaskRemoveFromEventList
0019AE  000000     NOP
0019B0  E00000     CP0 W0
0019B2  320002     BRA Z, .L13
1858:              					{
1859:              						/* The task waiting has a higher priority so record that
1860:              						a context switch is required. */
1861:              						vTaskMissedYield();
0019B4  02122A     CALL vTaskMissedYield
0019B6  000000     NOP
1862:              					}
1863:              					else
1864:              					{
1865:              						mtCOVERAGE_TEST_MARKER();
1866:              					}
1867:              				}
1868:              				else
1869:              				{
1870:              					break;
1871:              				}
1872:              			}
1873:              			#endif /* configUSE_QUEUE_SETS */
1874:              
1875:              			--cTxLock;
0019B8  E94489     DEC.B W9, W9
1876:              		}
1877:              
1878:              		pxQueue->cTxLock = queueUNLOCKED;
0019BE  EBC000     SETM.B W0
0019C0  986430     MOV.B W0, [W8+35]
1879:              	}
1880:              	taskEXIT_CRITICAL();
0019C2  022BC0     CALL vPortExitCritical
0019C4  000000     NOP
1881:              
1882:              	/* Do the same for the Rx lock. */
1883:              	taskENTER_CRITICAL();
0019C6  022BB0     CALL vPortEnterCritical
0019C8  000000     NOP
1884:              	{
1885:              		int8_t cRxLock = pxQueue->cRxLock;
0019CA  9064A8     MOV.B [W8+34], W9
1886:              
1887:              		while( cRxLock > queueLOCKED_UNMODIFIED )
0019CC  E00409     CP0.B W9
0019CE  340013     BRA LE, .L15
0019F2  A94042     BCLR SR, #2
0019F4  3CFFF1     BRA GT, .L18
1888:              		{
1889:              			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
0019D0  900048     MOV [W8+8], W0
0019D2  E00000     CP0 W0
0019D4  3A0005     BRA NZ, .L16
0019D6  37000F     BRA .L15
0019D8  900048     MOV [W8+8], W0
0019DA  E00000     CP0 W0
0019DC  3A0002     BRA NZ, .L20
0019DE  37000B     BRA .L15
1890:              			{
1891:              				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
0019E0  440568     ADD W8, #0x8, W10
0019E2  78000A     MOV W10, W0
0019E4  021152     CALL xTaskRemoveFromEventList
0019E6  000000     NOP
0019E8  E00000     CP0 W0
0019EA  320002     BRA Z, .L17
1892:              				{
1893:              					vTaskMissedYield();
0019EC  02122A     CALL vTaskMissedYield
0019EE  000000     NOP
1894:              				}
1895:              				else
1896:              				{
1897:              					mtCOVERAGE_TEST_MARKER();
1898:              				}
1899:              
1900:              				--cRxLock;
0019F0  E94489     DEC.B W9, W9
1901:              			}
1902:              			else
1903:              			{
1904:              				break;
1905:              			}
1906:              		}
1907:              
1908:              		pxQueue->cRxLock = queueUNLOCKED;
0019F6  EBC000     SETM.B W0
0019F8  986420     MOV.B W0, [W8+34]
1909:              	}
1910:              	taskEXIT_CRITICAL();
0019FA  022BC0     CALL vPortExitCritical
0019FC  000000     NOP
1911:              }
0019FE  78054F     MOV [--W15], W10
001A00  BE044F     MOV.D [--W15], W8
001A02  060000     RETURN
1912:              /*-----------------------------------------------------------*/
1913:              
1914:              static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
1915:              {
00196E  781F88     MOV W8, [W15++]
001970  780400     MOV W0, W8
1916:              BaseType_t xReturn;
1917:              
1918:              	taskENTER_CRITICAL();
001972  022BB0     CALL vPortEnterCritical
001974  000000     NOP
1919:              	{
1920:              		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
001976  900C68     MOV [W8+28], W8
1921:              		{
1922:              			xReturn = pdTRUE;
00197C  A7F008     BTSC W8, #15
00197E  EA0408     NEG W8, W8
001980  E90008     DEC W8, W0
001982  DE004F     LSR W0, #15, W0
1923:              		}
1924:              		else
1925:              		{
1926:              			xReturn = pdFALSE;
1927:              		}
1928:              	}
1929:              	taskEXIT_CRITICAL();
001978  022BC0     CALL vPortExitCritical
00197A  000000     NOP
1930:              
1931:              	return xReturn;
1932:              }
001984  78044F     MOV [--W15], W8
001986  060000     RETURN
1933:              /*-----------------------------------------------------------*/
1934:              
1935:              BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
1936:              {
1937:              BaseType_t xReturn;
1938:              
1939:              	configASSERT( xQueue );
1940:              	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( UBaseType_t ) 0 )
001DA8  900860     MOV [W0+28], W0
1941:              	{
1942:              		xReturn = pdTRUE;
001DAA  A7F000     BTSC W0, #15
001DAC  EA0000     NEG W0, W0
001DAE  E90000     DEC W0, W0
001DB0  DE004F     LSR W0, #15, W0
1943:              	}
1944:              	else
1945:              	{
1946:              		xReturn = pdFALSE;
1947:              	}
1948:              
1949:              	return xReturn;
1950:              } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
001DB2  060000     RETURN
1951:              /*-----------------------------------------------------------*/
1952:              
1953:              static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
1954:              {
00194E  781F88     MOV W8, [W15++]
001950  780400     MOV W0, W8
1955:              BaseType_t xReturn;
1956:              
1957:              	taskENTER_CRITICAL();
001952  022BB0     CALL vPortEnterCritical
001954  000000     NOP
1958:              	{
1959:              		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
001956  9008E8     MOV [W8+28], W1
1960:              		{
1961:              			xReturn = pdTRUE;
001958  900878     MOV [W8+30], W0
00195A  688400     XOR W1, W0, W8
00195C  A7F008     BTSC W8, #15
00195E  EA0408     NEG W8, W8
001960  E90408     DEC W8, W8
001962  DE444F     LSR W8, #15, W8
1962:              		}
1963:              		else
1964:              		{
1965:              			xReturn = pdFALSE;
1966:              		}
1967:              	}
1968:              	taskEXIT_CRITICAL();
001964  022BC0     CALL vPortExitCritical
001966  000000     NOP
1969:              
1970:              	return xReturn;
1971:              }
001968  780008     MOV W8, W0
00196A  78044F     MOV [--W15], W8
00196C  060000     RETURN
1972:              /*-----------------------------------------------------------*/
1973:              
1974:              BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
1975:              {
1976:              BaseType_t xReturn;
1977:              
1978:              	configASSERT( xQueue );
1979:              	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( ( Queue_t * ) xQueue )->uxLength )
001DB4  9008E0     MOV [W0+28], W1
1980:              	{
1981:              		xReturn = pdTRUE;
001DB6  900870     MOV [W0+30], W0
001DB8  688000     XOR W1, W0, W0
001DBA  A7F000     BTSC W0, #15
001DBC  EA0000     NEG W0, W0
001DBE  E90000     DEC W0, W0
001DC0  DE004F     LSR W0, #15, W0
1982:              	}
1983:              	else
1984:              	{
1985:              		xReturn = pdFALSE;
1986:              	}
1987:              
1988:              	return xReturn;
1989:              } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
001DC2  060000     RETURN
1990:              /*-----------------------------------------------------------*/
1991:              
1992:              #if ( configUSE_CO_ROUTINES == 1 )
1993:              
1994:              	BaseType_t xQueueCRSend( QueueHandle_t xQueue, const void *pvItemToQueue, TickType_t xTicksToWait )
1995:              	{
001DC4  BE9F88     MOV.D W8, [W15++]
001DC6  781F8A     MOV W10, [W15++]
001DC8  780501     MOV W1, W10
001DCA  780482     MOV W2, W9
1996:              	BaseType_t xReturn;
1997:              	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
001DCC  780400     MOV W0, W8
1998:              
1999:              		/* If the queue is already full we may have to block.  A critical section
2000:              		is required to prevent an interrupt removing something from the queue
2001:              		between the check to see if the queue is full and blocking on the queue. */
2002:              		portDISABLE_INTERRUPTS();
001DCE  2FF1F0     MOV #0xFF1F, W0
001DD0  B60042     AND SR, WREG
001DD2  A05000     BSET W0, #5
001DD4  880210     MOV W0, SR
001DD6  000000     NOP
001DD8  000000     NOP
2003:              		{
2004:              			if( prvIsQueueFull( pxQueue ) != pdFALSE )
001DDA  780008     MOV W8, W0
001DDC  07FDB8     RCALL _prvIsQueueFull, .LFE14, .LFB18
001DDE  E00000     CP0 W0
001DE0  320010     BRA Z, .L96
2005:              			{
2006:              				/* The queue is full - do we want to block or just leave without
2007:              				posting? */
2008:              				if( xTicksToWait > ( TickType_t ) 0 )
001DE2  E00009     CP0 W9
001DE4  320009     BRA Z, .L97
2009:              				{
2010:              					/* As this is called from a coroutine we cannot block directly, but
2011:              					return indicating that we need to block. */
2012:              					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToSend ) );
001DE6  4400E8     ADD W8, #0x8, W1
001DE8  780009     MOV W9, W0
001DEA  0222B4     CALL vCoRoutineAddToDelayedList
001DEC  000000     NOP
2013:              					portENABLE_INTERRUPTS();
001DEE  2FF1F0     MOV #0xFF1F, W0
001DF0  B62042     AND SR
001DF2  000000     NOP
2014:              					return errQUEUE_BLOCKED;
001DF4  2FFFC0     MOV #0xFFFC, W0
001DF6  370026     BRA .L98
2015:              				}
2016:              				else
2017:              				{
2018:              					portENABLE_INTERRUPTS();
001DF8  2FF1F0     MOV #0xFF1F, W0
001DFA  B62042     AND SR
001DFC  000000     NOP
2019:              					return errQUEUE_FULL;
001DFE  EB0000     CLR W0
001E00  370021     BRA .L98
2020:              				}
2021:              			}
2022:              		}
2023:              		portENABLE_INTERRUPTS();
001E02  2FF1F0     MOV #0xFF1F, W0
001E04  B62042     AND SR
001E06  000000     NOP
2024:              
2025:              		portDISABLE_INTERRUPTS();
001E08  B60042     AND SR, WREG
001E0A  A05000     BSET W0, #5
001E0C  880210     MOV W0, SR
001E0E  000000     NOP
001E10  000000     NOP
2026:              		{
2027:              			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
001E12  900968     MOV [W8+28], W2
001E14  9008F8     MOV [W8+30], W1
001E18  510F81     SUB W2, W1, [W15]
001E1A  310010     BRA C, .L99
2028:              			{
2029:              				/* There is room in the queue, copy the data into the queue. */
2030:              				prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
001E1C  EB0100     CLR W2
001E1E  78008A     MOV W10, W1
001E20  780008     MOV W8, W0
001E22  07FD55     RCALL .Letext0, .LFE3, _prvCopyDataToQueue, .Ltext0, .LFB13
2031:              				xReturn = pdPASS;
001E26  200010     MOV #0x1, W0
001E3A  200010     MOV #0x1, W0
2032:              
2033:              				/* Were any co-routines waiting for data to become available? */
2034:              				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
001E24  900898     MOV [W8+18], W1
001E28  E00001     CP0 W1
001E2A  320008     BRA Z, .L99
2035:              				{
2036:              					/* In this instance the co-routine could be placed directly
2037:              					into the ready list as we are within a critical section.
2038:              					Instead the same pending ready list mechanism is used as if
2039:              					the event were caused from within an interrupt. */
2040:              					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
001E2C  440072     ADD W8, #0x12, W0
001E2E  0224BE     CALL xCoRoutineRemoveFromEventList
001E30  000000     NOP
001E32  780080     MOV W0, W1
001E36  E00001     CP0 W1
001E38  3A0001     BRA NZ, .L99
2041:              					{
2042:              						/* The co-routine waiting has a higher priority so record
2043:              						that a yield might be appropriate. */
2044:              						xReturn = errQUEUE_YIELD;
001E34  2FFFB0     MOV #0xFFFB, W0
2045:              					}
2046:              					else
2047:              					{
2048:              						mtCOVERAGE_TEST_MARKER();
2049:              					}
2050:              				}
2051:              				else
2052:              				{
2053:              					mtCOVERAGE_TEST_MARKER();
2054:              				}
2055:              			}
2056:              			else
2057:              			{
2058:              				xReturn = errQUEUE_FULL;
001E16  EB0000     CLR W0
2059:              			}
2060:              		}
2061:              		portENABLE_INTERRUPTS();
001E3C  2FF1F1     MOV #0xFF1F, W1
001E3E  200422     MOV #0x42, W2
001E40  608912     AND W1, [W2], [W2]
001E42  000000     NOP
2062:              
2063:              		return xReturn;
2064:              	}
001E44  78054F     MOV [--W15], W10
001E46  BE044F     MOV.D [--W15], W8
001E48  060000     RETURN
2065:              
2066:              #endif /* configUSE_CO_ROUTINES */
2067:              /*-----------------------------------------------------------*/
2068:              
2069:              #if ( configUSE_CO_ROUTINES == 1 )
2070:              
2071:              	BaseType_t xQueueCRReceive( QueueHandle_t xQueue, void *pvBuffer, TickType_t xTicksToWait )
2072:              	{
001E4A  781F88     MOV W8, [W15++]
001E4C  780181     MOV W1, W3
2073:              	BaseType_t xReturn;
2074:              	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
001E4E  780400     MOV W0, W8
2075:              
2076:              		/* If the queue is already empty we may have to block.  A critical section
2077:              		is required to prevent an interrupt adding something to the queue
2078:              		between the check to see if the queue is empty and blocking on the queue. */
2079:              		portDISABLE_INTERRUPTS();
001E50  2FF1F0     MOV #0xFF1F, W0
001E52  B60042     AND SR, WREG
001E54  A05000     BSET W0, #5
001E56  880210     MOV W0, SR
001E58  000000     NOP
001E5A  000000     NOP
2080:              		{
2081:              			if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
001E5C  900868     MOV [W8+28], W0
001E5E  E00000     CP0 W0
001E60  3A0010     BRA NZ, .L104
2082:              			{
2083:              				/* There are no messages in the queue, do we want to block or just
2084:              				leave with nothing? */
2085:              				if( xTicksToWait > ( TickType_t ) 0 )
001E62  E00002     CP0 W2
001E64  320009     BRA Z, .L105
2086:              				{
2087:              					/* As this is a co-routine we cannot block directly, but return
2088:              					indicating that we need to block. */
2089:              					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToReceive ) );
001E66  4400F2     ADD W8, #0x12, W1
001E68  780002     MOV W2, W0
001E6A  0222B4     CALL vCoRoutineAddToDelayedList
001E6C  000000     NOP
2090:              					portENABLE_INTERRUPTS();
001E6E  2FF1F0     MOV #0xFF1F, W0
001E70  B62042     AND SR
001E72  000000     NOP
2091:              					return errQUEUE_BLOCKED;
001E74  2FFFC0     MOV #0xFFFC, W0
001E76  370031     BRA .L106
2092:              				}
2093:              				else
2094:              				{
2095:              					portENABLE_INTERRUPTS();
001E78  2FF1F0     MOV #0xFF1F, W0
001E7A  B62042     AND SR
001E7C  000000     NOP
2096:              					return errQUEUE_FULL;
001E7E  EB0000     CLR W0
001E80  37002C     BRA .L106
2097:              				}
2098:              			}
2099:              			else
2100:              			{
2101:              				mtCOVERAGE_TEST_MARKER();
2102:              			}
2103:              		}
2104:              		portENABLE_INTERRUPTS();
001E82  2FF1F0     MOV #0xFF1F, W0
001E84  B62042     AND SR
001E86  000000     NOP
2105:              
2106:              		portDISABLE_INTERRUPTS();
001E88  B60042     AND SR, WREG
001E8A  A05000     BSET W0, #5
001E8C  880210     MOV W0, SR
001E8E  000000     NOP
001E90  000000     NOP
2107:              		{
2108:              			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
001E92  9008E8     MOV [W8+28], W1
001E96  E00001     CP0 W1
001E98  32001C     BRA Z, .L107
2109:              			{
2110:              				/* Data is available from the queue. */
2111:              				pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
001E9A  901108     MOV [W8+32], W2
001E9C  900038     MOV [W8+6], W0
001E9E  400002     ADD W0, W2, W0
001EA0  980430     MOV W0, [W8+6]
2112:              				if( pxQueue->u.pcReadFrom >= pxQueue->pcTail )
001EA2  900098     MOV [W8+2], W1
001EA4  500F81     SUB W0, W1, [W15]
001EA6  390002     BRA NC, .L108
2113:              				{
2114:              					pxQueue->u.pcReadFrom = pxQueue->pcHead;
001EA8  780018     MOV [W8], W0
001EAA  980430     MOV W0, [W8+6]
2115:              				}
2116:              				else
2117:              				{
2118:              					mtCOVERAGE_TEST_MARKER();
2119:              				}
2120:              				--( pxQueue->uxMessagesWaiting );
001EAC  900868     MOV [W8+28], W0
001EAE  E90000     DEC W0, W0
001EB0  980C60     MOV W0, [W8+28]
2121:              				( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
001EB2  9000B8     MOV [W8+6], W1
001EB4  780003     MOV W3, W0
001EB6  020D1C     CALL _memcpy
001EB8  000000     NOP
2122:              
2123:              				xReturn = pdPASS;
001EBC  200010     MOV #0x1, W0
001ED0  200010     MOV #0x1, W0
2124:              
2125:              				/* Were any co-routines waiting for space to become available? */
2126:              				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
001EBA  9000C8     MOV [W8+8], W1
001EBE  E00001     CP0 W1
001EC0  320008     BRA Z, .L107
2127:              				{
2128:              					/* In this instance the co-routine could be placed directly
2129:              					into the ready list as we are within a critical section.
2130:              					Instead the same pending ready list mechanism is used as if
2131:              					the event were caused from within an interrupt. */
2132:              					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
001EC2  440068     ADD W8, #0x8, W0
001EC4  0224BE     CALL xCoRoutineRemoveFromEventList
001EC6  000000     NOP
001EC8  780080     MOV W0, W1
001ECC  E00001     CP0 W1
001ECE  3A0001     BRA NZ, .L107
2133:              					{
2134:              						xReturn = errQUEUE_YIELD;
001ECA  2FFFB0     MOV #0xFFFB, W0
2135:              					}
2136:              					else
2137:              					{
2138:              						mtCOVERAGE_TEST_MARKER();
2139:              					}
2140:              				}
2141:              				else
2142:              				{
2143:              					mtCOVERAGE_TEST_MARKER();
2144:              				}
2145:              			}
2146:              			else
2147:              			{
2148:              				xReturn = pdFAIL;
001E94  EB0000     CLR W0
2149:              			}
2150:              		}
2151:              		portENABLE_INTERRUPTS();
001ED2  2FF1F1     MOV #0xFF1F, W1
001ED4  200422     MOV #0x42, W2
001ED6  608912     AND W1, [W2], [W2]
001ED8  000000     NOP
2152:              
2153:              		return xReturn;
2154:              	}
001EDA  78044F     MOV [--W15], W8
001EDC  060000     RETURN
2155:              
2156:              #endif /* configUSE_CO_ROUTINES */
2157:              /*-----------------------------------------------------------*/
2158:              
2159:              #if ( configUSE_CO_ROUTINES == 1 )
2160:              
2161:              	BaseType_t xQueueCRSendFromISR( QueueHandle_t xQueue, const void *pvItemToQueue, BaseType_t xCoRoutinePreviouslyWoken )
001F02  780480     MOV W0, W9
001F04  A7F009     BTSC W9, #15
001F06  EA0489     NEG W9, W9
001F08  EA0489     NEG W9, W9
2162:              	{
001EDE  BE9F88     MOV.D W8, [W15++]
001EE0  780482     MOV W2, W9
2163:              	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
001EE2  780400     MOV W0, W8
2164:              
2165:              		/* Cannot block within an ISR so if there is no space on the queue then
2166:              		exit without doing anything. */
2167:              		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
001EE4  900968     MOV [W8+28], W2
001EE6  900878     MOV [W8+30], W0
001EE8  510F80     SUB W2, W0, [W15]
001EEA  310010     BRA C, .L113
2168:              		{
2169:              			prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
001EEC  EB0100     CLR W2
001EEE  780008     MOV W8, W0
001EF0  07FCEE     RCALL .Letext0, .LFE3, _prvCopyDataToQueue, .Ltext0, .LFB13
2170:              
2171:              			/* We only want to wake one co-routine per ISR, so check that a
2172:              			co-routine has not already been woken. */
2173:              			if( xCoRoutinePreviouslyWoken == pdFALSE )
001EF2  E00009     CP0 W9
001EF4  3A000B     BRA NZ, .L113
2174:              			{
2175:              				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
001EF6  900818     MOV [W8+18], W0
001EF8  E00000     CP0 W0
001EFA  320008     BRA Z, .L113
2176:              				{
2177:              					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
001EFC  440072     ADD W8, #0x12, W0
001EFE  0224BE     CALL xCoRoutineRemoveFromEventList
001F00  000000     NOP
2178:              					{
2179:              						return pdTRUE;
001F0A  DE4CCF     LSR W9, #15, W9
2180:              					}
2181:              					else
2182:              					{
2183:              						mtCOVERAGE_TEST_MARKER();
2184:              					}
2185:              				}
2186:              				else
2187:              				{
2188:              					mtCOVERAGE_TEST_MARKER();
2189:              				}
2190:              			}
2191:              			else
2192:              			{
2193:              				mtCOVERAGE_TEST_MARKER();
2194:              			}
2195:              		}
2196:              		else
2197:              		{
2198:              			mtCOVERAGE_TEST_MARKER();
2199:              		}
2200:              
2201:              		return xCoRoutinePreviouslyWoken;
2202:              	}
001F0C  780009     MOV W9, W0
001F0E  BE044F     MOV.D [--W15], W8
001F10  060000     RETURN
2203:              
2204:              #endif /* configUSE_CO_ROUTINES */
2205:              /*-----------------------------------------------------------*/
2206:              
2207:              #if ( configUSE_CO_ROUTINES == 1 )
2208:              
2209:              	BaseType_t xQueueCRReceiveFromISR( QueueHandle_t xQueue, void *pvBuffer, BaseType_t *pxCoRoutineWoken )
2210:              	{
001F12  BE9F88     MOV.D W8, [W15++]
001F14  780400     MOV W0, W8
001F16  780181     MOV W1, W3
001F18  780482     MOV W2, W9
2211:              	BaseType_t xReturn;
2212:              	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
2213:              
2214:              		/* We cannot block from an ISR, so check there is data available. If
2215:              		not then just leave without doing anything. */
2216:              		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
001F1A  9008E8     MOV [W8+28], W1
001F1E  E00001     CP0 W1
001F20  32001E     BRA Z, .L115
2217:              		{
2218:              			/* Copy the data from the queue. */
2219:              			pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
001F22  901108     MOV [W8+32], W2
001F24  900038     MOV [W8+6], W0
001F26  400002     ADD W0, W2, W0
001F28  980430     MOV W0, [W8+6]
2220:              			if( pxQueue->u.pcReadFrom >= pxQueue->pcTail )
001F2A  900098     MOV [W8+2], W1
001F2C  500F81     SUB W0, W1, [W15]
001F2E  390002     BRA NC, .L116
2221:              			{
2222:              				pxQueue->u.pcReadFrom = pxQueue->pcHead;
001F30  780018     MOV [W8], W0
001F32  980430     MOV W0, [W8+6]
2223:              			}
2224:              			else
2225:              			{
2226:              				mtCOVERAGE_TEST_MARKER();
2227:              			}
2228:              			--( pxQueue->uxMessagesWaiting );
001F34  900868     MOV [W8+28], W0
001F36  E90000     DEC W0, W0
001F38  980C60     MOV W0, [W8+28]
2229:              			( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
001F3A  9000B8     MOV [W8+6], W1
001F3C  780003     MOV W3, W0
001F3E  020D1C     CALL _memcpy
001F40  000000     NOP
2230:              
2231:              			if( ( *pxCoRoutineWoken ) == pdFALSE )
001F44  E00019     CP0 [W9]
001F46  3A000B     BRA NZ, .L115
2232:              			{
2233:              				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
001F48  9000C8     MOV [W8+8], W1
001F4A  E00001     CP0 W1
001F4C  320008     BRA Z, .L115
2234:              				{
2235:              					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
001F4E  440068     ADD W8, #0x8, W0
001F50  0224BE     CALL xCoRoutineRemoveFromEventList
001F52  000000     NOP
001F54  780080     MOV W0, W1
001F58  E00001     CP0 W1
001F5A  320001     BRA Z, .L115
2236:              					{
2237:              						*pxCoRoutineWoken = pdTRUE;
001F5C  780C80     MOV W0, [W9]
2238:              					}
2239:              					else
2240:              					{
2241:              						mtCOVERAGE_TEST_MARKER();
2242:              					}
2243:              				}
2244:              				else
2245:              				{
2246:              					mtCOVERAGE_TEST_MARKER();
2247:              				}
2248:              			}
2249:              			else
2250:              			{
2251:              				mtCOVERAGE_TEST_MARKER();
2252:              			}
2253:              
2254:              			xReturn = pdPASS;
001F42  200010     MOV #0x1, W0
001F56  200010     MOV #0x1, W0
2255:              		}
2256:              		else
2257:              		{
2258:              			xReturn = pdFAIL;
001F1C  EB0000     CLR W0
2259:              		}
2260:              
2261:              		return xReturn;
2262:              	}
001F5E  BE044F     MOV.D [--W15], W8
001F60  060000     RETURN
2263:              
2264:              #endif /* configUSE_CO_ROUTINES */
2265:              /*-----------------------------------------------------------*/
2266:              
2267:              #if ( configQUEUE_REGISTRY_SIZE > 0 )
2268:              
2269:              	void vQueueAddToRegistry( QueueHandle_t xQueue, const char *pcQueueName ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
2270:              	{
2271:              	UBaseType_t ux;
2272:              
2273:              		/* See if there is an empty space in the registry.  A NULL name denotes
2274:              		a free slot. */
2275:              		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
2276:              		{
2277:              			if( xQueueRegistry[ ux ].pcQueueName == NULL )
2278:              			{
2279:              				/* Store the information on this queue. */
2280:              				xQueueRegistry[ ux ].pcQueueName = pcQueueName;
2281:              				xQueueRegistry[ ux ].xHandle = xQueue;
2282:              
2283:              				traceQUEUE_REGISTRY_ADD( xQueue, pcQueueName );
2284:              				break;
2285:              			}
2286:              			else
2287:              			{
2288:              				mtCOVERAGE_TEST_MARKER();
2289:              			}
2290:              		}
2291:              	}
2292:              
2293:              #endif /* configQUEUE_REGISTRY_SIZE */
2294:              /*-----------------------------------------------------------*/
2295:              
2296:              #if ( configQUEUE_REGISTRY_SIZE > 0 )
2297:              
2298:              	const char *pcQueueGetName( QueueHandle_t xQueue ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
2299:              	{
2300:              	UBaseType_t ux;
2301:              	const char *pcReturn = NULL; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
2302:              
2303:              		/* Note there is nothing here to protect against another task adding or
2304:              		removing entries from the registry while it is being searched. */
2305:              		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
2306:              		{
2307:              			if( xQueueRegistry[ ux ].xHandle == xQueue )
2308:              			{
2309:              				pcReturn = xQueueRegistry[ ux ].pcQueueName;
2310:              				break;
2311:              			}
2312:              			else
2313:              			{
2314:              				mtCOVERAGE_TEST_MARKER();
2315:              			}
2316:              		}
2317:              
2318:              		return pcReturn;
2319:              	}
2320:              
2321:              #endif /* configQUEUE_REGISTRY_SIZE */
2322:              /*-----------------------------------------------------------*/
2323:              
2324:              #if ( configQUEUE_REGISTRY_SIZE > 0 )
2325:              
2326:              	void vQueueUnregisterQueue( QueueHandle_t xQueue )
2327:              	{
2328:              	UBaseType_t ux;
2329:              
2330:              		/* See if the handle of the queue being unregistered in actually in the
2331:              		registry. */
2332:              		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
2333:              		{
2334:              			if( xQueueRegistry[ ux ].xHandle == xQueue )
2335:              			{
2336:              				/* Set the name to NULL to show that this slot if free again. */
2337:              				xQueueRegistry[ ux ].pcQueueName = NULL;
2338:              
2339:              				/* Set the handle to NULL to ensure the same queue handle cannot
2340:              				appear in the registry twice if it is added, removed, then
2341:              				added again. */
2342:              				xQueueRegistry[ ux ].xHandle = ( QueueHandle_t ) 0;
2343:              				break;
2344:              			}
2345:              			else
2346:              			{
2347:              				mtCOVERAGE_TEST_MARKER();
2348:              			}
2349:              		}
2350:              
2351:              	} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
2352:              
2353:              #endif /* configQUEUE_REGISTRY_SIZE */
2354:              /*-----------------------------------------------------------*/
2355:              
2356:              #if ( configUSE_TIMERS == 1 )
2357:              
2358:              	void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
2359:              	{
2360:              	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
2361:              
2362:              		/* This function should not be called by application code hence the
2363:              		'Restricted' in its name.  It is not part of the public API.  It is
2364:              		designed for use by kernel code, and has special calling requirements.
2365:              		It can result in vListInsert() being called on a list that can only
2366:              		possibly ever have one item in it, so the list will be fast, but even
2367:              		so it should be called with the scheduler locked and not from a critical
2368:              		section. */
2369:              
2370:              		/* Only do anything if there are no messages in the queue.  This function
2371:              		will not actually cause the task to block, just place it on a blocked
2372:              		list.  It will not block until the scheduler is unlocked - at which
2373:              		time a yield will be performed.  If an item is added to the queue while
2374:              		the queue is locked, and the calling task blocks on the queue, then the
2375:              		calling task will be immediately unblocked when the queue is unlocked. */
2376:              		prvLockQueue( pxQueue );
2377:              		if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
2378:              		{
2379:              			/* There is nothing in the queue, block for the specified period. */
2380:              			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
2381:              		}
2382:              		else
2383:              		{
2384:              			mtCOVERAGE_TEST_MARKER();
2385:              		}
2386:              		prvUnlockQueue( pxQueue );
2387:              	}
2388:              
2389:              #endif /* configUSE_TIMERS */
2390:              /*-----------------------------------------------------------*/
2391:              
2392:              #if( ( configUSE_QUEUE_SETS == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
2393:              
2394:              	QueueSetHandle_t xQueueCreateSet( const UBaseType_t uxEventQueueLength )
2395:              	{
2396:              	QueueSetHandle_t pxQueue;
2397:              
2398:              		pxQueue = xQueueGenericCreate( uxEventQueueLength, sizeof( Queue_t * ), queueQUEUE_TYPE_SET );
2399:              
2400:              		return pxQueue;
2401:              	}
2402:              
2403:              #endif /* configUSE_QUEUE_SETS */
2404:              /*-----------------------------------------------------------*/
2405:              
2406:              #if ( configUSE_QUEUE_SETS == 1 )
2407:              
2408:              	BaseType_t xQueueAddToSet( QueueSetMemberHandle_t xQueueOrSemaphore, QueueSetHandle_t xQueueSet )
2409:              	{
2410:              	BaseType_t xReturn;
2411:              
2412:              		taskENTER_CRITICAL();
2413:              		{
2414:              			if( ( ( Queue_t * ) xQueueOrSemaphore )->pxQueueSetContainer != NULL )
2415:              			{
2416:              				/* Cannot add a queue/semaphore to more than one queue set. */
2417:              				xReturn = pdFAIL;
2418:              			}
2419:              			else if( ( ( Queue_t * ) xQueueOrSemaphore )->uxMessagesWaiting != ( UBaseType_t ) 0 )
2420:              			{
2421:              				/* Cannot add a queue/semaphore to a queue set if there are already
2422:              				items in the queue/semaphore. */
2423:              				xReturn = pdFAIL;
2424:              			}
2425:              			else
2426:              			{
2427:              				( ( Queue_t * ) xQueueOrSemaphore )->pxQueueSetContainer = xQueueSet;
2428:              				xReturn = pdPASS;
2429:              			}
2430:              		}
2431:              		taskEXIT_CRITICAL();
2432:              
2433:              		return xReturn;
2434:              	}
2435:              
2436:              #endif /* configUSE_QUEUE_SETS */
2437:              /*-----------------------------------------------------------*/
2438:              
2439:              #if ( configUSE_QUEUE_SETS == 1 )
2440:              
2441:              	BaseType_t xQueueRemoveFromSet( QueueSetMemberHandle_t xQueueOrSemaphore, QueueSetHandle_t xQueueSet )
2442:              	{
2443:              	BaseType_t xReturn;
2444:              	Queue_t * const pxQueueOrSemaphore = ( Queue_t * ) xQueueOrSemaphore;
2445:              
2446:              		if( pxQueueOrSemaphore->pxQueueSetContainer != xQueueSet )
2447:              		{
2448:              			/* The queue was not a member of the set. */
2449:              			xReturn = pdFAIL;
2450:              		}
2451:              		else if( pxQueueOrSemaphore->uxMessagesWaiting != ( UBaseType_t ) 0 )
2452:              		{
2453:              			/* It is dangerous to remove a queue from a set when the queue is
2454:              			not empty because the queue set will still hold pending events for
2455:              			the queue. */
2456:              			xReturn = pdFAIL;
2457:              		}
2458:              		else
2459:              		{
2460:              			taskENTER_CRITICAL();
2461:              			{
2462:              				/* The queue is no longer contained in the set. */
2463:              				pxQueueOrSemaphore->pxQueueSetContainer = NULL;
2464:              			}
2465:              			taskEXIT_CRITICAL();
2466:              			xReturn = pdPASS;
2467:              		}
2468:              
2469:              		return xReturn;
2470:              	} /*lint !e818 xQueueSet could not be declared as pointing to const as it is a typedef. */
2471:              
2472:              #endif /* configUSE_QUEUE_SETS */
2473:              /*-----------------------------------------------------------*/
2474:              
2475:              #if ( configUSE_QUEUE_SETS == 1 )
2476:              
2477:              	QueueSetMemberHandle_t xQueueSelectFromSet( QueueSetHandle_t xQueueSet, TickType_t const xTicksToWait )
2478:              	{
2479:              	QueueSetMemberHandle_t xReturn = NULL;
2480:              
2481:              		( void ) xQueueGenericReceive( ( QueueHandle_t ) xQueueSet, &xReturn, xTicksToWait, pdFALSE ); /*lint !e961 Casting from one typedef to another is not redundant. */
2482:              		return xReturn;
2483:              	}
2484:              
2485:              #endif /* configUSE_QUEUE_SETS */
2486:              /*-----------------------------------------------------------*/
2487:              
2488:              #if ( configUSE_QUEUE_SETS == 1 )
2489:              
2490:              	QueueSetMemberHandle_t xQueueSelectFromSetFromISR( QueueSetHandle_t xQueueSet )
2491:              	{
2492:              	QueueSetMemberHandle_t xReturn = NULL;
2493:              
2494:              		( void ) xQueueReceiveFromISR( ( QueueHandle_t ) xQueueSet, &xReturn, NULL ); /*lint !e961 Casting from one typedef to another is not redundant. */
2495:              		return xReturn;
2496:              	}
2497:              
2498:              #endif /* configUSE_QUEUE_SETS */
2499:              /*-----------------------------------------------------------*/
2500:              
2501:              #if ( configUSE_QUEUE_SETS == 1 )
2502:              
2503:              	static BaseType_t prvNotifyQueueSetContainer( const Queue_t * const pxQueue, const BaseType_t xCopyPosition )
2504:              	{
2505:              	Queue_t *pxQueueSetContainer = pxQueue->pxQueueSetContainer;
2506:              	BaseType_t xReturn = pdFALSE;
2507:              
2508:              		/* This function must be called form a critical section. */
2509:              
2510:              		configASSERT( pxQueueSetContainer );
2511:              		configASSERT( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength );
2512:              
2513:              		if( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength )
2514:              		{
2515:              			const int8_t cTxLock = pxQueueSetContainer->cTxLock;
2516:              
2517:              			traceQUEUE_SEND( pxQueueSetContainer );
2518:              
2519:              			/* The data copied is the handle of the queue that contains data. */
2520:              			xReturn = prvCopyDataToQueue( pxQueueSetContainer, &pxQueue, xCopyPosition );
2521:              
2522:              			if( cTxLock == queueUNLOCKED )
2523:              			{
2524:              				if( listLIST_IS_EMPTY( &( pxQueueSetContainer->xTasksWaitingToReceive ) ) == pdFALSE )
2525:              				{
2526:              					if( xTaskRemoveFromEventList( &( pxQueueSetContainer->xTasksWaitingToReceive ) ) != pdFALSE )
2527:              					{
2528:              						/* The task waiting has a higher priority. */
2529:              						xReturn = pdTRUE;
2530:              					}
2531:              					else
2532:              					{
2533:              						mtCOVERAGE_TEST_MARKER();
2534:              					}
2535:              				}
2536:              				else
2537:              				{
2538:              					mtCOVERAGE_TEST_MARKER();
2539:              				}
2540:              			}
2541:              			else
2542:              			{
2543:              				pxQueueSetContainer->cTxLock = ( int8_t ) ( cTxLock + 1 );
2544:              			}
2545:              		}
2546:              		else
2547:              		{
2548:              			mtCOVERAGE_TEST_MARKER();
2549:              		}
2550:              
2551:              		return xReturn;
2552:              	}
2553:              
2554:              #endif /* configUSE_QUEUE_SETS */
2555:              
2556:              
2557:              
2558:              
2559:              
2560:              
2561:              
2562:              
2563:              
2564:              
2565:              
2566:              
---  D:/code/FreeRTOS/Source/portable/MemMang/heap_1.c  -------------------------------------------------
1:                 /*
2:                     FreeRTOS V9.0.0 - Copyright (C) 2016 Real Time Engineers Ltd.
3:                     All rights reserved
4:                 
5:                     VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
6:                 
7:                     This file is part of the FreeRTOS distribution.
8:                 
9:                     FreeRTOS is free software; you can redistribute it and/or modify it under
10:                    the terms of the GNU General Public License (version 2) as published by the
11:                    Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
12:                
13:                    ***************************************************************************
14:                    >>!   NOTE: The modification to the GPL is included to allow you to     !<<
15:                    >>!   distribute a combined work that includes FreeRTOS without being   !<<
16:                    >>!   obliged to provide the source code for proprietary components     !<<
17:                    >>!   outside of the FreeRTOS kernel.                                   !<<
18:                    ***************************************************************************
19:                
20:                    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
21:                    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
22:                    FOR A PARTICULAR PURPOSE.  Full license text is available on the following
23:                    link: http://www.freertos.org/a00114.html
24:                
25:                    ***************************************************************************
26:                     *                                                                       *
27:                     *    FreeRTOS provides completely free yet professionally developed,    *
28:                     *    robust, strictly quality controlled, supported, and cross          *
29:                     *    platform software that is more than just the market leader, it     *
30:                     *    is the industry's de facto standard.                               *
31:                     *                                                                       *
32:                     *    Help yourself get started quickly while simultaneously helping     *
33:                     *    to support the FreeRTOS project by purchasing a FreeRTOS           *
34:                     *    tutorial book, reference manual, or both:                          *
35:                     *    http://www.FreeRTOS.org/Documentation                              *
36:                     *                                                                       *
37:                    ***************************************************************************
38:                
39:                    http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
40:                    the FAQ page "My application does not run, what could be wrong?".  Have you
41:                    defined configASSERT()?
42:                
43:                    http://www.FreeRTOS.org/support - In return for receiving this top quality
44:                    embedded software for free we request you assist our global community by
45:                    participating in the support forum.
46:                
47:                    http://www.FreeRTOS.org/training - Investing in training allows your team to
48:                    be as productive as possible as early as possible.  Now you can receive
49:                    FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
50:                    Ltd, and the world's leading authority on the world's leading RTOS.
51:                
52:                    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
53:                    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
54:                    compatible FAT file system, and our tiny thread aware UDP/IP stack.
55:                
56:                    http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
57:                    Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
58:                
59:                    http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
60:                    Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
61:                    licenses offer ticketed support, indemnification and commercial middleware.
62:                
63:                    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
64:                    engineered and independently SIL3 certified version for use in safety and
65:                    mission critical applications that require provable dependability.
66:                
67:                    1 tab == 4 spaces!
68:                */
69:                
70:                
71:                /*
72:                 * The simplest possible implementation of pvPortMalloc().  Note that this
73:                 * implementation does NOT allow allocated memory to be freed again.
74:                 *
75:                 * See heap_2.c, heap_3.c and heap_4.c for alternative implementations, and the
76:                 * memory management pages of http://www.FreeRTOS.org for more information.
77:                 */
78:                #include <stdlib.h>
79:                
80:                /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
81:                all the API functions to use the MPU wrappers.  That should only be done when
82:                task.h is included from an application file. */
83:                #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
84:                
85:                #include "FreeRTOS.h"
86:                #include "task.h"
87:                
88:                #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE
89:                
90:                #if( configSUPPORT_DYNAMIC_ALLOCATION == 0 )
91:                	#error This file must not be used if configSUPPORT_DYNAMIC_ALLOCATION is 0
92:                #endif
93:                
94:                /* A few bytes might be lost to byte aligning the heap start address. */
95:                #define configADJUSTED_HEAP_SIZE	( configTOTAL_HEAP_SIZE - portBYTE_ALIGNMENT )
96:                
97:                /* Allocate the memory for the heap. */
98:                /* Allocate the memory for the heap. */
99:                #if( configAPPLICATION_ALLOCATED_HEAP == 1 )
100:               	/* The application writer has already defined the array used for the RTOS
101:               	heap - probably so it can be placed in a special segment or address. */
102:               	extern uint8_t ucHeap[ configTOTAL_HEAP_SIZE ];
103:               #else
104:               	static uint8_t ucHeap[ configTOTAL_HEAP_SIZE ];
105:               #endif /* configAPPLICATION_ALLOCATED_HEAP */
106:               
107:               static size_t xNextFreeByte = ( size_t ) 0;
108:               
109:               /*-----------------------------------------------------------*/
110:               
111:               void *pvPortMalloc( size_t xWantedSize )
112:               {
002E18  BE9F88     MOV.D W8, [W15++]
002E1A  780400     MOV W0, W8
113:               void *pvReturn = NULL;
002E36  EB0480     CLR W9
114:               static uint8_t *pucAlignedHeap = NULL;
115:               
116:               	/* Ensure that blocks are always aligned to the required number of bytes. */
117:               	#if( portBYTE_ALIGNMENT != 1 )
118:               	{
119:               		if( xWantedSize & portBYTE_ALIGNMENT_MASK )
002E1C  A30808     BTST.Z W8, #0
002E1E  320002     BRA Z, .L2
120:               		{
121:               			/* Byte alignment required. */
122:               			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
002E20  A10008     BCLR W8, #0
002E22  E88408     INC2 W8, W8
123:               		}
124:               	}
125:               	#endif
126:               
127:               	vTaskSuspendAll();
002E24  0210AA     CALL vTaskSuspendAll
002E26  000000     NOP
128:               	{
129:               		if( pucAlignedHeap == NULL )
002E28  E20898     CP0 pucAlignedHeap
002E2A  3A0003     BRA NZ, .L3
130:               		{
131:               			/* Ensure the heap starts on a correctly aligned boundary. */
132:               			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
002E2C  208A80     MOV #0x8A8, W0
002E2E  A10000     BCLR W0, #0
002E30  8844C0     MOV W0, pucAlignedHeap
133:               		}
134:               
135:               		/* Check there is enough room left for the allocation. */
136:               		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
002E32  8044B0     MOV xNextFreeByte, W0
002E34  440400     ADD W8, W0, W8
002E38  213FD1     MOV #0x13FD, W1
002E3A  540F81     SUB W8, W1, [W15]
002E3C  3E0005     BRA GTU, .L4
002E3E  500F88     SUB W0, W8, [W15]
002E40  310003     BRA C, .L4
137:               			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
138:               		{
139:               			/* Return the next free byte then increment the index past this
140:               			block. */
141:               			pvReturn = pucAlignedHeap + xNextFreeByte;
002E42  B40898     ADD pucAlignedHeap, WREG
002E44  780480     MOV W0, W9
142:               			xNextFreeByte += xWantedSize;
002E46  8844B8     MOV W8, xNextFreeByte
143:               		}
144:               
145:               		traceMALLOC( pvReturn, xWantedSize );
146:               	}
147:               	( void ) xTaskResumeAll();
002E48  021408     CALL xTaskResumeAll
002E4A  000000     NOP
148:               
149:               	#if( configUSE_MALLOC_FAILED_HOOK == 1 )
150:               	{
151:               		if( pvReturn == NULL )
152:               		{
153:               			extern void vApplicationMallocFailedHook( void );
154:               			vApplicationMallocFailedHook();
155:               		}
156:               	}
157:               	#endif
158:               
159:               	return pvReturn;
160:               }
002E4C  780009     MOV W9, W0
002E4E  BE044F     MOV.D [--W15], W8
002E50  060000     RETURN
161:               /*-----------------------------------------------------------*/
162:               
163:               void vPortFree( void *pv )
164:               {
165:               	/* Memory cannot be freed using this scheme.  See heap_2.c, heap_3.c and
166:               	heap_4.c for alternative implementations, and the memory management pages of
167:               	http://www.FreeRTOS.org for more information. */
168:               	( void ) pv;
169:               
170:               	/* Force an assert as it is invalid to call this function. */
171:               	configASSERT( pv == NULL );
172:               }
002E52  060000     RETURN
173:               /*-----------------------------------------------------------*/
174:               
175:               void vPortInitialiseBlocks( void )
176:               {
177:               	/* Only required when static memory is not cleared. */
178:               	xNextFreeByte = ( size_t ) 0;
002E54  EF2896     CLR xNextFreeByte
179:               }
002E56  060000     RETURN
180:               /*-----------------------------------------------------------*/
181:               
182:               size_t xPortGetFreeHeapSize( void )
183:               {
184:               	return ( configADJUSTED_HEAP_SIZE - xNextFreeByte );
002E58  8044B0     MOV xNextFreeByte, W0
002E5A  213FE1     MOV #0x13FE, W1
002E5C  508000     SUB W1, W0, W0
185:               }
002E5E  060000     RETURN
186:               
187:               
188:               
---  D:/code/FreeRTOS/Source/portable/MPLAB/PIC24_dsPIC/portasm_PIC24.S  --------------------------------
                                                  1:     /*
                                                  2:         FreeRTOS V9.0.0 - Copyright (C) 2016 Real Time Engineers Ltd.
                                                  3:         All rights reserved
                                                  4:     
                                                  5:         VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
                                                  6:     
                                                  7:         This file is part of the FreeRTOS distribution.
                                                  8:     
                                                  9:         FreeRTOS is free software; you can redistribute it and/or modify it under
                                                  10:        the terms of the GNU General Public License (version 2) as published by the
                                                  11:        Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
                                                  12:    
                                                  13:        ***************************************************************************
                                                  14:        >>!   NOTE: The modification to the GPL is included to allow you to     !<<
                                                  15:        >>!   distribute a combined work that includes FreeRTOS without being   !<<
                                                  16:        >>!   obliged to provide the source code for proprietary components     !<<
                                                  17:        >>!   outside of the FreeRTOS kernel.                                   !<<
                                                  18:        ***************************************************************************
                                                  19:    
                                                  20:        FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
                                                  21:        WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
                                                  22:        FOR A PARTICULAR PURPOSE.  Full license text is available on the following
                                                  23:        link: http://www.freertos.org/a00114.html
                                                  24:    
                                                  25:        ***************************************************************************
                                                  26:         *                                                                       *
                                                  27:         *    FreeRTOS provides completely free yet professionally developed,    *
                                                  28:         *    robust, strictly quality controlled, supported, and cross          *
                                                  29:         *    platform software that is more than just the market leader, it     *
                                                  30:         *    is the industry's de facto standard.                               *
                                                  31:         *                                                                       *
                                                  32:         *    Help yourself get started quickly while simultaneously helping     *
                                                  33:         *    to support the FreeRTOS project by purchasing a FreeRTOS           *
                                                  34:         *    tutorial book, reference manual, or both:                          *
                                                  35:         *    http://www.FreeRTOS.org/Documentation                              *
                                                  36:         *                                                                       *
                                                  37:        ***************************************************************************
                                                  38:    
                                                  39:        http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
                                                  40:        the FAQ page "My application does not run, what could be wrong?".  Have you
                                                  41:        defined configASSERT()?
                                                  42:    
                                                  43:        http://www.FreeRTOS.org/support - In return for receiving this top quality
                                                  44:        embedded software for free we request you assist our global community by
                                                  45:        participating in the support forum.
                                                  46:    
                                                  47:        http://www.FreeRTOS.org/training - Investing in training allows your team to
                                                  48:        be as productive as possible as early as possible.  Now you can receive
                                                  49:        FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
                                                  50:        Ltd, and the world's leading authority on the world's leading RTOS.
                                                  51:    
                                                  52:        http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
                                                  53:        including FreeRTOS+Trace - an indispensable productivity tool, a DOS
                                                  54:        compatible FAT file system, and our tiny thread aware UDP/IP stack.
                                                  55:    
                                                  56:        http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
                                                  57:        Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
                                                  58:    
                                                  59:        http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
                                                  60:        Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
                                                  61:        licenses offer ticketed support, indemnification and commercial middleware.
                                                  62:    
                                                  63:        http://www.SafeRTOS.com - High Integrity Systems also provide a safety
                                                  64:        engineered and independently SIL3 certified version for use in safety and
                                                  65:        mission critical applications that require provable dependability.
                                                  66:    
                                                  67:        1 tab == 4 spaces!
                                                  68:    */
                                                  69:    
                                                  70:    #if defined( __PIC24E__ ) || defined ( __PIC24F__ ) || defined( __PIC24FK__ ) || defined( __PIC24H__ )
                                                  71:    
                                                  72:            .global _vPortYield
                                                  73:    		.extern _vTaskSwitchContext
                                                  74:    		.extern uxCriticalNesting
                                                  75:    
                                                  76:    _vPortYield:
                                                  77:    
002DC4  F80042     PUSH SR                        78:    		PUSH	SR						/* Save the SR used by the task.... */
002DC6  781F80     MOV W0, [W15++]                79:    		PUSH	W0						/* ....then disable interrupts. */
002DC8  200200     MOV #0x20, W0                  80:    		MOV		#32, W0
002DCA  880210     MOV W0, SR                     81:    		MOV		W0, SR
002DCC  781F81     MOV W1, [W15++]                82:    		PUSH	W1						/* Save registers to the stack. */
002DCE  BE9F82     MOV.D W2, [W15++]              83:    		PUSH.D	W2
002DD0  BE9F84     MOV.D W4, [W15++]              84:    		PUSH.D	W4
002DD2  BE9F86     MOV.D W6, [W15++]              85:    		PUSH.D	W6
002DD4  BE9F88     MOV.D W8, [W15++]              86:    		PUSH.D 	W8
002DD6  BE9F8A     MOV.D W10, [W15++]             87:    		PUSH.D 	W10
002DD8  BE9F8C     MOV.D W12, [W15++]             88:    		PUSH.D	W12
002DDA  781F8E     MOV W14, [W15++]               89:    		PUSH	W14
002DDC  F80036     PUSH RCOUNT                    90:    		PUSH	RCOUNT
002DDE  F80054     PUSH TBLPAG                    91:    		PUSH	TBLPAG
                                                  92:    
002DE0  F80044     PUSH CORCON                    93:    		PUSH	CORCON
                                                  94:    		#ifdef __HAS_EDS__
002DE2  F80032     PUSH DSRPAG                    95:    			PUSH	DSRPAG
002DE4  F80034     PUSH DSWPAG                    96:    			PUSH	DSWPAG
                                                  97:    		#else
                                                  98:    			PUSH	PSVPAG
                                                  99:    		#endif /* __HAS_EDS__ */
002DE6  804140     MOV 0x828, W0                  100:   		MOV		_uxCriticalNesting, W0		/* Save the critical nesting counter for the task. */
002DE8  781F80     MOV W0, [W15++]                101:   		PUSH	W0
002DEA  804280     MOV 0x850, W0                  102:   		MOV		_pxCurrentTCB, W0			/* Save the new top of stack into the TCB. */
002DEC  78080F     MOV W15, [W0]                  103:   		MOV		W15, [W0]
                                                  104:   
002DEE  0210D2     CALL 0x10D2                    105:   		call 	_vTaskSwitchContext
                                                  106:   
002DF2  804280     MOV 0x850, W0                  107:   		MOV		_pxCurrentTCB, W0			/* Restore the stack pointer for the task. */
002DF4  780790     MOV [W0], W15                  108:   		MOV		[W0], W15
002DF6  78004F     MOV [--W15], W0                109:   		POP		W0							/* Restore the critical nesting counter for the task. */
002DF8  884140     MOV W0, 0x828                  110:   		MOV		W0, _uxCriticalNesting
                                                  111:   		#ifdef __HAS_EDS__
002DFA  F90034     POP DSWPAG                     112:   			POP		DSWPAG
002DFC  F90032     POP DSRPAG                     113:   			POP		DSRPAG
                                                  114:   		#else
                                                  115:   			POP		PSVPAG
                                                  116:   		#endif /* __HAS_EDS__ */
002DFE  F90044     POP CORCON                     117:   		POP		CORCON
002E00  F90054     POP TBLPAG                     118:   		POP		TBLPAG
002E02  F90036     POP RCOUNT                     119:   		POP		RCOUNT						/* Restore the registers from the stack. */
002E04  78074F     MOV [--W15], W14               120:   		POP		W14
002E06  BE064F     MOV.D [--W15], W12             121:   		POP.D	W12
002E08  BE054F     MOV.D [--W15], W10             122:   		POP.D	W10
002E0A  BE044F     MOV.D [--W15], W8              123:   		POP.D	W8
002E0C  BE034F     MOV.D [--W15], W6              124:   		POP.D	W6
002E0E  BE024F     MOV.D [--W15], W4              125:   		POP.D	W4
002E10  BE014F     MOV.D [--W15], W2              126:   		POP.D	W2
002E12  BE004F     MOV.D [--W15], W0              127:   		POP.D	W0
002E14  F90042     POP SR                         128:   		POP		SR
                                                  129:   
002E16  060000     RETURN                         130:           return
                                                  131:   
                                                  132:           .end
                                                  133:   		
                                                  134:   #endif /* defined( __PIC24E__ ) || defined ( __PIC24F__ ) || defined( __PIC24FK__ ) || defined( __PIC24H__ ) */
---  D:/code/FreeRTOS/Source/portable/MPLAB/PIC24_dsPIC/port.c  -----------------------------------------
1:                 /*
2:                     FreeRTOS V9.0.0 - Copyright (C) 2016 Real Time Engineers Ltd.
3:                     All rights reserved
4:                 
5:                     VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
6:                 
7:                     This file is part of the FreeRTOS distribution.
8:                 
9:                     FreeRTOS is free software; you can redistribute it and/or modify it under
10:                    the terms of the GNU General Public License (version 2) as published by the
11:                    Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
12:                
13:                    ***************************************************************************
14:                    >>!   NOTE: The modification to the GPL is included to allow you to     !<<
15:                    >>!   distribute a combined work that includes FreeRTOS without being   !<<
16:                    >>!   obliged to provide the source code for proprietary components     !<<
17:                    >>!   outside of the FreeRTOS kernel.                                   !<<
18:                    ***************************************************************************
19:                
20:                    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
21:                    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
22:                    FOR A PARTICULAR PURPOSE.  Full license text is available on the following
23:                    link: http://www.freertos.org/a00114.html
24:                
25:                    ***************************************************************************
26:                     *                                                                       *
27:                     *    FreeRTOS provides completely free yet professionally developed,    *
28:                     *    robust, strictly quality controlled, supported, and cross          *
29:                     *    platform software that is more than just the market leader, it     *
30:                     *    is the industry's de facto standard.                               *
31:                     *                                                                       *
32:                     *    Help yourself get started quickly while simultaneously helping     *
33:                     *    to support the FreeRTOS project by purchasing a FreeRTOS           *
34:                     *    tutorial book, reference manual, or both:                          *
35:                     *    http://www.FreeRTOS.org/Documentation                              *
36:                     *                                                                       *
37:                    ***************************************************************************
38:                
39:                    http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
40:                    the FAQ page "My application does not run, what could be wrong?".  Have you
41:                    defined configASSERT()?
42:                
43:                    http://www.FreeRTOS.org/support - In return for receiving this top quality
44:                    embedded software for free we request you assist our global community by
45:                    participating in the support forum.
46:                
47:                    http://www.FreeRTOS.org/training - Investing in training allows your team to
48:                    be as productive as possible as early as possible.  Now you can receive
49:                    FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
50:                    Ltd, and the world's leading authority on the world's leading RTOS.
51:                
52:                    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
53:                    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
54:                    compatible FAT file system, and our tiny thread aware UDP/IP stack.
55:                
56:                    http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
57:                    Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
58:                
59:                    http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
60:                    Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
61:                    licenses offer ticketed support, indemnification and commercial middleware.
62:                
63:                    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
64:                    engineered and independently SIL3 certified version for use in safety and
65:                    mission critical applications that require provable dependability.
66:                
67:                    1 tab == 4 spaces!
68:                */
69:                
70:                /*
71:                	Changes from V4.2.1
72:                
73:                	+ Introduced the configKERNEL_INTERRUPT_PRIORITY definition.
74:                */
75:                
76:                /*-----------------------------------------------------------
77:                 * Implementation of functions defined in portable.h for the PIC24 port.
78:                 *----------------------------------------------------------*/
79:                
80:                /* Scheduler include files. */
81:                #include "FreeRTOS.h"
82:                #include "task.h"
83:                
84:                /* Hardware specifics. */
85:                #define portBIT_SET 1
86:                #define portTIMER_PRESCALE 8
87:                #define portINITIAL_SR	0
88:                
89:                /* Defined for backward compatability with project created prior to
90:                FreeRTOS.org V4.3.0. */
91:                #ifndef configKERNEL_INTERRUPT_PRIORITY
92:                	#define configKERNEL_INTERRUPT_PRIORITY 1
93:                #endif
94:                
95:                /* Use _T1Interrupt as the interrupt handler name if the application writer has
96:                not provided their own. */
97:                #ifndef configTICK_INTERRUPT_HANDLER
98:                	#define configTICK_INTERRUPT_HANDLER _T1Interrupt
99:                #endif /* configTICK_INTERRUPT_HANDLER */
100:               
101:               /* The program counter is only 23 bits. */
102:               #define portUNUSED_PR_BITS	0x7f
103:               
104:               /* Records the nesting depth of calls to portENTER_CRITICAL(). */
105:               UBaseType_t uxCriticalNesting = 0xef;
106:               
107:               #if configKERNEL_INTERRUPT_PRIORITY != 1
108:               	#error If configKERNEL_INTERRUPT_PRIORITY is not 1 then the #32 in the following macros needs changing to equal the portINTERRUPT_BITS value, which is ( configKERNEL_INTERRUPT_PRIORITY << 5 )
109:               #endif
110:               
111:               #if defined( __PIC24E__ ) || defined ( __PIC24F__ ) || defined( __PIC24FK__ ) || defined( __PIC24H__ )
112:               
113:                   #ifdef __HAS_EDS__
114:               		#define portRESTORE_CONTEXT()																						\
115:               					asm volatile(	"MOV	_pxCurrentTCB, W0		\n"	/* Restore the stack pointer for the task. */		\
116:               							"MOV	[W0], W15				\n"																\
117:               							"POP	W0						\n"	/* Restore the critical nesting counter for the task. */	\
118:               							"MOV	W0, _uxCriticalNesting	\n"																\
119:               							"POP	DSWPAG					\n"																\
120:               							"POP    DSRPAG					\n"																\
121:               							"POP	CORCON					\n"																\
122:               							"POP	TBLPAG					\n"																\
123:               							"POP	RCOUNT					\n"	/* Restore the registers from the stack. */					\
124:               							"POP	W14						\n"																\
125:               							"POP.D	W12						\n"																\
126:               							"POP.D	W10						\n"																\
127:               							"POP.D	W8						\n"																\
128:               							"POP.D	W6						\n"																\
129:               							"POP.D	W4						\n"																\
130:               							"POP.D	W2						\n"																\
131:               							"POP.D	W0						\n"																\
132:               							"POP	SR						  " );
133:               	#else /* __HAS_EDS__ */
134:               		#define portRESTORE_CONTEXT()																						\
135:               			asm volatile(	"MOV	_pxCurrentTCB, W0		\n"	/* Restore the stack pointer for the task. */				\
136:               							"MOV	[W0], W15				\n"																\
137:               							"POP	W0						\n"	/* Restore the critical nesting counter for the task. */	\
138:               							"MOV	W0, _uxCriticalNesting	\n"																\
139:               							"POP	PSVPAG					\n"																\
140:               							"POP	CORCON					\n"																\
141:               							"POP	TBLPAG					\n"																\
142:               							"POP	RCOUNT					\n"	/* Restore the registers from the stack. */					\
143:               							"POP	W14						\n"																\
144:               							"POP.D	W12						\n"																\
145:               							"POP.D	W10						\n"																\
146:               							"POP.D	W8						\n"																\
147:               							"POP.D	W6						\n"																\
148:               							"POP.D	W4						\n"																\
149:               							"POP.D	W2						\n"																\
150:               							"POP.D	W0						\n"																\
151:               							"POP	SR						  " );
152:               		#endif /* __HAS_EDS__ */
153:               #endif /* MPLAB_PIC24_PORT */
154:               
155:               #if defined( __dsPIC30F__ ) || defined( __dsPIC33F__ )
156:               
157:               	#define portRESTORE_CONTEXT()																						\
158:               		asm volatile(	"MOV	_pxCurrentTCB, W0		\n"	/* Restore the stack pointer for the task. */				\
159:               						"MOV	[W0], W15				\n"																\
160:               						"POP	W0						\n"	/* Restore the critical nesting counter for the task. */	\
161:               						"MOV	W0, _uxCriticalNesting	\n"																\
162:               						"POP	PSVPAG					\n"																\
163:               						"POP	CORCON					\n"																\
164:               						"POP	DOENDH					\n"																\
165:               						"POP	DOENDL					\n"																\
166:               						"POP	DOSTARTH				\n"																\
167:               						"POP	DOSTARTL				\n"																\
168:               						"POP	DCOUNT					\n"																\
169:               						"POP	ACCBU					\n"																\
170:               						"POP	ACCBH					\n"																\
171:               						"POP	ACCBL					\n"																\
172:               						"POP	ACCAU					\n"																\
173:               						"POP	ACCAH					\n"																\
174:               						"POP	ACCAL					\n"																\
175:               						"POP	TBLPAG					\n"																\
176:               						"POP	RCOUNT					\n"	/* Restore the registers from the stack. */					\
177:               						"POP	W14						\n"																\
178:               						"POP.D	W12						\n"																\
179:               						"POP.D	W10						\n"																\
180:               						"POP.D	W8						\n"																\
181:               						"POP.D	W6						\n"																\
182:               						"POP.D	W4						\n"																\
183:               						"POP.D	W2						\n"																\
184:               						"POP.D	W0						\n"																\
185:               						"POP	SR						  " );
186:               
187:               #endif /* MPLAB_DSPIC_PORT */
188:               
189:               #ifndef portRESTORE_CONTEXT
190:               	#error Unrecognised device selected
191:               
192:               	/* Note:  dsPIC parts with EDS are not supported as there is no easy way to
193:               	recover the hardware stacked copies for DOCOUNT, DOHIGH, DOLOW. */
194:               #endif
195:               
196:               /*
197:                * Setup the timer used to generate the tick interrupt.
198:                */
199:               void vApplicationSetupTickTimerInterrupt( void );
200:               
201:               /*
202:                * See header file for description.
203:                */
204:               StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
002B44  B00280     ADD #0x28, W0
205:               {
002B28  FA0020     LNK #0x20
206:               uint16_t usCode;
207:               UBaseType_t i;
208:               
209:               const StackType_t xInitialStack[] =
002B2A  2FFE03     MOV #0xFFE0, W3
002B2C  478183     ADD W15, W3, W3
002B2E  28E2C4     MOV #0x8E2C, W4
002B30  09000F     REPEAT #0xF
002B32  7819B4     MOV [W4++], [W3++]
210:               {
211:               	0x1111,	/* W1 */
212:               	0x2222, /* W2 */
213:               	0x3333, /* W3 */
214:               	0x4444, /* W4 */
215:               	0x5555, /* W5 */
216:               	0x6666, /* W6 */
217:               	0x7777, /* W7 */
218:               	0x8888, /* W8 */
219:               	0x9999, /* W9 */
220:               	0xaaaa, /* W10 */
221:               	0xbbbb, /* W11 */
222:               	0xcccc, /* W12 */
223:               	0xdddd, /* W13 */
224:               	0xeeee, /* W14 */
225:               	0xcdce, /* RCOUNT */
226:               	0xabac, /* TBLPAG */
227:               
228:               	/* dsPIC specific registers. */
229:               	#ifdef MPLAB_DSPIC_PORT
230:               		0x0202, /* ACCAL */
231:               		0x0303, /* ACCAH */
232:               		0x0404, /* ACCAU */
233:               		0x0505, /* ACCBL */
234:               		0x0606, /* ACCBH */
235:               		0x0707, /* ACCBU */
236:               		0x0808, /* DCOUNT */
237:               		0x090a, /* DOSTARTL */
238:               		0x1010, /* DOSTARTH */
239:               		0x1110, /* DOENDL */
240:               		0x1212, /* DOENDH */
241:               	#endif
242:               };
243:               
244:               	/* Setup the stack as if a yield had occurred.
245:               
246:               	Save the low bytes of the program counter. */
247:               	usCode = ( uint16_t ) pxCode;
248:               	*pxTopOfStack = ( StackType_t ) usCode;
002B34  780180     MOV W0, W3
002B36  781981     MOV W1, [W3++]
249:               	pxTopOfStack++;
250:               
251:               	/* Save the high byte of the program counter.  This will always be zero
252:               	here as it is passed in a 16bit pointer.  If the address is greater than
253:               	16 bits then the pointer will point to a jump table. */
254:               	*pxTopOfStack = ( StackType_t ) 0;
002B38  EB0080     CLR W1
002B3A  781981     MOV W1, [W3++]
255:               	pxTopOfStack++;
256:               
257:               	/* Status register with interrupts enabled. */
258:               	*pxTopOfStack = portINITIAL_SR;
002B3C  781981     MOV W1, [W3++]
259:               	pxTopOfStack++;
260:               
261:               	/* Parameters are passed in W0. */
262:               	*pxTopOfStack = ( StackType_t ) pvParameters;
002B3E  781982     MOV W2, [W3++]
263:               	pxTopOfStack++;
002B40  2FFDE2     MOV #0xFFDE, W2
002B42  41010F     ADD W2, W15, W2
002B46  780083     MOV W3, W1
264:               
265:               	for( i = 0; i < ( sizeof( xInitialStack ) / sizeof( StackType_t ) ); i++ )
002B4A  508F80     SUB W1, W0, [W15]
002B4C  3AFFFD     BRA NZ, .L2
266:               	{
267:               		*pxTopOfStack = xInitialStack[ i ];
002B48  7818D2     MOV [++W2], [W1++]
268:               		pxTopOfStack++;
269:               	}
270:               
271:               	*pxTopOfStack = CORCON;
002B4E  200200     MOV #0x20, W0
002B50  400003     ADD W0, W3, W0
002B52  800221     MOV CORCON, W1
002B54  781801     MOV W1, [W0++]
272:               	pxTopOfStack++;
273:               
274:               	#if defined(__HAS_EDS__)
275:               		*pxTopOfStack = DSRPAG;
002B56  800193     MOV DSRPAG, W3
002B58  781803     MOV W3, [W0++]
276:               		pxTopOfStack++;
277:               		*pxTopOfStack = DSWPAG;
002B5A  8001A4     MOV DSWPAG, W4
002B5C  781804     MOV W4, [W0++]
278:               		pxTopOfStack++;
279:               	#else /* __HAS_EDS__ */
280:               		*pxTopOfStack = PSVPAG;
281:               		pxTopOfStack++;
282:               	#endif /* __HAS_EDS__ */
283:               
284:               	/* Finally the critical nesting depth. */
285:               	*pxTopOfStack = 0x00;
002B5E  EB1800     CLR [W0++]
286:               	pxTopOfStack++;
287:               
288:               	return pxTopOfStack;
289:               }
002B60  FA8000     ULNK
002B62  060000     RETURN
290:               /*-----------------------------------------------------------*/
291:               
292:               BaseType_t xPortStartScheduler( void )
293:               {
294:               	/* Setup a timer for the tick ISR. */
295:               	vApplicationSetupTickTimerInterrupt();
002B82  022B66     CALL vApplicationSetupTickTimerInterrupt
002B84  000000     NOP
296:               
297:               	/* Restore the context of the first task to run. */
298:               	portRESTORE_CONTEXT();
002B86  804280     MOV pxCurrentTCB, W0
002B88  780790     MOV [W0], W15
002B8A  78004F     MOV [--W15], W0
002B8C  884140     MOV W0, 0x828
002B8E  F90034     POP DSWPAG
002B90  F90032     POP DSRPAG
002B92  F90044     POP CORCON
002B94  F90054     POP TBLPAG
002B96  F90036     POP RCOUNT
002B98  78074F     MOV [--W15], W14
002B9A  BE064F     MOV.D [--W15], W12
002B9C  BE054F     MOV.D [--W15], W10
002B9E  BE044F     MOV.D [--W15], W8
002BA0  BE034F     MOV.D [--W15], W6
002BA2  BE024F     MOV.D [--W15], W4
002BA4  BE014F     MOV.D [--W15], W2
002BA6  BE004F     MOV.D [--W15], W0
002BA8  F90042     POP SR
299:               
300:               	/* Simulate the end of the yield function. */
301:               	asm volatile ( "return" );
002BAA  060000     RETURN
302:               
303:               	/* Should not reach here. */
304:               	return pdTRUE;
305:               }
002BAC  200010     MOV #0x1, W0
002BAE  060000     RETURN
306:               /*-----------------------------------------------------------*/
307:               
308:               void vPortEndScheduler( void )
309:               {
310:               	/* Not implemented in ports where there is nothing to return to.
311:               	Artificially force an assert. */
312:               	configASSERT( uxCriticalNesting == 1000UL );
313:               }
002B64  060000     RETURN
314:               /*-----------------------------------------------------------*/
315:               
316:               /*
317:                * Setup a timer for a regular tick.
318:                */
319:               __attribute__(( weak )) void vApplicationSetupTickTimerInterrupt( void )
320:               {
321:               const uint32_t ulCompareMatch = ( ( configCPU_CLOCK_HZ / portTIMER_PRESCALE ) / configTICK_RATE_HZ ) - 1;
322:               
323:               	/* Prescale of 8. */
324:               	T1CON = 0;
002B66  EF2194     CLR T1CON
325:               	TMR1 = 0;
002B68  EF2190     CLR TMR1
326:               
327:               	PR1 = ( uint16_t ) ulCompareMatch;
002B6A  207CF0     MOV #0x7CF, W0
002B6C  880C90     MOV W0, PR1
328:               
329:               	/* Setup timer 1 interrupt priority. */
330:               	IPC0bits.T1IP = configKERNEL_INTERRUPT_PRIORITY;
002B6E  28FFF0     MOV #0x8FFF, W0
002B70  B600A8     AND IPC0, WREG
002B72  A0C000     BSET W0, #12
002B74  880540     MOV W0, IPC0
331:               
332:               	/* Clear the interrupt as a starting condition. */
333:               	IFS0bits.T1IF = 0;
002B76  A96088     BCLR IFS0, #3
334:               
335:               	/* Enable the interrupt. */
336:               	IEC0bits.T1IE = 1;
002B78  A86098     BSET IEC0, #3
337:               
338:               	/* Setup the prescale value. */
339:               	T1CONbits.TCKPS0 = 1;
002B7A  A88194     BSET T1CON, #4
340:               	T1CONbits.TCKPS1 = 0;
002B7C  A9A194     BCLR T1CON, #5
341:               
342:               	/* Start the timer. */
343:               	T1CONbits.TON = 1;
002B7E  A8E195     BSET 0x195, #7
344:               }
002B80  060000     RETURN
345:               /*-----------------------------------------------------------*/
346:               
347:               void vPortEnterCritical( void )
348:               {
349:               	portDISABLE_INTERRUPTS();
002BB0  2FF1F0     MOV #0xFF1F, W0
002BB2  B60042     AND SR, WREG
002BB4  A05000     BSET W0, #5
002BB6  880210     MOV W0, SR
002BB8  000000     NOP
002BBA  000000     NOP
350:               	uxCriticalNesting++;
002BBC  EC2828     INC 0x828
351:               }
002BBE  060000     RETURN
352:               /*-----------------------------------------------------------*/
353:               
354:               void vPortExitCritical( void )
355:               {
356:               	configASSERT( uxCriticalNesting );
357:               	uxCriticalNesting--;
002BC0  ED0828     DEC 0x828, WREG
002BC2  884140     MOV W0, 0x828
358:               	if( uxCriticalNesting == 0 )
002BC4  3A0003     BRA NZ, .L8
359:               	{
360:               		portENABLE_INTERRUPTS();
002BC6  2FF1F0     MOV #0xFF1F, W0
002BC8  B62042     AND SR
002BCA  000000     NOP
361:               	}
362:               }
002BCC  060000     RETURN
363:               /*-----------------------------------------------------------*/
364:               
365:               void __attribute__((__interrupt__, auto_psv)) configTICK_INTERRUPT_HANDLER( void )
366:               {
000234  F80036     PUSH RCOUNT
000236  BE9F80     MOV.D W0, [W15++]
000238  BE9F82     MOV.D W2, [W15++]
00023A  BE9F84     MOV.D W4, [W15++]
00023C  BE9F86     MOV.D W6, [W15++]
00023E  F80032     PUSH DSRPAG
000240  F80034     PUSH DSWPAG
000242  200010     MOV #0x1, W0
000244  8801A0     MOV W0, DSWPAG
000246  202000     MOV #0x200, W0
000248  880190     MOV W0, DSRPAG
367:               	/* Clear the timer interrupt. */
368:               	IFS0bits.T1IF = 0;
00024A  A96088     BCLR IFS0, #3
369:               
370:               	if( xTaskIncrementTick() != pdFALSE )
00024C  021364     CALL xTaskIncrementTick
00024E  000000     NOP
000250  E00000     CP0 W0
000252  320003     BRA Z, .L10
371:               	{
372:               		portYIELD();
000254  022DC4     CALL .Letext0, .LFE2, _vPortYield
000256  000000     NOP
000258  000000     NOP
373:               	}
374:               }
00025A  F90034     POP DSWPAG
00025C  F90032     POP DSRPAG
00025E  BE034F     MOV.D [--W15], W6
000260  BE024F     MOV.D [--W15], W4
000262  BE014F     MOV.D [--W15], W2
000264  BE004F     MOV.D [--W15], W0
000266  F90036     POP RCOUNT
000268  064000     RETFIE
375:               
---  D:/code/FreeRTOS/Source/list.c  --------------------------------------------------------------------
1:                 /*
2:                     FreeRTOS V9.0.0 - Copyright (C) 2016 Real Time Engineers Ltd.
3:                     All rights reserved
4:                 
5:                     VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
6:                 
7:                     This file is part of the FreeRTOS distribution.
8:                 
9:                     FreeRTOS is free software; you can redistribute it and/or modify it under
10:                    the terms of the GNU General Public License (version 2) as published by the
11:                    Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
12:                
13:                    ***************************************************************************
14:                    >>!   NOTE: The modification to the GPL is included to allow you to     !<<
15:                    >>!   distribute a combined work that includes FreeRTOS without being   !<<
16:                    >>!   obliged to provide the source code for proprietary components     !<<
17:                    >>!   outside of the FreeRTOS kernel.                                   !<<
18:                    ***************************************************************************
19:                
20:                    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
21:                    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
22:                    FOR A PARTICULAR PURPOSE.  Full license text is available on the following
23:                    link: http://www.freertos.org/a00114.html
24:                
25:                    ***************************************************************************
26:                     *                                                                       *
27:                     *    FreeRTOS provides completely free yet professionally developed,    *
28:                     *    robust, strictly quality controlled, supported, and cross          *
29:                     *    platform software that is more than just the market leader, it     *
30:                     *    is the industry's de facto standard.                               *
31:                     *                                                                       *
32:                     *    Help yourself get started quickly while simultaneously helping     *
33:                     *    to support the FreeRTOS project by purchasing a FreeRTOS           *
34:                     *    tutorial book, reference manual, or both:                          *
35:                     *    http://www.FreeRTOS.org/Documentation                              *
36:                     *                                                                       *
37:                    ***************************************************************************
38:                
39:                    http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
40:                    the FAQ page "My application does not run, what could be wrong?".  Have you
41:                    defined configASSERT()?
42:                
43:                    http://www.FreeRTOS.org/support - In return for receiving this top quality
44:                    embedded software for free we request you assist our global community by
45:                    participating in the support forum.
46:                
47:                    http://www.FreeRTOS.org/training - Investing in training allows your team to
48:                    be as productive as possible as early as possible.  Now you can receive
49:                    FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
50:                    Ltd, and the world's leading authority on the world's leading RTOS.
51:                
52:                    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
53:                    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
54:                    compatible FAT file system, and our tiny thread aware UDP/IP stack.
55:                
56:                    http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
57:                    Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
58:                
59:                    http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
60:                    Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
61:                    licenses offer ticketed support, indemnification and commercial middleware.
62:                
63:                    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
64:                    engineered and independently SIL3 certified version for use in safety and
65:                    mission critical applications that require provable dependability.
66:                
67:                    1 tab == 4 spaces!
68:                */
69:                
70:                
71:                #include <stdlib.h>
72:                #include "FreeRTOS.h"
73:                #include "list.h"
74:                
75:                /*-----------------------------------------------------------
76:                 * PUBLIC LIST API documented in list.h
77:                 *----------------------------------------------------------*/
78:                
79:                void vListInitialise( List_t * const pxList )
80:                {
81:                	/* The list structure contains a list item which is used to mark the
82:                	end of the list.  To initialise the list the list end is inserted
83:                	as the only list entry. */
84:                	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
002CFA  4000E4     ADD W0, #0x4, W1
002CFC  980011     MOV W1, [W0+2]
85:                
86:                	/* The list end value is the highest possible value in the list to
87:                	ensure it remains at the end of the list. */
88:                	pxList->xListEnd.xItemValue = portMAX_DELAY;
002CFE  EB8100     SETM W2
002D00  980022     MOV W2, [W0+4]
89:                
90:                	/* The list end next and previous pointers point to itself so we know
91:                	when the list is empty. */
92:                	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
002D02  980031     MOV W1, [W0+6]
93:                	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
002D04  980041     MOV W1, [W0+8]
94:                
95:                	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
002D06  EB0800     CLR [W0]
96:                
97:                	/* Write known values into the list if
98:                	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
99:                	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
100:               	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
101:               }
002D08  060000     RETURN
102:               /*-----------------------------------------------------------*/
103:               
104:               void vListInitialiseItem( ListItem_t * const pxItem )
105:               {
106:               	/* Make sure the list item is not recorded as being on a list. */
107:               	pxItem->pvContainer = NULL;
002D0A  EB0080     CLR W1
002D0C  980041     MOV W1, [W0+8]
108:               
109:               	/* Write known values into the list item if
110:               	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
111:               	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
112:               	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
113:               }
002D0E  060000     RETURN
114:               /*-----------------------------------------------------------*/
115:               
116:               void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
117:               {
118:               ListItem_t * const pxIndex = pxList->pxIndex;
002D10  900110     MOV [W0+2], W2
119:               
120:               	/* Only effective when configASSERT() is also defined, these tests may catch
121:               	the list data structures being overwritten in memory.  They will not catch
122:               	data errors caused by incorrect configuration or use of FreeRTOS. */
123:               	listTEST_LIST_INTEGRITY( pxList );
124:               	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );
125:               
126:               	/* Insert a new list item into pxList, but rather than sort the list,
127:               	makes the new list item the last item to be removed by a call to
128:               	listGET_OWNER_OF_NEXT_ENTRY(). */
129:               	pxNewListItem->pxNext = pxIndex;
002D12  980092     MOV W2, [W1+2]
130:               	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
002D14  9001A2     MOV [W2+4], W3
002D16  9800A3     MOV W3, [W1+4]
131:               
132:               	/* Only used during decision coverage testing. */
133:               	mtCOVERAGE_TEST_DELAY();
134:               
135:               	pxIndex->pxPrevious->pxNext = pxNewListItem;
002D18  9001A2     MOV [W2+4], W3
002D1A  980191     MOV W1, [W3+2]
136:               	pxIndex->pxPrevious = pxNewListItem;
002D1C  980121     MOV W1, [W2+4]
137:               
138:               	/* Remember which list the item is in. */
139:               	pxNewListItem->pvContainer = ( void * ) pxList;
002D1E  9800C0     MOV W0, [W1+8]
140:               
141:               	( pxList->uxNumberOfItems )++;
002D20  E80810     INC [W0], [W0]
142:               }
002D22  060000     RETURN
143:               /*-----------------------------------------------------------*/
144:               
145:               void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
146:               {
147:               ListItem_t *pxIterator;
148:               const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
002D24  780211     MOV [W1], W4
149:               
150:               	/* Only effective when configASSERT() is also defined, these tests may catch
151:               	the list data structures being overwritten in memory.  They will not catch
152:               	data errors caused by incorrect configuration or use of FreeRTOS. */
153:               	listTEST_LIST_INTEGRITY( pxList );
154:               	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );
155:               
156:               	/* Insert the new list item into the list, sorted in xItemValue order.
157:               
158:               	If the list already contains a list item with the same item value then the
159:               	new list item should be placed after it.  This ensures that TCB's which are
160:               	stored in ready lists (all of which have the same xItemValue value) get a
161:               	share of the CPU.  However, if the xItemValue is the same as the back marker
162:               	the iteration loop below will not end.  Therefore the value is checked
163:               	first, and the algorithm slightly modified if necessary. */
164:               	if( xValueOfInsertion == portMAX_DELAY )
002D26  420FE1     ADD W4, #0x1, [W15]
002D28  3A0002     BRA NZ, .L5
165:               	{
166:               		pxIterator = pxList->xListEnd.pxPrevious;
002D2A  9001C0     MOV [W0+8], W3
002D2C  370006     BRA .L6
167:               	}
168:               	else
169:               	{
170:               		/* *** NOTE ***********************************************************
171:               		If you find your application is crashing here then likely causes are
172:               		listed below.  In addition see http://www.freertos.org/FAQHelp.html for
173:               		more tips, and ensure configASSERT() is defined!
174:               		http://www.freertos.org/a00110.html#configASSERT
175:               
176:               			1) Stack overflow -
177:               			   see http://www.freertos.org/Stacks-and-stack-overflow-checking.html
178:               			2) Incorrect interrupt priority assignment, especially on Cortex-M
179:               			   parts where numerically high priority values denote low actual
180:               			   interrupt priorities, which can seem counter intuitive.  See
181:               			   http://www.freertos.org/RTOS-Cortex-M3-M4.html and the definition
182:               			   of configMAX_SYSCALL_INTERRUPT_PRIORITY on
183:               			   http://www.freertos.org/a00110.html
184:               			3) Calling an API function from within a critical section or when
185:               			   the scheduler is suspended, or calling an API function that does
186:               			   not end in "FromISR" from an interrupt.
187:               			4) Using a queue or semaphore before it has been initialised or
188:               			   before the scheduler has been started (are interrupts firing
189:               			   before vTaskStartScheduler() has been called?).
190:               		**********************************************************************/
191:               
192:               		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
002D2E  4001E4     ADD W0, #0x4, W3
002D30  370001     BRA .L7
002D32  780182     MOV W2, W3
002D34  900113     MOV [W3+2], W2
002D36  520F92     SUB W4, [W2], [W15]
002D38  31FFFC     BRA C, .L8
193:               		{
194:               			/* There is nothing to do here, just iterating to the wanted
195:               			insertion position. */
196:               		}
197:               	}
198:               
199:               	pxNewListItem->pxNext = pxIterator->pxNext;
002D3A  900113     MOV [W3+2], W2
002D3C  980092     MOV W2, [W1+2]
200:               	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
002D3E  980121     MOV W1, [W2+4]
201:               	pxNewListItem->pxPrevious = pxIterator;
002D40  9800A3     MOV W3, [W1+4]
202:               	pxIterator->pxNext = pxNewListItem;
002D42  980191     MOV W1, [W3+2]
203:               
204:               	/* Remember which list the item is in.  This allows fast removal of the
205:               	item later. */
206:               	pxNewListItem->pvContainer = ( void * ) pxList;
002D44  9800C0     MOV W0, [W1+8]
207:               
208:               	( pxList->uxNumberOfItems )++;
002D46  E80810     INC [W0], [W0]
209:               }
002D48  060000     RETURN
210:               /*-----------------------------------------------------------*/
211:               
212:               UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
213:               {
214:               /* The list item knows which list it is in.  Obtain the list from the list
215:               item. */
216:               List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
002D4A  9000C0     MOV [W0+8], W1
217:               
218:               	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
002D4C  900110     MOV [W0+2], W2
002D4E  9001A0     MOV [W0+4], W3
002D50  980123     MOV W3, [W2+4]
219:               	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
002D52  900120     MOV [W0+4], W2
002D54  900190     MOV [W0+2], W3
002D56  980113     MOV W3, [W2+2]
220:               
221:               	/* Only used during decision coverage testing. */
222:               	mtCOVERAGE_TEST_DELAY();
223:               
224:               	/* Make sure the index is left pointing to a valid item. */
225:               	if( pxList->pxIndex == pxItemToRemove )
002D58  900111     MOV [W1+2], W2
002D5A  510F80     SUB W2, W0, [W15]
002D5C  3A0002     BRA NZ, .L10
226:               	{
227:               		pxList->pxIndex = pxItemToRemove->pxPrevious;
002D5E  900122     MOV [W2+4], W2
002D60  980092     MOV W2, [W1+2]
228:               	}
229:               	else
230:               	{
231:               		mtCOVERAGE_TEST_MARKER();
232:               	}
233:               
234:               	pxItemToRemove->pvContainer = NULL;
002D62  EB0100     CLR W2
002D64  980042     MOV W2, [W0+8]
235:               	( pxList->uxNumberOfItems )--;
002D66  E90011     DEC [W1], W0
002D68  780880     MOV W0, [W1]
236:               
237:               	return pxList->uxNumberOfItems;
238:               }
002D6A  060000     RETURN
239:               /*-----------------------------------------------------------*/
240:               
---  D:/code/FreeRTOS/Source/croutine.c  ----------------------------------------------------------------
1:                 /*
2:                     FreeRTOS V9.0.0 - Copyright (C) 2016 Real Time Engineers Ltd.
3:                     All rights reserved
4:                 
5:                     VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
6:                 
7:                     This file is part of the FreeRTOS distribution.
8:                 
9:                     FreeRTOS is free software; you can redistribute it and/or modify it under
10:                    the terms of the GNU General Public License (version 2) as published by the
11:                    Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
12:                
13:                    ***************************************************************************
14:                    >>!   NOTE: The modification to the GPL is included to allow you to     !<<
15:                    >>!   distribute a combined work that includes FreeRTOS without being   !<<
16:                    >>!   obliged to provide the source code for proprietary components     !<<
17:                    >>!   outside of the FreeRTOS kernel.                                   !<<
18:                    ***************************************************************************
19:                
20:                    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
21:                    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
22:                    FOR A PARTICULAR PURPOSE.  Full license text is available on the following
23:                    link: http://www.freertos.org/a00114.html
24:                
25:                    ***************************************************************************
26:                     *                                                                       *
27:                     *    FreeRTOS provides completely free yet professionally developed,    *
28:                     *    robust, strictly quality controlled, supported, and cross          *
29:                     *    platform software that is more than just the market leader, it     *
30:                     *    is the industry's de facto standard.                               *
31:                     *                                                                       *
32:                     *    Help yourself get started quickly while simultaneously helping     *
33:                     *    to support the FreeRTOS project by purchasing a FreeRTOS           *
34:                     *    tutorial book, reference manual, or both:                          *
35:                     *    http://www.FreeRTOS.org/Documentation                              *
36:                     *                                                                       *
37:                    ***************************************************************************
38:                
39:                    http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
40:                    the FAQ page "My application does not run, what could be wrong?".  Have you
41:                    defined configASSERT()?
42:                
43:                    http://www.FreeRTOS.org/support - In return for receiving this top quality
44:                    embedded software for free we request you assist our global community by
45:                    participating in the support forum.
46:                
47:                    http://www.FreeRTOS.org/training - Investing in training allows your team to
48:                    be as productive as possible as early as possible.  Now you can receive
49:                    FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
50:                    Ltd, and the world's leading authority on the world's leading RTOS.
51:                
52:                    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
53:                    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
54:                    compatible FAT file system, and our tiny thread aware UDP/IP stack.
55:                
56:                    http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
57:                    Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
58:                
59:                    http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
60:                    Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
61:                    licenses offer ticketed support, indemnification and commercial middleware.
62:                
63:                    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
64:                    engineered and independently SIL3 certified version for use in safety and
65:                    mission critical applications that require provable dependability.
66:                
67:                    1 tab == 4 spaces!
68:                */
69:                
70:                #include "FreeRTOS.h"
71:                #include "task.h"
72:                #include "croutine.h"
73:                
74:                /* Remove the whole file is co-routines are not being used. */
75:                #if( configUSE_CO_ROUTINES != 0 )
76:                
77:                /*
78:                 * Some kernel aware debuggers require data to be viewed to be global, rather
79:                 * than file scope.
80:                 */
81:                #ifdef portREMOVE_STATIC_QUALIFIER
82:                	#define static
83:                #endif
84:                
85:                
86:                /* Lists for ready and blocked co-routines. --------------------*/
87:                static List_t pxReadyCoRoutineLists[ configMAX_CO_ROUTINE_PRIORITIES ];	/*< Prioritised ready co-routines. */
88:                static List_t xDelayedCoRoutineList1;									/*< Delayed co-routines. */
89:                static List_t xDelayedCoRoutineList2;									/*< Delayed co-routines (two lists are used - one for delays that have overflowed the current tick count. */
90:                static List_t * pxDelayedCoRoutineList;									/*< Points to the delayed co-routine list currently being used. */
91:                static List_t * pxOverflowDelayedCoRoutineList;							/*< Points to the delayed co-routine list currently being used to hold co-routines that have overflowed the current tick count. */
92:                static List_t xPendingReadyCoRoutineList;								/*< Holds co-routines that have been readied by an external event.  They cannot be added directly to the ready lists as the ready lists cannot be accessed by interrupts. */
93:                
94:                /* Other file private variables. --------------------------------*/
95:                CRCB_t * pxCurrentCoRoutine = NULL;
96:                static UBaseType_t uxTopCoRoutineReadyPriority = 0;
97:                static TickType_t xCoRoutineTickCount = 0, xLastTickCount = 0, xPassedTicks = 0;
98:                
99:                /* The initial state of the co-routine when it is created. */
100:               #define corINITIAL_STATE	( 0 )
101:               
102:               /*
103:                * Place the co-routine represented by pxCRCB into the appropriate ready queue
104:                * for the priority.  It is inserted at the end of the list.
105:                *
106:                * This macro accesses the co-routine ready lists and therefore must not be
107:                * used from within an ISR.
108:                */
109:               #define prvAddCoRoutineToReadyQueue( pxCRCB )																		\
110:               {																													\
111:               	if( pxCRCB->uxPriority > uxTopCoRoutineReadyPriority )															\
112:               	{																												\
113:               		uxTopCoRoutineReadyPriority = pxCRCB->uxPriority;															\
114:               	}																												\
115:               	vListInsertEnd( ( List_t * ) &( pxReadyCoRoutineLists[ pxCRCB->uxPriority ] ), &( pxCRCB->xGenericListItem ) );	\
116:               }
117:               
118:               /*
119:                * Utility to ready all the lists used by the scheduler.  This is called
120:                * automatically upon the creation of the first co-routine.
121:                */
122:               static void prvInitialiseCoRoutineLists( void );
123:               
124:               /*
125:                * Co-routines that are readied by an interrupt cannot be placed directly into
126:                * the ready lists (there is no mutual exclusion).  Instead they are placed in
127:                * in the pending ready list in order that they can later be moved to the ready
128:                * list by the co-routine scheduler.
129:                */
130:               static void prvCheckPendingReadyList( void );
131:               
132:               /*
133:                * Macro that looks at the list of co-routines that are currently delayed to
134:                * see if any require waking.
135:                *
136:                * Co-routines are stored in the queue in the order of their wake time -
137:                * meaning once one co-routine has been found whose timer has not expired
138:                * we need not look any further down the list.
139:                */
140:               static void prvCheckDelayedList( void );
141:               
142:               /*-----------------------------------------------------------*/
143:               
144:               BaseType_t xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, UBaseType_t uxPriority, UBaseType_t uxIndex )
145:               {
00245C  BE9F88     MOV.D W8, [W15++]
00245E  BE9F8A     MOV.D W10, [W15++]
002460  780580     MOV W0, W11
002462  780501     MOV W1, W10
002464  780482     MOV W2, W9
146:               BaseType_t xReturn;
147:               CRCB_t *pxCoRoutine;
148:               
149:               	/* Allocate the memory that will store the co-routine control block. */
150:               	pxCoRoutine = ( CRCB_t * ) pvPortMalloc( sizeof( CRCB_t ) );
002466  2001C0     MOV #0x1C, W0
002468  022E18     CALL pvPortMalloc
00246A  000000     NOP
00246C  780400     MOV W0, W8
151:               	if( pxCoRoutine )
002470  E00008     CP0 W8
002472  320022     BRA Z, .L34
152:               	{
153:               		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
154:               		be created and the co-routine data structures need initialising. */
155:               		if( pxCurrentCoRoutine == NULL )
002474  E2087C     CP0 pxCurrentCoRoutine
002476  3A0002     BRA NZ, .L35
156:               		{
157:               			pxCurrentCoRoutine = pxCoRoutine;
158:               			prvInitialiseCoRoutineLists();
002478  8843E8     MOV W8, pxCurrentCoRoutine
00247A  07FFDC     RCALL prvInitialiseCoRoutineLists
00247C  E0000A     CP0 W10
00247E  320001     BRA Z, .L36
002480  20001A     MOV #0x1, W10
159:               		}
160:               
161:               		/* Check the priority is within limits. */
162:               		if( uxPriority >= configMAX_CO_ROUTINE_PRIORITIES )
163:               		{
164:               			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
165:               		}
166:               
167:               		/* Fill out the co-routine control block from the function parameters. */
168:               		pxCoRoutine->uxState = corINITIAL_STATE;
002482  EB0000     CLR W0
002484  980C50     MOV W0, [W8+26]
169:               		pxCoRoutine->uxPriority = uxPriority;
002486  980C3A     MOV W10, [W8+22]
170:               		pxCoRoutine->uxIndex = uxIndex;
002488  980C49     MOV W9, [W8+24]
171:               		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
00248A  780488     MOV W8, W9
00248C  781C8B     MOV W11, [W9++]
172:               
173:               		/* Initialise all the other co-routine control block parameters. */
174:               		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
00248E  780009     MOV W9, W0
002490  022D0A     CALL vListInitialiseItem
002492  000000     NOP
175:               		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
002494  44006C     ADD W8, #0xC, W0
002496  022D0A     CALL vListInitialiseItem
002498  000000     NOP
176:               
177:               		/* Set the co-routine control block as a link back from the ListItem_t.
178:               		This is so we can get back to the containing CRCB from a generic item
179:               		in a list. */
180:               		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
00249A  980448     MOV W8, [W8+8]
181:               		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
00249C  980C18     MOV W8, [W8+18]
182:               
183:               		/* Event lists are always in priority order. */
184:               		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), ( ( TickType_t ) configMAX_CO_ROUTINE_PRIORITIES - ( TickType_t ) uxPriority ) );
00249E  150562     SUBR W10, #0x2, W10
0024A0  98046A     MOV W10, [W8+12]
185:               
186:               		/* Now the co-routine has been initialised it can be added to the ready
187:               		list at the correct priority. */
188:               		prvAddCoRoutineToReadyQueue( pxCoRoutine );
0024A2  900838     MOV [W8+22], W0
0024A4  E3087E     CP uxTopCoRoutineReadyPriority
0024A6  310001     BRA C, .L37
0024A8  8843F0     MOV W0, uxTopCoRoutineReadyPriority
0024AA  B9006A     MUL.SU W0, #10, W0
0024AC  21D482     MOV #0x1D48, W2
0024AE  410000     ADD W2, W0, W0
0024B0  780089     MOV W9, W1
0024B2  022D10     CALL vListInsertEnd
0024B4  000000     NOP
189:               
190:               		xReturn = pdPASS;
0024B6  200010     MOV #0x1, W0
191:               	}
192:               	else
193:               	{
194:               		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
00246E  EB8000     SETM W0
195:               	}
196:               
197:               	return xReturn;
198:               }
0024B8  BE054F     MOV.D [--W15], W10
0024BA  BE044F     MOV.D [--W15], W8
0024BC  060000     RETURN
199:               /*-----------------------------------------------------------*/
200:               
201:               void vCoRoutineAddToDelayedList( TickType_t xTicksToDelay, List_t *pxEventList )
202:               {
0022B4  BE9F88     MOV.D W8, [W15++]
0022B6  780401     MOV W1, W8
203:               TickType_t xTimeToWake;
204:               
205:               	/* Calculate the time to wake - this may overflow but this is
206:               	not a problem. */
207:               	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
0022B8  804409     MOV xCoRoutineTickCount, W9
0022BA  400489     ADD W0, W9, W9
208:               
209:               	/* We must remove ourselves from the ready list before adding
210:               	ourselves to the blocked list as the same list item is used for
211:               	both lists. */
212:               	( void ) uxListRemove( ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
0022BC  EC887C     INC2 pxCurrentCoRoutine, WREG
0022BE  022D4A     CALL uxListRemove
0022C0  000000     NOP
213:               
214:               	/* The list item will be inserted in wake time order. */
215:               	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
0022C2  8043E1     MOV pxCurrentCoRoutine, W1
0022C4  980099     MOV W9, [W1+2]
216:               
217:               	if( xTimeToWake < xCoRoutineTickCount )
0022C6  804400     MOV xCoRoutineTickCount, W0
0022C8  500F89     SUB W0, W9, [W15]
0022CA  360005     BRA LEU, .L2
218:               	{
219:               		/* Wake time has overflowed.  Place this item in the
220:               		overflow list. */
221:               		vListInsert( ( List_t * ) pxOverflowDelayedCoRoutineList, ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
0022CC  E88081     INC2 W1, W1
0022CE  804440     MOV pxOverflowDelayedCoRoutineList, W0
0022D0  022D24     CALL vListInsert
0022D2  000000     NOP
0022D4  370004     BRA .L3
222:               	}
223:               	else
224:               	{
225:               		/* The wake time has not overflowed, so we can use the
226:               		current block list. */
227:               		vListInsert( ( List_t * ) pxDelayedCoRoutineList, ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
0022D6  E88081     INC2 W1, W1
0022D8  804430     MOV pxDelayedCoRoutineList, W0
0022DA  022D24     CALL vListInsert
0022DC  000000     NOP
228:               	}
229:               
230:               	if( pxEventList )
0022DE  E00008     CP0 W8
0022E0  320005     BRA Z, .L1
231:               	{
232:               		/* Also add the co-routine to an event list.  If this is done then the
233:               		function must be called with interrupts disabled. */
234:               		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
0022E2  8043E1     MOV pxCurrentCoRoutine, W1
0022E4  4080EC     ADD W1, #0xC, W1
0022E6  780008     MOV W8, W0
0022E8  022D24     CALL vListInsert
0022EA  000000     NOP
235:               	}
236:               }
0022EC  BE044F     MOV.D [--W15], W8
0022EE  060000     RETURN
237:               /*-----------------------------------------------------------*/
238:               
239:               static void prvCheckPendingReadyList( void )
240:               {
0022F0  BE9F88     MOV.D W8, [W15++]
0022F2  BE9F8A     MOV.D W10, [W15++]
241:               	/* Are there any co-routines waiting to get moved to the ready list?  These
242:               	are co-routines that have been readied by an ISR.  The ISR cannot access
243:               	the	ready lists itself. */
244:               	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
0022F4  80EB80     MOV xPendingReadyCoRoutineList, W0
0022F6  E00000     CP0 W0
0022F8  320020     BRA Z, .L5
0022FC  21D70B     MOV #0x1D70, W11
002336  E0001B     CP0 [W11]
002338  3AFFE2     BRA NZ, .L9
245:               	{
246:               		CRCB_t *pxUnblockedCRCB;
247:               
248:               		/* The pending ready list can be accessed by an ISR. */
249:               		portDISABLE_INTERRUPTS();
0022FE  2FF1F9     MOV #0xFF1F, W9
002300  800211     MOV SR, W1
002302  648001     AND W9, W1, W0
002304  A05000     BSET W0, #5
002306  880210     MOV W0, SR
002308  000000     NOP
00230A  000000     NOP
250:               		{
251:               			pxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );
00230C  80EBB0     MOV 0x1D76, W0
00230E  900430     MOV [W0+6], W8
252:               			( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
002310  44006C     ADD W8, #0xC, W0
002312  022D4A     CALL uxListRemove
002314  000000     NOP
253:               		}
254:               		portENABLE_INTERRUPTS();
002316  200420     MOV #0x42, W0
002318  648810     AND W9, [W0], [W0]
00231A  000000     NOP
255:               
256:               		( void ) uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
00231C  E88488     INC2 W8, W9
00231E  780009     MOV W9, W0
002320  022D4A     CALL uxListRemove
002322  000000     NOP
257:               		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
0022FA  21D48A     MOV #0x1D48, W10
002324  900838     MOV [W8+22], W0
002326  E3087E     CP uxTopCoRoutineReadyPriority
002328  310001     BRA C, .L7
00232A  8843F0     MOV W0, uxTopCoRoutineReadyPriority
00232C  B9006A     MUL.SU W0, #10, W0
00232E  450000     ADD W10, W0, W0
002330  780089     MOV W9, W1
002332  022D10     CALL vListInsertEnd
002334  000000     NOP
258:               	}
259:               }
00233A  BE054F     MOV.D [--W15], W10
00233C  BE044F     MOV.D [--W15], W8
00233E  060000     RETURN
260:               /*-----------------------------------------------------------*/
261:               
262:               static void prvCheckDelayedList( void )
263:               {
002340  BE9F88     MOV.D W8, [W15++]
002342  BE9F8A     MOV.D W10, [W15++]
264:               CRCB_t *pxCRCB;
265:               
266:               	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
002344  0210AE     CALL xTaskGetTickCount
002346  000000     NOP
002348  804411     MOV xLastTickCount, W1
00234A  500001     SUB W0, W1, W0
00234C  884420     MOV W0, xPassedTicks
267:               	while( xPassedTicks )
002352  370037     BRA .L22
0023C2  804421     MOV xPassedTicks, W1
0023C4  E00001     CP0 W1
0023C6  3AFFC6     BRA NZ, .L19
268:               	{
269:               		xCoRoutineTickCount++;
002354  EC0880     INC xCoRoutineTickCount, WREG
002356  884400     MOV W0, xCoRoutineTickCount
270:               		xPassedTicks--;
002358  E90081     DEC W1, W1
00235A  884421     MOV W1, xPassedTicks
271:               
272:               		/* If the tick count has overflowed we need to swap the ready lists. */
273:               		if( xCoRoutineTickCount == 0 )
00235C  E00000     CP0 W0
00235E  3A0004     BRA NZ, .L13, .LBE4
274:               		{
275:               			List_t * pxTemp;
276:               
277:               			/* Tick count has overflowed so we need to swap the delay lists.  If there are
278:               			any items in pxDelayedCoRoutineList here then there is an error! */
279:               			pxTemp = pxDelayedCoRoutineList;
002360  804431     MOV pxDelayedCoRoutineList, W1
280:               			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
002362  F80888     PUSH pxOverflowDelayedCoRoutineList
002364  F90886     POP pxDelayedCoRoutineList
281:               			pxOverflowDelayedCoRoutineList = pxTemp;
002366  884441     MOV W1, pxOverflowDelayedCoRoutineList
282:               		}
283:               
284:               		/* See if this tick has made a timeout expire. */
285:               		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
002368  804431     MOV pxDelayedCoRoutineList, W1
00236A  E00011     CP0 [W1]
00236C  32002A     BRA Z, .L22
0023BC  804430     MOV pxDelayedCoRoutineList, W0
0023BE  E00010     CP0 [W0]
0023C0  3AFFDC     BRA NZ, .L18
286:               		{
287:               			pxCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
00236E  9000B1     MOV [W1+6], W1
002370  900431     MOV [W1+6], W8
00237A  900030     MOV [W0+6], W0
00237C  900430     MOV [W0+6], W8
288:               
289:               			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )
002372  900098     MOV [W8+2], W1
002374  500F81     SUB W0, W1, [W15]
002376  310006     BRA C, .L24
002378  370024     BRA .L22
00237E  900018     MOV [W8+2], W0
002380  E30880     CP xCoRoutineTickCount
002382  39001F     BRA NC, .L22
290:               			{
291:               				/* Timeout not yet expired. */
292:               				break;
293:               			}
294:               
295:               			portDISABLE_INTERRUPTS();
00234E  2FF1FA     MOV #0xFF1F, W10
002384  800211     MOV SR, W1
002386  650001     AND W10, W1, W0
002388  A05000     BSET W0, #5
00238A  880210     MOV W0, SR
00238C  000000     NOP
00238E  000000     NOP
296:               			{
297:               				/* The event could have occurred just before this critical
298:               				section.  If this is the case then the generic list item will
299:               				have been moved to the pending ready list and the following
300:               				line is still valid.  Also the pvContainer parameter will have
301:               				been set to NULL so the following lines are also valid. */
302:               				( void ) uxListRemove( &( pxCRCB->xGenericListItem ) );
002390  E88488     INC2 W8, W9
002392  780009     MOV W9, W0
002394  022D4A     CALL uxListRemove
002396  000000     NOP
303:               
304:               				/* Is the co-routine waiting on an event also? */
305:               				if( pxCRCB->xEventListItem.pvContainer )
002398  900828     MOV [W8+20], W0
00239A  E00000     CP0 W0
00239C  320003     BRA Z, .L16
306:               				{
307:               					( void ) uxListRemove( &( pxCRCB->xEventListItem ) );
00239E  44006C     ADD W8, #0xC, W0
0023A0  022D4A     CALL uxListRemove
0023A2  000000     NOP
308:               				}
309:               			}
310:               			portENABLE_INTERRUPTS();
0023A4  200420     MOV #0x42, W0
0023A6  650810     AND W10, [W0], [W0]
0023A8  000000     NOP
311:               
312:               			prvAddCoRoutineToReadyQueue( pxCRCB );
002350  21D48B     MOV #0x1D48, W11
0023AA  900838     MOV [W8+22], W0
0023AC  E3087E     CP uxTopCoRoutineReadyPriority
0023AE  310001     BRA C, .L17
0023B0  8843F0     MOV W0, uxTopCoRoutineReadyPriority
0023B2  B9006A     MUL.SU W0, #10, W0
0023B4  458000     ADD W11, W0, W0
0023B6  780089     MOV W9, W1
0023B8  022D10     CALL vListInsertEnd
0023BA  000000     NOP
313:               		}
314:               	}
315:               
316:               	xLastTickCount = xCoRoutineTickCount;
0023C8  F80880     PUSH xCoRoutineTickCount
0023CA  F90882     POP xLastTickCount
317:               }
0023CC  BE054F     MOV.D [--W15], W10
0023CE  BE044F     MOV.D [--W15], W8
318:               /*-----------------------------------------------------------*/
319:               
320:               void vCoRoutineSchedule( void )
0023E8  B9116A     MUL.SU W2, #10, W2
0023EA  21D481     MOV #0x1D48, W1
0023EC  408082     ADD W1, W2, W1
0023EE  370005     BRA .L28
321:               {
322:               	/* See if any co-routines readied by events need moving to the ready lists. */
323:               	prvCheckPendingReadyList();
0023D0  060000     RETURN
324:               
325:               	/* See if any delayed co-routines have timed out. */
326:               	prvCheckDelayedList();
0023D2  07FF8E     RCALL prvCheckPendingReadyList
0023D4  07FFB5     RCALL prvCheckDelayedList
327:               
328:               	/* Find the highest priority queue that contains ready co-routines. */
329:               	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
0023D6  8043F0     MOV uxTopCoRoutineReadyPriority, W0
0023D8  B9016A     MUL.SU W0, #10, W2
0023DA  21D481     MOV #0x1D48, W1
0023DC  7900E1     MOV [W1+W2], W1
0023DE  E00001     CP0 W1
0023E0  3A0010     BRA NZ, .L26, .LBB5
0023E6  E90100     DEC W0, W2
0023FC  E00011     CP0 [W1]
0023FE  32FFF8     BRA Z, .L29
002400  8843F0     MOV W0, uxTopCoRoutineReadyPriority
330:               	{
331:               		if( uxTopCoRoutineReadyPriority == 0 )
0023E2  E00000     CP0 W0
0023E4  320026     BRA Z, .L25
0023F0  5080EA     SUB W1, #0xA, W1
0023F2  E00000     CP0 W0
0023F4  3A0002     BRA NZ, .L28
0023F6  8843F0     MOV W0, uxTopCoRoutineReadyPriority
0023F8  37001C     BRA .L25
332:               		{
333:               			/* No more co-routines to check. */
334:               			return;
335:               		}
336:               		--uxTopCoRoutineReadyPriority;
0023FA  E90000     DEC W0, W0
337:               	}
338:               
339:               	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
340:               	 of the	same priority get an equal share of the processor time. */
341:               	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
002402  B9016A     MUL.SU W0, #10, W2
002404  E88182     INC2 W2, W3
002406  21D481     MOV #0x1D48, W1
002408  7981E1     MOV [W1+W3], W3
00240A  900193     MOV [W3+2], W3
00240C  408202     ADD W1, W2, W4
00240E  980213     MOV W3, [W4+2]
002410  410164     ADD W2, #0x4, W2
002412  410081     ADD W2, W1, W1
002414  518F81     SUB W3, W1, [W15]
002416  3A0004     BRA NZ, .L30
002418  B9026A     MUL.SU W0, #10, W4
00241A  21D4A1     MOV #0x1D4A, W1
00241C  900193     MOV [W3+2], W3
00241E  7A3083     MOV W3, [W1+W4]
002420  B9006A     MUL.SU W0, #10, W0
002422  E88000     INC2 W0, W0
002424  21D481     MOV #0x1D48, W1
002426  780061     MOV [W1+W0], W0
002428  900030     MOV [W0+6], W0
00242A  8843E0     MOV W0, pxCurrentCoRoutine
342:               
343:               	/* Call the co-routine. */
344:               	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
00242C  9008C0     MOV [W0+24], W1
00242E  780110     MOV [W0], W2
002430  010002     CALL W2
345:               
346:               	return;
347:               }
002432  060000     RETURN
348:               /*-----------------------------------------------------------*/
349:               
350:               static void prvInitialiseCoRoutineLists( void )
351:               {
352:               UBaseType_t uxPriority;
353:               
354:               	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
355:               	{
356:               		vListInitialise( ( List_t * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
002434  21D480     MOV #0x1D48, W0
002436  022CFA     CALL vListInitialise
002438  000000     NOP
00243A  21D520     MOV #0x1D52, W0
00243C  022CFA     CALL vListInitialise
00243E  000000     NOP
357:               	}
358:               
359:               	vListInitialise( ( List_t * ) &xDelayedCoRoutineList1 );
002440  21D5C0     MOV #0x1D5C, W0
002442  022CFA     CALL vListInitialise
002444  000000     NOP
360:               	vListInitialise( ( List_t * ) &xDelayedCoRoutineList2 );
002446  21D660     MOV #0x1D66, W0
002448  022CFA     CALL vListInitialise
00244A  000000     NOP
361:               	vListInitialise( ( List_t * ) &xPendingReadyCoRoutineList );
00244C  21D700     MOV #0x1D70, W0
00244E  022CFA     CALL vListInitialise
002450  000000     NOP
362:               
363:               	/* Start with pxDelayedCoRoutineList using list1 and the
364:               	pxOverflowDelayedCoRoutineList using list2. */
365:               	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
002452  21D5C0     MOV #0x1D5C, W0
002454  884430     MOV W0, pxDelayedCoRoutineList
366:               	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
002456  21D660     MOV #0x1D66, W0
002458  884440     MOV W0, pxOverflowDelayedCoRoutineList
367:               }
00245A  060000     RETURN
368:               /*-----------------------------------------------------------*/
369:               
370:               BaseType_t xCoRoutineRemoveFromEventList( const List_t *pxEventList )
371:               {
0024BE  BE9F88     MOV.D W8, [W15++]
372:               CRCB_t *pxUnblockedCRCB;
373:               BaseType_t xReturn;
374:               
375:               	/* This function is called from within an interrupt.  It can only access
376:               	event lists and the pending ready list.  This function assumes that a
377:               	check has already been made to ensure pxEventList is not empty. */
378:               	pxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
0024C0  900030     MOV [W0+6], W0
0024C2  9004B0     MOV [W0+6], W9
379:               	( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
0024C4  44846C     ADD W9, #0xC, W8
0024C6  780008     MOV W8, W0
0024C8  022D4A     CALL uxListRemove
0024CA  000000     NOP
380:               	vListInsertEnd( ( List_t * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
0024CC  780088     MOV W8, W1
0024CE  21D700     MOV #0x1D70, W0
0024D0  022D10     CALL vListInsertEnd
0024D2  000000     NOP
381:               
382:               	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
383:               	{
384:               		xReturn = pdTRUE;
0024D4  200010     MOV #0x1, W0
0024D6  900939     MOV [W9+22], W2
0024D8  8043E1     MOV pxCurrentCoRoutine, W1
0024DA  9008B1     MOV [W1+22], W1
0024DC  510F81     SUB W2, W1, [W15]
0024DE  310001     BRA C, .L40
0024E0  EB0000     CLR W0
385:               	}
386:               	else
387:               	{
388:               		xReturn = pdFALSE;
389:               	}
390:               
391:               	return xReturn;
392:               }
0024E2  BE044F     MOV.D [--W15], W8
0024E4  060000     RETURN
393:               
394:               #endif /* configUSE_CO_ROUTINES == 0 */
395:               
---  D:/code/FreeRTOS/Demo/PIC24_MPLAB/timertest.c  -----------------------------------------------------
1:                 /*
2:                     FreeRTOS V9.0.0 - Copyright (C) 2016 Real Time Engineers Ltd.
3:                     All rights reserved
4:                 
5:                     VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
6:                 
7:                     This file is part of the FreeRTOS distribution.
8:                 
9:                     FreeRTOS is free software; you can redistribute it and/or modify it under
10:                    the terms of the GNU General Public License (version 2) as published by the
11:                    Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
12:                
13:                    ***************************************************************************
14:                    >>!   NOTE: The modification to the GPL is included to allow you to     !<<
15:                    >>!   distribute a combined work that includes FreeRTOS without being   !<<
16:                    >>!   obliged to provide the source code for proprietary components     !<<
17:                    >>!   outside of the FreeRTOS kernel.                                   !<<
18:                    ***************************************************************************
19:                
20:                    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
21:                    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
22:                    FOR A PARTICULAR PURPOSE.  Full license text is available on the following
23:                    link: http://www.freertos.org/a00114.html
24:                
25:                    ***************************************************************************
26:                     *                                                                       *
27:                     *    FreeRTOS provides completely free yet professionally developed,    *
28:                     *    robust, strictly quality controlled, supported, and cross          *
29:                     *    platform software that is more than just the market leader, it     *
30:                     *    is the industry's de facto standard.                               *
31:                     *                                                                       *
32:                     *    Help yourself get started quickly while simultaneously helping     *
33:                     *    to support the FreeRTOS project by purchasing a FreeRTOS           *
34:                     *    tutorial book, reference manual, or both:                          *
35:                     *    http://www.FreeRTOS.org/Documentation                              *
36:                     *                                                                       *
37:                    ***************************************************************************
38:                
39:                    http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
40:                    the FAQ page "My application does not run, what could be wrong?".  Have you
41:                    defined configASSERT()?
42:                
43:                    http://www.FreeRTOS.org/support - In return for receiving this top quality
44:                    embedded software for free we request you assist our global community by
45:                    participating in the support forum.
46:                
47:                    http://www.FreeRTOS.org/training - Investing in training allows your team to
48:                    be as productive as possible as early as possible.  Now you can receive
49:                    FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
50:                    Ltd, and the world's leading authority on the world's leading RTOS.
51:                
52:                    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
53:                    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
54:                    compatible FAT file system, and our tiny thread aware UDP/IP stack.
55:                
56:                    http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
57:                    Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
58:                
59:                    http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
60:                    Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
61:                    licenses offer ticketed support, indemnification and commercial middleware.
62:                
63:                    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
64:                    engineered and independently SIL3 certified version for use in safety and
65:                    mission critical applications that require provable dependability.
66:                
67:                    1 tab == 4 spaces!
68:                */
69:                
70:                /* High speed timer test as described in main.c. */
71:                
72:                
73:                /* Scheduler includes. */
74:                #include "FreeRTOS.h"
75:                
76:                /* Demo includes. */
77:                #include "partest.h"
78:                
79:                /* The number of interrupts to pass before we start looking at the jitter. */
80:                #define timerSETTLE_TIME			5
81:                
82:                /* The maximum value the 16bit timer can contain. */
83:                #define timerMAX_COUNT				0xffff
84:                
85:                /*-----------------------------------------------------------*/
86:                
87:                /*
88:                 * Measure the time between this interrupt and the previous interrupt to 
89:                 * calculate the timing jitter.  Remember the maximum value the jitter has
90:                 * ever been calculated to be.
91:                 */
92:                static void prvCalculateAndStoreJitter( void );
93:                
94:                /*-----------------------------------------------------------*/
95:                
96:                /* The maximum time (in processor clocks) between two consecutive timer
97:                interrupts so far. */
98:                unsigned short usMaxJitter = 0;
99:                
100:               /*-----------------------------------------------------------*/
101:               
102:               void vSetupTimerTest( unsigned short usFrequencyHz )
103:               {
002E7E  780100     MOV W0, W2
104:               	/* T2 is used to generate interrupts.  T4 is used to provide an accurate
105:               	time measurement. */
106:               	T2CON = 0;
002E80  EF21A0     CLR T2CON
107:               	T4CON = 0;
002E82  EF21AE     CLR T4CON
108:               	TMR2 = 0;
002E84  EF2196     CLR TMR2
109:               	TMR4 = 0;
002E86  EF21A4     CLR TMR4
110:               
111:               	/* Timer 2 is going to interrupt at usFrequencyHz Hz. */
112:               	PR2 = ( unsigned short ) ( configCPU_CLOCK_HZ / ( unsigned long ) usFrequencyHz );
002E88  EB0180     CLR W3
002E8A  224000     MOV #0x2400, W0
002E8C  200F41     MOV #0xF4, W1
002E8E  02065C     CALL ___udivsi3
002E90  000000     NOP
002E92  880CE0     MOV W0, PR2
113:               
114:               	/* Timer 4 is going to free run from minimum to maximum value. */
115:               	PR4 = ( unsigned short ) timerMAX_COUNT;
002E94  EFA1AA     SETM PR4
116:               
117:               	/* Setup timer 2 interrupt priority to be above the kernel priority so 
118:               	the timer jitter is not effected by the kernel activity. */
119:               	IPC1bits.T2IP = configKERNEL_INTERRUPT_PRIORITY + 1;
002E96  28FFF0     MOV #0x8FFF, W0
002E98  B600AA     AND IPC1, WREG
002E9A  A0D000     BSET W0, #13
002E9C  880550     MOV W0, IPC1
120:               
121:               	/* Clear the interrupt as a starting condition. */
122:               	IFS0bits.T2IF = 0;
002E9E  A9E088     BCLR IFS0, #7
123:               
124:               	/* Enable the interrupt. */
125:               	IEC0bits.T2IE = 1;
002EA0  A8E098     BSET IEC0, #7
126:               
127:               	/* Start both timers. */
128:               	T2CONbits.TON = 1;
002EA2  A8E1A1     BSET 0x1A1, #7
129:               	T4CONbits.TON = 1;
002EA4  A8E1AF     BSET 0x1AF, #7
130:               }
002EA6  060000     RETURN
131:               /*-----------------------------------------------------------*/
132:               
133:               static void prvCalculateAndStoreJitter( void )
134:               {
135:               static unsigned short usLastCount = 0, usSettleCount = 0;
136:               unsigned short usThisCount, usDifference;
137:               
138:               	/* Capture the timer value as we enter the interrupt. */
139:               	usThisCount = TMR4;
002E60  800D20     MOV TMR4, W0
140:               
141:               	if( usSettleCount >= timerSETTLE_TIME )
002E62  804461     MOV usSettleCount, W1
002E64  508FE4     SUB W1, #0x4, [W15]
002E66  360007     BRA LEU, .L2
142:               	{
143:               		/* What is the difference between the timer value in this interrupt
144:               		and the value from the last interrupt. */
145:               		usDifference = usThisCount - usLastCount;
002E68  804471     MOV .L47, W1
002E6A  500081     SUB W0, W1, W1
146:               
147:               		/* Store the difference in the timer values if it is larger than the
148:               		currently stored largest value.  The difference over and above the 
149:               		expected difference will give the 'jitter' in the processing of these
150:               		interrupts. */
151:               		if( usDifference > usMaxJitter )
002E6C  804452     MOV usMaxJitter, W2
002E6E  510F81     SUB W2, W1, [W15]
002E70  310004     BRA C, .L3
152:               		{
153:               			usMaxJitter = usDifference;
002E72  884451     MOV W1, usMaxJitter
002E74  370002     BRA .L3
154:               		}
155:               	}
156:               	else
157:               	{
158:               		/* Don't bother storing any values for the first couple of 
159:               		interrupts. */
160:               		usSettleCount++;
002E76  E80081     INC W1, W1
002E78  884461     MOV W1, usSettleCount
161:               	}
162:               
163:               	/* Remember what the timer value was this time through, so we can calculate
164:               	the difference the next time through. */
165:               	usLastCount = usThisCount;
002E7A  884470     MOV W0, .L47
166:               }
002E7C  060000     RETURN
167:               /*-----------------------------------------------------------*/
168:               
169:               void __attribute__((__interrupt__, auto_psv)) _T2Interrupt( void )
170:               {
00026A  F80036     PUSH RCOUNT
00026C  BE9F80     MOV.D W0, [W15++]
00026E  BE9F82     MOV.D W2, [W15++]
000270  BE9F84     MOV.D W4, [W15++]
000272  BE9F86     MOV.D W6, [W15++]
000274  F80032     PUSH DSRPAG
000276  F80034     PUSH DSWPAG
000278  200010     MOV #0x1, W0
00027A  8801A0     MOV W0, DSWPAG
00027C  202000     MOV #0x200, W0
00027E  880190     MOV W0, DSRPAG
171:               	/* Work out the time between this and the previous interrupt. */
172:               	prvCalculateAndStoreJitter();
000280  022E60     CALL .Letext0, .LFE3, _prvCalculateAndStoreJitter, .Ltext0, .LFB1
000282  000000     NOP
173:               
174:               	/* Clear the timer interrupt. */
175:               	IFS0bits.T2IF = 0;
000284  A9E088     BCLR IFS0, #7
176:               }
000286  F90034     POP DSWPAG
000288  F90032     POP DSRPAG
00028A  BE034F     MOV.D [--W15], W6
00028C  BE024F     MOV.D [--W15], W4
00028E  BE014F     MOV.D [--W15], W2
000290  BE004F     MOV.D [--W15], W0
000292  F90036     POP RCOUNT
000294  064000     RETFIE
177:               
178:               
---  D:/code/FreeRTOS/Demo/PIC24_MPLAB/serial/serial.c  -------------------------------------------------
1:                 /*
2:                     FreeRTOS V9.0.0 - Copyright (C) 2016 Real Time Engineers Ltd.
3:                     All rights reserved
4:                 
5:                     VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
6:                 
7:                     This file is part of the FreeRTOS distribution.
8:                 
9:                     FreeRTOS is free software; you can redistribute it and/or modify it under
10:                    the terms of the GNU General Public License (version 2) as published by the
11:                    Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
12:                
13:                    ***************************************************************************
14:                    >>!   NOTE: The modification to the GPL is included to allow you to     !<<
15:                    >>!   distribute a combined work that includes FreeRTOS without being   !<<
16:                    >>!   obliged to provide the source code for proprietary components     !<<
17:                    >>!   outside of the FreeRTOS kernel.                                   !<<
18:                    ***************************************************************************
19:                
20:                    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
21:                    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
22:                    FOR A PARTICULAR PURPOSE.  Full license text is available on the following
23:                    link: http://www.freertos.org/a00114.html
24:                
25:                    ***************************************************************************
26:                     *                                                                       *
27:                     *    FreeRTOS provides completely free yet professionally developed,    *
28:                     *    robust, strictly quality controlled, supported, and cross          *
29:                     *    platform software that is more than just the market leader, it     *
30:                     *    is the industry's de facto standard.                               *
31:                     *                                                                       *
32:                     *    Help yourself get started quickly while simultaneously helping     *
33:                     *    to support the FreeRTOS project by purchasing a FreeRTOS           *
34:                     *    tutorial book, reference manual, or both:                          *
35:                     *    http://www.FreeRTOS.org/Documentation                              *
36:                     *                                                                       *
37:                    ***************************************************************************
38:                
39:                    http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
40:                    the FAQ page "My application does not run, what could be wrong?".  Have you
41:                    defined configASSERT()?
42:                
43:                    http://www.FreeRTOS.org/support - In return for receiving this top quality
44:                    embedded software for free we request you assist our global community by
45:                    participating in the support forum.
46:                
47:                    http://www.FreeRTOS.org/training - Investing in training allows your team to
48:                    be as productive as possible as early as possible.  Now you can receive
49:                    FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
50:                    Ltd, and the world's leading authority on the world's leading RTOS.
51:                
52:                    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
53:                    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
54:                    compatible FAT file system, and our tiny thread aware UDP/IP stack.
55:                
56:                    http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
57:                    Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
58:                
59:                    http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
60:                    Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
61:                    licenses offer ticketed support, indemnification and commercial middleware.
62:                
63:                    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
64:                    engineered and independently SIL3 certified version for use in safety and
65:                    mission critical applications that require provable dependability.
66:                
67:                    1 tab == 4 spaces!
68:                */
69:                
70:                
71:                /* BASIC INTERRUPT DRIVEN SERIAL PORT DRIVER. 
72:                
73:                NOTE:  This driver is primarily to test the scheduler functionality.  It does
74:                not effectively use the buffers or DMA and is therefore not intended to be
75:                an example of an efficient driver. */
76:                
77:                /* Standard include file. */
78:                #include <stdlib.h>
79:                
80:                /* Scheduler include files. */
81:                #include "FreeRTOS.h"
82:                #include "queue.h"
83:                #include "task.h"
84:                
85:                /* Demo app include files. */
86:                #include "serial.h"
87:                
88:                /* Hardware setup. */
89:                #define serOUTPUT						0
90:                #define serINPUT						1
91:                #define serLOW_SPEED					0
92:                #define serONE_STOP_BIT					0
93:                #define serEIGHT_DATA_BITS_NO_PARITY	0
94:                #define serNORMAL_IDLE_STATE			0
95:                #define serAUTO_BAUD_OFF				0
96:                #define serLOOPBACK_OFF					0
97:                #define serWAKE_UP_DISABLE				0
98:                #define serNO_HARDWARE_FLOW_CONTROL		0
99:                #define serSTANDARD_IO					0
100:               #define serNO_IRDA						0
101:               #define serCONTINUE_IN_IDLE_MODE		0
102:               #define serUART_ENABLED					1
103:               #define serINTERRUPT_ON_SINGLE_CHAR		0
104:               #define serTX_ENABLE					1
105:               #define serINTERRUPT_ENABLE				1
106:               #define serINTERRUPT_DISABLE			0
107:               #define serCLEAR_FLAG					0
108:               #define serSET_FLAG						1
109:               
110:               
111:               /* The queues used to communicate between tasks and ISR's. */
112:               static QueueHandle_t xRxedChars; 
113:               static QueueHandle_t xCharsForTx; 
114:               
115:               static portBASE_TYPE xTxHasEnded;
116:               /*-----------------------------------------------------------*/
117:               
118:               xComPortHandle xSerialPortInitMinimal( unsigned long ulWantedBaud, unsigned portBASE_TYPE uxQueueLength )
119:               {
002972  BE9F88     MOV.D W8, [W15++]
002974  781F8A     MOV W10, [W15++]
002976  BE0400     MOV.D W0, W8
002978  780502     MOV W2, W10
120:               char cChar;
121:               
122:               	/* Create the queues used by the com test task. */
123:               	xRxedChars = xQueueCreate( uxQueueLength, ( unsigned portBASE_TYPE ) sizeof( signed char ) );
00297A  EB4100     CLR.B W2
00297C  200011     MOV #0x1, W1
00297E  78000A     MOV W10, W0
002980  021A74     CALL xQueueGenericCreate
002982  000000     NOP
002984  8844A0     MOV W0, xRxedChars
124:               	xCharsForTx = xQueueCreate( uxQueueLength, ( unsigned portBASE_TYPE ) sizeof( signed char ) );
002986  EB4100     CLR.B W2
002988  200011     MOV #0x1, W1
00298A  78000A     MOV W10, W0
00298C  021A74     CALL xQueueGenericCreate
00298E  000000     NOP
002990  884480     MOV W0, xCharsForTx
125:               
126:               	/* Setup the UART. */
127:               	U2MODEbits.BRGH		= serLOW_SPEED;
002992  A963AE     BCLR U2MODE, #3
128:               	U2MODEbits.STSEL	= serONE_STOP_BIT;
002994  A903AE     BCLR U2MODE, #0
129:               	U2MODEbits.PDSEL	= serEIGHT_DATA_BITS_NO_PARITY;
002996  2FFF90     MOV #0xFFF9, W0
002998  B623AE     AND U2MODE
130:               	U2MODEbits.RXINV	= serNORMAL_IDLE_STATE;
00299A  A983AE     BCLR U2MODE, #4
131:               	U2MODEbits.ABAUD	= serAUTO_BAUD_OFF;
00299C  A9A3AE     BCLR U2MODE, #5
132:               	U2MODEbits.LPBACK	= serLOOPBACK_OFF;
00299E  A9C3AE     BCLR U2MODE, #6
133:               	U2MODEbits.WAKE		= serWAKE_UP_DISABLE;
0029A0  A9E3AE     BCLR U2MODE, #7
134:               	U2MODEbits.UEN		= serNO_HARDWARE_FLOW_CONTROL;
0029A2  2FCFF0     MOV #0xFCFF, W0
0029A4  B623AE     AND U2MODE
135:               	U2MODEbits.IREN		= serNO_IRDA;
0029A6  A983AF     BCLR 0x3AF, #4
136:               	U2MODEbits.USIDL	= serCONTINUE_IN_IDLE_MODE;
0029A8  A9A3AF     BCLR 0x3AF, #5
137:               	U2MODEbits.UARTEN	= serUART_ENABLED;
0029AA  A8E3AF     BSET 0x3AF, #7
138:               
139:               	U2BRG = (unsigned short)(( (float)configCPU_CLOCK_HZ / ( (float)16 * (float)ulWantedBaud ) ) - (float)0.5);
0029AC  BE0008     MOV.D W8, W0
0029AE  02054A     CALL ___floatunsisf
0029B0  000000     NOP
0029B2  200002     MOV #0x0, W2
0029B4  241803     MOV #0x4180, W3
0029B6  0205F4     CALL ___mulsf3
0029B8  000000     NOP
0029BA  BE0100     MOV.D W0, W2
0029BC  224000     MOV #0x2400, W0
0029BE  24B741     MOV #0x4B74, W1
0029C0  020472     CALL ___divsf3
0029C2  000000     NOP
0029C4  200002     MOV #0x0, W2
0029C6  23F003     MOV #0x3F00, W3
0029C8  0203B6     CALL ___subsf3
0029CA  000000     NOP
0029CC  020514     CALL ___fixunssfsi
0029CE  000000     NOP
0029D0  881DB0     MOV W0, U2BRG
140:               
141:               	U2STAbits.URXISEL	= serINTERRUPT_ON_SINGLE_CHAR;
0029D2  2FF3F0     MOV #0xFF3F, W0
0029D4  B623B0     AND U2STA
142:               	U2STAbits.UTXEN		= serTX_ENABLE;
0029D6  A843B1     BSET 0x3B1, #2
143:               	U2STAbits.UTXINV	= serNORMAL_IDLE_STATE;
0029D8  A9C3B1     BCLR 0x3B1, #6
144:               	U2STAbits.UTXISEL0	= serINTERRUPT_ON_SINGLE_CHAR;
0029DA  A9A3B1     BCLR 0x3B1, #5
145:               	U2STAbits.UTXISEL1	= serINTERRUPT_ON_SINGLE_CHAR;
0029DC  A9E3B1     BCLR 0x3B1, #7
146:               
147:               	/* It is assumed that this function is called prior to the scheduler being
148:               	started.  Therefore interrupts must not be allowed to occur yet as they
149:               	may attempt to perform a context switch. */
150:               	portDISABLE_INTERRUPTS();
0029DE  2FF1F0     MOV #0xFF1F, W0
0029E0  B60042     AND SR, WREG
0029E2  A05000     BSET W0, #5
0029E4  880210     MOV W0, SR
0029E6  000000     NOP
0029E8  000000     NOP
151:               
152:               	IFS1bits.U2RXIF = serCLEAR_FLAG;
0029EA  A9C08B     BCLR 0x8B, #6
153:               	IFS1bits.U2TXIF = serCLEAR_FLAG;
0029EC  A9E08B     BCLR 0x8B, #7
154:               	IPC7bits.U2RXIP = configKERNEL_INTERRUPT_PRIORITY;
0029EE  2F8FF0     MOV #0xF8FF, W0
0029F0  B600B6     AND IPC7, WREG
0029F2  A08000     BSET W0, #8
0029F4  8805B0     MOV W0, IPC7
155:               	IPC7bits.U2TXIP = configKERNEL_INTERRUPT_PRIORITY;
0029F6  28FFF0     MOV #0x8FFF, W0
0029F8  B600B6     AND IPC7, WREG
0029FA  A0C000     BSET W0, #12
0029FC  8805B0     MOV W0, IPC7
156:               	IEC1bits.U2TXIE = serINTERRUPT_ENABLE;
0029FE  A8E09B     BSET 0x9B, #7
157:               	IEC1bits.U2RXIE = serINTERRUPT_ENABLE;
002A00  A8C09B     BSET 0x9B, #6
158:               
159:               	/* Clear the Rx buffer. */
160:               	while( U2STAbits.URXDA == serSET_FLAG )
002A02  AB03B0     BTST U2STA, #0
002A04  320003     BRA Z, .L2
002A08  AB03B0     BTST U2STA, #0
002A0A  3AFFFD     BRA NZ, .L4
161:               	{
162:               		cChar = U2RXREG;
002A06  801DA0     MOV U2RXREG, W0
163:               	}
164:               
165:               	xTxHasEnded = pdTRUE;
002A0C  200010     MOV #0x1, W0
002A0E  884490     MOV W0, xTxHasEnded
166:               
167:               	return NULL;
168:               }
002A10  EB0000     CLR W0
002A12  78054F     MOV [--W15], W10
002A14  BE044F     MOV.D [--W15], W8
002A16  060000     RETURN
169:               /*-----------------------------------------------------------*/
170:               
171:               signed portBASE_TYPE xSerialGetChar( xComPortHandle pxPort, signed char *pcRxedChar, TickType_t xBlockTime )
172:               {
173:               	/* Only one port is supported. */
174:               	( void ) pxPort;
175:               
176:               	/* Get the next character from the buffer.  Return false if no characters
177:               	are available or arrive before xBlockTime expires. */
178:               	if( xQueueReceive( xRxedChars, pcRxedChar, xBlockTime ) )
002A18  EB0180     CLR W3
002A1A  8044A0     MOV xRxedChars, W0
002A1C  021C16     CALL xQueueGenericReceive
002A1E  000000     NOP
179:               	{
180:               		return pdTRUE;
002A20  A7F000     BTSC W0, #15
002A22  EA0000     NEG W0, W0
002A24  EA0000     NEG W0, W0
002A26  DE004F     LSR W0, #15, W0
181:               	}
182:               	else
183:               	{
184:               		return pdFALSE;
185:               	}
186:               }
002A28  060000     RETURN
187:               /*-----------------------------------------------------------*/
188:               
189:               signed portBASE_TYPE xSerialPutChar( xComPortHandle pxPort, signed char cOutChar, TickType_t xBlockTime )
190:               {
002A2A  FA0002     LNK #0x2
002A2C  9FFFE1     MOV.B W1, [W15-2]
191:               	/* Only one port is supported. */
192:               	( void ) pxPort;
193:               
194:               	/* Return false if after the block time there is no room on the Tx queue. */
195:               	if( xQueueSend( xCharsForTx, &cOutChar, xBlockTime ) != pdPASS )
002A2E  EB0180     CLR W3
002A30  E9808F     DEC2 W15, W1
002A32  804480     MOV xCharsForTx, W0
002A34  021AA8     CALL xQueueGenericSend
002A36  000000     NOP
002A38  780080     MOV W0, W1
002A3C  508FE1     SUB W1, #0x1, [W15]
002A3E  3A0005     BRA NZ, .L8
196:               	{
197:               		return pdFAIL;
002A3A  EB0000     CLR W0
198:               	}
199:               
200:               	/* A critical section should not be required as xTxHasEnded will not be
201:               	written to by the ISR if it is already 0 (is this correct?). */
202:               	if( xTxHasEnded )
002A42  E20892     CP0 xTxHasEnded
002A44  320002     BRA Z, .L8
203:               	{
204:               		xTxHasEnded = pdFALSE;
002A46  EF2892     CLR xTxHasEnded
205:               		IFS1bits.U2TXIF = serSET_FLAG;
002A48  A8E08B     BSET 0x8B, #7
206:               	}
207:               
208:               	return pdPASS;
002A40  200010     MOV #0x1, W0
209:               }
002A4A  FA8000     ULNK
002A4C  060000     RETURN
210:               /*-----------------------------------------------------------*/
211:               
212:               void vSerialClose( xComPortHandle xPort )
213:               {
214:               	/* Note implemented. */
215:               	( void ) xPort;
216:               }
002A4E  060000     RETURN
217:               /*-----------------------------------------------------------*/
218:               
219:               void __attribute__((__interrupt__, auto_psv)) _U2RXInterrupt( void )
220:               {
000296  F80036     PUSH RCOUNT
000298  BE9F80     MOV.D W0, [W15++]
00029A  BE9F82     MOV.D W2, [W15++]
00029C  BE9F84     MOV.D W4, [W15++]
00029E  BE9F86     MOV.D W6, [W15++]
0002A0  781F88     MOV W8, [W15++]
0002A2  F80032     PUSH DSRPAG
0002A4  F80034     PUSH DSWPAG
0002A6  200010     MOV #0x1, W0
0002A8  8801A0     MOV W0, DSWPAG
0002AA  202000     MOV #0x200, W0
0002AC  880190     MOV W0, DSRPAG
0002AE  FA0004     LNK #0x4
221:               char cChar;
222:               portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
0002B0  EB0000     CLR W0
0002B2  9FBFF0     MOV W0, [W15-2]
223:               
224:               	/* Get the character and post it on the queue of Rxed characters.
225:               	If the post causes a task to wake force a context switch as the woken task
226:               	may have a higher priority than the task we have interrupted. */
227:               	IFS1bits.U2RXIF = serCLEAR_FLAG;
0002B4  A9C08B     BCLR 0x8B, #6
228:               	while( U2STAbits.URXDA )
0002B6  AB03B0     BTST U2STA, #0
0002B8  32000B     BRA Z, .L13
0002CC  AB03B0     BTST U2STA, #0
0002CE  3AFFF6     BRA NZ, .L16
229:               	{
230:               		cChar = U2RXREG;
0002BC  801DA0     MOV U2RXREG, W0
0002BE  9FFFC0     MOV.B W0, [W15-4]
231:               		xQueueSendFromISR( xRxedChars, &cChar, &xHigherPriorityTaskWoken );
0002BA  EB0400     CLR W8
0002C0  780188     MOV W8, W3
0002C2  E9810F     DEC2 W15, W2
0002C4  5780E4     SUB W15, #0x4, W1
0002C6  8044A0     MOV xRxedChars, W0
0002C8  021B8A     CALL xQueueGenericSendFromISR
0002CA  000000     NOP
232:               	}
233:               
234:               	if( xHigherPriorityTaskWoken != pdFALSE )
0002D0  97B87F     MOV [W15-2], W0
0002D2  E00000     CP0 W0
0002D4  320003     BRA Z, .L12
235:               	{
236:               		taskYIELD();
0002D6  022DC4     CALL .Letext0, .LFE2, _vPortYield
0002D8  000000     NOP
0002DA  000000     NOP
237:               	}
238:               }
0002DC  FA8000     ULNK
0002DE  F90034     POP DSWPAG
0002E0  F90032     POP DSRPAG
0002E2  78044F     MOV [--W15], W8
0002E4  BE034F     MOV.D [--W15], W6
0002E6  BE024F     MOV.D [--W15], W4
0002E8  BE014F     MOV.D [--W15], W2
0002EA  BE004F     MOV.D [--W15], W0
0002EC  F90036     POP RCOUNT
0002EE  064000     RETFIE
239:               /*-----------------------------------------------------------*/
240:               
241:               void __attribute__((__interrupt__, auto_psv)) _U2TXInterrupt( void )
242:               {
0002F0  F80036     PUSH RCOUNT
0002F2  BE9F80     MOV.D W0, [W15++]
0002F4  BE9F82     MOV.D W2, [W15++]
0002F6  BE9F84     MOV.D W4, [W15++]
0002F8  BE9F86     MOV.D W6, [W15++]
0002FA  781F88     MOV W8, [W15++]
0002FC  F80032     PUSH DSRPAG
0002FE  F80034     PUSH DSWPAG
000300  200010     MOV #0x1, W0
000302  8801A0     MOV W0, DSWPAG
000304  202000     MOV #0x200, W0
000306  880190     MOV W0, DSRPAG
000308  FA0004     LNK #0x4
243:               signed char cChar;
244:               portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
00030A  EB0000     CLR W0
00030C  9FBFF0     MOV W0, [W15-2]
245:               
246:               	/* If the transmit buffer is full we cannot get the next character.
247:               	Another interrupt will occur the next time there is space so this does
248:               	not matter. */
249:               	IFS1bits.U2TXIF = serCLEAR_FLAG;
00030E  A9E08B     BCLR 0x8B, #7
250:               	while( !( U2STAbits.UTXBF ) )
000310  AB23B1     BTST 0x3B1, #1
000312  3A0011     BRA NZ, .L19
000314  202008     MOV #0x200, W8
00032A  801D81     MOV U2STA, W1
00032C  640001     AND W8, W1, W0
00032E  32FFF3     BRA Z, .L23
000330  370002     BRA .L19
251:               	{
252:               		if( xQueueReceiveFromISR( xCharsForTx, &cChar, &xHigherPriorityTaskWoken ) == pdTRUE )
000316  E9810F     DEC2 W15, W2
000318  5780E4     SUB W15, #0x4, W1
00031A  804480     MOV xCharsForTx, W0
00031C  021D10     CALL xQueueReceiveFromISR
00031E  000000     NOP
000320  500FE1     SUB W0, #0x1, [W15]
000322  3A0007     BRA NZ, .L20
253:               		{
254:               			/* Send the next character queued for Tx. */
255:               			U2TXREG = cChar;
000324  97F8CF     MOV.B [W15-4], W1
000326  FB0001     SE W1, W0
000328  881D90     MOV W0, U2TXREG
256:               		}
257:               		else
258:               		{
259:               			/* Queue empty, nothing to send. */
260:               			xTxHasEnded = pdTRUE;
000332  200010     MOV #0x1, W0
000334  884490     MOV W0, xTxHasEnded
261:               			break;
262:               		}
263:               	}
264:               
265:               	if( xHigherPriorityTaskWoken != pdFALSE )
000336  97B87F     MOV [W15-2], W0
000338  E00000     CP0 W0
00033A  320003     BRA Z, .L18
266:               	{
267:               		taskYIELD();
00033C  022DC4     CALL .Letext0, .LFE2, _vPortYield
00033E  000000     NOP
000340  000000     NOP
268:               	}
269:               }
000342  FA8000     ULNK
000344  F90034     POP DSWPAG
000346  F90032     POP DSRPAG
000348  78044F     MOV [--W15], W8
00034A  BE034F     MOV.D [--W15], W6
00034C  BE024F     MOV.D [--W15], W4
00034E  BE014F     MOV.D [--W15], W2
000350  BE004F     MOV.D [--W15], W0
000352  F90036     POP RCOUNT
000354  064000     RETFIE
270:               
271:               
---  D:/code/FreeRTOS/Demo/PIC24_MPLAB/main.c  ----------------------------------------------------------
1:                 /*
2:                     FreeRTOS V9.0.0 - Copyright (C) 2016 Real Time Engineers Ltd.
3:                     All rights reserved
4:                 
5:                     VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
6:                 
7:                     This file is part of the FreeRTOS distribution.
8:                 
9:                     FreeRTOS is free software; you can redistribute it and/or modify it under
10:                    the terms of the GNU General Public License (version 2) as published by the
11:                    Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
12:                
13:                 ***************************************************************************
14:                    >>!   NOTE: The modification to the GPL is included to allow you to     !<<
15:                    >>!   distribute a combined work that includes FreeRTOS without being   !<<
16:                    >>!   obliged to provide the source code for proprietary components     !<<
17:                    >>!   outside of the FreeRTOS kernel.                                   !<<
18:                 ***************************************************************************
19:                
20:                    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
21:                    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
22:                    FOR A PARTICULAR PURPOSE.  Full license text is available on the following
23:                    link: http://www.freertos.org/a00114.html
24:                
25:                 ***************************************************************************
26:                 *                                                                       *
27:                 *    FreeRTOS provides completely free yet professionally developed,    *
28:                 *    robust, strictly quality controlled, supported, and cross          *
29:                 *    platform software that is more than just the market leader, it     *
30:                 *    is the industry's de facto standard.                               *
31:                 *                                                                       *
32:                 *    Help yourself get started quickly while simultaneously helping     *
33:                 *    to support the FreeRTOS project by purchasing a FreeRTOS           *
34:                 *    tutorial book, reference manual, or both:                          *
35:                 *    http://www.FreeRTOS.org/Documentation                              *
36:                 *                                                                       *
37:                 ***************************************************************************
38:                
39:                    http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
40:                    the FAQ page "My application does not run, what could be wrong?".  Have you
41:                    defined configASSERT()?
42:                
43:                    http://www.FreeRTOS.org/support - In return for receiving this top quality
44:                    embedded software for free we request you assist our global community by
45:                    participating in the support forum.
46:                
47:                    http://www.FreeRTOS.org/training - Investing in training allows your team to
48:                    be as productive as possible as early as possible.  Now you can receive
49:                    FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
50:                    Ltd, and the world's leading authority on the world's leading RTOS.
51:                
52:                    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
53:                    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
54:                    compatible FAT file system, and our tiny thread aware UDP/IP stack.
55:                
56:                    http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
57:                    Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
58:                
59:                    http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
60:                    Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
61:                    licenses offer ticketed support, indemnification and commercial middleware.
62:                
63:                    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
64:                    engineered and independently SIL3 certified version for use in safety and
65:                    mission critical applications that require provable dependability.
66:                
67:                    1 tab == 4 spaces!
68:                 */
69:                // ****************************************************************************
70:                // FSEC
71:                #pragma config BWRP = OFF               //  (Boot Segment may be written)
72:                #pragma config BSS = DISABLED           // Boot Segment Code-Protect Level bits (No Protection (other than BWRP))
73:                #pragma config BSEN = OFF               // Boot Segment Control bit (No Boot Segment)
74:                #pragma config GWRP = OFF               // General Segment Write-Protect bit (General Segment may be written)
75:                #pragma config GSS = DISABLED           // General Segment Code-Protect Level bits (No Protection (other than GWRP))
76:                #pragma config CWRP = OFF               // Configuration Segment Write-Protect bit (Configuration Segment may be written)
77:                #pragma config CSS = DISABLED           // Configuration Segment Code-Protect Level bits (No Protection (other than CWRP))
78:                #pragma config AIVTDIS = OFF            // Alternate Interrupt Vector Table bit (Disabled AIVT)
79:                
80:                // FBSLIM
81:                #pragma config BSLIM = 0x1FFF           // Boot Segment Flash Page Address Limit bits (Boot Segment Flash page address  limit)
82:                
83:                // FSIGN
84:                
85:                // FOSCSEL
86:                #pragma config FNOSC = PRIPLL           // Oscillator Source Selection (Primary Oscillator with PLL module (XT + PLL, HS + PLL, EC + PLL))
87:                #pragma config PLLMODE = PLL96DIV2      // PLL Mode Selection (96 MHz PLL. (8 MHz input))
88:                #pragma config IESO = OFF               // Two-speed Oscillator Start-up Enable bit (Start up with user-selected oscillator source)
89:                
90:                // FOSC
91:                #pragma config POSCMD = HS              // Primary Oscillator Mode Select bits (HS Crystal Oscillator Mode)
92:                #pragma config OSCIOFCN = OFF           // OSC2 Pin Function bit (OSC2 is clock output)
93:                #pragma config SOSCSEL = ON             // SOSC Power Selection Configuration bits (SOSC is used in crystal (SOSCI/SOSCO) mode)
94:                #pragma config PLLSS = PLL_PRI          // PLL Secondary Selection Configuration bit (PLL is fed by the Primary oscillator)
95:                #pragma config IOL1WAY = ON             // Peripheral pin select configuration bit (Allow only one reconfiguration)
96:                #pragma config FCKSM = CSDCMD           // Clock Switching Mode bits (Both Clock switching and Fail-safe Clock Monitor are disabled)
97:                
98:                // FWDT
99:                #pragma config WDTPS = PS32768          // Watchdog Timer Postscaler bits (1:32,768)
100:               #pragma config FWPSA = PR128            // Watchdog Timer Prescaler bit (1:128)
101:               #pragma config FWDTEN = OFF             // Watchdog Timer Enable bits (WDT and SWDTEN disabled)
102:               #pragma config WINDIS = OFF             // Watchdog Timer Window Enable bit (Watchdog Timer in Non-Window mode)
103:               #pragma config WDTWIN = WIN25           // Watchdog Timer Window Select bits (WDT Window is 25% of WDT period)
104:               #pragma config WDTCMX = WDTCLK          // WDT MUX Source Select bits (WDT clock source is determined by the WDTCLK Configuration bits)
105:               #pragma config WDTCLK = LPRC            // WDT Clock Source Select bits (WDT uses LPRC)
106:               
107:               // FPOR
108:               #pragma config BOREN = ON               // Brown Out Enable bit (Brown Out Enable Bit)
109:               #pragma config LPCFG = ON               // Low power regulator control (Retention Sleep controlled by RETEN)
110:               #pragma config DNVPEN = ENABLE          // Downside Voltage Protection Enable bit (Downside protection enabled using ZPBOR when BOR is inactive)
111:               
112:               // FICD
113:               #pragma config ICS = PGD2               // ICD Communication Channel Select bits (Communicate on PGEC2 and PGED2)
114:               #pragma config JTAGEN = OFF             // JTAG Enable bit (JTAG is disabled)
115:               #pragma config BTSWP = OFF              // BOOTSWP Disable (BOOTSWP instruction disabled)
116:               
117:               // FDEVOPT1
118:               #pragma config ALTCMPI = DISABLE        // Alternate Comparator Input Enable bit (C1INC, C2INC, and C3INC are on their standard pin locations)
119:               #pragma config TMPRPIN = OFF            // Tamper Pin Enable bit (TMPRN pin function is disabled)
120:               #pragma config SOSCHP = ON              // SOSC High Power Enable bit (valid only when SOSCSEL = 1 (Enable SOSC high power mode (default))
121:               #pragma config ALTVREF = ALTVREFDIS     // Alternate Voltage Reference Location Enable bit (VREF+ and CVREF+ on RB0, VREF- and CVREF- on RB1)
122:               
123:               /*
124:                * Creates all the demo application tasks, then starts the scheduler.  The WEB
125:                * documentation provides more details of the standard demo application tasks.
126:                * In addition to the standard demo tasks, the following tasks and tests are
127:                * defined and/or created within this file:
128:                *
129:                * "Fast Interrupt Test" - A high frequency periodic interrupt is generated
130:                * using a free running timer to demonstrate the use of the 
131:                * configKERNEL_INTERRUPT_PRIORITY configuration constant.  The interrupt 
132:                * service routine measures the number of processor clocks that occur between
133:                * each interrupt - and in so doing measures the jitter in the interrupt 
134:                * timing.  The maximum measured jitter time is latched in the usMaxJitter 
135:                * variable, and displayed on the LCD by the 'Check' as described below.  
136:                * The fast interrupt is configured and handled in the timer_test.c source 
137:                * file.
138:                *
139:                * "LCD" task - the LCD task is a 'gatekeeper' task.  It is the only task that
140:                * is permitted to access the LCD directly.  Other tasks wishing to write a
141:                * message to the LCD send the message on a queue to the LCD task instead of 
142:                * accessing the LCD themselves.  The LCD task just blocks on the queue waiting 
143:                * for messages - waking and displaying the messages as they arrive.  The LCD
144:                * task is defined in lcd.c.  
145:                * 
146:                * "Check" task -  This only executes every three seconds but has the highest 
147:                * priority so is guaranteed to get processor time.  Its main function is to 
148:                * check that all the standard demo tasks are still operational.  Should any
149:                * unexpected behaviour within a demo task be discovered the 'check' task will
150:                * write "FAIL #n" to the LCD (via the LCD task).  If all the demo tasks are 
151:                * executing with their expected behaviour then the check task writes the max
152:                * jitter time to the LCD (again via the LCD task), as described above.
153:                */
154:               
155:               /* Standard includes. */
156:               #include <stdio.h>
157:               
158:               /* Scheduler includes. */
159:               #include "FreeRTOS.h"
160:               #include "task.h"
161:               #include "queue.h"
162:               #include "croutine.h"
163:               
164:               /* Demo application includes. */
165:               #include "BlockQ.h"
166:               #include "crflash.h"
167:               #include "blocktim.h"
168:               #include "integer.h"
169:               #include "comtest2.h"
170:               #include "partest.h"
171:               #include "lcd.h"
172:               #include "timertest.h"
173:               
174:               /* Demo task priorities. */
175:               #define mainBLOCK_Q_PRIORITY				( tskIDLE_PRIORITY + 2 )
176:               #define mainCHECK_TASK_PRIORITY				( tskIDLE_PRIORITY + 3 )
177:               #define mainCOM_TEST_PRIORITY				( 2 )
178:               
179:               /* The check task may require a bit more stack as it calls sprintf(). */
180:               #define mainCHECK_TAKS_STACK_SIZE			( configMINIMAL_STACK_SIZE * 2 )
181:               
182:               /* The execution period of the check task. */
183:               #define mainCHECK_TASK_PERIOD				( ( TickType_t ) 3000 / portTICK_PERIOD_MS )
184:               
185:               /* The number of flash co-routines to create. */
186:               #define mainNUM_FLASH_COROUTINES			( 5 )
187:               
188:               /* Baud rate used by the comtest tasks. */
189:               #define mainCOM_TEST_BAUD_RATE				( 19200 )
190:               
191:               /* The LED used by the comtest tasks.  mainCOM_TEST_LED + 1 is also used.
192:               See the comtest.c file for more information. */
193:               #define mainCOM_TEST_LED					( 6 )
194:               
195:               /* The frequency at which the "fast interrupt test" interrupt will occur. */
196:               #define mainTEST_INTERRUPT_FREQUENCY		( 20000 )
197:               
198:               /* The number of processor clocks we expect to occur between each "fast
199:               interrupt test" interrupt. */
200:               #define mainEXPECTED_CLOCKS_BETWEEN_INTERRUPTS ( configCPU_CLOCK_HZ / mainTEST_INTERRUPT_FREQUENCY )
201:               
202:               /* The number of nano seconds between each processor clock. */
203:               #define mainNS_PER_CLOCK ( ( unsigned short ) ( ( 1.0 / ( double ) configCPU_CLOCK_HZ ) * 1000000000.0 ) )
204:               
205:               /* Dimension the buffer used to hold the value of the maximum jitter time when
206:               it is converted to a string. */
207:               #define mainMAX_STRING_LENGTH				( 20 )
208:               
209:               /*-----------------------------------------------------------*/
210:               
211:               /*
212:                * The check task as described at the top of this file.
213:                */
214:               static void vCheckTask(void *pvParameters);
215:               
216:               /*
217:                * Setup the processor ready for the demo.
218:                */
219:               static void prvSetupHardware(void);
220:               
221:               /* Prototypes for the standard FreeRTOS callback/hook functions implemented
222:               within this file. */
223:               void vApplicationStackOverflowHook(TaskHandle_t pxTask, char *pcTaskName);
224:               
225:               /*-----------------------------------------------------------*/
226:               
227:               /* The queue used to send messages to the LCD task. */
228:               static QueueHandle_t xLCDQueue;
229:               
230:               /*-----------------------------------------------------------*/
231:               
232:               /*
233:                * Create the demo tasks then start the scheduler.
234:                */
235:               int main(void) {
236:                   /* Configure any hardware required for this demo. */
237:                   prvSetupHardware();
002926  37FFC1     BRA .L8
238:               
239:                   /* Create the standard demo tasks. */
240:                   vStartBlockingQueueTasks(mainBLOCK_Q_PRIORITY);
00292A  200020     MOV #0x2, W0
00292C  022554     CALL vStartBlockingQueueTasks
00292E  000000     NOP
241:                   vStartIntegerMathTasks(tskIDLE_PRIORITY);
002930  EB0000     CLR W0
002932  022CDA     CALL vStartIntegerMathTasks
002934  000000     NOP
242:                   vStartFlashCoRoutines(mainNUM_FLASH_COROUTINES);
002936  200050     MOV #0x5, W0
002938  02273E     CALL vStartFlashCoRoutines
00293A  000000     NOP
243:                   //    vAltStartComTestTasks(mainCOM_TEST_PRIORITY, mainCOM_TEST_BAUD_RATE, mainCOM_TEST_LED);
244:                   vCreateBlockTimeTasks();
00293C  022258     CALL vCreateBlockTimeTasks
00293E  000000     NOP
245:               
246:                   /* Create the test tasks defined within this file. */
247:                   xTaskCreate(vCheckTask, "Check", mainCHECK_TAKS_STACK_SIZE, NULL, mainCHECK_TASK_PRIORITY, NULL);
002940  EB0280     CLR W5
002942  200034     MOV #0x3, W4
002944  EB0180     CLR W3
002946  200E62     MOV #0xE6, W2
002948  28DF61     MOV #0x8DF6, W1
00294A  228860     MOV #0x2886, W0
00294C  0212C4     CALL xTaskCreate
00294E  000000     NOP
248:               
249:                   /* Start the task that will control the LCD.  This returns the handle
250:                   to the queue used to write text out to the task. */
251:                   //	xLCDQueue = xStartLCDTask();
252:               
253:                   /* Start the high frequency interrupt test. */
254:                   vSetupTimerTest(mainTEST_INTERRUPT_FREQUENCY);
002950  24E200     MOV #0x4E20, W0
002952  022E7E     CALL vSetupTimerTest
002954  000000     NOP
255:               
256:                   /* Finally start the scheduler. */
257:                   vTaskStartScheduler();
002956  021320     CALL vTaskStartScheduler
002958  000000     NOP
258:               
259:                   /* Will only reach here if there is insufficient heap available to start
260:                   the scheduler. */
261:                   return 0;
262:               }
00295A  EB0000     CLR W0
00295C  060000     RETURN
263:               
264:               /*-----------------------------------------------------------*/
265:               
266:               static void prvSetupHardware(void) {
267:                   vParTestInitialise();
002880  022D6C     CALL vParTestInitialise
002882  000000     NOP
268:               }
002884  060000     RETURN
269:               
270:               /*-----------------------------------------------------------*/
271:               
272:               static void vCheckTask(void *pvParameters) {
002886  4787E8     ADD W15, #0x8, W15
002888  BE9F88     MOV.D W8, [W15++]
00288A  BE9F8A     MOV.D W10, [W15++]
00288C  781F8C     MOV W12, [W15++]
00288E  781F8E     MOV W14, [W15++]
273:                   /* Used to wake the task at the correct frequency. */
274:                   TickType_t xLastExecutionTime;
275:               
276:                   /* The maximum jitter time measured by the fast interrupt test. */
277:                   extern unsigned short usMaxJitter;
278:               
279:                   /* Buffer into which the maximum jitter time is written as a string. */
280:                   static char cStringBuffer[ mainMAX_STRING_LENGTH ];
281:               
282:                   /* The message that is sent on the queue to the LCD task.  The first
283:                   parameter is the minimum time (in ticks) that the message should be
284:                   left on the LCD without being overwritten.  The second parameter is a pointer
285:                   to the message to display itself. */
286:                   xLCDMessage xMessage = {0, cStringBuffer};
002890  EB0000     CLR W0
002892  9FBF80     MOV W0, [W15-16]
002894  21DBA0     MOV #0x1DBA, W0
002896  9FBF90     MOV W0, [W15-14]
287:               
288:                   /* Set to pdTRUE should an error be detected in any of the standard demo tasks. */
289:                   unsigned short usErrorDetected = pdFALSE;
0028A0  EB0400     CLR W8
290:               
291:                   /* Remove compiler warnings. */
292:                   (void) pvParameters;
293:               
294:                   /* Initialise xLastExecutionTime so the first call to vTaskDelayUntil()
295:                   works correctly. */
296:                   xLastExecutionTime = xTaskGetTickCount();
002898  0210AE     CALL xTaskGetTickCount
00289A  000000     NOP
00289C  578772     SUB W15, #0x12, W14
00289E  781F00     MOV W0, [W14++]
297:               
298:                   for (;;) {
299:                       /* Wait until it is time for the next cycle. */
300:                       vTaskDelayUntil(&xLastExecutionTime, mainCHECK_TASK_PERIOD);
0028AA  20BB81     MOV #0xBB8, W1
0028AC  578072     SUB W15, #0x12, W0
0028AE  021888     CALL vTaskDelayUntil
0028B0  000000     NOP
301:               
302:                       /* Has an error been found in any of the standard demo tasks? */
303:               
304:                       if (xAreIntegerMathsTaskStillRunning() != pdTRUE) {
0028B2  022CEC     CALL xAreIntegerMathsTaskStillRunning
0028B4  000000     NOP
0028B6  500FE1     SUB W0, #0x1, [W15]
0028B8  320005     BRA Z, .L3
305:                           usErrorDetected = pdTRUE;
0028C2  200018     MOV #0x1, W8
306:                           sprintf(cStringBuffer, "FAIL #1");
0028A2  21DBA9     MOV #0x1DBA, W9
0028A4  28DC6B     MOV #0x8DC6, W11
0028BA  090007     REPEAT #0x7
0028BC  785CBB     MOV.B [W11++], [W9++]
0028BE  B10089     SUB #0x8, W9
0028C0  B1008B     SUB #0x8, W11
307:                       }
308:               
309:                       if (xAreComTestTasksStillRunning() != pdTRUE) {
0028C4  022872     CALL xAreComTestTasksStillRunning
0028C6  000000     NOP
0028C8  500FE1     SUB W0, #0x1, [W15]
0028CA  320005     BRA Z, .L4
310:                           usErrorDetected = pdTRUE;
0028D4  200018     MOV #0x1, W8
311:                           sprintf(cStringBuffer, "FAIL #2");
0028A6  28DCEC     MOV #0x8DCE, W12
0028CC  090007     REPEAT #0x7
0028CE  785CBC     MOV.B [W12++], [W9++]
0028D0  B10089     SUB #0x8, W9
0028D2  B1008C     SUB #0x8, W12
312:                       }
313:               
314:                       if (xAreBlockTimeTestTasksStillRunning() != pdTRUE) {
0028D6  02228A     CALL xAreBlockTimeTestTasksStillRunning
0028D8  000000     NOP
0028DA  500FE1     SUB W0, #0x1, [W15]
0028DC  320006     BRA Z, .L5
315:                           usErrorDetected = pdTRUE;
0028E8  200018     MOV #0x1, W8
316:                           sprintf(cStringBuffer, "FAIL #3");
0028DE  28DD60     MOV #0x8DD6, W0
0028E0  090007     REPEAT #0x7
0028E2  785CB0     MOV.B [W0++], [W9++]
0028E4  B10089     SUB #0x8, W9
0028E6  B10080     SUB #0x8, W0
317:                       }
318:               
319:                       if (xAreBlockingQueuesStillRunning() != pdTRUE) {
0028EA  02263E     CALL xAreBlockingQueuesStillRunning
0028EC  000000     NOP
0028EE  500FE1     SUB W0, #0x1, [W15]
0028F0  320007     BRA Z, .L6
320:                           usErrorDetected = pdTRUE;
0028FC  200018     MOV #0x1, W8
0028FE  37000D     BRA .L7
321:                           sprintf(cStringBuffer, "FAIL #4");
0028F2  28DDE0     MOV #0x8DDE, W0
0028F4  090007     REPEAT #0x7
0028F6  785CB0     MOV.B [W0++], [W9++]
0028F8  B10089     SUB #0x8, W9
0028FA  B10080     SUB #0x8, W0
322:                       }
323:               
324:                       if (usErrorDetected == pdFALSE) {
002900  E00008     CP0 W8
002902  3A000B     BRA NZ, .L7
325:                           /* No errors have been discovered, so display the maximum jitter
326:                           timer discovered by the "fast interrupt test". */
327:                           sprintf(cStringBuffer, "%dns max jitter", (short) (usMaxJitter - mainEXPECTED_CLOCKS_BETWEEN_INTERRUPTS) * mainNS_PER_CLOCK);
002904  2003E0     MOV #0x3E, W0
002906  804451     MOV usMaxJitter, W1
002908  B98800     MUL.SS W1, W0, W0
00290A  23E402     MOV #0x3E40, W2
00290C  411F80     ADD W2, W0, [W15++]
00290E  28DE60     MOV #0x8DE6, W0
002910  781F80     MOV W0, [W15++]
002912  780009     MOV W9, W0
002914  0206DA     CALL __sprintf_cdnopuxX
002916  000000     NOP
002918  5787E4     SUB W15, #0x4, W15
328:                       }
329:               
330:                       /* Send the message to the LCD gatekeeper for display. */
331:                       xQueueSend(xLCDQueue, &xMessage, portMAX_DELAY);
0028A8  80EDCA     MOV xLCDQueue, W10
00291A  EB0180     CLR W3
00291C  EB8100     SETM W2
00291E  78008E     MOV W14, W1
002920  78000A     MOV W10, W0
002922  021AA8     CALL xQueueGenericSend
002924  000000     NOP
332:                   }
333:               }
334:               
335:               /*-----------------------------------------------------------*/
336:               
337:               void vApplicationIdleHook(void) {
338:                   /* Schedule the co-routines from within the idle task hook. */
339:                   vCoRoutineSchedule();
00295E  0223D2     CALL vCoRoutineSchedule
002960  000000     NOP
340:               }
002962  060000     RETURN
341:               
342:               /*-----------------------------------------------------------*/
343:               
344:               void vApplicationStackOverflowHook(TaskHandle_t pxTask, char *pcTaskName) {
345:                   (void) pcTaskName;
346:                   (void) pxTask;
347:               
348:                   /* Run time stack overflow checking is performed if
349:                   configCHECK_FOR_STACK_OVERFLOW is defined to 1 or 2.  This hook
350:                   function is called if a stack overflow is detected. */
351:                   taskDISABLE_INTERRUPTS();
002964  2FF1F0     MOV #0xFF1F, W0
352:                   for (;;);
353:               }
354:               
---  D:/code/FreeRTOS/Demo/PIC24_MPLAB/lcd.c  -----------------------------------------------------------
1:                 /*
2:                     FreeRTOS V9.0.0 - Copyright (C) 2016 Real Time Engineers Ltd.
3:                     All rights reserved
4:                 
5:                     VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
6:                 
7:                     This file is part of the FreeRTOS distribution.
8:                 
9:                     FreeRTOS is free software; you can redistribute it and/or modify it under
10:                    the terms of the GNU General Public License (version 2) as published by the
11:                    Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
12:                
13:                    ***************************************************************************
14:                    >>!   NOTE: The modification to the GPL is included to allow you to     !<<
15:                    >>!   distribute a combined work that includes FreeRTOS without being   !<<
16:                    >>!   obliged to provide the source code for proprietary components     !<<
17:                    >>!   outside of the FreeRTOS kernel.                                   !<<
18:                    ***************************************************************************
19:                
20:                    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
21:                    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
22:                    FOR A PARTICULAR PURPOSE.  Full license text is available on the following
23:                    link: http://www.freertos.org/a00114.html
24:                
25:                    ***************************************************************************
26:                     *                                                                       *
27:                     *    FreeRTOS provides completely free yet professionally developed,    *
28:                     *    robust, strictly quality controlled, supported, and cross          *
29:                     *    platform software that is more than just the market leader, it     *
30:                     *    is the industry's de facto standard.                               *
31:                     *                                                                       *
32:                     *    Help yourself get started quickly while simultaneously helping     *
33:                     *    to support the FreeRTOS project by purchasing a FreeRTOS           *
34:                     *    tutorial book, reference manual, or both:                          *
35:                     *    http://www.FreeRTOS.org/Documentation                              *
36:                     *                                                                       *
37:                    ***************************************************************************
38:                
39:                    http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
40:                    the FAQ page "My application does not run, what could be wrong?".  Have you
41:                    defined configASSERT()?
42:                
43:                    http://www.FreeRTOS.org/support - In return for receiving this top quality
44:                    embedded software for free we request you assist our global community by
45:                    participating in the support forum.
46:                
47:                    http://www.FreeRTOS.org/training - Investing in training allows your team to
48:                    be as productive as possible as early as possible.  Now you can receive
49:                    FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
50:                    Ltd, and the world's leading authority on the world's leading RTOS.
51:                
52:                    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
53:                    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
54:                    compatible FAT file system, and our tiny thread aware UDP/IP stack.
55:                
56:                    http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
57:                    Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
58:                
59:                    http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
60:                    Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
61:                    licenses offer ticketed support, indemnification and commercial middleware.
62:                
63:                    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
64:                    engineered and independently SIL3 certified version for use in safety and
65:                    mission critical applications that require provable dependability.
66:                
67:                    1 tab == 4 spaces!
68:                */
69:                
70:                /* Scheduler includes. */
71:                #include "FreeRTOS.h"
72:                #include "task.h"
73:                #include "queue.h"
74:                
75:                /* Demo includes. */
76:                #include "lcd.h"
77:                
78:                /*
79:                 * The LCD is written to by more than one task so is controlled by this
80:                 * 'gatekeeper' task.  This is the only task that is actually permitted to
81:                 * access the LCD directly.  Other tasks wanting to display a message send
82:                 * the message to the gatekeeper.
83:                 */
84:                static void vLCDTask( void *pvParameters );
85:                
86:                /*
87:                 * Setup the peripherals required to communicate with the LCD.
88:                 */
89:                static void prvSetupLCD( void );
90:                
91:                /* 
92:                 * Move to the first (0) or second (1) row of the LCD. 
93:                 */
94:                static void prvLCDGotoRow( unsigned short usRow );
95:                
96:                /* 
97:                 * Write a string of text to the LCD. 
98:                 */
99:                static void prvLCDPutString( char *pcString );
100:               
101:               /* 
102:                * Clear the LCD. 
103:                */
104:               static void prvLCDClear( void );
105:               
106:               /*-----------------------------------------------------------*/
107:               
108:               /* Brief delay to permit the LCD to catch up with commands. */
109:               #define lcdSHORT_DELAY		3
110:               
111:               /* SFR that seems to be missing from the standard header files. */
112:               #define PMAEN				*( ( unsigned short * ) 0x60c )
113:               
114:               /* LCD commands. */
115:               #define lcdDEFAULT_FUNCTION	0x3c
116:               #define lcdDISPLAY_CONTROL	0x0c
117:               #define lcdCLEAR_DISPLAY	0x01
118:               #define lcdENTRY_MODE		0x06
119:               
120:               /* The length of the queue used to send messages to the LCD gatekeeper task. */
121:               #define lcdQUEUE_SIZE		3
122:               /*-----------------------------------------------------------*/
123:               
124:               /* The queue used to send messages to the LCD task. */
125:               QueueHandle_t xLCDQueue;
126:               
127:               
128:               /*-----------------------------------------------------------*/
129:               
130:               QueueHandle_t xStartLCDTask( void )
131:               {
132:               	/* Create the queue used by the LCD task.  Messages for display on the LCD
133:               	are received via this queue. */
134:               	xLCDQueue = xQueueCreate( lcdQUEUE_SIZE, sizeof( xLCDMessage ) );
002C50  EB4100     CLR.B W2
002C52  200041     MOV #0x4, W1
002C54  200030     MOV #0x3, W0
002C56  021A74     CALL xQueueGenericCreate
002C58  000000     NOP
002C5A  884520     MOV W0, xLCDQueue
135:               
136:               	/* Start the task that will write to the LCD.  The LCD hardware is
137:               	initialised from within the task itself so delays can be used. */
138:               	xTaskCreate( vLCDTask, "LCD", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY + 1, NULL );
002C5C  EB0280     CLR W5
002C5E  200014     MOV #0x1, W4
002C60  EB0180     CLR W3
002C62  200732     MOV #0x73, W2
002C64  28E771     MOV #0x8E77, W1
002C66  22C1A0     MOV #0x2C1A, W0
002C68  0212C4     CALL xTaskCreate
002C6A  000000     NOP
139:               
140:               	return xLCDQueue;
141:               }
002C6C  804520     MOV xLCDQueue, W0
002C6E  060000     RETURN
142:               /*-----------------------------------------------------------*/
143:               
144:               static void prvLCDGotoRow( unsigned short usRow )
145:               {
146:               //	if( usRow == 0 )
147:               //	{
148:               //		PMADDR = 0x0000;
149:               //		PMDIN1 = 0x02;
150:               //	}
151:               //	else
152:               //	{
153:               //		PMADDR = 0x0000;
154:               //		PMDIN1 = 0xc0;
155:               //	}
156:               
157:               	vTaskDelay( lcdSHORT_DELAY );
002BFA  200030     MOV #0x3, W0
002BFC  021868     CALL vTaskDelay
002BFE  000000     NOP
158:               }
002C00  060000     RETURN
159:               /*-----------------------------------------------------------*/
160:               
161:               static void prvLCDPutString( char *pcString )
162:               {
002C02  BE9F88     MOV.D W8, [W15++]
002C04  780400     MOV W0, W8
163:               	/* Write out each character with appropriate delay between each. */
164:               	while( *pcString )
002C06  E00418     CP0.B [W8]
002C08  320006     BRA Z, .L4
002C12  E00418     CP0.B [W8]
002C14  3AFFFB     BRA NZ, .L7
165:               	{
166:               //		PMADDR = 0x0001;
167:               //		PMDIN1 = *pcString;
168:               //		pcString++;
169:               		vTaskDelay( lcdSHORT_DELAY );
002C0A  200039     MOV #0x3, W9
002C0C  780009     MOV W9, W0
002C0E  021868     CALL vTaskDelay
002C10  000000     NOP
170:               	}
171:               }
002C16  BE044F     MOV.D [--W15], W8
002C18  060000     RETURN
172:               /*-----------------------------------------------------------*/
173:               
174:               static void prvLCDClear( void )
175:               {
176:               	/* Clear the display. */
177:               //	PMADDR = 0x0000;
178:               	PMDIN1 = lcdCLEAR_DISPLAY;
002BEE  200010     MOV #0x1, W0
002BF0  880A00     MOV W0, PMDIN1
179:               	vTaskDelay( lcdSHORT_DELAY );	
002BF2  200030     MOV #0x3, W0
002BF4  021868     CALL vTaskDelay
002BF6  000000     NOP
180:               }
002BF8  060000     RETURN
181:               /*-----------------------------------------------------------*/
182:               
183:               static void prvSetupLCD( void )
184:               {
185:               	/* Setup the PMP. */
186:               //	PMCON = 0x83BF;
187:               //	PMMODE = 0x3FF;
188:               //	PMAEN = 1;
189:               //	PMADDR = 0x0000;
190:               	vTaskDelay( lcdSHORT_DELAY );
002BCE  200030     MOV #0x3, W0
002BD0  021868     CALL vTaskDelay
002BD2  000000     NOP
191:               
192:               	/* Set the default function. */
193:               //	PMDIN1 = lcdDEFAULT_FUNCTION;
194:               	vTaskDelay( lcdSHORT_DELAY );
002BD4  200030     MOV #0x3, W0
002BD6  021868     CALL vTaskDelay
002BD8  000000     NOP
195:               
196:               	/* Set the display control. */
197:               //	PMDIN1 = lcdDISPLAY_CONTROL;
198:               	vTaskDelay( lcdSHORT_DELAY );
002BDA  200030     MOV #0x3, W0
002BDC  021868     CALL vTaskDelay
002BDE  000000     NOP
199:               
200:               	/* Clear the display. */
201:               //	PMDIN1 = lcdCLEAR_DISPLAY;
202:               	vTaskDelay( lcdSHORT_DELAY );
002BE0  200030     MOV #0x3, W0
002BE2  021868     CALL vTaskDelay
002BE4  000000     NOP
203:               
204:               	/* Set the entry mode. */
205:               //	PMDIN1 = lcdENTRY_MODE;
206:               	vTaskDelay( lcdSHORT_DELAY );
002BE6  200030     MOV #0x3, W0
002BE8  021868     CALL vTaskDelay
002BEA  000000     NOP
207:               }
002BEC  060000     RETURN
208:               /*-----------------------------------------------------------*/
209:               
210:               static void vLCDTask( void *pvParameters )
211:               {
002C1A  FA0004     LNK #0x4
002C1C  BE9F88     MOV.D W8, [W15++]
212:               xLCDMessage xMessage;
213:               unsigned short usRow = 0;
002C26  EB0500     CLR W10
214:               
215:               	/* Remove compiler warnigns. */
216:               	( void ) pvParameters;
217:               
218:               	/* Initialise the hardware.  This uses delays so must not be called prior
219:               	to the scheduler being started. */
220:               	prvSetupLCD();
002C1E  781F8A     MOV W10, [W15++]
002C20  07FFD6     RCALL .Letext0, .LFE5, _prvSetupLCD, .Ltext0, .LFB4
221:               
222:               	/* Welcome message. */
223:               	prvLCDPutString( "www.FreeRTOS.org" );
002C22  28E660     MOV #0x8E66, W0
002C24  07FFEE     RCALL _prvLCDPutString, .LFE1, .LFB2
224:               
225:               	for( ;; )
226:               	{
227:               		/* Wait for a message to arrive that requires displaying. */
228:               		while( xQueueReceive( xLCDQueue, &xMessage, portMAX_DELAY ) != pdPASS );
002C28  EB0400     CLR W8
002C2A  EB8480     SETM W9
002C2C  780188     MOV W8, W3
002C2E  780109     MOV W9, W2
002C30  5780EA     SUB W15, #0xA, W1
002C32  804520     MOV xLCDQueue, W0
002C34  021C16     CALL xQueueGenericReceive
002C36  000000     NOP
002C38  500FE1     SUB W0, #0x1, [W15]
229:               
230:               		/* Clear the current display value. */
231:               		prvLCDClear();
002C3A  3AFFF8     BRA NZ, .L14
002C3C  07FFD8     RCALL _prvLCDClear, .LFE4, .LFB3
232:               
233:               		/* Switch rows each time so we can see that the display is still being
234:               		updated. */
235:               		prvLCDGotoRow( usRow & 0x01 );
002C3E  650061     AND W10, #0x1, W0
002C40  07FFDC     RCALL _prvLCDGotoRow, .LFE3, .LFB1
236:               		usRow++;
002C42  E8050A     INC W10, W10
237:               		prvLCDPutString( xMessage.pcMessage );
002C44  97B84F     MOV [W15-8], W0
002C46  07FFDD     RCALL _prvLCDPutString, .LFE1, .LFB2
238:               
239:               		/* Delay the requested amount of time to ensure the text just written 
240:               		to the LCD is not overwritten. */
241:               		vTaskDelay( xMessage.xMinDisplayTime );		
002C48  97B83F     MOV [W15-10], W0
002C4A  021868     CALL vTaskDelay
002C4C  000000     NOP
002C4E  37FFEE     BRA .L14
242:               	}
243:               }
244:               
245:               
246:               
247:               
---  D:/code/FreeRTOS/Demo/PIC24_MPLAB/ParTest/ParTest.c  -----------------------------------------------
1:                 /*
2:                     FreeRTOS V9.0.0 - Copyright (C) 2016 Real Time Engineers Ltd.
3:                     All rights reserved
4:                 
5:                     VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
6:                 
7:                     This file is part of the FreeRTOS distribution.
8:                 
9:                     FreeRTOS is free software; you can redistribute it and/or modify it under
10:                    the terms of the GNU General Public License (version 2) as published by the
11:                    Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
12:                
13:                    ***************************************************************************
14:                    >>!   NOTE: The modification to the GPL is included to allow you to     !<<
15:                    >>!   distribute a combined work that includes FreeRTOS without being   !<<
16:                    >>!   obliged to provide the source code for proprietary components     !<<
17:                    >>!   outside of the FreeRTOS kernel.                                   !<<
18:                    ***************************************************************************
19:                
20:                    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
21:                    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
22:                    FOR A PARTICULAR PURPOSE.  Full license text is available on the following
23:                    link: http://www.freertos.org/a00114.html
24:                
25:                    ***************************************************************************
26:                     *                                                                       *
27:                     *    FreeRTOS provides completely free yet professionally developed,    *
28:                     *    robust, strictly quality controlled, supported, and cross          *
29:                     *    platform software that is more than just the market leader, it     *
30:                     *    is the industry's de facto standard.                               *
31:                     *                                                                       *
32:                     *    Help yourself get started quickly while simultaneously helping     *
33:                     *    to support the FreeRTOS project by purchasing a FreeRTOS           *
34:                     *    tutorial book, reference manual, or both:                          *
35:                     *    http://www.FreeRTOS.org/Documentation                              *
36:                     *                                                                       *
37:                    ***************************************************************************
38:                
39:                    http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
40:                    the FAQ page "My application does not run, what could be wrong?".  Have you
41:                    defined configASSERT()?
42:                
43:                    http://www.FreeRTOS.org/support - In return for receiving this top quality
44:                    embedded software for free we request you assist our global community by
45:                    participating in the support forum.
46:                
47:                    http://www.FreeRTOS.org/training - Investing in training allows your team to
48:                    be as productive as possible as early as possible.  Now you can receive
49:                    FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
50:                    Ltd, and the world's leading authority on the world's leading RTOS.
51:                
52:                    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
53:                    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
54:                    compatible FAT file system, and our tiny thread aware UDP/IP stack.
55:                
56:                    http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
57:                    Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
58:                
59:                    http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
60:                    Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
61:                    licenses offer ticketed support, indemnification and commercial middleware.
62:                
63:                    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
64:                    engineered and independently SIL3 certified version for use in safety and
65:                    mission critical applications that require provable dependability.
66:                
67:                    1 tab == 4 spaces!
68:                */
69:                
70:                /* Scheduler includes. */
71:                #include "FreeRTOS.h"
72:                
73:                /* Demo app includes. */
74:                #include "partest.h"
75:                
76:                #define ptOUTPUT 	0
77:                #define ptALL_OFF	0
78:                
79:                /*-----------------------------------------------------------
80:                 * Simple parallel port IO routines.
81:                 *-----------------------------------------------------------*/
82:                
83:                void vParTestInitialise( void )
84:                {
85:                	/* The explorer 16 board has LED's on port A.  All bits are set as output
86:                	so PORTA is read-modified-written directly. */
87:                	TRISA = ptOUTPUT;
002D6C  EF2662     CLR TRISA
88:                	PORTA = ptALL_OFF;
002D6E  EF2664     CLR PORTA
89:                }
002D70  060000     RETURN
90:                /*-----------------------------------------------------------*/
91:                
92:                void vParTestSetLED( unsigned portBASE_TYPE uxLED, signed portBASE_TYPE xValue )
93:                {
002D72  781F88     MOV W8, [W15++]
94:                unsigned portBASE_TYPE uxLEDBit;
95:                
96:                	/* Which port A bit is being modified? */
97:                	uxLEDBit = 1 << uxLED;
002D74  200018     MOV #0x1, W8
002D76  DD4400     SL W8, W0, W8
98:                
99:                	if( xValue )
002D78  E00001     CP0 W1
002D7A  320007     BRA Z, .L3
100:               	{
101:               		/* Turn the LED on. */
102:               		portENTER_CRITICAL();
002D7C  022BB0     CALL vPortEnterCritical
002D7E  000000     NOP
103:               		{
104:               			PORTA |= uxLEDBit;
002D80  780008     MOV W8, W0
002D82  B72664     IOR PORTA
105:               		}
106:               		portEXIT_CRITICAL();
002D84  022BC0     CALL vPortExitCritical
002D86  000000     NOP
002D88  370008     BRA .L2
107:               	}
108:               	else
109:               	{
110:               		/* Turn the LED off. */
111:               		portENTER_CRITICAL();
002D8A  022BB0     CALL vPortEnterCritical
002D8C  000000     NOP
112:               		{
113:               			PORTA &= ~uxLEDBit;
002D8E  EA8408     COM W8, W8
002D90  803320     MOV PORTA, W0
002D92  600408     AND W0, W8, W8
002D94  883328     MOV W8, PORTA
114:               		}
115:               		portEXIT_CRITICAL();
002D96  022BC0     CALL vPortExitCritical
002D98  000000     NOP
116:               	}
117:               }
002D9A  78044F     MOV [--W15], W8
002D9C  060000     RETURN
118:               /*-----------------------------------------------------------*/
119:               
120:               void vParTestToggleLED( unsigned portBASE_TYPE uxLED )
121:               {
002D9E  781F88     MOV W8, [W15++]
122:               unsigned portBASE_TYPE uxLEDBit;
123:               
124:               	uxLEDBit = 1 << uxLED;
002DA0  200018     MOV #0x1, W8
002DA2  DD4400     SL W8, W0, W8
125:               	portENTER_CRITICAL();
002DA4  022BB0     CALL vPortEnterCritical
002DA6  000000     NOP
126:               	{
127:               		/* If the LED is already on - turn it off.  If the LED is already
128:               		off, turn it on. */
129:               		if( PORTA & uxLEDBit )
002DA8  803321     MOV PORTA, W1
002DAA  608008     AND W1, W8, W0
002DAC  320005     BRA Z, .L6
130:               		{
131:               			PORTA &= ~uxLEDBit;
002DAE  EA8408     COM W8, W8
002DB0  803320     MOV PORTA, W0
002DB2  600408     AND W0, W8, W8
002DB4  883328     MOV W8, PORTA
002DB6  370002     BRA .L7
132:               		}
133:               		else
134:               		{
135:               			PORTA |= uxLEDBit;
002DB8  780008     MOV W8, W0
002DBA  B72664     IOR PORTA
136:               		}
137:               	}
138:               	portEXIT_CRITICAL();
002DBC  022BC0     CALL vPortExitCritical
002DBE  000000     NOP
139:               }
002DC0  78044F     MOV [--W15], W8
002DC2  060000     RETURN
140:               
---  D:/code/FreeRTOS/Demo/Common/Minimal/integer.c  ----------------------------------------------------
1:                 /*
2:                     FreeRTOS V9.0.0 - Copyright (C) 2016 Real Time Engineers Ltd.
3:                     All rights reserved
4:                 
5:                     VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
6:                 
7:                     This file is part of the FreeRTOS distribution.
8:                 
9:                     FreeRTOS is free software; you can redistribute it and/or modify it under
10:                    the terms of the GNU General Public License (version 2) as published by the
11:                    Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
12:                
13:                    ***************************************************************************
14:                    >>!   NOTE: The modification to the GPL is included to allow you to     !<<
15:                    >>!   distribute a combined work that includes FreeRTOS without being   !<<
16:                    >>!   obliged to provide the source code for proprietary components     !<<
17:                    >>!   outside of the FreeRTOS kernel.                                   !<<
18:                    ***************************************************************************
19:                
20:                    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
21:                    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
22:                    FOR A PARTICULAR PURPOSE.  Full license text is available on the following
23:                    link: http://www.freertos.org/a00114.html
24:                
25:                    ***************************************************************************
26:                     *                                                                       *
27:                     *    FreeRTOS provides completely free yet professionally developed,    *
28:                     *    robust, strictly quality controlled, supported, and cross          *
29:                     *    platform software that is more than just the market leader, it     *
30:                     *    is the industry's de facto standard.                               *
31:                     *                                                                       *
32:                     *    Help yourself get started quickly while simultaneously helping     *
33:                     *    to support the FreeRTOS project by purchasing a FreeRTOS           *
34:                     *    tutorial book, reference manual, or both:                          *
35:                     *    http://www.FreeRTOS.org/Documentation                              *
36:                     *                                                                       *
37:                    ***************************************************************************
38:                
39:                    http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
40:                    the FAQ page "My application does not run, what could be wrong?".  Have you
41:                    defined configASSERT()?
42:                
43:                    http://www.FreeRTOS.org/support - In return for receiving this top quality
44:                    embedded software for free we request you assist our global community by
45:                    participating in the support forum.
46:                
47:                    http://www.FreeRTOS.org/training - Investing in training allows your team to
48:                    be as productive as possible as early as possible.  Now you can receive
49:                    FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
50:                    Ltd, and the world's leading authority on the world's leading RTOS.
51:                
52:                    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
53:                    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
54:                    compatible FAT file system, and our tiny thread aware UDP/IP stack.
55:                
56:                    http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
57:                    Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
58:                
59:                    http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
60:                    Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
61:                    licenses offer ticketed support, indemnification and commercial middleware.
62:                
63:                    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
64:                    engineered and independently SIL3 certified version for use in safety and
65:                    mission critical applications that require provable dependability.
66:                
67:                    1 tab == 4 spaces!
68:                */
69:                
70:                /*
71:                 * Creates one or more tasks that repeatedly perform a set of integer
72:                 * calculations.  The result of each run-time calculation is compared to the 
73:                 * known expected result - with a mismatch being indicative of an error in the
74:                 * context switch mechanism.
75:                 */
76:                
77:                #include <stdlib.h>
78:                
79:                /* Scheduler include files. */
80:                #include "FreeRTOS.h"
81:                #include "task.h"
82:                
83:                /* Demo program include files. */
84:                #include "integer.h"
85:                
86:                /* The constants used in the calculation. */
87:                #define intgCONST1				( ( long ) 123 )
88:                #define intgCONST2				( ( long ) 234567 )
89:                #define intgCONST3				( ( long ) -3 )
90:                #define intgCONST4				( ( long ) 7 )
91:                #define intgEXPECTED_ANSWER		( ( ( intgCONST1 + intgCONST2 ) * intgCONST3 ) / intgCONST4 )
92:                
93:                #define intgSTACK_SIZE			configMINIMAL_STACK_SIZE
94:                
95:                /* As this is the minimal version, we will only create one task. */
96:                #define intgNUMBER_OF_TASKS		( 1 )
97:                
98:                /* The task function.  Repeatedly performs a 32 bit calculation, checking the
99:                result against the expected result.  If the result is incorrect then the
100:               context switch must have caused some corruption. */
101:               static portTASK_FUNCTION_PROTO( vCompeteingIntMathTask, pvParameters );
102:               
103:               /* Variables that are set to true within the calculation task to indicate
104:               that the task is still executing.  The check task sets the variable back to
105:               false, flagging an error if the variable is still false the next time it
106:               is called. */
107:               static volatile BaseType_t xTaskCheck[ intgNUMBER_OF_TASKS ] = { ( BaseType_t ) pdFALSE };
108:               
109:               /*-----------------------------------------------------------*/
110:               
111:               void vStartIntegerMathTasks( UBaseType_t uxPriority )
112:               {
002CDA  780200     MOV W0, W4
113:               short sTask;
114:               
115:               	for( sTask = 0; sTask < intgNUMBER_OF_TASKS; sTask++ )
116:               	{
117:               		xTaskCreate( vCompeteingIntMathTask, "IntMath", intgSTACK_SIZE, ( void * ) &( xTaskCheck[ sTask ] ), uxPriority, ( TaskHandle_t * ) NULL );
002CDC  EB0280     CLR W5
002CDE  208A23     MOV #0x8A2, W3
002CE0  200732     MOV #0x73, W2
002CE2  28EA61     MOV #0x8EA6, W1
002CE4  22C700     MOV #0x2C70, W0
002CE6  0212C4     CALL xTaskCreate
002CE8  000000     NOP
118:               	}
119:               }
002CEA  060000     RETURN
120:               /*-----------------------------------------------------------*/
121:               
122:               static portTASK_FUNCTION( vCompeteingIntMathTask, pvParameters )
123:               {
002C70  FA0004     LNK #0x4
002C72  BE9F88     MOV.D W8, [W15++]
002C74  BE9F8A     MOV.D W10, [W15++]
002C76  BE9F8C     MOV.D W12, [W15++]
002C78  780480     MOV W0, W9
124:               /* These variables are all effectively set to constants so they are volatile to
125:               ensure the compiler does not just get rid of them. */
126:               volatile long lValue;
127:               short sError = pdFALSE;
002C7A  EB0400     CLR W8
128:               volatile BaseType_t *pxTaskHasExecuted;
129:               
130:               	/* Set a pointer to the variable we are going to set to true each
131:               	iteration.  This is also a good test of the parameter passing mechanism
132:               	within each port. */
133:               	pxTaskHasExecuted = ( volatile BaseType_t * ) pvParameters;
134:               
135:               	/* Keep performing a calculation and checking the result against a constant. */
136:               	for( ;; )
137:               	{
138:               		/* Perform the calculation.  This will store partial value in
139:               		registers, resulting in a good test of the context switch mechanism. */
140:               		lValue = intgCONST1;
002C88  2007B0     MOV #0x7B, W0
002C8A  200001     MOV #0x0, W1
002C8C  9FBF80     MOV W0, [W15-16]
002C8E  9FBF91     MOV W1, [W15-14]
141:               		lValue += intgCONST2;
002C7C  29447A     MOV #0x9447, W10
002C7E  20003B     MOV #0x3, W11
002C90  97B80F     MOV [W15-16], W0
002C92  97B89F     MOV [W15-14], W1
002C94  450000     ADD W10, W0, W0
002C96  4D8081     ADDC W11, W1, W1
002C98  9FBF80     MOV W0, [W15-16]
002C9A  9FBF91     MOV W1, [W15-14]
142:               
143:               		/* Yield in case cooperative scheduling is being used. */
144:               		#if configUSE_PREEMPTION == 0
145:               		{
146:               			taskYIELD();
147:               		}
148:               		#endif
149:               
150:               		/* Finish off the calculation. */
151:               		lValue *= intgCONST3;
002C9C  97B80F     MOV [W15-16], W0
002C9E  97B89F     MOV [W15-14], W1
002CA0  2FFFD2     MOV #0xFFFD, W2
002CA2  B98A02     MUL.SS W1, W2, W4
002CA4  520180     SUB W4, W0, W3
002CA6  B80002     MUL.UU W0, W2, W0
002CA8  418081     ADD W3, W1, W1
002CAA  9FBF80     MOV W0, [W15-16]
002CAC  9FBF91     MOV W1, [W15-14]
152:               		lValue /= intgCONST4;
002CAE  97B80F     MOV [W15-16], W0
002CB0  97B89F     MOV [W15-14], W1
002CB2  200072     MOV #0x7, W2
002CB4  200003     MOV #0x0, W3
002CB6  0204F6     CALL ___divsi3
002CB8  000000     NOP
002CBA  9FBF80     MOV W0, [W15-16]
002CBC  9FBF91     MOV W1, [W15-14]
153:               
154:               		/* If the calculation is found to be incorrect we stop setting the 
155:               		TaskHasExecuted variable so the check task can see an error has 
156:               		occurred. */
157:               		if( lValue != intgEXPECTED_ANSWER ) /*lint !e774 volatile used to prevent this being optimised out. */
002C80  2771BC     MOV #0x771B, W12
002C82  2FFFED     MOV #0xFFFE, W13
002C84  370001     BRA .L7
002CBE  97B80F     MOV [W15-16], W0
002CC0  97B89F     MOV [W15-14], W1
002CC2  500F8C     SUB W0, W12, [W15]
002CC4  588F8D     SUBB W1, W13, [W15]
002CC6  3AFFDF     BRA NZ, .L4
158:               		{
159:               			sError = pdTRUE;
002C86  200018     MOV #0x1, W8
160:               		}
161:               
162:               		if( sError == pdFALSE )
002CC8  E00008     CP0 W8
002CCA  3AFFDE     BRA NZ, .L7
163:               		{
164:               			/* We have not encountered any errors, so set the flag that show
165:               			we are still executing.  This will be periodically cleared by
166:               			the check task. */
167:               			portENTER_CRITICAL();
002CCC  022BB0     CALL vPortEnterCritical
002CCE  000000     NOP
168:               				*pxTaskHasExecuted = pdTRUE;
002CD0  200010     MOV #0x1, W0
002CD2  780C80     MOV W0, [W9]
169:               			portEXIT_CRITICAL();
002CD4  022BC0     CALL vPortExitCritical
002CD6  000000     NOP
002CD8  37FFD7     BRA .L7
170:               		}
171:               
172:               		/* Yield in case cooperative scheduling is being used. */
173:               		#if configUSE_PREEMPTION == 0
174:               		{
175:               			taskYIELD();
176:               		}
177:               		#endif
178:               	}
179:               }
180:               /*-----------------------------------------------------------*/
181:               
182:               /* This is called to check that all the created tasks are still running. */
183:               BaseType_t xAreIntegerMathsTaskStillRunning( void )
002CF0  A7F000     BTSC W0, #15
002CF2  EA0000     NEG W0, W0
002CF4  EA0000     NEG W0, W0
002CF6  DE004F     LSR W0, #15, W0
184:               {
185:               BaseType_t xReturn = pdTRUE;
186:               short sTask;
187:               
188:               	/* Check the maths tasks are still running by ensuring their check variables 
189:               	are still being set to true. */
190:               	for( sTask = 0; sTask < intgNUMBER_OF_TASKS; sTask++ )
191:               	{
192:               		if( xTaskCheck[ sTask ] == pdFALSE )
002CEC  804510     MOV xTaskCheck, W0
193:               		{
194:               			/* The check has not incremented so an error exists. */
195:               			xReturn = pdFALSE;
196:               		}
197:               
198:               		/* Reset the check variable so we can tell if it has been set by
199:               		the next time around. */
200:               		xTaskCheck[ sTask ] = pdFALSE;
002CEE  EF28A2     CLR xTaskCheck
201:               	}
202:               
203:               	return xReturn;
204:               }
002CF8  060000     RETURN
205:               
---  D:/code/FreeRTOS/Demo/Common/Minimal/crflash.c  ----------------------------------------------------
1:                 /*
2:                     FreeRTOS V9.0.0 - Copyright (C) 2016 Real Time Engineers Ltd.
3:                     All rights reserved
4:                 
5:                     VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
6:                 
7:                     This file is part of the FreeRTOS distribution.
8:                 
9:                     FreeRTOS is free software; you can redistribute it and/or modify it under
10:                    the terms of the GNU General Public License (version 2) as published by the
11:                    Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
12:                
13:                    ***************************************************************************
14:                    >>!   NOTE: The modification to the GPL is included to allow you to     !<<
15:                    >>!   distribute a combined work that includes FreeRTOS without being   !<<
16:                    >>!   obliged to provide the source code for proprietary components     !<<
17:                    >>!   outside of the FreeRTOS kernel.                                   !<<
18:                    ***************************************************************************
19:                
20:                    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
21:                    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
22:                    FOR A PARTICULAR PURPOSE.  Full license text is available on the following
23:                    link: http://www.freertos.org/a00114.html
24:                
25:                    ***************************************************************************
26:                     *                                                                       *
27:                     *    FreeRTOS provides completely free yet professionally developed,    *
28:                     *    robust, strictly quality controlled, supported, and cross          *
29:                     *    platform software that is more than just the market leader, it     *
30:                     *    is the industry's de facto standard.                               *
31:                     *                                                                       *
32:                     *    Help yourself get started quickly while simultaneously helping     *
33:                     *    to support the FreeRTOS project by purchasing a FreeRTOS           *
34:                     *    tutorial book, reference manual, or both:                          *
35:                     *    http://www.FreeRTOS.org/Documentation                              *
36:                     *                                                                       *
37:                    ***************************************************************************
38:                
39:                    http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
40:                    the FAQ page "My application does not run, what could be wrong?".  Have you
41:                    defined configASSERT()?
42:                
43:                    http://www.FreeRTOS.org/support - In return for receiving this top quality
44:                    embedded software for free we request you assist our global community by
45:                    participating in the support forum.
46:                
47:                    http://www.FreeRTOS.org/training - Investing in training allows your team to
48:                    be as productive as possible as early as possible.  Now you can receive
49:                    FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
50:                    Ltd, and the world's leading authority on the world's leading RTOS.
51:                
52:                    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
53:                    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
54:                    compatible FAT file system, and our tiny thread aware UDP/IP stack.
55:                
56:                    http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
57:                    Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
58:                
59:                    http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
60:                    Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
61:                    licenses offer ticketed support, indemnification and commercial middleware.
62:                
63:                    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
64:                    engineered and independently SIL3 certified version for use in safety and
65:                    mission critical applications that require provable dependability.
66:                
67:                    1 tab == 4 spaces!
68:                */
69:                
70:                /*
71:                 * This demo application file demonstrates the use of queues to pass data
72:                 * between co-routines.
73:                 *
74:                 * N represents the number of 'fixed delay' co-routines that are created and
75:                 * is set during initialisation.
76:                 *
77:                 * N 'fixed delay' co-routines are created that just block for a fixed
78:                 * period then post the number of an LED onto a queue.  Each such co-routine
79:                 * uses a different block period.  A single 'flash' co-routine is also created
80:                 * that blocks on the same queue, waiting for the number of the next LED it
81:                 * should flash.  Upon receiving a number it simply toggle the instructed LED
82:                 * then blocks on the queue once more.  In this manner each LED from LED 0 to
83:                 * LED N-1 is caused to flash at a different rate.
84:                 *
85:                 * The 'fixed delay' co-routines are created with co-routine priority 0.  The
86:                 * flash co-routine is created with co-routine priority 1.  This means that
87:                 * the queue should never contain more than a single item.  This is because
88:                 * posting to the queue will unblock the 'flash' co-routine, and as this has
89:                 * a priority greater than the tasks posting to the queue it is guaranteed to
90:                 * have emptied the queue and blocked once again before the queue can contain
91:                 * any more date.  An error is indicated if an attempt to post data to the
92:                 * queue fails - indicating that the queue is already full.
93:                 *
94:                 */
95:                
96:                /* Scheduler includes. */
97:                #include "FreeRTOS.h"
98:                #include "croutine.h"
99:                #include "queue.h"
100:               
101:               /* Demo application includes. */
102:               #include "partest.h"
103:               #include "crflash.h"
104:               
105:               /* The queue should only need to be of length 1.  See the description at the
106:               top of the file. */
107:               #define crfQUEUE_LENGTH		1
108:               
109:               #define crfFIXED_DELAY_PRIORITY		0
110:               #define crfFLASH_PRIORITY			1
111:               
112:               /* Only one flash co-routine is created so the index is not significant. */
113:               #define crfFLASH_INDEX				0
114:               
115:               /* Don't allow more than crfMAX_FLASH_TASKS 'fixed delay' co-routines to be
116:               created. */
117:               #define crfMAX_FLASH_TASKS			8
118:               
119:               /* We don't want to block when posting to the queue. */
120:               #define crfPOSTING_BLOCK_TIME		0
121:               
122:               /*
123:                * The 'fixed delay' co-routine as described at the top of the file.
124:                */
125:               static void prvFixedDelayCoRoutine( CoRoutineHandle_t xHandle, UBaseType_t uxIndex );
126:               
127:               /*
128:                * The 'flash' co-routine as described at the top of the file.
129:                */
130:               static void prvFlashCoRoutine( CoRoutineHandle_t xHandle, UBaseType_t uxIndex );
131:               
132:               /* The queue used to pass data between the 'fixed delay' co-routines and the
133:               'flash' co-routine. */
134:               static QueueHandle_t xFlashQueue;
135:               
136:               /* This will be set to pdFALSE if we detect an error. */
137:               static BaseType_t xCoRoutineFlashStatus = pdPASS;
138:               
139:               /*-----------------------------------------------------------*/
140:               
141:               /*
142:                * See the header file for details.
143:                */
144:               void vStartFlashCoRoutines( UBaseType_t uxNumberToCreate )
145:               {
00273E  BE9F88     MOV.D W8, [W15++]
002740  BE9F8A     MOV.D W10, [W15++]
002742  780480     MOV W0, W9
146:               UBaseType_t uxIndex;
147:               
148:               	if( uxNumberToCreate > crfMAX_FLASH_TASKS )
149:               	{
150:               		uxNumberToCreate = crfMAX_FLASH_TASKS;
151:               	}
152:               
153:               	/* Create the queue used to pass data between the co-routines. */
154:               	xFlashQueue = xQueueCreate( crfQUEUE_LENGTH, sizeof( UBaseType_t ) );
002744  EB4100     CLR.B W2
002746  200021     MOV #0x2, W1
002748  200010     MOV #0x1, W0
00274A  021A74     CALL xQueueGenericCreate
00274C  000000     NOP
00274E  884500     MOV W0, xFlashQueue
155:               
156:               	if( xFlashQueue )
002750  E00000     CP0 W0
002752  320015     BRA Z, .L19
002754  548FE8     SUB W9, #0x8, [W15]
002756  360001     BRA LEU, .L21
002758  200089     MOV #0x8, W9
157:               	{
158:               		/* Create uxNumberToCreate 'fixed delay' co-routines. */
159:               		for( uxIndex = 0; uxIndex < uxNumberToCreate; uxIndex++ )
00275A  E00009     CP0 W9
00275C  32000B     BRA Z, .L22
00275E  EB0400     CLR W8
00276E  E80408     INC W8, W8
002770  548F88     SUB W9, W8, [W15]
002772  3EFFF8     BRA GTU, .L23
160:               		{
161:               			xCoRoutineCreate( prvFixedDelayCoRoutine, crfFIXED_DELAY_PRIORITY, uxIndex );
002760  EB0500     CLR W10
002762  226CEB     MOV #0x26CE, W11
002764  780108     MOV W8, W2
002766  78008A     MOV W10, W1
002768  78000B     MOV W11, W0
00276A  02245C     CALL xCoRoutineCreate
00276C  000000     NOP
162:               		}
163:               
164:               		/* Create the 'flash' co-routine. */
165:               		xCoRoutineCreate( prvFlashCoRoutine, crfFLASH_PRIORITY, crfFLASH_INDEX );
002774  EB0100     CLR W2
002776  200011     MOV #0x1, W1
002778  226760     MOV #0x2676, W0
00277A  02245C     CALL xCoRoutineCreate
00277C  000000     NOP
166:               	}
167:               }
00277E  BE054F     MOV.D [--W15], W10
002780  BE044F     MOV.D [--W15], W8
002782  060000     RETURN
168:               /*-----------------------------------------------------------*/
169:               
170:               static void prvFixedDelayCoRoutine( CoRoutineHandle_t xHandle, UBaseType_t uxIndex )
171:               {
0026CE  FA0002     LNK #0x2
0026D0  781F88     MOV W8, [W15++]
0026D2  9FBFE1     MOV W1, [W15-4]
172:               /* Even though this is a co-routine the xResult variable does not need to be
173:               static as we do not need it to maintain its state between blocks. */
174:               BaseType_t xResult;
175:               /* The uxIndex parameter of the co-routine function is used as an index into
176:               the xFlashRates array to obtain the delay period to use. */
177:               static const TickType_t xFlashRates[ crfMAX_FLASH_TASKS ] = { 150 / portTICK_PERIOD_MS,
178:               																200 / portTICK_PERIOD_MS,
179:               																250 / portTICK_PERIOD_MS,
180:               																300 / portTICK_PERIOD_MS,
181:               																350 / portTICK_PERIOD_MS,
182:               																400 / portTICK_PERIOD_MS,
183:               																450 / portTICK_PERIOD_MS,
184:               																500  / portTICK_PERIOD_MS };
185:               
186:               	/* Co-routines MUST start with a call to crSTART. */
187:               	crSTART( xHandle );
0026D4  780400     MOV W0, W8
0026D6  900858     MOV [W8+26], W0
0026D8  201821     MOV #0x182, W1
0026DA  500F81     SUB W0, W1, [W15]
0026DC  320014     BRA Z, .L12
0026DE  3E0003     BRA GTU, .L14
0026E0  E00000     CP0 W0
0026E2  320007     BRA Z, .L11
0026E4  370029     BRA .L9
0026E6  201831     MOV #0x183, W1
0026E8  500F81     SUB W0, W1, [W15]
0026EA  320017     BRA Z, .L18
0026EC  4080F3     ADD W1, #0x13, W1
0026EE  500F81     SUB W0, W1, [W15]
0026F0  3A0023     BRA NZ, .L9
188:               
189:               	for( ;; )
190:               	{
191:               		/* Post our uxIndex value onto the queue.  This is used as the LED to
192:               		flash. */
193:               		crQUEUE_SEND( xHandle, xFlashQueue, ( void * ) &uxIndex, crfPOSTING_BLOCK_TIME, &xResult );
0026F2  EB0100     CLR W2
0026F4  5780E4     SUB W15, #0x4, W1
0026F6  804500     MOV xFlashQueue, W0
0026F8  021DC4     CALL xQueueCRSend
0026FA  000000     NOP
0026FC  400FE4     ADD W0, #0x4, [W15]
0026FE  3A0008     BRA NZ, .L15
002700  201820     MOV #0x182, W0
002702  980C50     MOV W0, [W8+26]
002704  370019     BRA .L9
002706  EB0100     CLR W2
002708  5780E4     SUB W15, #0x4, W1
00270A  804500     MOV xFlashQueue, W0
00270C  021DC4     CALL xQueueCRSend
00270E  000000     NOP
002710  400FE5     ADD W0, #0x5, [W15]
002712  3A0004     BRA NZ, .L13
002714  201830     MOV #0x183, W0
002716  980C50     MOV W0, [W8+26]
002718  37000F     BRA .L9
00271A  200010     MOV #0x1, W0
194:               
195:               		if( xResult != pdPASS )
00271C  500FE1     SUB W0, #0x1, [W15]
00271E  320001     BRA Z, .L16
196:               		{
197:               			/* For the reasons stated at the top of the file we should always
198:               			find that we can post to the queue.  If we could not then an error
199:               			has occurred. */
200:               			xCoRoutineFlashStatus = pdFAIL;
002720  EF289E     CLR 0x89E
201:               		}
202:               
203:               		crDELAY( xHandle, xFlashRates[ uxIndex ] );
002722  97B86F     MOV [W15-4], W0
002724  400000     ADD W0, W0, W0
002726  28E7C1     MOV #0x8E7C, W1
002728  780061     MOV [W1+W0], W0
00272A  E00000     CP0 W0
00272C  320003     BRA Z, .L17
00272E  EB0080     CLR W1
002730  0222B4     CALL vCoRoutineAddToDelayedList
002732  000000     NOP
002734  201960     MOV #0x196, W0
002736  980C50     MOV W0, [W8+26]
204:               	}
205:               
206:               	/* Co-routines MUST end with a call to crEND. */
207:               	crEND();
208:               }
002738  78044F     MOV [--W15], W8
00273A  FA8000     ULNK
00273C  060000     RETURN
209:               /*-----------------------------------------------------------*/
210:               
211:               static void prvFlashCoRoutine( CoRoutineHandle_t xHandle, UBaseType_t uxIndex )
212:               {
002676  FA0002     LNK #0x2
002678  781F88     MOV W8, [W15++]
00267A  780400     MOV W0, W8
213:               /* Even though this is a co-routine the variable do not need to be
214:               static as we do not need it to maintain their state between blocks. */
215:               BaseType_t xResult;
216:               UBaseType_t uxLEDToFlash;
217:               
218:               	/* Co-routines MUST start with a call to crSTART. */
219:               	crSTART( xHandle );
00267C  900858     MOV [W8+26], W0
00267E  201C21     MOV #0x1C2, W1
002680  500F81     SUB W0, W1, [W15]
002682  32000F     BRA Z, .L4
002684  E80081     INC W1, W1
002686  500F81     SUB W0, W1, [W15]
002688  320016     BRA Z, .L8
00268A  E00000     CP0 W0
00268C  3A001D     BRA NZ, .L1
220:               	( void ) uxIndex;
221:               	
222:               	for( ;; )
223:               	{
224:               		/* Block to wait for the number of the LED to flash. */
225:               		crQUEUE_RECEIVE( xHandle, xFlashQueue, &uxLEDToFlash, portMAX_DELAY, &xResult );		
00268E  EB8100     SETM W2
002690  5780E4     SUB W15, #0x4, W1
002692  804500     MOV xFlashQueue, W0
002694  021E4A     CALL xQueueCRReceive
002696  000000     NOP
002698  400FE4     ADD W0, #0x4, [W15]
00269A  3A0008     BRA NZ, .L6
00269C  201C20     MOV #0x1C2, W0
00269E  980C50     MOV W0, [W8+26]
0026A0  370013     BRA .L1
0026A2  EB0100     CLR W2
0026A4  5780E4     SUB W15, #0x4, W1
0026A6  804500     MOV xFlashQueue, W0
0026A8  021E4A     CALL xQueueCRReceive
0026AA  000000     NOP
0026AC  400FE5     ADD W0, #0x5, [W15]
0026AE  3A0004     BRA NZ, .L5
0026B0  201C30     MOV #0x1C3, W0
0026B2  980C50     MOV W0, [W8+26]
0026B4  370009     BRA .L1
0026B6  200010     MOV #0x1, W0
226:               
227:               		if( xResult != pdPASS )
0026B8  500FE1     SUB W0, #0x1, [W15]
0026BA  320002     BRA Z, .L7
228:               		{
229:               			/* We would not expect to wake unless we received something. */
230:               			xCoRoutineFlashStatus = pdFAIL;
0026BC  EF289E     CLR 0x89E
0026BE  37FFE7     BRA .L3
231:               		}
232:               		else
233:               		{
234:               			/* We received the number of an LED to flash - flash it! */
235:               			vParTestToggleLED( uxLEDToFlash );
0026C0  97B86F     MOV [W15-4], W0
0026C2  022D9E     CALL vParTestToggleLED
0026C4  000000     NOP
0026C6  37FFE3     BRA .L3
236:               		}
237:               	}
238:               
239:               	/* Co-routines MUST end with a call to crEND. */
240:               	crEND();
241:               }
0026C8  78044F     MOV [--W15], W8
0026CA  FA8000     ULNK
0026CC  060000     RETURN
242:               /*-----------------------------------------------------------*/
243:               
244:               BaseType_t xAreFlashCoRoutinesStillRunning( void )
245:               {
246:               	/* Return pdPASS or pdFAIL depending on whether an error has been detected
247:               	or not. */
248:               	return xCoRoutineFlashStatus;
249:               }
002784  8044F0     MOV 0x89E, W0
002786  060000     RETURN
250:               
---  D:/code/FreeRTOS/Demo/Common/Minimal/comtest.c  ----------------------------------------------------
1:                 /*
2:                     FreeRTOS V9.0.0 - Copyright (C) 2016 Real Time Engineers Ltd.
3:                     All rights reserved
4:                 
5:                     VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
6:                 
7:                     This file is part of the FreeRTOS distribution.
8:                 
9:                     FreeRTOS is free software; you can redistribute it and/or modify it under
10:                    the terms of the GNU General Public License (version 2) as published by the
11:                    Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
12:                
13:                    ***************************************************************************
14:                    >>!   NOTE: The modification to the GPL is included to allow you to     !<<
15:                    >>!   distribute a combined work that includes FreeRTOS without being   !<<
16:                    >>!   obliged to provide the source code for proprietary components     !<<
17:                    >>!   outside of the FreeRTOS kernel.                                   !<<
18:                    ***************************************************************************
19:                
20:                    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
21:                    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
22:                    FOR A PARTICULAR PURPOSE.  Full license text is available on the following
23:                    link: http://www.freertos.org/a00114.html
24:                
25:                    ***************************************************************************
26:                     *                                                                       *
27:                     *    FreeRTOS provides completely free yet professionally developed,    *
28:                     *    robust, strictly quality controlled, supported, and cross          *
29:                     *    platform software that is more than just the market leader, it     *
30:                     *    is the industry's de facto standard.                               *
31:                     *                                                                       *
32:                     *    Help yourself get started quickly while simultaneously helping     *
33:                     *    to support the FreeRTOS project by purchasing a FreeRTOS           *
34:                     *    tutorial book, reference manual, or both:                          *
35:                     *    http://www.FreeRTOS.org/Documentation                              *
36:                     *                                                                       *
37:                    ***************************************************************************
38:                
39:                    http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
40:                    the FAQ page "My application does not run, what could be wrong?".  Have you
41:                    defined configASSERT()?
42:                
43:                    http://www.FreeRTOS.org/support - In return for receiving this top quality
44:                    embedded software for free we request you assist our global community by
45:                    participating in the support forum.
46:                
47:                    http://www.FreeRTOS.org/training - Investing in training allows your team to
48:                    be as productive as possible as early as possible.  Now you can receive
49:                    FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
50:                    Ltd, and the world's leading authority on the world's leading RTOS.
51:                
52:                    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
53:                    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
54:                    compatible FAT file system, and our tiny thread aware UDP/IP stack.
55:                
56:                    http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
57:                    Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
58:                
59:                    http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
60:                    Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
61:                    licenses offer ticketed support, indemnification and commercial middleware.
62:                
63:                    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
64:                    engineered and independently SIL3 certified version for use in safety and
65:                    mission critical applications that require provable dependability.
66:                
67:                    1 tab == 4 spaces!
68:                */
69:                
70:                
71:                /*
72:                 * This version of comtest. c is for use on systems that have limited stack
73:                 * space and no display facilities.  The complete version can be found in
74:                 * the Demo/Common/Full directory.
75:                 *
76:                 * Creates two tasks that operate on an interrupt driven serial port.  A
77:                 * loopback connector should be used so that everything that is transmitted is
78:                 * also received.  The serial port does not use any flow control.  On a
79:                 * standard 9way 'D' connector pins two and three should be connected together.
80:                 *
81:                 * The first task posts a sequence of characters to the Tx queue, toggling an
82:                 * LED on each successful post.  At the end of the sequence it sleeps for a
83:                 * pseudo-random period before resending the same sequence.
84:                 *
85:                 * The UART Tx end interrupt is enabled whenever data is available in the Tx
86:                 * queue.  The Tx end ISR removes a single character from the Tx queue and
87:                 * passes it to the UART for transmission.
88:                 *
89:                 * The second task blocks on the Rx queue waiting for a character to become
90:                 * available.  When the UART Rx end interrupt receives a character it places
91:                 * it in the Rx queue, waking the second task.  The second task checks that the
92:                 * characters removed from the Rx queue form the same sequence as those posted
93:                 * to the Tx queue, and toggles an LED for each correct character.
94:                 *
95:                 * The receiving task is spawned with a higher priority than the transmitting
96:                 * task.  The receiver will therefore wake every time a character is
97:                 * transmitted so neither the Tx or Rx queue should ever hold more than a few
98:                 * characters.
99:                 *
100:                */
101:               
102:               /* Scheduler include files. */
103:               #include <stdlib.h>
104:               #include "FreeRTOS.h"
105:               #include "task.h"
106:               
107:               /* Demo program include files. */
108:               #include "serial.h"
109:               #include "comtest.h"
110:               #include "partest.h"
111:               
112:               #define comSTACK_SIZE				configMINIMAL_STACK_SIZE
113:               #define comTX_LED_OFFSET			( 0 )
114:               #define comRX_LED_OFFSET			( 1 )
115:               #define comTOTAL_PERMISSIBLE_ERRORS ( 2 )
116:               
117:               /* The Tx task will transmit the sequence of characters at a pseudo random
118:               interval.  This is the maximum and minimum block time between sends. */
119:               #define comTX_MAX_BLOCK_TIME		( ( TickType_t ) 0x96 )
120:               #define comTX_MIN_BLOCK_TIME		( ( TickType_t ) 0x32 )
121:               #define comOFFSET_TIME				( ( TickType_t ) 3 )
122:               
123:               /* We should find that each character can be queued for Tx immediately and we
124:               don't have to block to send. */
125:               #define comNO_BLOCK					( ( TickType_t ) 0 )
126:               
127:               /* The Rx task will block on the Rx queue for a long period. */
128:               #define comRX_BLOCK_TIME			( ( TickType_t ) 0xffff )
129:               
130:               /* The sequence transmitted is from comFIRST_BYTE to and including comLAST_BYTE. */
131:               #define comFIRST_BYTE				( 'A' )
132:               #define comLAST_BYTE				( 'X' )
133:               
134:               #define comBUFFER_LEN				( ( UBaseType_t ) ( comLAST_BYTE - comFIRST_BYTE ) + ( UBaseType_t ) 1 )
135:               #define comINITIAL_RX_COUNT_VALUE	( 0 )
136:               
137:               /* Handle to the com port used by both tasks. */
138:               static xComPortHandle xPort = NULL;
139:               
140:               /* The transmit task as described at the top of the file. */
141:               static portTASK_FUNCTION_PROTO( vComTxTask, pvParameters );
142:               
143:               /* The receive task as described at the top of the file. */
144:               static portTASK_FUNCTION_PROTO( vComRxTask, pvParameters );
145:               
146:               /* The LED that should be toggled by the Rx and Tx tasks.  The Rx task will
147:               toggle LED ( uxBaseLED + comRX_LED_OFFSET).  The Tx task will toggle LED
148:               ( uxBaseLED + comTX_LED_OFFSET ). */
149:               static UBaseType_t uxBaseLED = 0;
150:               
151:               /* Check variable used to ensure no error have occurred.  The Rx task will
152:               increment this variable after every successfully received sequence.  If at any
153:               time the sequence is incorrect the the variable will stop being incremented. */
154:               static volatile UBaseType_t uxRxLoops = comINITIAL_RX_COUNT_VALUE;
155:               
156:               /*-----------------------------------------------------------*/
157:               
158:               void vAltStartComTestTasks( UBaseType_t uxPriority, uint32_t ulBaudRate, UBaseType_t uxLED )
159:               {
00283E  781F88     MOV W8, [W15++]
002840  780400     MOV W0, W8
002842  BE0202     MOV.D W2, W4
160:               	/* Initialise the com port then spawn the Rx and Tx tasks. */
161:               	uxBaseLED = uxLED;
002844  8844E1     MOV W1, uxBaseLED
162:               	xSerialPortInitMinimal( ulBaudRate, comBUFFER_LEN );
002846  200182     MOV #0x18, W2
002848  BE0004     MOV.D W4, W0
00284A  022972     CALL xSerialPortInitMinimal
00284C  000000     NOP
163:               
164:               	/* The Tx task is spawned with a lower priority than the Rx task. */
165:               	xTaskCreate( vComTxTask, "COMTx", comSTACK_SIZE, NULL, uxPriority - 1, ( TaskHandle_t * ) NULL );
00284E  EB0280     CLR W5
002850  E90208     DEC W8, W4
002852  EB0180     CLR W3
002854  200732     MOV #0x73, W2
002856  28E9A1     MOV #0x8E9A, W1
002858  227F40     MOV #0x27F4, W0
00285A  0212C4     CALL xTaskCreate
00285C  000000     NOP
166:               	xTaskCreate( vComRxTask, "COMRx", comSTACK_SIZE, NULL, uxPriority, ( TaskHandle_t * ) NULL );
00285E  EB0280     CLR W5
002860  780208     MOV W8, W4
002862  EB0180     CLR W3
002864  200732     MOV #0x73, W2
002866  28EA01     MOV #0x8EA0, W1
002868  227880     MOV #0x2788, W0
00286A  0212C4     CALL xTaskCreate
00286C  000000     NOP
167:               }
00286E  78044F     MOV [--W15], W8
002870  060000     RETURN
168:               /*-----------------------------------------------------------*/
169:               
170:               static portTASK_FUNCTION( vComTxTask, pvParameters )
171:               {
0027F4  BE9F88     MOV.D W8, [W15++]
0027F6  781F8A     MOV W10, [W15++]
172:               char cByteToSend;
173:               TickType_t xTimeToWait;
174:               
175:               	/* Just to stop compiler warnings. */
176:               	( void ) pvParameters;
177:               
178:               	for( ;; )
179:               	{
180:               		/* Simply transmit a sequence of characters from comFIRST_BYTE to
181:               		comLAST_BYTE. */
182:               		for( cByteToSend = comFIRST_BYTE; cByteToSend <= comLAST_BYTE; cByteToSend++ )
0027F8  B3C418     MOV.B #0x41, W8
0027FA  B3C589     MOV.B #0x58, W9
002814  E84408     INC.B W8, W8
002816  544F89     SUB.B W8, W9, [W15]
002818  34FFF3     BRA LE, .L18
00283A  B3C418     MOV.B #0x41, W8
00283C  37FFEC     BRA .L22
183:               		{
184:               			if( xSerialPutChar( xPort, cByteToSend, comNO_BLOCK ) == pdPASS )
002800  EB0100     CLR W2
002802  784088     MOV.B W8, W1
002804  EB0000     CLR W0
002806  022A2A     CALL xSerialPutChar
002808  000000     NOP
00280A  500FE1     SUB W0, #0x1, [W15]
00280C  3A0003     BRA NZ, .L17
185:               			{
186:               				vParTestToggleLED( uxBaseLED + comTX_LED_OFFSET );
00280E  8044E0     MOV uxBaseLED, W0
002810  022D9E     CALL vParTestToggleLED
002812  000000     NOP
187:               			}
188:               		}
189:               
190:               		/* Turn the LED off while we are not doing anything. */
191:               		vParTestSetLED( uxBaseLED + comTX_LED_OFFSET, pdFALSE );
00281A  EB0080     CLR W1
00281C  8044E0     MOV uxBaseLED, W0
00281E  022D72     CALL vParTestSetLED
002820  000000     NOP
192:               
193:               		/* We have posted all the characters in the string - wait before
194:               		re-sending.  Wait a pseudo-random time as this will provide a better
195:               		test. */
196:               		xTimeToWait = xTaskGetTickCount() + comOFFSET_TIME;
002822  0210AE     CALL xTaskGetTickCount
002824  000000     NOP
002826  400063     ADD W0, #0x3, W0
197:               
198:               		/* Make sure we don't wait too long... */
199:               		xTimeToWait %= comTX_MAX_BLOCK_TIME;
0027FC  20096A     MOV #0x96, W10
0027FE  37000B     BRA .L22
002828  090011     REPEAT #0x11
00282A  D8800A     DIV.UW W0, W10
00282C  FD0080     EXCH W0, W1
200:               
201:               		/* ...but we do want to wait. */
202:               		if( xTimeToWait < comTX_MIN_BLOCK_TIME )
00282E  200311     MOV #0x31, W1
002830  500F81     SUB W0, W1, [W15]
002832  3E0001     BRA GTU, .L19
203:               		{
204:               			xTimeToWait = comTX_MIN_BLOCK_TIME;
002834  200320     MOV #0x32, W0
205:               		}
206:               
207:               		vTaskDelay( xTimeToWait );
002836  021868     CALL vTaskDelay
002838  000000     NOP
00283A  B3C418     MOV.B #0x41, W8
00283C  37FFEC     BRA .L22
208:               	}
209:               } /*lint !e715 !e818 pvParameters is required for a task function even if it is not referenced. */
210:               /*-----------------------------------------------------------*/
211:               
212:               static portTASK_FUNCTION( vComRxTask, pvParameters )
213:               {
002788  FA0002     LNK #0x2
00278A  BE9F88     MOV.D W8, [W15++]
00278C  BE9F8A     MOV.D W10, [W15++]
00278E  BE9F8C     MOV.D W12, [W15++]
214:               signed char cExpectedByte, cByteRxed;
215:               BaseType_t xResyncRequired = pdFALSE, xErrorOccurred = pdFALSE;
002790  EB0600     CLR W12
216:               
217:               	/* Just to stop compiler warnings. */
218:               	( void ) pvParameters;
219:               
220:               	for( ;; )
221:               	{
222:               		/* We expect to receive the characters from comFIRST_BYTE to
223:               		comLAST_BYTE in an incrementing order.  Loop to receive each byte. */
224:               		for( cExpectedByte = comFIRST_BYTE; cExpectedByte <= comLAST_BYTE; cExpectedByte++ )
002792  B3C41D     MOV.B #0x41, W13
002794  B3C59A     MOV.B #0x59, W10
002798  78440D     MOV.B W13, W8
0027B6  E84408     INC.B W8, W8
0027B8  544F8A     SUB.B W8, W10, [W15]
0027BA  3AFFF0     BRA NZ, .L5
225:               		{
226:               			/* Block on the queue that contains received bytes until a byte is
227:               			available. */
228:               			if( xSerialGetChar( xPort, &cByteRxed, comRX_BLOCK_TIME ) )
00279A  EB8480     SETM W9
00279C  780109     MOV W9, W2
00279E  5780EE     SUB W15, #0xE, W1
0027A0  EB0000     CLR W0
0027A2  022A18     CALL xSerialGetChar
0027A4  000000     NOP
0027A6  E00000     CP0 W0
0027A8  320006     BRA Z, .L3
229:               			{
230:               				/* Was this the byte we were expecting?  If so, toggle the LED,
231:               				otherwise we are out on sync and should break out of the loop
232:               				until the expected character sequence is about to restart. */
233:               				if( cByteRxed == cExpectedByte )
0027AA  97F02F     MOV.B [W15-14], W0
0027AC  504F88     SUB.B W0, W8, [W15]
0027AE  3A0019     BRA NZ, .L4
234:               				{
235:               					vParTestToggleLED( uxBaseLED + comRX_LED_OFFSET );
0027B0  EC089C     INC uxBaseLED, WREG
0027B2  022D9E     CALL vParTestToggleLED
0027B4  000000     NOP
236:               				}
237:               				else
238:               				{
239:               					xResyncRequired = pdTRUE;
240:               					break; /*lint !e960 Non-switch break allowed. */
241:               				}
242:               			}
243:               		}
244:               
245:               		/* Turn the LED off while we are not doing anything. */
246:               		vParTestSetLED( uxBaseLED + comRX_LED_OFFSET, pdFALSE );
0027BC  EC089C     INC uxBaseLED, WREG
0027BE  EB0080     CLR W1
0027C0  022D72     CALL vParTestSetLED
0027C2  000000     NOP
0027E2  EC089C     INC uxBaseLED, WREG
0027E4  EB0080     CLR W1
0027E6  022D72     CALL vParTestSetLED
0027E8  000000     NOP
247:               
248:               		/* Did we break out of the loop because the characters were received in
249:               		an unexpected order?  If so wait here until the character sequence is
250:               		about to restart. */
251:               		if( xResyncRequired == pdTRUE )
252:               		{
253:               			while( cByteRxed != comLAST_BYTE )
002796  B3C58B     MOV.B #0x58, W11
0027D4  97F02F     MOV.B [W15-14], W0
0027D6  504F8B     SUB.B W0, W11, [W15]
0027D8  3AFFF8     BRA NZ, .L10
0027EC  97F02F     MOV.B [W15-14], W0
0027EE  504F8B     SUB.B W0, W11, [W15]
0027F0  3AFFEC     BRA NZ, .L10
0027F2  37FFF3     BRA .L9
254:               			{
255:               				/* Block until the next char is available. */
256:               				xSerialGetChar( xPort, &cByteRxed, comRX_BLOCK_TIME );
0027CA  780108     MOV W8, W2
0027CC  5780EE     SUB W15, #0xE, W1
0027CE  EB0000     CLR W0
0027D0  022A18     CALL xSerialGetChar
0027D2  000000     NOP
0027EA  EB8400     SETM W8
257:               			}
258:               
259:               			/* Note that an error occurred which caused us to have to resync.
260:               			We use this to stop incrementing the loop counter so
261:               			sAreComTestTasksStillRunning() will return false - indicating an
262:               			error. */
263:               			xErrorOccurred++;
0027DA  E8060C     INC W12, W12
0027DC  37FFDD     BRA .L13
264:               
265:               			/* We have now resynced with the Tx task and can continue. */
266:               			xResyncRequired = pdFALSE;
267:               		}
268:               		else
269:               		{
270:               			if( xErrorOccurred < comTOTAL_PERMISSIBLE_ERRORS )
0027C4  560FE1     SUB W12, #0x1, [W15]
0027C6  3CFFE8     BRA GT, .L13
0027C8  37000A     BRA .L14
271:               			{
272:               				/* Increment the count of successful loops.  As error
273:               				occurring (i.e. an unexpected character being received) will
274:               				prevent this counter being incremented for the rest of the
275:               				execution.   Don't worry about mutual exclusion on this
276:               				variable - it doesn't really matter as we just want it
277:               				to change. */
278:               				uxRxLoops++;
0027DE  EC289A     INC uxRxLoops
0027E0  37FFDB     BRA .L13
0027E2  EC089C     INC uxBaseLED, WREG
0027E4  EB0080     CLR W1
0027E6  022D72     CALL vParTestSetLED
0027E8  000000     NOP
0027EA  EB8400     SETM W8
0027EC  97F02F     MOV.B [W15-14], W0
0027EE  504F8B     SUB.B W0, W11, [W15]
0027F0  3AFFEC     BRA NZ, .L10
0027F2  37FFF3     BRA .L9
279:               			}
280:               		}
281:               	}
282:               } /*lint !e715 !e818 pvParameters is required for a task function even if it is not referenced. */
283:               /*-----------------------------------------------------------*/
284:               
285:               BaseType_t xAreComTestTasksStillRunning( void )
286:               {
287:               BaseType_t xReturn;
288:               
289:               	/* If the count of successful reception loops has not changed than at
290:               	some time an error occurred (i.e. a character was received out of sequence)
291:               	and we will return false. */
292:               	if( uxRxLoops == comINITIAL_RX_COUNT_VALUE )
002872  8044D0     MOV uxRxLoops, W0
293:               	{
294:               		xReturn = pdFALSE;
002876  A7F000     BTSC W0, #15
002878  EA0000     NEG W0, W0
00287A  EA0000     NEG W0, W0
00287C  DE004F     LSR W0, #15, W0
295:               	}
296:               	else
297:               	{
298:               		xReturn = pdTRUE;
299:               	}
300:               
301:               	/* Reset the count of successful Rx loops.  When this function is called
302:               	again we expect this to have been incremented. */
303:               	uxRxLoops = comINITIAL_RX_COUNT_VALUE;
002874  EF289A     CLR uxRxLoops
304:               
305:               	return xReturn;
306:               }
00287E  060000     RETURN
307:               
---  D:/code/FreeRTOS/Demo/Common/Minimal/blocktim.c  ---------------------------------------------------
1:                 /*
2:                     FreeRTOS V9.0.0 - Copyright (C) 2016 Real Time Engineers Ltd.
3:                     All rights reserved
4:                 
5:                     VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
6:                 
7:                     This file is part of the FreeRTOS distribution.
8:                 
9:                     FreeRTOS is free software; you can redistribute it and/or modify it under
10:                    the terms of the GNU General Public License (version 2) as published by the
11:                    Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
12:                
13:                    ***************************************************************************
14:                    >>!   NOTE: The modification to the GPL is included to allow you to     !<<
15:                    >>!   distribute a combined work that includes FreeRTOS without being   !<<
16:                    >>!   obliged to provide the source code for proprietary components     !<<
17:                    >>!   outside of the FreeRTOS kernel.                                   !<<
18:                    ***************************************************************************
19:                
20:                    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
21:                    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
22:                    FOR A PARTICULAR PURPOSE.  Full license text is available on the following
23:                    link: http://www.freertos.org/a00114.html
24:                
25:                    ***************************************************************************
26:                     *                                                                       *
27:                     *    FreeRTOS provides completely free yet professionally developed,    *
28:                     *    robust, strictly quality controlled, supported, and cross          *
29:                     *    platform software that is more than just the market leader, it     *
30:                     *    is the industry's de facto standard.                               *
31:                     *                                                                       *
32:                     *    Help yourself get started quickly while simultaneously helping     *
33:                     *    to support the FreeRTOS project by purchasing a FreeRTOS           *
34:                     *    tutorial book, reference manual, or both:                          *
35:                     *    http://www.FreeRTOS.org/Documentation                              *
36:                     *                                                                       *
37:                    ***************************************************************************
38:                
39:                    http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
40:                    the FAQ page "My application does not run, what could be wrong?".  Have you
41:                    defined configASSERT()?
42:                
43:                    http://www.FreeRTOS.org/support - In return for receiving this top quality
44:                    embedded software for free we request you assist our global community by
45:                    participating in the support forum.
46:                
47:                    http://www.FreeRTOS.org/training - Investing in training allows your team to
48:                    be as productive as possible as early as possible.  Now you can receive
49:                    FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
50:                    Ltd, and the world's leading authority on the world's leading RTOS.
51:                
52:                    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
53:                    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
54:                    compatible FAT file system, and our tiny thread aware UDP/IP stack.
55:                
56:                    http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
57:                    Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
58:                
59:                    http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
60:                    Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
61:                    licenses offer ticketed support, indemnification and commercial middleware.
62:                
63:                    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
64:                    engineered and independently SIL3 certified version for use in safety and
65:                    mission critical applications that require provable dependability.
66:                
67:                    1 tab == 4 spaces!
68:                */
69:                
70:                /*
71:                 * This file contains some test scenarios that ensure tasks do not exit queue
72:                 * send or receive functions prematurely.  A description of the tests is
73:                 * included within the code.
74:                 */
75:                
76:                /* Kernel includes. */
77:                #include "FreeRTOS.h"
78:                #include "task.h"
79:                #include "queue.h"
80:                
81:                /* Demo includes. */
82:                #include "blocktim.h"
83:                
84:                /* Task priorities.  Allow these to be overridden. */
85:                #ifndef bktPRIMARY_PRIORITY
86:                	#define bktPRIMARY_PRIORITY		( configMAX_PRIORITIES - 3 )
87:                #endif
88:                
89:                #ifndef bktSECONDARY_PRIORITY
90:                	#define bktSECONDARY_PRIORITY	( configMAX_PRIORITIES - 4 )
91:                #endif
92:                
93:                /* Task behaviour. */
94:                #define bktQUEUE_LENGTH				( 5 )
95:                #define bktSHORT_WAIT				pdMS_TO_TICKS( ( TickType_t ) 20 )
96:                #define bktPRIMARY_BLOCK_TIME		( 10 )
97:                #define bktALLOWABLE_MARGIN			( 15 )
98:                #define bktTIME_TO_BLOCK			( 175 )
99:                #define bktDONT_BLOCK				( ( TickType_t ) 0 )
100:               #define bktRUN_INDICATOR			( ( UBaseType_t ) 0x55 )
101:               
102:               /* In case the demo does not have software timers enabled, as this file uses
103:               the configTIMER_TASK_PRIORITY setting. */
104:               #ifndef configTIMER_TASK_PRIORITY
105:               	#define configTIMER_TASK_PRIORITY ( configMAX_PRIORITIES - 1 )
106:               #endif
107:               
108:               /*-----------------------------------------------------------*/
109:               
110:               /*
111:                * The two test tasks.  Their behaviour is commented within the functions.
112:                */
113:               static void vPrimaryBlockTimeTestTask( void *pvParameters );
114:               static void vSecondaryBlockTimeTestTask( void *pvParameters );
115:               
116:               /*
117:                * Very basic tests to verify the block times are as expected.
118:                */
119:               static void prvBasicDelayTests( void );
120:               
121:               /*-----------------------------------------------------------*/
122:               
123:               /* The queue on which the tasks block. */
124:               static QueueHandle_t xTestQueue;
125:               
126:               /* Handle to the secondary task is required by the primary task for calls
127:               to vTaskSuspend/Resume(). */
128:               static TaskHandle_t xSecondary;
129:               
130:               /* Used to ensure that tasks are still executing without error. */
131:               static volatile BaseType_t xPrimaryCycles = 0, xSecondaryCycles = 0;
132:               static volatile BaseType_t xErrorOccurred = pdFALSE;
133:               
134:               /* Provides a simple mechanism for the primary task to know when the
135:               secondary task has executed. */
136:               static volatile UBaseType_t xRunIndicator;
137:               
138:               /*-----------------------------------------------------------*/
139:               
140:               void vCreateBlockTimeTasks( void )
141:               {
142:               	/* Create the queue on which the two tasks block. */
143:               	xTestQueue = xQueueCreate( bktQUEUE_LENGTH, sizeof( BaseType_t ) );
002258  EB4100     CLR.B W2
00225A  200021     MOV #0x2, W1
00225C  200050     MOV #0x5, W0
00225E  021A74     CALL xQueueGenericCreate
002260  000000     NOP
002262  8843B0     MOV W0, xTestQueue
144:               
145:               	if( xTestQueue != NULL )
002264  E00000     CP0 W0
002266  320010     BRA Z, .L60
146:               	{
147:               		/* vQueueAddToRegistry() adds the queue to the queue registry, if one
148:               		is in use.  The queue registry is provided as a means for kernel aware
149:               		debuggers to locate queues and has no purpose if a kernel aware
150:               		debugger is not being used.  The call to vQueueAddToRegistry() will be
151:               		removed by the pre-processor if configQUEUE_REGISTRY_SIZE is not
152:               		defined or is defined to be less than 1. */
153:               		vQueueAddToRegistry( xTestQueue, "Block_Time_Queue" );
154:               
155:               		/* Create the two test tasks. */
156:               		xTaskCreate( vPrimaryBlockTimeTestTask, "BTest1", configMINIMAL_STACK_SIZE, NULL, bktPRIMARY_PRIORITY, NULL );
002268  EB0280     CLR W5
00226A  200014     MOV #0x1, W4
00226C  EB0180     CLR W3
00226E  200732     MOV #0x73, W2
002270  28E8C1     MOV #0x8E8C, W1
002272  220540     MOV #0x2054, W0
002274  0212C4     CALL xTaskCreate
002276  000000     NOP
157:               		xTaskCreate( vSecondaryBlockTimeTestTask, "BTest2", configMINIMAL_STACK_SIZE, NULL, bktSECONDARY_PRIORITY, &xSecondary );
002278  208785     MOV #0x878, W5
00227A  EB0200     CLR W4
00227C  EB0180     CLR W3
00227E  200732     MOV #0x73, W2
002280  28E931     MOV #0x8E93, W1
002282  21F620     MOV #0x1F62, W0
002284  0212C4     CALL xTaskCreate
002286  000000     NOP
158:               	}
159:               }
002288  060000     RETURN
160:               /*-----------------------------------------------------------*/
161:               
162:               static void vPrimaryBlockTimeTestTask( void *pvParameters )
163:               {
002054  FA0004     LNK #0x4
002056  BE9F88     MOV.D W8, [W15++]
002058  BE9F8A     MOV.D W10, [W15++]
00205A  781F8C     MOV W12, [W15++]
164:               BaseType_t xItem, xData;
165:               TickType_t xTimeWhenBlocking;
166:               TickType_t xTimeToBlock, xBlockedTime;
167:               
168:               	( void ) pvParameters;
169:               
170:               	for( ;; )
171:               	{
172:               		/*********************************************************************
173:               		Test 0
174:               
175:               		Basic vTaskDelay() and vTaskDelayUntil() tests. */
176:               		prvBasicDelayTests();
00205C  200559     MOV #0x55, W9
00205E  07FFC6     RCALL _prvBasicDelayTests, .LFE2, .LFB3
177:               
178:               
179:               		/*********************************************************************
180:               		Test 1
181:               
182:               		Simple block time wakeup test on queue receives. */
183:               		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
002060  EB0000     CLR W0
002062  9FBF90     MOV W0, [W15-14]
002064  EB0400     CLR W8
00209C  97B89F     MOV [W15-14], W1
00209E  E80401     INC W1, W8
0020A0  9FBF98     MOV W8, [W15-14]
0020A2  540FE4     SUB W8, #0x4, [W15]
0020A4  34FFE1     BRA LE, .L18
184:               		{
185:               			/* The queue is empty. Attempt to read from the queue using a block
186:               			time.  When we wake, ensure the delta in time is as expected. */
187:               			xTimeToBlock = ( TickType_t ) ( bktPRIMARY_BLOCK_TIME << xItem );
002066  2000AB     MOV #0xA, W11
002068  DD5C08     SL W11, W8, W8
188:               
189:               			xTimeWhenBlocking = xTaskGetTickCount();
00206A  0210AE     CALL xTaskGetTickCount
00206C  000000     NOP
00206E  780500     MOV W0, W10
190:               
191:               			/* We should unblock after xTimeToBlock having not received
192:               			anything on the queue. */
193:               			if( xQueueReceive( xTestQueue, &xData, xTimeToBlock ) != errQUEUE_EMPTY )
002070  EB0180     CLR W3
002072  780108     MOV W8, W2
002074  5780EC     SUB W15, #0xC, W1
002076  8043B0     MOV xTestQueue, W0
002078  021C16     CALL xQueueGenericReceive
00207A  000000     NOP
00207C  E00000     CP0 W0
00207E  320002     BRA Z, .L15
194:               			{
195:               				xErrorOccurred = pdTRUE;
002080  200010     MOV #0x1, W0
002082  884380     MOV W0, xErrorOccurred
196:               			}
197:               
198:               			/* How long were we blocked for? */
199:               			xBlockedTime = xTaskGetTickCount() - xTimeWhenBlocking;
002084  0210AE     CALL xTaskGetTickCount
002086  000000     NOP
002088  50050A     SUB W0, W10, W10
200:               
201:               			if( xBlockedTime < xTimeToBlock )
00208A  540F8A     SUB W8, W10, [W15]
00208C  360002     BRA LEU, .L16
202:               			{
203:               				/* Should not have blocked for less than we requested. */
204:               				xErrorOccurred = pdTRUE;
00208E  200010     MOV #0x1, W0
002090  884380     MOV W0, xErrorOccurred
205:               			}
206:               
207:               			if( xBlockedTime > ( xTimeToBlock + bktALLOWABLE_MARGIN ) )
002092  44046F     ADD W8, #0xF, W8
002094  550F88     SUB W10, W8, [W15]
002096  360002     BRA LEU, .L17
208:               			{
209:               				/* Should not have blocked for longer than we requested,
210:               				although we would not necessarily run as soon as we were
211:               				unblocked so a margin is allowed. */
212:               				xErrorOccurred = pdTRUE;
002098  200010     MOV #0x1, W0
00209A  884380     MOV W0, xErrorOccurred
213:               			}
214:               		}
215:               
216:               		/*********************************************************************
217:               		Test 2
218:               
219:               		Simple block time wakeup test on queue sends.
220:               
221:               		First fill the queue.  It should be empty so all sends should pass. */
222:               		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
0020A6  EB0000     CLR W0
0020A8  9FBF90     MOV W0, [W15-14]
0020C0  97B89F     MOV [W15-14], W1
0020C2  E80001     INC W1, W0
0020C4  9FBF90     MOV W0, [W15-14]
0020C6  500FE4     SUB W0, #0x4, [W15]
0020C8  34FFF2     BRA LE, .L20
223:               		{
224:               			if( xQueueSend( xTestQueue, &xItem, bktDONT_BLOCK ) != pdPASS )
0020AA  EB0400     CLR W8
0020AE  780188     MOV W8, W3
0020B0  780108     MOV W8, W2
0020B2  5780EE     SUB W15, #0xE, W1
0020B4  8043B0     MOV xTestQueue, W0
0020B6  021AA8     CALL xQueueGenericSend
0020B8  000000     NOP
0020BA  500FE1     SUB W0, #0x1, [W15]
0020BC  320001     BRA Z, .L19
225:               			{
226:               				xErrorOccurred = pdTRUE;
0020AC  20001A     MOV #0x1, W10
0020BE  88438A     MOV W10, xErrorOccurred
227:               			}
228:               
229:               			#if configUSE_PREEMPTION == 0
230:               				taskYIELD();
231:               			#endif
232:               		}
233:               
234:               		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
0020CA  EB0000     CLR W0
0020CC  9FBF90     MOV W0, [W15-14]
0020CE  EB0400     CLR W8
002102  97B89F     MOV [W15-14], W1
002104  E80401     INC W1, W8
002106  9FBF98     MOV W8, [W15-14]
002108  540FE4     SUB W8, #0x4, [W15]
00210A  34FFE4     BRA LE, .L24
235:               		{
236:               			/* The queue is full. Attempt to write to the queue using a block
237:               			time.  When we wake, ensure the delta in time is as expected. */
238:               			xTimeToBlock = ( TickType_t ) ( bktPRIMARY_BLOCK_TIME << xItem );
0020D0  2000AC     MOV #0xA, W12
0020D4  DD6408     SL W12, W8, W8
239:               
240:               			xTimeWhenBlocking = xTaskGetTickCount();
0020D6  0210AE     CALL xTaskGetTickCount
0020D8  000000     NOP
0020DA  780500     MOV W0, W10
241:               
242:               			/* We should unblock after xTimeToBlock having not received
243:               			anything on the queue. */
244:               			if( xQueueSend( xTestQueue, &xItem, xTimeToBlock ) != errQUEUE_FULL )
0020DC  EB0180     CLR W3
0020DE  780108     MOV W8, W2
0020E0  5780EE     SUB W15, #0xE, W1
0020E2  8043B0     MOV xTestQueue, W0
0020E4  021AA8     CALL xQueueGenericSend
0020E6  000000     NOP
0020E8  E00000     CP0 W0
0020EA  320001     BRA Z, .L21
245:               			{
246:               				xErrorOccurred = pdTRUE;
0020D2  20001B     MOV #0x1, W11
0020EC  88438B     MOV W11, xErrorOccurred
247:               			}
248:               
249:               			/* How long were we blocked for? */
250:               			xBlockedTime = xTaskGetTickCount() - xTimeWhenBlocking;
0020EE  0210AE     CALL xTaskGetTickCount
0020F0  000000     NOP
0020F2  50050A     SUB W0, W10, W10
251:               
252:               			if( xBlockedTime < xTimeToBlock )
0020F4  540F8A     SUB W8, W10, [W15]
0020F6  360001     BRA LEU, .L22
253:               			{
254:               				/* Should not have blocked for less than we requested. */
255:               				xErrorOccurred = pdTRUE;
0020F8  88438B     MOV W11, xErrorOccurred
256:               			}
257:               
258:               			if( xBlockedTime > ( xTimeToBlock + bktALLOWABLE_MARGIN ) )
0020FA  44046F     ADD W8, #0xF, W8
0020FC  550F88     SUB W10, W8, [W15]
0020FE  360001     BRA LEU, .L23
259:               			{
260:               				/* Should not have blocked for longer than we requested,
261:               				although we would not necessarily run as soon as we were
262:               				unblocked so a margin is allowed. */
263:               				xErrorOccurred = pdTRUE;
002100  88438B     MOV W11, xErrorOccurred
264:               			}
265:               		}
266:               
267:               		/*********************************************************************
268:               		Test 3
269:               
270:               		Wake the other task, it will block attempting to post to the queue.
271:               		When we read from the queue the other task will wake, but before it
272:               		can run we will post to the queue again.  When the other task runs it
273:               		will find the queue still full, even though it was woken.  It should
274:               		recognise that its block time has not expired and return to block for
275:               		the remains of its block time.
276:               
277:               		Wake the other task so it blocks attempting to post to the already
278:               		full queue. */
279:               		xRunIndicator = 0;
00210C  EF287A     CLR xRunIndicator
280:               		vTaskResume( xSecondary );
00210E  8043C0     MOV xSecondary, W0
002110  020FF6     CALL vTaskResume
002112  000000     NOP
281:               
282:               		/* We need to wait a little to ensure the other task executes. */
283:               		while( xRunIndicator != bktRUN_INDICATOR )
002114  8043D0     MOV xRunIndicator, W0
002116  500F89     SUB W0, W9, [W15]
002118  320007     BRA Z, .L25
002122  8043D1     MOV xRunIndicator, W1
002124  508F89     SUB W1, W9, [W15]
002126  3AFFFA     BRA NZ, .L49
284:               		{
285:               			/* The other task has not yet executed. */
286:               			vTaskDelay( bktSHORT_WAIT );
00211A  200148     MOV #0x14, W8
00211C  780008     MOV W8, W0
00211E  021868     CALL vTaskDelay
002120  000000     NOP
287:               		}
288:               		/* Make sure the other task is blocked on the queue. */
289:               		vTaskDelay( bktSHORT_WAIT );
002128  200140     MOV #0x14, W0
00212A  021868     CALL vTaskDelay
00212C  000000     NOP
290:               		xRunIndicator = 0;
00212E  EF287A     CLR xRunIndicator
291:               
292:               		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
002130  EB0000     CLR W0
002132  9FBF90     MOV W0, [W15-14]
00217C  97B89F     MOV [W15-14], W1
00217E  E80001     INC W1, W0
002180  9FBF90     MOV W0, [W15-14]
002182  500FE4     SUB W0, #0x4, [W15]
002184  34FFD7     BRA LE, .L31
293:               		{
294:               			/* Now when we make space on the queue the other task should wake
295:               			but not execute as this task has higher priority. */
296:               			if( xQueueReceive( xTestQueue, &xData, bktDONT_BLOCK ) != pdPASS )
002134  B81160     MUL.UU W2, #0, W2
002136  5780EC     SUB W15, #0xC, W1
002138  8043B0     MOV xTestQueue, W0
00213A  021C16     CALL xQueueGenericReceive
00213C  000000     NOP
00213E  500FE1     SUB W0, #0x1, [W15]
002140  320002     BRA Z, .L27
297:               			{
298:               				xErrorOccurred = pdTRUE;
002142  200010     MOV #0x1, W0
002144  884380     MOV W0, xErrorOccurred
299:               			}
300:               
301:               			/* Now fill the queue again before the other task gets a chance to
302:               			execute.  If the other task had executed we would find the queue
303:               			full ourselves, and the other task have set xRunIndicator. */
304:               			if( xQueueSend( xTestQueue, &xItem, bktDONT_BLOCK ) != pdPASS )
002146  B81160     MUL.UU W2, #0, W2
002148  5780EE     SUB W15, #0xE, W1
00214A  8043B0     MOV xTestQueue, W0
00214C  021AA8     CALL xQueueGenericSend
00214E  000000     NOP
002150  500FE1     SUB W0, #0x1, [W15]
002152  320002     BRA Z, .L28
305:               			{
306:               				xErrorOccurred = pdTRUE;
002154  200010     MOV #0x1, W0
002156  884380     MOV W0, xErrorOccurred
307:               			}
308:               
309:               			if( xRunIndicator == bktRUN_INDICATOR )
002158  8043D1     MOV xRunIndicator, W1
00215A  508F89     SUB W1, W9, [W15]
00215C  3A0002     BRA NZ, .L29
310:               			{
311:               				/* The other task should not have executed. */
312:               				xErrorOccurred = pdTRUE;
00215E  200010     MOV #0x1, W0
002160  884380     MOV W0, xErrorOccurred
313:               			}
314:               
315:               			/* Raise the priority of the other task so it executes and blocks
316:               			on the queue again. */
317:               			vTaskPrioritySet( xSecondary, bktPRIMARY_PRIORITY + 2 );
002162  200031     MOV #0x3, W1
002164  8043C0     MOV xSecondary, W0
002166  020F50     CALL vTaskPrioritySet
002168  000000     NOP
318:               
319:               			/* The other task should now have re-blocked without exiting the
320:               			queue function. */
321:               			if( xRunIndicator == bktRUN_INDICATOR )
00216A  8043D0     MOV xRunIndicator, W0
00216C  500F89     SUB W0, W9, [W15]
00216E  3A0002     BRA NZ, .L30
322:               			{
323:               				/* The other task should not have executed outside of the
324:               				queue function. */
325:               				xErrorOccurred = pdTRUE;
002170  200010     MOV #0x1, W0
002172  884380     MOV W0, xErrorOccurred
326:               			}
327:               
328:               			/* Set the priority back down. */
329:               			vTaskPrioritySet( xSecondary, bktSECONDARY_PRIORITY );
002174  EB0080     CLR W1
002176  8043C0     MOV xSecondary, W0
002178  020F50     CALL vTaskPrioritySet
00217A  000000     NOP
330:               		}
331:               
332:               		/* Let the other task timeout.  When it unblockes it will check that it
333:               		unblocked at the correct time, then suspend itself. */
334:               		while( xRunIndicator != bktRUN_INDICATOR )
002186  8043D0     MOV xRunIndicator, W0
002188  500F89     SUB W0, W9, [W15]
00218A  320007     BRA Z, .L32
002194  8043D1     MOV xRunIndicator, W1
002196  508F89     SUB W1, W9, [W15]
002198  3AFFFA     BRA NZ, .L48
335:               		{
336:               			vTaskDelay( bktSHORT_WAIT );
00218C  200148     MOV #0x14, W8
00218E  780008     MOV W8, W0
002190  021868     CALL vTaskDelay
002192  000000     NOP
337:               		}
338:               		vTaskDelay( bktSHORT_WAIT );
00219A  200140     MOV #0x14, W0
00219C  021868     CALL vTaskDelay
00219E  000000     NOP
339:               		xRunIndicator = 0;
0021A0  EF287A     CLR xRunIndicator
340:               
341:               
342:               		/*********************************************************************
343:               		Test 4
344:               
345:               		As per test 3 - but with the send and receive the other way around.
346:               		The other task blocks attempting to read from the queue.
347:               
348:               		Empty the queue.  We should find that it is full. */
349:               		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
0021A2  EB0000     CLR W0
0021A4  9FBF90     MOV W0, [W15-14]
0021B8  97B89F     MOV [W15-14], W1
0021BA  E80001     INC W1, W0
0021BC  9FBF90     MOV W0, [W15-14]
0021BE  500FE4     SUB W0, #0x4, [W15]
0021C0  34FFF3     BRA LE, .L35
350:               		{
351:               			if( xQueueReceive( xTestQueue, &xData, bktDONT_BLOCK ) != pdPASS )
0021A8  B81160     MUL.UU W2, #0, W2
0021AA  5780EC     SUB W15, #0xC, W1
0021AC  8043B0     MOV xTestQueue, W0
0021AE  021C16     CALL xQueueGenericReceive
0021B0  000000     NOP
0021B2  500FE1     SUB W0, #0x1, [W15]
0021B4  320001     BRA Z, .L34
352:               			{
353:               				xErrorOccurred = pdTRUE;
0021A6  200018     MOV #0x1, W8
0021B6  884388     MOV W8, xErrorOccurred
354:               			}
355:               		}
356:               
357:               		/* Wake the other task so it blocks attempting to read from  the
358:               		already	empty queue. */
359:               		vTaskResume( xSecondary );
0021C2  8043C0     MOV xSecondary, W0
0021C4  020FF6     CALL vTaskResume
0021C6  000000     NOP
360:               
361:               		/* We need to wait a little to ensure the other task executes. */
362:               		while( xRunIndicator != bktRUN_INDICATOR )
0021C8  8043D0     MOV xRunIndicator, W0
0021CA  500F89     SUB W0, W9, [W15]
0021CC  320007     BRA Z, .L36
0021D6  8043D1     MOV xRunIndicator, W1
0021D8  508F89     SUB W1, W9, [W15]
0021DA  3AFFFA     BRA NZ, .L47
363:               		{
364:               			vTaskDelay( bktSHORT_WAIT );
0021CE  200148     MOV #0x14, W8
0021D0  780008     MOV W8, W0
0021D2  021868     CALL vTaskDelay
0021D4  000000     NOP
365:               		}
366:               		vTaskDelay( bktSHORT_WAIT );
0021DC  200140     MOV #0x14, W0
0021DE  021868     CALL vTaskDelay
0021E0  000000     NOP
367:               		xRunIndicator = 0;
0021E2  EF287A     CLR xRunIndicator
368:               
369:               		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
0021E4  EB0000     CLR W0
0021E6  9FBF90     MOV W0, [W15-14]
002230  97B89F     MOV [W15-14], W1
002232  E80001     INC W1, W0
002234  9FBF90     MOV W0, [W15-14]
002236  500FE4     SUB W0, #0x4, [W15]
002238  34FFD7     BRA LE, .L42
370:               		{
371:               			/* Now when we place an item on the queue the other task should
372:               			wake but not execute as this task has higher priority. */
373:               			if( xQueueSend( xTestQueue, &xItem, bktDONT_BLOCK ) != pdPASS )
0021E8  B81160     MUL.UU W2, #0, W2
0021EA  5780EE     SUB W15, #0xE, W1
0021EC  8043B0     MOV xTestQueue, W0
0021EE  021AA8     CALL xQueueGenericSend
0021F0  000000     NOP
0021F2  500FE1     SUB W0, #0x1, [W15]
0021F4  320002     BRA Z, .L38
374:               			{
375:               				xErrorOccurred = pdTRUE;
0021F6  200010     MOV #0x1, W0
0021F8  884380     MOV W0, xErrorOccurred
376:               			}
377:               
378:               			/* Now empty the queue again before the other task gets a chance to
379:               			execute.  If the other task had executed we would find the queue
380:               			empty ourselves, and the other task would be suspended. */
381:               			if( xQueueReceive( xTestQueue, &xData, bktDONT_BLOCK ) != pdPASS )
0021FA  B81160     MUL.UU W2, #0, W2
0021FC  5780EC     SUB W15, #0xC, W1
0021FE  8043B0     MOV xTestQueue, W0
002200  021C16     CALL xQueueGenericReceive
002202  000000     NOP
002204  500FE1     SUB W0, #0x1, [W15]
002206  320002     BRA Z, .L39
382:               			{
383:               				xErrorOccurred = pdTRUE;
002208  200010     MOV #0x1, W0
00220A  884380     MOV W0, xErrorOccurred
384:               			}
385:               
386:               			if( xRunIndicator == bktRUN_INDICATOR )
00220C  8043D1     MOV xRunIndicator, W1
00220E  508F89     SUB W1, W9, [W15]
002210  3A0002     BRA NZ, .L40
387:               			{
388:               				/* The other task should not have executed. */
389:               				xErrorOccurred = pdTRUE;
002212  200010     MOV #0x1, W0
002214  884380     MOV W0, xErrorOccurred
390:               			}
391:               
392:               			/* Raise the priority of the other task so it executes and blocks
393:               			on the queue again. */
394:               			vTaskPrioritySet( xSecondary, bktPRIMARY_PRIORITY + 2 );
002216  200031     MOV #0x3, W1
002218  8043C0     MOV xSecondary, W0
00221A  020F50     CALL vTaskPrioritySet
00221C  000000     NOP
395:               
396:               			/* The other task should now have re-blocked without exiting the
397:               			queue function. */
398:               			if( xRunIndicator == bktRUN_INDICATOR )
00221E  8043D0     MOV xRunIndicator, W0
002220  500F89     SUB W0, W9, [W15]
002222  3A0002     BRA NZ, .L41
399:               			{
400:               				/* The other task should not have executed outside of the
401:               				queue function. */
402:               				xErrorOccurred = pdTRUE;
002224  200010     MOV #0x1, W0
002226  884380     MOV W0, xErrorOccurred
403:               			}
404:               			vTaskPrioritySet( xSecondary, bktSECONDARY_PRIORITY );
002228  EB0080     CLR W1
00222A  8043C0     MOV xSecondary, W0
00222C  020F50     CALL vTaskPrioritySet
00222E  000000     NOP
405:               		}
406:               
407:               		/* Let the other task timeout.  When it unblockes it will check that it
408:               		unblocked at the correct time, then suspend itself. */
409:               		while( xRunIndicator != bktRUN_INDICATOR )
00223A  8043D0     MOV xRunIndicator, W0
00223C  500F89     SUB W0, W9, [W15]
00223E  320007     BRA Z, .L43
002248  8043D1     MOV xRunIndicator, W1
00224A  508F89     SUB W1, W9, [W15]
00224C  3AFFFA     BRA NZ, .L46
410:               		{
411:               			vTaskDelay( bktSHORT_WAIT );
002240  200148     MOV #0x14, W8
002242  780008     MOV W8, W0
002244  021868     CALL vTaskDelay
002246  000000     NOP
412:               		}
413:               		vTaskDelay( bktSHORT_WAIT );
00224E  200140     MOV #0x14, W0
002250  021868     CALL vTaskDelay
002252  000000     NOP
414:               
415:               		xPrimaryCycles++;
002254  EC286C     INC xPrimaryCycles
416:               	}
002256  37FF03     BRA .L45
417:               }
418:               /*-----------------------------------------------------------*/
419:               
420:               static void vSecondaryBlockTimeTestTask( void *pvParameters )
421:               {
001F62  FA0002     LNK #0x2
001F64  BE9F88     MOV.D W8, [W15++]
001F66  781F8A     MOV W10, [W15++]
422:               TickType_t xTimeWhenBlocking, xBlockedTime;
423:               BaseType_t xData;
424:               
425:               	( void ) pvParameters;
426:               
427:               	for( ;; )
428:               	{
429:               		/*********************************************************************
430:               		Test 0, 1 and 2
431:               
432:               		This task does not participate in these tests. */
433:               		vTaskSuspend( NULL );
001F6C  EB0000     CLR W0
001F6E  021490     CALL vTaskSuspend
001F70  000000     NOP
434:               
435:               		/*********************************************************************
436:               		Test 3
437:               
438:               		The first thing we do is attempt to read from the queue.  It should be
439:               		full so we block.  Note the time before we block so we can check the
440:               		wake time is as per that expected. */
441:               		xTimeWhenBlocking = xTaskGetTickCount();
001F72  0210AE     CALL xTaskGetTickCount
001F74  000000     NOP
001F76  780480     MOV W0, W9
442:               
443:               		/* We should unblock after bktTIME_TO_BLOCK having not sent anything to
444:               		the queue. */
445:               		xData = 0;
001F78  EB0000     CLR W0
001F7A  9FBFC0     MOV W0, [W15-8]
446:               		xRunIndicator = bktRUN_INDICATOR;
001F68  200558     MOV #0x55, W8
001F7C  8843D8     MOV W8, xRunIndicator
447:               		if( xQueueSend( xTestQueue, &xData, bktTIME_TO_BLOCK ) != errQUEUE_FULL )
001F7E  EB0180     CLR W3
001F80  200AF2     MOV #0xAF, W2
001F82  5780E8     SUB W15, #0x8, W1
001F84  8043B0     MOV xTestQueue, W0
001F86  021AA8     CALL xQueueGenericSend
001F88  000000     NOP
001F8A  E00000     CP0 W0
001F8C  320002     BRA Z, .L2
448:               		{
449:               			xErrorOccurred = pdTRUE;
001F8E  200010     MOV #0x1, W0
001F90  884380     MOV W0, xErrorOccurred
450:               		}
451:               
452:               		/* How long were we inside the send function? */
453:               		xBlockedTime = xTaskGetTickCount() - xTimeWhenBlocking;
001F92  0210AE     CALL xTaskGetTickCount
001F94  000000     NOP
001F96  500489     SUB W0, W9, W9
454:               
455:               		/* We should not have blocked for less time than bktTIME_TO_BLOCK. */
456:               		if( xBlockedTime < bktTIME_TO_BLOCK )
001F6A  200AEA     MOV #0xAE, W10
001F98  548F8A     SUB W9, W10, [W15]
001F9A  3E0002     BRA GTU, .L3
457:               		{
458:               			xErrorOccurred = pdTRUE;
001F9C  200010     MOV #0x1, W0
001F9E  884380     MOV W0, xErrorOccurred
459:               		}
460:               
461:               		/* We should of not blocked for much longer than bktALLOWABLE_MARGIN
462:               		either.  A margin is permitted as we would not necessarily run as
463:               		soon as we unblocked. */
464:               		if( xBlockedTime > ( bktTIME_TO_BLOCK + bktALLOWABLE_MARGIN ) )
001FA0  200BE0     MOV #0xBE, W0
001FA2  548F80     SUB W9, W0, [W15]
001FA4  360002     BRA LEU, .L4
465:               		{
466:               			xErrorOccurred = pdTRUE;
001FA6  200010     MOV #0x1, W0
001FA8  884380     MOV W0, xErrorOccurred
467:               		}
468:               
469:               		/* Suspend ready for test 3. */
470:               		xRunIndicator = bktRUN_INDICATOR;
001FAA  8843D8     MOV W8, xRunIndicator
471:               		vTaskSuspend( NULL );
001FAC  EB0000     CLR W0
001FAE  021490     CALL vTaskSuspend
001FB0  000000     NOP
472:               
473:               		/*********************************************************************
474:                       Test 4
475:               
476:               		As per test three, but with the send and receive reversed. */
477:               		xTimeWhenBlocking = xTaskGetTickCount();
001FB2  0210AE     CALL xTaskGetTickCount
001FB4  000000     NOP
001FB6  780480     MOV W0, W9
478:               
479:               		/* We should unblock after bktTIME_TO_BLOCK having not received
480:               		anything on the queue. */
481:               		xRunIndicator = bktRUN_INDICATOR;
001FB8  8843D8     MOV W8, xRunIndicator
482:               		if( xQueueReceive( xTestQueue, &xData, bktTIME_TO_BLOCK ) != errQUEUE_EMPTY )
001FBA  EB0180     CLR W3
001FBC  200AF2     MOV #0xAF, W2
001FBE  5780E8     SUB W15, #0x8, W1
001FC0  8043B0     MOV xTestQueue, W0
001FC2  021C16     CALL xQueueGenericReceive
001FC4  000000     NOP
001FC6  E00000     CP0 W0
001FC8  320002     BRA Z, .L5
483:               		{
484:               			xErrorOccurred = pdTRUE;
001FCA  200010     MOV #0x1, W0
001FCC  884380     MOV W0, xErrorOccurred
485:               		}
486:               
487:               		xBlockedTime = xTaskGetTickCount() - xTimeWhenBlocking;
001FCE  0210AE     CALL xTaskGetTickCount
001FD0  000000     NOP
001FD2  500489     SUB W0, W9, W9
488:               
489:               		/* We should not have blocked for less time than bktTIME_TO_BLOCK. */
490:               		if( xBlockedTime < bktTIME_TO_BLOCK )
001FD4  548F8A     SUB W9, W10, [W15]
001FD6  3E0002     BRA GTU, .L6
491:               		{
492:               			xErrorOccurred = pdTRUE;
001FD8  200010     MOV #0x1, W0
001FDA  884380     MOV W0, xErrorOccurred
493:               		}
494:               
495:               		/* We should of not blocked for much longer than bktALLOWABLE_MARGIN
496:               		either.  A margin is permitted as we would not necessarily run as soon
497:               		as we unblocked. */
498:               		if( xBlockedTime > ( bktTIME_TO_BLOCK + bktALLOWABLE_MARGIN ) )
001FDC  200BE0     MOV #0xBE, W0
001FDE  548F80     SUB W9, W0, [W15]
001FE0  360002     BRA LEU, .L7
499:               		{
500:               			xErrorOccurred = pdTRUE;
001FE2  200010     MOV #0x1, W0
001FE4  884380     MOV W0, xErrorOccurred
501:               		}
502:               
503:               		xRunIndicator = bktRUN_INDICATOR;
001FE6  8843D8     MOV W8, xRunIndicator
504:               
505:               		xSecondaryCycles++;
001FE8  EC286E     INC xSecondaryCycles
506:               	}
001FEA  37FFC0     BRA .L8
507:               }
508:               /*-----------------------------------------------------------*/
509:               
510:               static void prvBasicDelayTests( void )
511:               {
001FEC  FA0002     LNK #0x2
001FEE  BE9F88     MOV.D W8, [W15++]
001FF0  BE9F8A     MOV.D W10, [W15++]
512:               TickType_t xPreTime, xPostTime, x, xLastUnblockTime, xExpectedUnblockTime;
513:               const TickType_t xPeriod = 75, xCycles = 5, xAllowableMargin = ( bktALLOWABLE_MARGIN >> 1 );
514:               
515:               	/* Temporarily increase priority so the timing is more accurate, but not so
516:               	high as to disrupt the timer tests. */
517:               	vTaskPrioritySet( NULL, configTIMER_TASK_PRIORITY - 1 );
001FF2  200021     MOV #0x2, W1
001FF4  EB0000     CLR W0
001FF6  020F50     CALL vTaskPrioritySet
001FF8  000000     NOP
518:               
519:               	/* Crude check to too that vTaskDelay() blocks for the expected period. */
520:               	xPreTime = xTaskGetTickCount();
001FFA  0210AE     CALL xTaskGetTickCount
001FFC  000000     NOP
001FFE  780400     MOV W0, W8
521:               	vTaskDelay( bktTIME_TO_BLOCK );
002000  200AF0     MOV #0xAF, W0
002002  021868     CALL vTaskDelay
002004  000000     NOP
522:               	xPostTime = xTaskGetTickCount();
002006  0210AE     CALL xTaskGetTickCount
002008  000000     NOP
523:               
524:               	/* The priority is higher, so the allowable margin is halved when compared
525:               	to the other tests in this file. */
526:               	if( ( xPostTime - xPreTime ) > ( bktTIME_TO_BLOCK + xAllowableMargin ) )
00200A  500408     SUB W0, W8, W8
00200C  200B61     MOV #0xB6, W1
00200E  540F81     SUB W8, W1, [W15]
002010  360002     BRA LEU, .L10
527:               	{
528:               		xErrorOccurred = pdTRUE;
002012  200010     MOV #0x1, W0
002014  884380     MOV W0, xErrorOccurred
529:               	}
530:               
531:               	/* Now crude tests to check the vTaskDelayUntil() functionality. */
532:               	xPostTime = xTaskGetTickCount();
002016  0210AE     CALL xTaskGetTickCount
002018  000000     NOP
00201A  780480     MOV W0, W9
533:               	xLastUnblockTime = xPostTime;
00201C  9FBFB9     MOV W9, [W15-10]
00201E  EB0400     CLR W8
534:               
535:               	for( x = 0; x < xCycles; x++ )
002022  20177B     MOV #0x177, W11
002040  540F8B     SUB W8, W11, [W15]
002042  3AFFF0     BRA NZ, .L12
536:               	{
537:               		/* Calculate the next expected unblock time from the time taken before
538:               		this loop was entered. */
539:               		xExpectedUnblockTime = xPostTime + ( x * xPeriod );
002030  500009     SUB W0, W9, W0
540:               
541:               		vTaskDelayUntil( &xLastUnblockTime, xPeriod );
002024  2004B1     MOV #0x4B, W1
002026  57806A     SUB W15, #0xA, W0
002028  021888     CALL vTaskDelayUntil
00202A  000000     NOP
542:               
543:               		if( ( xTaskGetTickCount() - xExpectedUnblockTime ) > ( bktTIME_TO_BLOCK + xAllowableMargin ) )
002020  200B6A     MOV #0xB6, W10
00202C  0210AE     CALL xTaskGetTickCount
00202E  000000     NOP
002032  500008     SUB W0, W8, W0
002034  500F8A     SUB W0, W10, [W15]
002036  360002     BRA LEU, .L11
544:               		{
545:               			xErrorOccurred = pdTRUE;
002038  200010     MOV #0x1, W0
00203A  884380     MOV W0, xErrorOccurred
546:               		}
547:               
548:               		xPrimaryCycles++;
00203C  EC286C     INC xPrimaryCycles
00203E  B004B8     ADD #0x4B, W8
549:               	}
550:               
551:               	/* Reset to the original task priority ready for the other tests. */
552:               	vTaskPrioritySet( NULL, bktPRIMARY_PRIORITY );
002044  200011     MOV #0x1, W1
002046  EB0000     CLR W0
002048  020F50     CALL vTaskPrioritySet
00204A  000000     NOP
553:               }
00204C  BE054F     MOV.D [--W15], W10
00204E  BE044F     MOV.D [--W15], W8
002050  FA8000     ULNK
002052  060000     RETURN
554:               /*-----------------------------------------------------------*/
555:               
556:               BaseType_t xAreBlockTimeTestTasksStillRunning( void )
557:               {
558:               static BaseType_t xLastPrimaryCycleCount = 0, xLastSecondaryCycleCount = 0;
559:               BaseType_t xReturn = pdPASS;
002298  698102     XOR W3, W2, W2
00229A  A7F002     BTSC W2, #15
00229C  EA0102     NEG W2, W2
00229E  EA0002     NEG W2, W0
0022A0  DE004F     LSR W0, #15, W0
560:               
561:               	/* Have both tasks performed at least one cycle since this function was
562:               	last called? */
563:               	if( xPrimaryCycles == xLastPrimaryCycleCount )
00228A  804363     MOV xPrimaryCycles, W3
00228C  8043A2     MOV .L43, W2
564:               	{
565:               		xReturn = pdFAIL;
566:               	}
567:               
568:               	if( xSecondaryCycles == xLastSecondaryCycleCount )
002290  804391     MOV .L44, W1
002292  804374     MOV xSecondaryCycles, W4
002294  520F81     SUB W4, W1, [W15]
002296  320005     BRA Z, .L63
569:               	{
570:               		xReturn = pdFAIL;
00228E  EB0000     CLR W0
571:               	}
572:               
573:               	if( xErrorOccurred == pdTRUE )
0022A2  804381     MOV xErrorOccurred, W1
0022A4  508FE1     SUB W1, #0x1, [W15]
0022A6  3A0001     BRA NZ, .L64
574:               	{
575:               		xReturn = pdFAIL;
0022A8  EB0000     CLR W0
576:               	}
577:               
578:               	xLastSecondaryCycleCount = xSecondaryCycles;
0022AA  F8086E     PUSH xSecondaryCycles
0022AC  F90872     POP .L44
579:               	xLastPrimaryCycleCount = xPrimaryCycles;
0022AE  F8086C     PUSH xPrimaryCycles
0022B0  F90874     POP .L43
580:               
581:               	return xReturn;
582:               }
0022B2  060000     RETURN
---  D:/code/FreeRTOS/Demo/Common/Minimal/BlockQ.c  -----------------------------------------------------
1:                 /*
2:                     FreeRTOS V9.0.0 - Copyright (C) 2016 Real Time Engineers Ltd.
3:                     All rights reserved
4:                 
5:                     VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
6:                 
7:                     This file is part of the FreeRTOS distribution.
8:                 
9:                     FreeRTOS is free software; you can redistribute it and/or modify it under
10:                    the terms of the GNU General Public License (version 2) as published by the
11:                    Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
12:                
13:                    ***************************************************************************
14:                    >>!   NOTE: The modification to the GPL is included to allow you to     !<<
15:                    >>!   distribute a combined work that includes FreeRTOS without being   !<<
16:                    >>!   obliged to provide the source code for proprietary components     !<<
17:                    >>!   outside of the FreeRTOS kernel.                                   !<<
18:                    ***************************************************************************
19:                
20:                    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
21:                    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
22:                    FOR A PARTICULAR PURPOSE.  Full license text is available on the following
23:                    link: http://www.freertos.org/a00114.html
24:                
25:                    ***************************************************************************
26:                     *                                                                       *
27:                     *    FreeRTOS provides completely free yet professionally developed,    *
28:                     *    robust, strictly quality controlled, supported, and cross          *
29:                     *    platform software that is more than just the market leader, it     *
30:                     *    is the industry's de facto standard.                               *
31:                     *                                                                       *
32:                     *    Help yourself get started quickly while simultaneously helping     *
33:                     *    to support the FreeRTOS project by purchasing a FreeRTOS           *
34:                     *    tutorial book, reference manual, or both:                          *
35:                     *    http://www.FreeRTOS.org/Documentation                              *
36:                     *                                                                       *
37:                    ***************************************************************************
38:                
39:                    http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
40:                    the FAQ page "My application does not run, what could be wrong?".  Have you
41:                    defined configASSERT()?
42:                
43:                    http://www.FreeRTOS.org/support - In return for receiving this top quality
44:                    embedded software for free we request you assist our global community by
45:                    participating in the support forum.
46:                
47:                    http://www.FreeRTOS.org/training - Investing in training allows your team to
48:                    be as productive as possible as early as possible.  Now you can receive
49:                    FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
50:                    Ltd, and the world's leading authority on the world's leading RTOS.
51:                
52:                    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
53:                    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
54:                    compatible FAT file system, and our tiny thread aware UDP/IP stack.
55:                
56:                    http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
57:                    Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
58:                
59:                    http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
60:                    Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
61:                    licenses offer ticketed support, indemnification and commercial middleware.
62:                
63:                    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
64:                    engineered and independently SIL3 certified version for use in safety and
65:                    mission critical applications that require provable dependability.
66:                
67:                    1 tab == 4 spaces!
68:                */
69:                
70:                /*
71:                 * Creates six tasks that operate on three queues as follows:
72:                 *
73:                 * The first two tasks send and receive an incrementing number to/from a queue.
74:                 * One task acts as a producer and the other as the consumer.  The consumer is a
75:                 * higher priority than the producer and is set to block on queue reads.  The queue
76:                 * only has space for one item - as soon as the producer posts a message on the
77:                 * queue the consumer will unblock, pre-empt the producer, and remove the item.
78:                 *
79:                 * The second two tasks work the other way around.  Again the queue used only has
80:                 * enough space for one item.  This time the consumer has a lower priority than the
81:                 * producer.  The producer will try to post on the queue blocking when the queue is
82:                 * full.  When the consumer wakes it will remove the item from the queue, causing
83:                 * the producer to unblock, pre-empt the consumer, and immediately re-fill the
84:                 * queue.
85:                 *
86:                 * The last two tasks use the same queue producer and consumer functions.  This time the queue has
87:                 * enough space for lots of items and the tasks operate at the same priority.  The
88:                 * producer will execute, placing items into the queue.  The consumer will start
89:                 * executing when either the queue becomes full (causing the producer to block) or
90:                 * a context switch occurs (tasks of the same priority will time slice).
91:                 *
92:                 */
93:                
94:                #include <stdlib.h>
95:                
96:                /* Scheduler include files. */
97:                #include "FreeRTOS.h"
98:                #include "task.h"
99:                #include "queue.h"
100:               
101:               /* Demo program include files. */
102:               #include "BlockQ.h"
103:               
104:               #define blckqSTACK_SIZE		configMINIMAL_STACK_SIZE
105:               #define blckqNUM_TASK_SETS	( 3 )
106:               
107:               #if( configSUPPORT_DYNAMIC_ALLOCATION == 0 )
108:               	#error This example cannot be used if dynamic allocation is not allowed.
109:               #endif
110:               
111:               /* Structure used to pass parameters to the blocking queue tasks. */
112:               typedef struct BLOCKING_QUEUE_PARAMETERS
113:               {
114:               	QueueHandle_t xQueue;					/*< The queue to be used by the task. */
115:               	TickType_t xBlockTime;				/*< The block time to use on queue reads/writes. */
116:               	volatile short *psCheckVariable;	/*< Incremented on each successful cycle to check the task is still running. */
117:               } xBlockingQueueParameters;
118:               
119:               /* Task function that creates an incrementing number and posts it on a queue. */
120:               static portTASK_FUNCTION_PROTO( vBlockingQueueProducer, pvParameters );
121:               
122:               /* Task function that removes the incrementing number from a queue and checks that
123:               it is the expected number. */
124:               static portTASK_FUNCTION_PROTO( vBlockingQueueConsumer, pvParameters );
125:               
126:               /* Variables which are incremented each time an item is removed from a queue, and
127:               found to be the expected value.
128:               These are used to check that the tasks are still running. */
129:               static volatile short sBlockingConsumerCount[ blckqNUM_TASK_SETS ] = { ( uint16_t ) 0, ( uint16_t ) 0, ( uint16_t ) 0 };
130:               
131:               /* Variable which are incremented each time an item is posted on a queue.   These
132:               are used to check that the tasks are still running. */
133:               static volatile short sBlockingProducerCount[ blckqNUM_TASK_SETS ] = { ( uint16_t ) 0, ( uint16_t ) 0, ( uint16_t ) 0 };
134:               
135:               /*-----------------------------------------------------------*/
136:               
137:               void vStartBlockingQueueTasks( UBaseType_t uxPriority )
138:               {
002554  BE9F88     MOV.D W8, [W15++]
002556  BE9F8A     MOV.D W10, [W15++]
002558  781F8C     MOV W12, [W15++]
00255A  780600     MOV W0, W12
139:               xBlockingQueueParameters *pxQueueParameters1, *pxQueueParameters2;
140:               xBlockingQueueParameters *pxQueueParameters3, *pxQueueParameters4;
141:               xBlockingQueueParameters *pxQueueParameters5, *pxQueueParameters6;
142:               const UBaseType_t uxQueueSize1 = 1, uxQueueSize5 = 5;
143:               const TickType_t xBlockTime = pdMS_TO_TICKS( ( TickType_t ) 1000 );
144:               const TickType_t xDontBlock = ( TickType_t ) 0;
145:               
146:               	/* Create the first two tasks as described at the top of the file. */
147:               
148:               	/* First create the structure used to pass parameters to the consumer tasks. */
149:               	pxQueueParameters1 = ( xBlockingQueueParameters * ) pvPortMalloc( sizeof( xBlockingQueueParameters ) );
00255C  200060     MOV #0x6, W0
00255E  022E18     CALL pvPortMalloc
002560  000000     NOP
002562  780400     MOV W0, W8
150:               
151:               	/* Create the queue used by the first two tasks to pass the incrementing number.
152:               	Pass a pointer to the queue in the parameter structure. */
153:               	pxQueueParameters1->xQueue = xQueueCreate( uxQueueSize1, ( UBaseType_t ) sizeof( uint16_t ) );
002564  EB4100     CLR.B W2
002566  200021     MOV #0x2, W1
002568  200010     MOV #0x1, W0
00256A  021A74     CALL xQueueGenericCreate
00256C  000000     NOP
00256E  780C00     MOV W0, [W8]
154:               
155:               	/* The consumer is created first so gets a block time as described above. */
156:               	pxQueueParameters1->xBlockTime = xBlockTime;
002570  20010A     MOV #0x10, W10
002572  98041A     MOV W10, [W8+2]
157:               
158:               	/* Pass in the variable that this task is going to increment so we can check it
159:               	is still running. */
160:               	pxQueueParameters1->psCheckVariable = &( sBlockingConsumerCount[ 0 ] );
002574  21DA00     MOV #0x1DA0, W0
002576  980420     MOV W0, [W8+4]
161:               
162:               	/* Create the structure used to pass parameters to the producer task. */
163:               	pxQueueParameters2 = ( xBlockingQueueParameters * ) pvPortMalloc( sizeof( xBlockingQueueParameters ) );
002578  200060     MOV #0x6, W0
00257A  022E18     CALL pvPortMalloc
00257C  000000     NOP
00257E  780480     MOV W0, W9
164:               
165:               	/* Pass the queue to this task also, using the parameter structure. */
166:               	pxQueueParameters2->xQueue = pxQueueParameters1->xQueue;
002580  780C98     MOV [W8], [W9]
167:               
168:               	/* The producer is not going to block - as soon as it posts the consumer will
169:               	wake and remove the item so the producer should always have room to post. */
170:               	pxQueueParameters2->xBlockTime = xDontBlock;
002582  EB0580     CLR W11
002584  98049B     MOV W11, [W9+2]
171:               
172:               	/* Pass in the variable that this task is going to increment so we can check
173:               	it is still running. */
174:               	pxQueueParameters2->psCheckVariable = &( sBlockingProducerCount[ 0 ] );
002586  21DA60     MOV #0x1DA6, W0
002588  9804A0     MOV W0, [W9+4]
175:               
176:               
177:               	/* Note the producer has a lower priority than the consumer when the tasks are
178:               	spawned. */
179:               	xTaskCreate( vBlockingQueueConsumer, "QConsB1", blckqSTACK_SIZE, ( void * ) pxQueueParameters1, uxPriority, NULL );
00258A  EB0280     CLR W5
00258C  78020C     MOV W12, W4
00258E  780188     MOV W8, W3
002590  200732     MOV #0x73, W2
002592  28DFC1     MOV #0x8DFC, W1
002594  2251C0     MOV #0x251C, W0
002596  0212C4     CALL xTaskCreate
002598  000000     NOP
180:               	xTaskCreate( vBlockingQueueProducer, "QProdB2", blckqSTACK_SIZE, ( void * ) pxQueueParameters2, tskIDLE_PRIORITY, NULL );
00259A  B82260     MUL.UU W4, #0, W4
00259C  780189     MOV W9, W3
00259E  200732     MOV #0x73, W2
0025A0  28E041     MOV #0x8E04, W1
0025A2  224E60     MOV #0x24E6, W0
0025A4  0212C4     CALL xTaskCreate
0025A6  000000     NOP
181:               
182:               
183:               
184:               	/* Create the second two tasks as described at the top of the file.   This uses
185:               	the same mechanism but reverses the task priorities. */
186:               
187:               	pxQueueParameters3 = ( xBlockingQueueParameters * ) pvPortMalloc( sizeof( xBlockingQueueParameters ) );
0025A8  200060     MOV #0x6, W0
0025AA  022E18     CALL pvPortMalloc
0025AC  000000     NOP
0025AE  780400     MOV W0, W8
188:               	pxQueueParameters3->xQueue = xQueueCreate( uxQueueSize1, ( UBaseType_t ) sizeof( uint16_t ) );
0025B0  EB4100     CLR.B W2
0025B2  200021     MOV #0x2, W1
0025B4  200010     MOV #0x1, W0
0025B6  021A74     CALL xQueueGenericCreate
0025B8  000000     NOP
0025BA  780C00     MOV W0, [W8]
189:               	pxQueueParameters3->xBlockTime = xDontBlock;
0025BC  98041B     MOV W11, [W8+2]
190:               	pxQueueParameters3->psCheckVariable = &( sBlockingProducerCount[ 1 ] );
0025BE  21DA80     MOV #0x1DA8, W0
0025C0  980420     MOV W0, [W8+4]
191:               
192:               	pxQueueParameters4 = ( xBlockingQueueParameters * ) pvPortMalloc( sizeof( xBlockingQueueParameters ) );
0025C2  200060     MOV #0x6, W0
0025C4  022E18     CALL pvPortMalloc
0025C6  000000     NOP
0025C8  780480     MOV W0, W9
193:               	pxQueueParameters4->xQueue = pxQueueParameters3->xQueue;
0025CA  780C98     MOV [W8], [W9]
194:               	pxQueueParameters4->xBlockTime = xBlockTime;
0025CC  98049A     MOV W10, [W9+2]
195:               	pxQueueParameters4->psCheckVariable = &( sBlockingConsumerCount[ 1 ] );
0025CE  21DA20     MOV #0x1DA2, W0
0025D0  9804A0     MOV W0, [W9+4]
196:               
197:               	xTaskCreate( vBlockingQueueConsumer, "QConsB3", blckqSTACK_SIZE, ( void * ) pxQueueParameters3, tskIDLE_PRIORITY, NULL );
0025D2  B82260     MUL.UU W4, #0, W4
0025D4  780188     MOV W8, W3
0025D6  200732     MOV #0x73, W2
0025D8  28E0C1     MOV #0x8E0C, W1
0025DA  2251C0     MOV #0x251C, W0
0025DC  0212C4     CALL xTaskCreate
0025DE  000000     NOP
198:               	xTaskCreate( vBlockingQueueProducer, "QProdB4", blckqSTACK_SIZE, ( void * ) pxQueueParameters4, uxPriority, NULL );
0025E0  EB0280     CLR W5
0025E2  78020C     MOV W12, W4
0025E4  780189     MOV W9, W3
0025E6  200732     MOV #0x73, W2
0025E8  28E141     MOV #0x8E14, W1
0025EA  224E60     MOV #0x24E6, W0
0025EC  0212C4     CALL xTaskCreate
0025EE  000000     NOP
199:               
200:               
201:               
202:               	/* Create the last two tasks as described above.  The mechanism is again just
203:               	the same.  This time both parameter structures are given a block time. */
204:               	pxQueueParameters5 = ( xBlockingQueueParameters * ) pvPortMalloc( sizeof( xBlockingQueueParameters ) );
0025F0  200060     MOV #0x6, W0
0025F2  022E18     CALL pvPortMalloc
0025F4  000000     NOP
0025F6  780400     MOV W0, W8
205:               	pxQueueParameters5->xQueue = xQueueCreate( uxQueueSize5, ( UBaseType_t ) sizeof( uint16_t ) );
0025F8  EB4100     CLR.B W2
0025FA  200021     MOV #0x2, W1
0025FC  200050     MOV #0x5, W0
0025FE  021A74     CALL xQueueGenericCreate
002600  000000     NOP
002602  780C00     MOV W0, [W8]
206:               	pxQueueParameters5->xBlockTime = xBlockTime;
002604  98041A     MOV W10, [W8+2]
207:               	pxQueueParameters5->psCheckVariable = &( sBlockingProducerCount[ 2 ] );
002606  21DAA0     MOV #0x1DAA, W0
002608  980420     MOV W0, [W8+4]
208:               
209:               	pxQueueParameters6 = ( xBlockingQueueParameters * ) pvPortMalloc( sizeof( xBlockingQueueParameters ) );
00260A  200060     MOV #0x6, W0
00260C  022E18     CALL pvPortMalloc
00260E  000000     NOP
002610  780480     MOV W0, W9
210:               	pxQueueParameters6->xQueue = pxQueueParameters5->xQueue;
002612  780C98     MOV [W8], [W9]
211:               	pxQueueParameters6->xBlockTime = xBlockTime;
002614  98049A     MOV W10, [W9+2]
212:               	pxQueueParameters6->psCheckVariable = &( sBlockingConsumerCount[ 2 ] );
002616  21DA40     MOV #0x1DA4, W0
002618  9804A0     MOV W0, [W9+4]
213:               
214:               	xTaskCreate( vBlockingQueueProducer, "QProdB5", blckqSTACK_SIZE, ( void * ) pxQueueParameters5, tskIDLE_PRIORITY, NULL );
00261A  B82260     MUL.UU W4, #0, W4
00261C  780188     MOV W8, W3
00261E  200732     MOV #0x73, W2
002620  28E1C1     MOV #0x8E1C, W1
002622  224E60     MOV #0x24E6, W0
002624  0212C4     CALL xTaskCreate
002626  000000     NOP
215:               	xTaskCreate( vBlockingQueueConsumer, "QConsB6", blckqSTACK_SIZE, ( void * ) pxQueueParameters6, tskIDLE_PRIORITY, NULL );
002628  B82260     MUL.UU W4, #0, W4
00262A  780189     MOV W9, W3
00262C  200732     MOV #0x73, W2
00262E  28E241     MOV #0x8E24, W1
002630  2251C0     MOV #0x251C, W0
002632  0212C4     CALL xTaskCreate
002634  000000     NOP
216:               }
002636  78064F     MOV [--W15], W12
002638  BE054F     MOV.D [--W15], W10
00263A  BE044F     MOV.D [--W15], W8
00263C  060000     RETURN
217:               /*-----------------------------------------------------------*/
218:               
219:               static portTASK_FUNCTION( vBlockingQueueProducer, pvParameters )
220:               {
0024E6  FA0002     LNK #0x2
0024E8  BE9F88     MOV.D W8, [W15++]
0024EA  BE9F8A     MOV.D W10, [W15++]
221:               uint16_t usValue = 0;
0024EC  EB0080     CLR W1
0024EE  9FBFB1     MOV W1, [W15-10]
222:               xBlockingQueueParameters *pxQueueParameters;
223:               short sErrorEverOccurred = pdFALSE;
0024F2  EB0480     CLR W9
224:               
225:               	pxQueueParameters = ( xBlockingQueueParameters * ) pvParameters;
0024F0  780400     MOV W0, W8
226:               
227:               	for( ;; )
228:               	{
229:               		if( xQueueSend( pxQueueParameters->xQueue, ( void * ) &usValue, pxQueueParameters->xBlockTime ) != pdPASS )
0024F4  EB0500     CLR W10
0024FC  900118     MOV [W8+2], W2
0024FE  78018A     MOV W10, W3
002500  5780EA     SUB W15, #0xA, W1
002502  780018     MOV [W8], W0
002504  021AA8     CALL xQueueGenericSend
002506  000000     NOP
002508  500FE1     SUB W0, #0x1, [W15]
00250A  3AFFF7     BRA NZ, .L5
230:               		{
231:               			sErrorEverOccurred = pdTRUE;
0024F6  20001B     MOV #0x1, W11
0024F8  370001     BRA .L6
0024FA  78048B     MOV W11, W9
232:               		}
233:               		else
234:               		{
235:               			/* We have successfully posted a message, so increment the variable
236:               			used to check we are still running. */
237:               			if( sErrorEverOccurred == pdFALSE )
00250C  E00009     CP0 W9
00250E  3A0002     BRA NZ, .L3
238:               			{
239:               				( *pxQueueParameters->psCheckVariable )++;
002510  900028     MOV [W8+4], W0
002512  E80810     INC [W0], [W0]
240:               			}
241:               
242:               			/* Increment the variable we are going to post next time round.  The
243:               			consumer will expect the numbers to	follow in numerical order. */
244:               			++usValue;
002514  97B83F     MOV [W15-10], W0
002516  E80000     INC W0, W0
002518  9FBFB0     MOV W0, [W15-10]
00251A  37FFF0     BRA .L6
245:               
246:               			#if configUSE_PREEMPTION == 0
247:               				taskYIELD();
248:               			#endif
249:               		}
250:               	}
251:               }
252:               /*-----------------------------------------------------------*/
253:               
254:               static portTASK_FUNCTION( vBlockingQueueConsumer, pvParameters )
255:               {
00251C  FA0002     LNK #0x2
00251E  BE9F88     MOV.D W8, [W15++]
002520  BE9F8A     MOV.D W10, [W15++]
002522  781F8C     MOV W12, [W15++]
002524  780400     MOV W0, W8
256:               uint16_t usData, usExpectedValue = 0;
257:               xBlockingQueueParameters *pxQueueParameters;
258:               short sErrorEverOccurred = pdFALSE;
002526  B85560     MUL.UU W10, #0, W10
259:               
260:               	pxQueueParameters = ( xBlockingQueueParameters * ) pvParameters;
261:               
262:               	for( ;; )
263:               	{
264:               		if( xQueueReceive( pxQueueParameters->xQueue, &usData, pxQueueParameters->xBlockTime ) == pdPASS )
002528  EB0480     CLR W9
002532  900118     MOV [W8+2], W2
002534  780189     MOV W9, W3
002536  5780EC     SUB W15, #0xC, W1
002538  780018     MOV [W8], W0
00253A  021C16     CALL xQueueGenericReceive
00253C  000000     NOP
00253E  500FE1     SUB W0, #0x1, [W15]
002540  3AFFF8     BRA NZ, .L14
265:               		{
266:               			if( usData != usExpectedValue )
002542  97B82F     MOV [W15-12], W0
002544  500F8A     SUB W0, W10, [W15]
002546  3AFFF3     BRA NZ, .L11
267:               			{
268:               				/* Catch-up. */
269:               				usExpectedValue = usData;
00252E  780500     MOV W0, W10
270:               
271:               				sErrorEverOccurred = pdTRUE;
00252A  20001C     MOV #0x1, W12
00252C  370002     BRA .L14
002530  78058C     MOV W12, W11
272:               			}
273:               			else
274:               			{
275:               				/* We have successfully received a message, so increment the
276:               				variable used to check we are still running. */
277:               				if( sErrorEverOccurred == pdFALSE )
002548  E0000B     CP0 W11
00254A  3A0002     BRA NZ, .L10
278:               				{
279:               					( *pxQueueParameters->psCheckVariable )++;
00254C  9000A8     MOV [W8+4], W1
00254E  E80891     INC [W1], [W1]
280:               				}
281:               
282:               				/* Increment the value we expect to remove from the queue next time
283:               				round. */
284:               				++usExpectedValue;
002550  E80500     INC W0, W10
002552  37FFEF     BRA .L14
285:               			}
286:               
287:               			#if configUSE_PREEMPTION == 0
288:               			{
289:               				if( pxQueueParameters->xBlockTime == 0 )
290:               				{
291:               					taskYIELD();
292:               				}
293:               			}
294:               			#endif
295:               		}
296:               	}
297:               }
298:               /*-----------------------------------------------------------*/
299:               
300:               /* This is called to check that all the created tasks are still running. */
301:               BaseType_t xAreBlockingQueuesStillRunning( void )
302:               {
00263E  BE9F88     MOV.D W8, [W15++]
002644  780404     MOV W4, W8
002646  780383     MOV W3, W7
303:               static short sLastBlockingConsumerCount[ blckqNUM_TASK_SETS ] = { ( uint16_t ) 0, ( uint16_t ) 0, ( uint16_t ) 0 };
304:               static short sLastBlockingProducerCount[ blckqNUM_TASK_SETS ] = { ( uint16_t ) 0, ( uint16_t ) 0, ( uint16_t ) 0 };
305:               BaseType_t xReturn = pdPASS, xTasks;
00264A  200010     MOV #0x1, W0
306:               
307:               	/* Not too worried about mutual exclusion on these variables as they are 16
308:               	bits and we are only reading them. We also only care to see if they have
309:               	changed or not.
310:               
311:               	Loop through each check variable to and return pdFALSE if any are found not
312:               	to have changed since the last call. */
313:               
314:               	for( xTasks = 0; xTasks < blckqNUM_TASK_SETS; xTasks++ )
002648  EB0080     CLR W1
00266C  E80081     INC W1, W1
00266E  508FE3     SUB W1, #0x3, [W15]
002670  3AFFF0     BRA NZ, .L19
315:               	{
316:               		if( sBlockingConsumerCount[ xTasks ] == sLastBlockingConsumerCount[ xTasks ]  )
00264C  21DA06     MOV #0x1DA0, W6
002652  408101     ADD W1, W1, W2
002654  790166     MOV [W6+W2], W2
002656  510FD3     SUB W2, [++W3], [W15]
002658  3A0001     BRA NZ, .L17
317:               		{
318:               			xReturn = pdFALSE;
00264E  EB0480     CLR W9
00265A  780009     MOV W9, W0
319:               		}
320:               		sLastBlockingConsumerCount[ xTasks ] = sBlockingConsumerCount[ xTasks ];
00265C  408101     ADD W1, W1, W2
00265E  792BE6     MOV [W6+W2], [++W7]
321:               
322:               
323:               		if( sBlockingProducerCount[ xTasks ] == sLastBlockingProducerCount[ xTasks ]  )
002650  21DA65     MOV #0x1DA6, W5
002660  790165     MOV [W5+W2], W2
002662  510FD8     SUB W2, [++W8], [W15]
002664  3A0001     BRA NZ, .L18
324:               		{
325:               			xReturn = pdFALSE;
002640  21DB03     MOV #0x1DB0, W3
002642  21DAA4     MOV #0x1DAA, W4
002666  780009     MOV W9, W0
326:               		}
327:               		sLastBlockingProducerCount[ xTasks ] = sBlockingProducerCount[ xTasks ];
002668  408101     ADD W1, W1, W2
00266A  792A65     MOV [W5+W2], [++W4]
328:               	}
329:               
330:               	return xReturn;
331:               }
002672  BE044F     MOV.D [--W15], W8
002674  060000     RETURN
332:               
