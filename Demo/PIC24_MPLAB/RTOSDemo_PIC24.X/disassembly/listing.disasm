Disassembly Listing for RTOSDemo_PIC24
Generated From:
/home/zxc/Documents/WCGRTOS/Demo/PIC24_MPLAB/RTOSDemo_PIC24.X/dist/default/debug/RTOSDemo_PIC24.X.debug.elf
Jan 18, 2019 10:38:38 AM

---  /home/zxc/Documents/WCGRTOS/Source/tasks.c  --------------------------------------------------------
1:                 /*
2:                     FreeRTOS V9.0.0 - Copyright (C) 2016 Real Time Engineers Ltd.
3:                     All rights reserved
4:                 
5:                     VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
6:                 
7:                     This file is part of the FreeRTOS distribution.
8:                 
9:                     FreeRTOS is free software; you can redistribute it and/or modify it under
10:                    the terms of the GNU General Public License (version 2) as published by the
11:                    Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
12:                
13:                    ***************************************************************************
14:                    >>!   NOTE: The modification to the GPL is included to allow you to     !<<
15:                    >>!   distribute a combined work that includes FreeRTOS without being   !<<
16:                    >>!   obliged to provide the source code for proprietary components     !<<
17:                    >>!   outside of the FreeRTOS kernel.                                   !<<
18:                    ***************************************************************************
19:                
20:                    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
21:                    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
22:                    FOR A PARTICULAR PURPOSE.  Full license text is available on the following
23:                    link: http://www.freertos.org/a00114.html
24:                
25:                    ***************************************************************************
26:                     *                                                                       *
27:                     *    FreeRTOS provides completely free yet professionally developed,    *
28:                     *    robust, strictly quality controlled, supported, and cross          *
29:                     *    platform software that is more than just the market leader, it     *
30:                     *    is the industry's de facto standard.                               *
31:                     *                                                                       *
32:                     *    Help yourself get started quickly while simultaneously helping     *
33:                     *    to support the FreeRTOS project by purchasing a FreeRTOS           *
34:                     *    tutorial book, reference manual, or both:                          *
35:                     *    http://www.FreeRTOS.org/Documentation                              *
36:                     *                                                                       *
37:                    ***************************************************************************
38:                
39:                    http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
40:                    the FAQ page "My application does not run, what could be wrong?".  Have you
41:                    defined configASSERT()?
42:                
43:                    http://www.FreeRTOS.org/support - In return for receiving this top quality
44:                    embedded software for free we request you assist our global community by
45:                    participating in the support forum.
46:                
47:                    http://www.FreeRTOS.org/training - Investing in training allows your team to
48:                    be as productive as possible as early as possible.  Now you can receive
49:                    FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
50:                    Ltd, and the world's leading authority on the world's leading RTOS.
51:                
52:                    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
53:                    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
54:                    compatible FAT file system, and our tiny thread aware UDP/IP stack.
55:                
56:                    http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
57:                    Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
58:                
59:                    http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
60:                    Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
61:                    licenses offer ticketed support, indemnification and commercial middleware.
62:                
63:                    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
64:                    engineered and independently SIL3 certified version for use in safety and
65:                    mission critical applications that require provable dependability.
66:                
67:                    1 tab == 4 spaces!
68:                */
69:                
70:                /* Standard includes. */
71:                #include <stdlib.h>
72:                #include <string.h>
73:                
74:                /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
75:                all the API functions to use the MPU wrappers.  That should only be done when
76:                task.h is included from an application file. */
77:                #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
78:                
79:                /* FreeRTOS includes. */
80:                #include "FreeRTOS.h"
81:                #include "task.h"
82:                #include "timers.h"
83:                #include "StackMacros.h"
84:                
85:                /* Lint e961 and e750 are suppressed as a MISRA exception justified because the
86:                MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined for the
87:                header files above, but not in this file, in order to generate the correct
88:                privileged Vs unprivileged linkage and placement. */
89:                #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750. */
90:                
91:                /* Set configUSE_STATS_FORMATTING_FUNCTIONS to 2 to include the stats formatting
92:                functions but without including stdio.h here. */
93:                #if ( configUSE_STATS_FORMATTING_FUNCTIONS == 1 )
94:                	/* At the bottom of this file are two optional functions that can be used
95:                	to generate human readable text from the raw data generated by the
96:                	uxTaskGetSystemState() function.  Note the formatting functions are provided
97:                	for convenience only, and are NOT considered part of the kernel. */
98:                	#include <stdio.h>
99:                #endif /* configUSE_STATS_FORMATTING_FUNCTIONS == 1 ) */
100:               
101:               #if( configUSE_PREEMPTION == 0 )
102:               	/* If the cooperative scheduler is being used then a yield should not be
103:               	performed just because a higher priority task has been woken. */
104:               	#define taskYIELD_IF_USING_PREEMPTION()
105:               #else
106:               	#define taskYIELD_IF_USING_PREEMPTION() portYIELD_WITHIN_API()
107:               #endif
108:               
109:               /* Values that can be assigned to the ucNotifyState member of the TCB. */
110:               #define taskNOT_WAITING_NOTIFICATION	( ( uint8_t ) 0 )
111:               #define taskWAITING_NOTIFICATION		( ( uint8_t ) 1 )
112:               #define taskNOTIFICATION_RECEIVED		( ( uint8_t ) 2 )
113:               
114:               /*
115:                * The value used to fill the stack of a task when the task is created.  This
116:                * is used purely for checking the high water mark for tasks.
117:                */
118:               #define tskSTACK_FILL_BYTE	( 0xa5U )
119:               
120:               /* Sometimes the FreeRTOSConfig.h settings only allow a task to be created using
121:               dynamically allocated RAM, in which case when any task is deleted it is known
122:               that both the task's stack and TCB need to be freed.  Sometimes the
123:               FreeRTOSConfig.h settings only allow a task to be created using statically
124:               allocated RAM, in which case when any task is deleted it is known that neither
125:               the task's stack or TCB should be freed.  Sometimes the FreeRTOSConfig.h
126:               settings allow a task to be created using either statically or dynamically
127:               allocated RAM, in which case a member of the TCB is used to record whether the
128:               stack and/or TCB were allocated statically or dynamically, so when a task is
129:               deleted the RAM that was allocated dynamically is freed again and no attempt is
130:               made to free the RAM that was allocated statically.
131:               tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE is only true if it is possible for a
132:               task to be created using either statically or dynamically allocated RAM.  Note
133:               that if portUSING_MPU_WRAPPERS is 1 then a protected task can be created with
134:               a statically allocated stack and a dynamically allocated TCB. */
135:               #define tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE ( ( ( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) || ( portUSING_MPU_WRAPPERS == 1 ) )
136:               #define tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB 		( ( uint8_t ) 0 )
137:               #define tskSTATICALLY_ALLOCATED_STACK_ONLY 			( ( uint8_t ) 1 )
138:               #define tskSTATICALLY_ALLOCATED_STACK_AND_TCB		( ( uint8_t ) 2 )
139:               
140:               /*
141:                * Macros used by vListTask to indicate which state a task is in.
142:                */
143:               #define tskBLOCKED_CHAR		( 'B' )
144:               #define tskREADY_CHAR		( 'R' )
145:               #define tskDELETED_CHAR		( 'D' )
146:               #define tskSUSPENDED_CHAR	( 'S' )
147:               
148:               /*
149:                * Some kernel aware debuggers require the data the debugger needs access to be
150:                * global, rather than file scope.
151:                */
152:               #ifdef portREMOVE_STATIC_QUALIFIER
153:               	#define static
154:               #endif
155:               
156:               #if ( configUSE_PORT_OPTIMISED_TASK_SELECTION == 0 )
157:               
158:               	/* If configUSE_PORT_OPTIMISED_TASK_SELECTION is 0 then task selection is
159:               	performed in a generic way that is not optimised to any particular
160:               	microcontroller architecture. */
161:               
162:               	/* uxTopReadyPriority holds the priority of the highest priority ready
163:               	state task. */
164:               	#define taskRECORD_READY_PRIORITY( uxPriority )														\
165:               	{																									\
166:               		if( ( uxPriority ) > uxTopReadyPriority )														\
167:               		{																								\
168:               			uxTopReadyPriority = ( uxPriority );														\
169:               		}																								\
170:               	} /* taskRECORD_READY_PRIORITY */
171:               
172:               	/*-----------------------------------------------------------*/
173:               
174:               	#define taskSELECT_HIGHEST_PRIORITY_TASK()															\
175:               	{																									\
176:               	UBaseType_t uxTopPriority = uxTopReadyPriority;														\
177:               																										\
178:               		/* Find the highest priority queue that contains ready tasks. */								\
179:               		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopPriority ] ) ) )							\
180:               		{																								\
181:               			configASSERT( uxTopPriority );																\
182:               			--uxTopPriority;																			\
183:               		}																								\
184:               																										\
185:               		/* listGET_OWNER_OF_NEXT_ENTRY indexes through the list, so the tasks of						\
186:               		the	same priority get an equal share of the processor time. */									\
187:               		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopPriority ] ) );			\
188:               		uxTopReadyPriority = uxTopPriority;																\
189:               	} /* taskSELECT_HIGHEST_PRIORITY_TASK */
190:               
191:               	/*-----------------------------------------------------------*/
192:               
193:               	/* Define away taskRESET_READY_PRIORITY() and portRESET_READY_PRIORITY() as
194:               	they are only required when a port optimised method of task selection is
195:               	being used. */
196:               	#define taskRESET_READY_PRIORITY( uxPriority )
197:               	#define portRESET_READY_PRIORITY( uxPriority, uxTopReadyPriority )
198:               
199:               #else /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
200:               
201:               	/* If configUSE_PORT_OPTIMISED_TASK_SELECTION is 1 then task selection is
202:               	performed in a way that is tailored to the particular microcontroller
203:               	architecture being used. */
204:               
205:               	/* A port optimised version is provided.  Call the port defined macros. */
206:               	#define taskRECORD_READY_PRIORITY( uxPriority )	portRECORD_READY_PRIORITY( uxPriority, uxTopReadyPriority )
207:               
208:               	/*-----------------------------------------------------------*/
209:               
210:               	#define taskSELECT_HIGHEST_PRIORITY_TASK()														\
211:               	{																								\
212:               	UBaseType_t uxTopPriority;																		\
213:               																									\
214:               		/* Find the highest priority list that contains ready tasks. */								\
215:               		portGET_HIGHEST_PRIORITY( uxTopPriority, uxTopReadyPriority );								\
216:               		configASSERT( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ uxTopPriority ] ) ) > 0 );		\
217:               		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopPriority ] ) );		\
218:               	} /* taskSELECT_HIGHEST_PRIORITY_TASK() */
219:               
220:               	/*-----------------------------------------------------------*/
221:               
222:               	/* A port optimised version is provided, call it only if the TCB being reset
223:               	is being referenced from a ready list.  If it is referenced from a delayed
224:               	or suspended list then it won't be in a ready list. */
225:               	#define taskRESET_READY_PRIORITY( uxPriority )														\
226:               	{																									\
227:               		if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ ( uxPriority ) ] ) ) == ( UBaseType_t ) 0 )	\
228:               		{																								\
229:               			portRESET_READY_PRIORITY( ( uxPriority ), ( uxTopReadyPriority ) );							\
230:               		}																								\
231:               	}
232:               
233:               #endif /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
234:               
235:               /*-----------------------------------------------------------*/
236:               
237:               /* pxDelayedTaskList and pxOverflowDelayedTaskList are switched when the tick
238:               count overflows. */
239:               #define taskSWITCH_DELAYED_LISTS()																	\
240:               {																									\
241:               	List_t *pxTemp;																					\
242:               																									\
243:               	/* The delayed tasks list should be empty when the lists are switched. */						\
244:               	configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );										\
245:               																									\
246:               	pxTemp = pxDelayedTaskList;																		\
247:               	pxDelayedTaskList = pxOverflowDelayedTaskList;													\
248:               	pxOverflowDelayedTaskList = pxTemp;																\
249:               	xNumOfOverflows++;																				\
250:               	prvResetNextTaskUnblockTime();																	\
251:               }
252:               
253:               /*-----------------------------------------------------------*/
254:               
255:               /*
256:                * Place the task represented by pxTCB into the appropriate ready list for
257:                * the task.  It is inserted at the end of the list.
258:                */
259:               #define prvAddTaskToReadyList( pxTCB )																\
260:               	traceMOVED_TASK_TO_READY_STATE( pxTCB );														\
261:               	taskRECORD_READY_PRIORITY( ( pxTCB )->uxPriority );												\
262:               	vListInsertEnd( &( pxReadyTasksLists[ ( pxTCB )->uxPriority ] ), &( ( pxTCB )->xStateListItem ) ); \
263:               	tracePOST_MOVED_TASK_TO_READY_STATE( pxTCB )
264:               /*-----------------------------------------------------------*/
265:               
266:               /*
267:                * Several functions take an TaskHandle_t parameter that can optionally be NULL,
268:                * where NULL is used to indicate that the handle of the currently executing
269:                * task should be used in place of the parameter.  This macro simply checks to
270:                * see if the parameter is NULL and returns a pointer to the appropriate TCB.
271:                */
272:               #define prvGetTCBFromHandle( pxHandle ) ( ( ( pxHandle ) == NULL ) ? ( TCB_t * ) pxCurrentTCB : ( TCB_t * ) ( pxHandle ) )
273:               
274:               /* The item value of the event list item is normally used to hold the priority
275:               of the task to which it belongs (coded to allow it to be held in reverse
276:               priority order).  However, it is occasionally borrowed for other purposes.  It
277:               is important its value is not updated due to a task priority change while it is
278:               being used for another purpose.  The following bit definition is used to inform
279:               the scheduler that the value should not be changed - in which case it is the
280:               responsibility of whichever module is using the value to ensure it gets set back
281:               to its original value when it is released. */
282:               #if( configUSE_16_BIT_TICKS == 1 )
283:               	#define taskEVENT_LIST_ITEM_VALUE_IN_USE	0x8000U
284:               #else
285:               	#define taskEVENT_LIST_ITEM_VALUE_IN_USE	0x80000000UL
286:               #endif
287:               
288:               /*
289:                * Task control block.  A task control block (TCB) is allocated for each task,
290:                * and stores task state information, including a pointer to the task's context
291:                * (the task's run time environment, including register values)
292:                */
293:               typedef struct tskTaskControlBlock
294:               {
295:               	volatile StackType_t	*pxTopOfStack;	/*< Points to the location of the last item placed on the tasks stack.  THIS MUST BE THE FIRST MEMBER OF THE TCB STRUCT. */
296:               
297:               	#if ( portUSING_MPU_WRAPPERS == 1 )
298:               		xMPU_SETTINGS	xMPUSettings;		/*< The MPU settings are defined as part of the port layer.  THIS MUST BE THE SECOND MEMBER OF THE TCB STRUCT. */
299:               	#endif
300:               
301:               	ListItem_t			xStateListItem;	/*< The list that the state list item of a task is reference from denotes the state of that task (Ready, Blocked, Suspended ). */
302:               	ListItem_t			xEventListItem;		/*< Used to reference a task from an event list. */
303:               	UBaseType_t			uxPriority;			/*< The priority of the task.  0 is the lowest priority. */
304:               	StackType_t			*pxStack;			/*< Points to the start of the stack. */
305:               	char				pcTaskName[ configMAX_TASK_NAME_LEN ];/*< Descriptive name given to the task when created.  Facilitates debugging only. */ /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
306:               
307:               	#if ( portSTACK_GROWTH > 0 )
308:               		StackType_t		*pxEndOfStack;		/*< Points to the end of the stack on architectures where the stack grows up from low memory. */
309:               	#endif
310:               
311:               	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
312:               		UBaseType_t		uxCriticalNesting;	/*< Holds the critical section nesting depth for ports that do not maintain their own count in the port layer. */
313:               	#endif
314:               
315:               	#if ( configUSE_TRACE_FACILITY == 1 )
316:               		UBaseType_t		uxTCBNumber;		/*< Stores a number that increments each time a TCB is created.  It allows debuggers to determine when a task has been deleted and then recreated. */
317:               		UBaseType_t		uxTaskNumber;		/*< Stores a number specifically for use by third party trace code. */
318:               	#endif
319:               
320:               	#if ( configUSE_MUTEXES == 1 )
321:               		UBaseType_t		uxBasePriority;		/*< The priority last assigned to the task - used by the priority inheritance mechanism. */
322:               		UBaseType_t		uxMutexesHeld;
323:               	#endif
324:               
325:               	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
326:               		TaskHookFunction_t pxTaskTag;
327:               	#endif
328:               
329:               	#if( configNUM_THREAD_LOCAL_STORAGE_POINTERS > 0 )
330:               		void *pvThreadLocalStoragePointers[ configNUM_THREAD_LOCAL_STORAGE_POINTERS ];
331:               	#endif
332:               
333:               	#if( configGENERATE_RUN_TIME_STATS == 1 )
334:               		uint32_t		ulRunTimeCounter;	/*< Stores the amount of time the task has spent in the Running state. */
335:               	#endif
336:               
337:               	#if ( configUSE_NEWLIB_REENTRANT == 1 )
338:               		/* Allocate a Newlib reent structure that is specific to this task.
339:               		Note Newlib support has been included by popular demand, but is not
340:               		used by the FreeRTOS maintainers themselves.  FreeRTOS is not
341:               		responsible for resulting newlib operation.  User must be familiar with
342:               		newlib and must provide system-wide implementations of the necessary
343:               		stubs. Be warned that (at the time of writing) the current newlib design
344:               		implements a system-wide malloc() that must be provided with locks. */
345:               		struct	_reent xNewLib_reent;
346:               	#endif
347:               
348:               	#if( configUSE_TASK_NOTIFICATIONS == 1 )
349:               		volatile uint32_t ulNotifiedValue;
350:               		volatile uint8_t ucNotifyState;
351:               	#endif
352:               
353:               	/* See the comments above the definition of
354:               	tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE. */
355:               	#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 )
356:               		uint8_t	ucStaticallyAllocated; 		/*< Set to pdTRUE if the task is a statically allocated to ensure no attempt is made to free the memory. */
357:               	#endif
358:               
359:               	#if( INCLUDE_xTaskAbortDelay == 1 )
360:               		uint8_t ucDelayAborted;
361:               	#endif
362:               
363:               } tskTCB;
364:               
365:               /* The old tskTCB name is maintained above then typedefed to the new TCB_t name
366:               below to enable the use of older kernel aware debuggers. */
367:               typedef tskTCB TCB_t;
368:               
369:               /*lint -e956 A manual analysis and inspection has been used to determine which
370:               static variables must be declared volatile. */
371:               
372:               PRIVILEGED_DATA TCB_t * volatile pxCurrentTCB = NULL;
373:               
374:               /* Lists for ready and blocked tasks. --------------------*/
375:               PRIVILEGED_DATA static List_t pxReadyTasksLists[ configMAX_PRIORITIES ];/*< Prioritised ready tasks. */
376:               PRIVILEGED_DATA static List_t xDelayedTaskList1;						/*< Delayed tasks. */
377:               PRIVILEGED_DATA static List_t xDelayedTaskList2;						/*< Delayed tasks (two lists are used - one for delays that have overflowed the current tick count. */
378:               PRIVILEGED_DATA static List_t * volatile pxDelayedTaskList;				/*< Points to the delayed task list currently being used. */
379:               PRIVILEGED_DATA static List_t * volatile pxOverflowDelayedTaskList;		/*< Points to the delayed task list currently being used to hold tasks that have overflowed the current tick count. */
380:               PRIVILEGED_DATA static List_t xPendingReadyList;						/*< Tasks that have been readied while the scheduler was suspended.  They will be moved to the ready list when the scheduler is resumed. */
381:               
382:               #if( INCLUDE_vTaskDelete == 1 )
383:               
384:               	PRIVILEGED_DATA static List_t xTasksWaitingTermination;				/*< Tasks that have been deleted - but their memory not yet freed. */
385:               	PRIVILEGED_DATA static volatile UBaseType_t uxDeletedTasksWaitingCleanUp = ( UBaseType_t ) 0U;
386:               
387:               #endif
388:               
389:               #if ( INCLUDE_vTaskSuspend == 1 )
390:               
391:               	PRIVILEGED_DATA static List_t xSuspendedTaskList;					/*< Tasks that are currently suspended. */
392:               
393:               #endif
394:               
395:               /* Other file private variables. --------------------------------*/
396:               PRIVILEGED_DATA static volatile UBaseType_t uxCurrentNumberOfTasks 	= ( UBaseType_t ) 0U;
397:               PRIVILEGED_DATA static volatile TickType_t xTickCount 				= ( TickType_t ) 0U;
398:               PRIVILEGED_DATA static volatile UBaseType_t uxTopReadyPriority 		= tskIDLE_PRIORITY;
399:               PRIVILEGED_DATA static volatile BaseType_t xSchedulerRunning 		= pdFALSE;
400:               PRIVILEGED_DATA static volatile UBaseType_t uxPendedTicks 			= ( UBaseType_t ) 0U;
401:               PRIVILEGED_DATA static volatile BaseType_t xYieldPending 			= pdFALSE;
402:               PRIVILEGED_DATA static volatile BaseType_t xNumOfOverflows 			= ( BaseType_t ) 0;
403:               PRIVILEGED_DATA static UBaseType_t uxTaskNumber 					= ( UBaseType_t ) 0U;
404:               PRIVILEGED_DATA static volatile TickType_t xNextTaskUnblockTime		= ( TickType_t ) 0U; /* Initialised to portMAX_DELAY before the scheduler starts. */
405:               PRIVILEGED_DATA static TaskHandle_t xIdleTaskHandle					= NULL;			/*< Holds the handle of the idle task.  The idle task is created automatically when the scheduler is started. */
406:               
407:               /* Context switches are held pending while the scheduler is suspended.  Also,
408:               interrupts must not manipulate the xStateListItem of a TCB, or any of the
409:               lists the xStateListItem can be referenced from, if the scheduler is suspended.
410:               If an interrupt needs to unblock a task while the scheduler is suspended then it
411:               moves the task's event list item into the xPendingReadyList, ready for the
412:               kernel to move the task from the pending ready list into the real ready list
413:               when the scheduler is unsuspended.  The pending ready list itself can only be
414:               accessed from a critical section. */
415:               PRIVILEGED_DATA static volatile UBaseType_t uxSchedulerSuspended	= ( UBaseType_t ) pdFALSE;
416:               
417:               #if ( configGENERATE_RUN_TIME_STATS == 1 )
418:               
419:               	PRIVILEGED_DATA static uint32_t ulTaskSwitchedInTime = 0UL;	/*< Holds the value of a timer/counter the last time a task was switched in. */
420:               	PRIVILEGED_DATA static uint32_t ulTotalRunTime = 0UL;		/*< Holds the total amount of execution time as defined by the run time counter clock. */
421:               
422:               #endif
423:               
424:               /*lint +e956 */
425:               
426:               /*-----------------------------------------------------------*/
427:               
428:               /* Callback function prototypes. --------------------------*/
429:               #if(  configCHECK_FOR_STACK_OVERFLOW > 0 )
430:               	extern void vApplicationStackOverflowHook( TaskHandle_t xTask, char *pcTaskName );
431:               #endif
432:               
433:               #if( configUSE_TICK_HOOK > 0 )
434:               	extern void vApplicationTickHook( void );
435:               #endif
436:               
437:               #if( configSUPPORT_STATIC_ALLOCATION == 1 )
438:               	extern void vApplicationGetIdleTaskMemory( StaticTask_t **ppxIdleTaskTCBBuffer, StackType_t **ppxIdleTaskStackBuffer, uint32_t *pulIdleTaskStackSize );
439:               #endif
440:               
441:               /* File private functions. --------------------------------*/
442:               
443:               /**
444:                * Utility task that simply returns pdTRUE if the task referenced by xTask is
445:                * currently in the Suspended state, or pdFALSE if the task referenced by xTask
446:                * is in any other state.
447:                */
448:               #if ( INCLUDE_vTaskSuspend == 1 )
449:               	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
450:               #endif /* INCLUDE_vTaskSuspend */
451:               
452:               /*
453:                * Utility to ready all the lists used by the scheduler.  This is called
454:                * automatically upon the creation of the first task.
455:                */
456:               static void prvInitialiseTaskLists( void ) PRIVILEGED_FUNCTION;
457:               
458:               /*
459:                * The idle task, which as all tasks is implemented as a never ending loop.
460:                * The idle task is automatically created and added to the ready lists upon
461:                * creation of the first user task.
462:                *
463:                * The portTASK_FUNCTION_PROTO() macro is used to allow port/compiler specific
464:                * language extensions.  The equivalent prototype for this function is:
465:                *
466:                * void prvIdleTask( void *pvParameters );
467:                *
468:                */
469:               static portTASK_FUNCTION_PROTO( prvIdleTask, pvParameters );
470:               
471:               /*
472:                * Utility to free all memory allocated by the scheduler to hold a TCB,
473:                * including the stack pointed to by the TCB.
474:                *
475:                * This does not free memory allocated by the task itself (i.e. memory
476:                * allocated by calls to pvPortMalloc from within the tasks application code).
477:                */
478:               #if ( INCLUDE_vTaskDelete == 1 )
479:               
480:               	static void prvDeleteTCB( TCB_t *pxTCB ) PRIVILEGED_FUNCTION;
481:               
482:               #endif
483:               
484:               /*
485:                * Used only by the idle task.  This checks to see if anything has been placed
486:                * in the list of tasks waiting to be deleted.  If so the task is cleaned up
487:                * and its TCB deleted.
488:                */
489:               static void prvCheckTasksWaitingTermination( void ) PRIVILEGED_FUNCTION;
490:               
491:               /*
492:                * The currently executing task is entering the Blocked state.  Add the task to
493:                * either the current or the overflow delayed task list.
494:                */
495:               static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely ) PRIVILEGED_FUNCTION;
496:               
497:               /*
498:                * Fills an TaskStatus_t structure with information on each task that is
499:                * referenced from the pxList list (which may be a ready list, a delayed list,
500:                * a suspended list, etc.).
501:                *
502:                * THIS FUNCTION IS INTENDED FOR DEBUGGING ONLY, AND SHOULD NOT BE CALLED FROM
503:                * NORMAL APPLICATION CODE.
504:                */
505:               #if ( configUSE_TRACE_FACILITY == 1 )
506:               
507:               	static UBaseType_t prvListTasksWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, eTaskState eState ) PRIVILEGED_FUNCTION;
508:               
509:               #endif
510:               
511:               /*
512:                * Searches pxList for a task with name pcNameToQuery - returning a handle to
513:                * the task if it is found, or NULL if the task is not found.
514:                */
515:               #if ( INCLUDE_xTaskGetHandle == 1 )
516:               
517:               	static TCB_t *prvSearchForNameWithinSingleList( List_t *pxList, const char pcNameToQuery[] ) PRIVILEGED_FUNCTION;
518:               
519:               #endif
520:               
521:               /*
522:                * When a task is created, the stack of the task is filled with a known value.
523:                * This function determines the 'high water mark' of the task stack by
524:                * determining how much of the stack remains at the original preset value.
525:                */
526:               #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
527:               
528:               	static uint16_t prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte ) PRIVILEGED_FUNCTION;
529:               
530:               #endif
531:               
532:               /*
533:                * Return the amount of time, in ticks, that will pass before the kernel will
534:                * next move a task from the Blocked state to the Running state.
535:                *
536:                * This conditional compilation should use inequality to 0, not equality to 1.
537:                * This is to ensure portSUPPRESS_TICKS_AND_SLEEP() can be called when user
538:                * defined low power mode implementations require configUSE_TICKLESS_IDLE to be
539:                * set to a value other than 1.
540:                */
541:               #if ( configUSE_TICKLESS_IDLE != 0 )
542:               
543:               	static TickType_t prvGetExpectedIdleTime( void ) PRIVILEGED_FUNCTION;
544:               
545:               #endif
546:               
547:               /*
548:                * Set xNextTaskUnblockTime to the time at which the next Blocked state task
549:                * will exit the Blocked state.
550:                */
551:               static void prvResetNextTaskUnblockTime( void );
552:               
553:               #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) )
554:               
555:               	/*
556:               	 * Helper function used to pad task names with spaces when printing out
557:               	 * human readable tables of task information.
558:               	 */
559:               	static char *prvWriteNameToBuffer( char *pcBuffer, const char *pcTaskName ) PRIVILEGED_FUNCTION;
560:               
561:               #endif
562:               
563:               /*
564:                * Called after a Task_t structure has been allocated either statically or
565:                * dynamically to fill in the structure's members.
566:                */
567:               static void prvInitialiseNewTask( 	TaskFunction_t pxTaskCode,
568:               									const char * const pcName,
569:               									const uint32_t ulStackDepth,
570:               									void * const pvParameters,
571:               									UBaseType_t uxPriority,
572:               									TaskHandle_t * const pxCreatedTask,
573:               									TCB_t *pxNewTCB,
574:               									const MemoryRegion_t * const xRegions ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
575:               
576:               /*
577:                * Called after a new task has been created and initialised to place the task
578:                * under the control of the scheduler.
579:                */
580:               static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB ) PRIVILEGED_FUNCTION;
581:               
582:               /*-----------------------------------------------------------*/
583:               
584:               #if( configSUPPORT_STATIC_ALLOCATION == 1 )
585:               
586:               	TaskHandle_t xTaskCreateStatic(	TaskFunction_t pxTaskCode,
587:               									const char * const pcName,
588:               									const uint32_t ulStackDepth,
589:               									void * const pvParameters,
590:               									UBaseType_t uxPriority,
591:               									StackType_t * const puxStackBuffer,
592:               									StaticTask_t * const pxTaskBuffer ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
593:               	{
594:               	TCB_t *pxNewTCB;
595:               	TaskHandle_t xReturn;
596:               
597:               		configASSERT( puxStackBuffer != NULL );
598:               		configASSERT( pxTaskBuffer != NULL );
599:               
600:               		if( ( pxTaskBuffer != NULL ) && ( puxStackBuffer != NULL ) )
601:               		{
602:               			/* The memory used for the task's TCB and stack are passed into this
603:               			function - use them. */
604:               			pxNewTCB = ( TCB_t * ) pxTaskBuffer; /*lint !e740 Unusual cast is ok as the structures are designed to have the same alignment, and the size is checked by an assert. */
605:               			pxNewTCB->pxStack = ( StackType_t * ) puxStackBuffer;
606:               
607:               			#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 )
608:               			{
609:               				/* Tasks can be created statically or dynamically, so note this
610:               				task was created statically in case the task is later deleted. */
611:               				pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;
612:               			}
613:               			#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
614:               
615:               			prvInitialiseNewTask( pxTaskCode, pcName, ulStackDepth, pvParameters, uxPriority, &xReturn, pxNewTCB, NULL );
616:               			prvAddNewTaskToReadyList( pxNewTCB );
617:               		}
618:               		else
619:               		{
620:               			xReturn = NULL;
621:               		}
622:               
623:               		return xReturn;
624:               	}
625:               
626:               #endif /* SUPPORT_STATIC_ALLOCATION */
627:               /*-----------------------------------------------------------*/
628:               
629:               #if( portUSING_MPU_WRAPPERS == 1 )
630:               
631:               	BaseType_t xTaskCreateRestricted( const TaskParameters_t * const pxTaskDefinition, TaskHandle_t *pxCreatedTask )
632:               	{
633:               	TCB_t *pxNewTCB;
634:               	BaseType_t xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
635:               
636:               		configASSERT( pxTaskDefinition->puxStackBuffer );
637:               
638:               		if( pxTaskDefinition->puxStackBuffer != NULL )
639:               		{
640:               			/* Allocate space for the TCB.  Where the memory comes from depends
641:               			on the implementation of the port malloc function and whether or
642:               			not static allocation is being used. */
643:               			pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
644:               
645:               			if( pxNewTCB != NULL )
646:               			{
647:               				/* Store the stack location in the TCB. */
648:               				pxNewTCB->pxStack = pxTaskDefinition->puxStackBuffer;
649:               
650:               				/* Tasks can be created statically or dynamically, so note
651:               				this task had a statically allocated stack in case it is
652:               				later deleted.  The TCB was allocated dynamically. */
653:               				pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_ONLY;
654:               
655:               				prvInitialiseNewTask(	pxTaskDefinition->pvTaskCode,
656:               										pxTaskDefinition->pcName,
657:               										( uint32_t ) pxTaskDefinition->usStackDepth,
658:               										pxTaskDefinition->pvParameters,
659:               										pxTaskDefinition->uxPriority,
660:               										pxCreatedTask, pxNewTCB,
661:               										pxTaskDefinition->xRegions );
662:               
663:               				prvAddNewTaskToReadyList( pxNewTCB );
664:               				xReturn = pdPASS;
665:               			}
666:               		}
667:               
668:               		return xReturn;
669:               	}
670:               
671:               #endif /* portUSING_MPU_WRAPPERS */
672:               /*-----------------------------------------------------------*/
673:               
674:               #if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
675:               
676:               	BaseType_t xTaskCreate(	TaskFunction_t pxTaskCode,
677:               							const char * const pcName,
678:               							const uint16_t usStackDepth,
679:               							void * const pvParameters,
680:               							UBaseType_t uxPriority,
681:               							TaskHandle_t * const pxCreatedTask ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
682:               	{
0010E8  FA0010     LNK #0x10
0010EA  980720     MOV W0, [W14+4]
0010EC  980731     MOV W1, [W14+6]
0010EE  980742     MOV W2, [W14+8]
0010F0  980753     MOV W3, [W14+10]
0010F2  980764     MOV W4, [W14+12]
0010F4  980775     MOV W5, [W14+14]
683:               	TCB_t *pxNewTCB;
684:               	BaseType_t xReturn;
685:               
686:               		/* If the stack grows down then allocate the stack then the TCB so the stack
687:               		does not grow into the TCB.  Likewise if the stack grows up then allocate
688:               		the TCB then the stack. */
689:               		#if( portSTACK_GROWTH > 0 )
690:               		{
691:               			/* Allocate space for the TCB.  Where the memory comes from depends on
692:               			the implementation of the port malloc function and whether or not static
693:               			allocation is being used. */
694:               			pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
0010F6  200260     MOV #0x26, W0
0010F8  023C80     CALL pvPortMalloc
0010FA  000000     NOP
0010FC  780F00     MOV W0, [W14]
695:               
696:               			if( pxNewTCB != NULL )
0010FE  78001E     MOV [W14], W0
001100  E00000     CP0 W0
001102  320010     BRA Z, .L2
697:               			{
698:               				/* Allocate space for the stack used by the task being created.
699:               				The base of the stack memory stored in the TCB so the task can
700:               				be deleted later if required. */
701:               				pxNewTCB->pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
001104  90004E     MOV [W14+8], W0
001106  400000     ADD W0, W0, W0
001108  023C80     CALL pvPortMalloc
00110A  000000     NOP
00110C  780080     MOV W0, W1
00110E  78001E     MOV [W14], W0
001110  980841     MOV W1, [W0+24]
702:               
703:               				if( pxNewTCB->pxStack == NULL )
001112  78001E     MOV [W14], W0
001114  900840     MOV [W0+24], W0
001116  E00000     CP0 W0
001118  3A0005     BRA NZ, .L2
704:               				{
705:               					/* Could not allocate the stack.  Delete the allocated TCB. */
706:               					vPortFree( pxNewTCB );
00111A  78001E     MOV [W14], W0
00111C  023D68     CALL vPortFree
00111E  000000     NOP
707:               					pxNewTCB = NULL;
001120  EB0000     CLR W0
001122  780F00     MOV W0, [W14]
708:               				}
709:               			}
710:               		}
711:               		#else /* portSTACK_GROWTH */
712:               		{
713:               		StackType_t *pxStack;
714:               
715:               			/* Allocate space for the stack used by the task being created. */
716:               			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
717:               
718:               			if( pxStack != NULL )
719:               			{
720:               				/* Allocate space for the TCB. */
721:               				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e961 MISRA exception as the casts are only redundant for some paths. */
722:               
723:               				if( pxNewTCB != NULL )
724:               				{
725:               					/* Store the stack location in the TCB. */
726:               					pxNewTCB->pxStack = pxStack;
727:               				}
728:               				else
729:               				{
730:               					/* The stack cannot be used as the TCB was not created.  Free
731:               					it again. */
732:               					vPortFree( pxStack );
733:               				}
734:               			}
735:               			else
736:               			{
737:               				pxNewTCB = NULL;
738:               			}
739:               		}
740:               		#endif /* portSTACK_GROWTH */
741:               
742:               		if( pxNewTCB != NULL )
001124  78001E     MOV [W14], W0
001126  E00000     CP0 W0
001128  320012     BRA Z, .L3
743:               		{
744:               			#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 )
745:               			{
746:               				/* Tasks can be created statically or dynamically, so note this
747:               				task was created dynamically in case it is later deleted. */
748:               				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
749:               			}
750:               			#endif /* configSUPPORT_STATIC_ALLOCATION */
751:               
752:               			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
00112A  90004E     MOV [W14+8], W0
00112C  EB0080     CLR W1
00112E  EB0100     CLR W2
001130  781F82     MOV W2, [W15++]
001132  78039E     MOV [W14], W7
001134  90037E     MOV [W14+14], W6
001136  9002EE     MOV [W14+12], W5
001138  90025E     MOV [W14+10], W4
00113A  BE0100     MOV.D W0, W2
00113C  9000BE     MOV [W14+6], W1
00113E  90002E     MOV [W14+4], W0
001140  07000B     RCALL prvInitialiseNewTask
001142  E9878F     DEC2 W15, W15
753:               			prvAddNewTaskToReadyList( pxNewTCB );
001144  78001E     MOV [W14], W0
001146  07006F     RCALL prvAddNewTaskToReadyList
754:               			xReturn = pdPASS;
001148  200010     MOV #0x1, W0
00114A  980710     MOV W0, [W14+2]
00114C  370002     BRA .L4
755:               		}
756:               		else
757:               		{
758:               			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
00114E  EB8000     SETM W0
001150  980710     MOV W0, [W14+2]
759:               		}
760:               
761:               		return xReturn;
001152  90001E     MOV [W14+2], W0
762:               	}
001154  FA8000     ULNK
001156  060000     RETURN
763:               
764:               #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
765:               /*-----------------------------------------------------------*/
766:               
767:               static void prvInitialiseNewTask( 	TaskFunction_t pxTaskCode,
768:               									const char * const pcName,
769:               									const uint32_t ulStackDepth,
770:               									void * const pvParameters,
771:               									UBaseType_t uxPriority,
772:               									TaskHandle_t * const pxCreatedTask,
773:               									TCB_t *pxNewTCB,
774:               									const MemoryRegion_t * const xRegions ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
775:               {
001158  FA0014     LNK #0x14
00115A  980720     MOV W0, [W14+4]
00115C  980731     MOV W1, [W14+6]
00115E  980742     MOV W2, [W14+8]
001160  980753     MOV W3, [W14+10]
001162  980764     MOV W4, [W14+12]
001164  980775     MOV W5, [W14+14]
001166  980F06     MOV W6, [W14+16]
001168  980F17     MOV W7, [W14+18]
776:               StackType_t *pxTopOfStack;
777:               UBaseType_t x;
778:               
779:               	#if( portUSING_MPU_WRAPPERS == 1 )
780:               		/* Should the task be created in privileged mode? */
781:               		BaseType_t xRunPrivileged;
782:               		if( ( uxPriority & portPRIVILEGE_BIT ) != 0U )
783:               		{
784:               			xRunPrivileged = pdTRUE;
785:               		}
786:               		else
787:               		{
788:               			xRunPrivileged = pdFALSE;
789:               		}
790:               		uxPriority &= ~portPRIVILEGE_BIT;
791:               	#endif /* portUSING_MPU_WRAPPERS == 1 */
792:               
793:               	/* Avoid dependency on memset() if it is not required. */
794:               	#if( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
795:               	{
796:               		/* Fill the stack with a known value to assist debugging. */
797:               		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
00116A  90004E     MOV [W14+8], W0
00116C  400000     ADD W0, W0, W0
00116E  780080     MOV W0, W1
001170  90081E     MOV [W14+18], W0
001172  900840     MOV [W0+24], W0
001174  780101     MOV W1, W2
001176  200A51     MOV #0xA5, W1
001178  020EAC     CALL _memset
00117A  000000     NOP
798:               	}
799:               	#endif /* ( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) ) ) */
800:               
801:               	/* Calculate the top of stack address.  This depends on whether the stack
802:               	grows from high memory to low (as per the 80x86) or vice versa.
803:               	portSTACK_GROWTH is used to make the result positive or negative as required
804:               	by the port. */
805:               	#if( portSTACK_GROWTH < 0 )
806:               	{
807:               		pxTopOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
808:               		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type. */
809:               
810:               		/* Check the alignment of the calculated top of stack is correct. */
811:               		configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack & ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
812:               	}
813:               	#else /* portSTACK_GROWTH */
814:               	{
815:               		pxTopOfStack = pxNewTCB->pxStack;
00117C  90081E     MOV [W14+18], W0
00117E  9008C0     MOV [W0+24], W1
001180  980711     MOV W1, [W14+2]
816:               
817:               		/* Check the alignment of the stack buffer is correct. */
818:               		configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxNewTCB->pxStack & ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
819:               
820:               		/* The other extreme of the stack space is required if stack checking is
821:               		performed. */
822:               		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
001182  90081E     MOV [W14+18], W0
001184  9008C0     MOV [W0+24], W1
001186  90014E     MOV [W14+8], W2
001188  27FFF0     MOV #0x7FFF, W0
00118A  410000     ADD W2, W0, W0
00118C  400000     ADD W0, W0, W0
00118E  408080     ADD W1, W0, W1
001190  90081E     MOV [W14+18], W0
001192  980871     MOV W1, [W0+30]
823:               	}
824:               	#endif /* portSTACK_GROWTH */
825:               
826:               	/* Store the task name in the TCB. */
827:               	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
001194  EB0000     CLR W0
001196  780F00     MOV W0, [W14]
001198  37000D     BRA .L6
0011B2  E80F1E     INC [W14], [W14]
0011B4  78001E     MOV [W14], W0
0011B6  500FE3     SUB W0, #0x3, [W15]
0011B8  36FFF0     BRA LEU, .L9
0011BA  370001     BRA .L8
828:               	{
829:               		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
00119A  90003E     MOV [W14+6], W0
00119C  40001E     ADD W0, [W14], W0
00119E  784090     MOV.B [W0], W1
0011A0  90081E     MOV [W14+18], W0
0011A2  40001E     ADD W0, [W14], W0
0011A4  40007A     ADD W0, #0x1A, W0
0011A6  784801     MOV.B W1, [W0]
830:               
831:               		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
832:               		configMAX_TASK_NAME_LEN characters just in case the memory after the
833:               		string is not accessible (extremely unlikely). */
834:               		if( pcName[ x ] == 0x00 )
0011A8  90003E     MOV [W14+6], W0
0011AA  40001E     ADD W0, [W14], W0
0011AC  784010     MOV.B [W0], W0
0011AE  E00400     CP0.B W0
0011B0  320005     BRA Z, .L12
835:               		{
836:               			break;
0011BC  000000     NOP
837:               		}
838:               		else
839:               		{
840:               			mtCOVERAGE_TEST_MARKER();
841:               		}
842:               	}
843:               
844:               	/* Ensure the name string is terminated in the case that the string length
845:               	was greater or equal to configMAX_TASK_NAME_LEN. */
846:               	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
0011BE  90081E     MOV [W14+18], W0
0011C0  EB4080     CLR.B W1
0011C2  985851     MOV.B W1, [W0+29]
847:               
848:               	/* This is used as an array index so must ensure it's not too large.  First
849:               	remove the privilege bit if one is present. */
850:               	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
0011C4  90007E     MOV [W14+14], W0
0011C6  500FE3     SUB W0, #0x3, [W15]
0011C8  360002     BRA LEU, .L10
851:               	{
852:               		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
0011CA  200030     MOV #0x3, W0
0011CC  980770     MOV W0, [W14+14]
853:               	}
854:               	else
855:               	{
856:               		mtCOVERAGE_TEST_MARKER();
857:               	}
858:               
859:               	pxNewTCB->uxPriority = uxPriority;
0011CE  90081E     MOV [W14+18], W0
0011D0  9000FE     MOV [W14+14], W1
0011D2  980831     MOV W1, [W0+22]
860:               	#if ( configUSE_MUTEXES == 1 )
861:               	{
862:               		pxNewTCB->uxBasePriority = uxPriority;
863:               		pxNewTCB->uxMutexesHeld = 0;
864:               	}
865:               	#endif /* configUSE_MUTEXES */
866:               
867:               	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
0011D4  90081E     MOV [W14+18], W0
0011D6  E88000     INC2 W0, W0
0011D8  024942     CALL vListInitialiseItem
0011DA  000000     NOP
868:               	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
0011DC  90081E     MOV [W14+18], W0
0011DE  40006C     ADD W0, #0xC, W0
0011E0  024942     CALL vListInitialiseItem
0011E2  000000     NOP
869:               
870:               	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
871:               	back to	the containing TCB from a generic item in a list. */
872:               	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
0011E4  90081E     MOV [W14+18], W0
0011E6  90089E     MOV [W14+18], W1
0011E8  980041     MOV W1, [W0+8]
873:               
874:               	/* Event lists are always in priority order. */
875:               	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
0011EA  90007E     MOV [W14+14], W0
0011EC  1000E4     SUBR W0, #0x4, W1
0011EE  90081E     MOV [W14+18], W0
0011F0  980061     MOV W1, [W0+12]
876:               	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
0011F2  90081E     MOV [W14+18], W0
0011F4  90089E     MOV [W14+18], W1
0011F6  980811     MOV W1, [W0+18]
877:               
878:               	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
879:               	{
880:               		pxNewTCB->uxCriticalNesting = ( UBaseType_t ) 0U;
881:               	}
882:               	#endif /* portCRITICAL_NESTING_IN_TCB */
883:               
884:               	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
885:               	{
886:               		pxNewTCB->pxTaskTag = NULL;
887:               	}
888:               	#endif /* configUSE_APPLICATION_TASK_TAG */
889:               
890:               	#if ( configGENERATE_RUN_TIME_STATS == 1 )
891:               	{
892:               		pxNewTCB->ulRunTimeCounter = 0UL;
893:               	}
894:               	#endif /* configGENERATE_RUN_TIME_STATS */
895:               
896:               	#if ( portUSING_MPU_WRAPPERS == 1 )
897:               	{
898:               		vPortStoreTaskMPUSettings( &( pxNewTCB->xMPUSettings ), xRegions, pxNewTCB->pxStack, ulStackDepth );
899:               	}
900:               	#else
901:               	{
902:               		/* Avoid compiler warning about unreferenced parameter. */
903:               		( void ) xRegions;
904:               	}
905:               	#endif
906:               
907:               	#if( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
908:               	{
909:               		for( x = 0; x < ( UBaseType_t ) configNUM_THREAD_LOCAL_STORAGE_POINTERS; x++ )
910:               		{
911:               			pxNewTCB->pvThreadLocalStoragePointers[ x ] = NULL;
912:               		}
913:               	}
914:               	#endif
915:               
916:               	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
917:               	{
918:               		pxNewTCB->ulNotifiedValue = 0;
0011F8  90091E     MOV [W14+18], W2
0011FA  B80060     MUL.UU W0, #0, W0
0011FC  981100     MOV W0, [W2+32]
0011FE  981111     MOV W1, [W2+34]
919:               		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
001200  90081E     MOV [W14+18], W0
001202  EB4080     CLR.B W1
001204  986041     MOV.B W1, [W0+36]
920:               	}
921:               	#endif
922:               
923:               	#if ( configUSE_NEWLIB_REENTRANT == 1 )
924:               	{
925:               		/* Initialise this task's Newlib reent structure. */
926:               		_REENT_INIT_PTR( ( &( pxNewTCB->xNewLib_reent ) ) );
927:               	}
928:               	#endif
929:               
930:               	#if( INCLUDE_xTaskAbortDelay == 1 )
931:               	{
932:               		pxNewTCB->ucDelayAborted = pdFALSE;
933:               	}
934:               	#endif
935:               
936:               	/* Initialize the TCB stack to look as if the task was already running,
937:               	but had been interrupted by the scheduler.  The return address is set
938:               	to the start of the task function. Once the stack has been initialised
939:               	the	top of stack variable is updated. */
940:               	#if( portUSING_MPU_WRAPPERS == 1 )
941:               	{
942:               		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
943:               	}
944:               	#else /* portUSING_MPU_WRAPPERS */
945:               	{
946:               		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
001206  90016E     MOV [W14+12], W2
001208  9000AE     MOV [W14+4], W1
00120A  90001E     MOV [W14+2], W0
00120C  0247E0     CALL pxPortInitialiseStack
00120E  000000     NOP
001210  780080     MOV W0, W1
001212  90081E     MOV [W14+18], W0
001214  780801     MOV W1, [W0]
947:               	}
948:               	#endif /* portUSING_MPU_WRAPPERS */
949:               
950:               	if( ( void * ) pxCreatedTask != NULL )
001216  90080E     MOV [W14+16], W0
001218  E00000     CP0 W0
00121A  320003     BRA Z, .L5
951:               	{
952:               		/* Pass the handle out in an anonymous way.  The handle can be used to
953:               		change the created task's priority, delete the created task, etc.*/
954:               		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
00121C  90080E     MOV [W14+16], W0
00121E  90089E     MOV [W14+18], W1
001220  780801     MOV W1, [W0]
955:               	}
956:               	else
957:               	{
958:               		mtCOVERAGE_TEST_MARKER();
959:               	}
960:               }
001222  FA8000     ULNK
001224  060000     RETURN
961:               /*-----------------------------------------------------------*/
962:               
963:               static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
964:               {
001226  FA0002     LNK #0x2
001228  780F00     MOV W0, [W14]
965:               	/* Ensure interrupts don't access the task lists while the lists are being
966:               	updated. */
967:               	taskENTER_CRITICAL();
00122A  0248DA     CALL vPortEnterCritical
00122C  000000     NOP
968:               	{
969:               		uxCurrentNumberOfTasks++;
00122E  8042C0     MOV uxCurrentNumberOfTasks, W0
001230  E80000     INC W0, W0
001232  8842C0     MOV W0, uxCurrentNumberOfTasks
970:               		if( pxCurrentTCB == NULL )
001234  804280     MOV pxCurrentTCB, W0
001236  E00000     CP0 W0
001238  3A0007     BRA NZ, .L14
971:               		{
972:               			/* There are no other tasks, or all the other tasks are in
973:               			the suspended state - make this the current task. */
974:               			pxCurrentTCB = pxNewTCB;
00123A  78009E     MOV [W14], W1
00123C  884281     MOV W1, pxCurrentTCB
975:               
976:               			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
00123E  8042C0     MOV uxCurrentNumberOfTasks, W0
001240  500FE1     SUB W0, #0x1, [W15]
977:               			{
978:               				/* This is the first task to be created so do the preliminary
979:               				initialisation required.  We will not recover if this call
980:               				fails, but we will report the failure. */
981:               				prvInitialiseTaskLists();
001242  3A000D     BRA NZ, .L15
001244  07042F     RCALL prvInitialiseTaskLists
001246  37000B     BRA .L15
982:               			}
983:               			else
984:               			{
985:               				mtCOVERAGE_TEST_MARKER();
986:               			}
987:               		}
988:               		else
989:               		{
990:               			/* If the scheduler is not already running, make this task the
991:               			current task if it is the highest priority task to be created
992:               			so far. */
993:               			if( xSchedulerRunning == pdFALSE )
001248  8042F0     MOV xSchedulerRunning, W0
00124A  E00000     CP0 W0
00124C  3A0008     BRA NZ, .L15
994:               			{
995:               				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
00124E  804280     MOV pxCurrentTCB, W0
001250  9008B0     MOV [W0+22], W1
001252  78001E     MOV [W14], W0
001254  900830     MOV [W0+22], W0
001256  508F80     SUB W1, W0, [W15]
001258  3E0002     BRA GTU, .L15
996:               				{
997:               					pxCurrentTCB = pxNewTCB;
00125A  78009E     MOV [W14], W1
00125C  884281     MOV W1, pxCurrentTCB
998:               				}
999:               				else
1000:              				{
1001:              					mtCOVERAGE_TEST_MARKER();
1002:              				}
1003:              			}
1004:              			else
1005:              			{
1006:              				mtCOVERAGE_TEST_MARKER();
1007:              			}
1008:              		}
1009:              
1010:              		uxTaskNumber++;
00125E  804330     MOV uxTaskNumber, W0
001260  E80000     INC W0, W0
001262  884330     MOV W0, uxTaskNumber
1011:              
1012:              		#if ( configUSE_TRACE_FACILITY == 1 )
1013:              		{
1014:              			/* Add a counter into the TCB for tracing only. */
1015:              			pxNewTCB->uxTCBNumber = uxTaskNumber;
1016:              		}
1017:              		#endif /* configUSE_TRACE_FACILITY */
1018:              		traceTASK_CREATE( pxNewTCB );
1019:              
1020:              		prvAddTaskToReadyList( pxNewTCB );
001264  78001E     MOV [W14], W0
001266  9008B0     MOV [W0+22], W1
001268  8042E0     MOV uxTopReadyPriority, W0
00126A  508F80     SUB W1, W0, [W15]
00126C  360003     BRA LEU, .L16
00126E  78001E     MOV [W14], W0
001270  900830     MOV [W0+22], W0
001272  8842E0     MOV W0, uxTopReadyPriority
001274  E8811E     INC2 [W14], W2
001276  78001E     MOV [W14], W0
001278  900830     MOV [W0+22], W0
00127A  B9006A     MUL.SU W0, #10, W0
00127C  780080     MOV W0, W1
00127E  21CB40     MOV #0x1CB4, W0
001280  408000     ADD W1, W0, W0
001282  780082     MOV W2, W1
001284  024950     CALL vListInsertEnd
001286  000000     NOP
1021:              
1022:              		portSETUP_TCB( pxNewTCB );
1023:              	}
1024:              	taskEXIT_CRITICAL();
001288  0248F4     CALL vPortExitCritical
00128A  000000     NOP
1025:              
1026:              	if( xSchedulerRunning != pdFALSE )
00128C  8042F0     MOV xSchedulerRunning, W0
00128E  E00000     CP0 W0
001290  320009     BRA Z, .L13
1027:              	{
1028:              		/* If the created task is of a higher priority than the current task
1029:              		then it should run now. */
1030:              		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
001292  804280     MOV pxCurrentTCB, W0
001294  9008B0     MOV [W0+22], W1
001296  78001E     MOV [W14], W0
001298  900830     MOV [W0+22], W0
00129A  508F80     SUB W1, W0, [W15]
00129C  310003     BRA C, .L13
1031:              		{
1032:              			taskYIELD_IF_USING_PREEMPTION();
00129E  0250DC     CALL .Letext0, .LFE1, _vPortYield
0012A0  000000     NOP
0012A2  000000     NOP
1033:              		}
1034:              		else
1035:              		{
1036:              			mtCOVERAGE_TEST_MARKER();
1037:              		}
1038:              	}
1039:              	else
1040:              	{
1041:              		mtCOVERAGE_TEST_MARKER();
1042:              	}
1043:              }
0012A4  FA8000     ULNK
0012A6  060000     RETURN
1044:              /*-----------------------------------------------------------*/
1045:              
1046:              #if ( INCLUDE_vTaskDelete == 1 )
1047:              
1048:              	void vTaskDelete( TaskHandle_t xTaskToDelete )
1049:              	{
0012A8  FA0004     LNK #0x4
0012AA  980710     MOV W0, [W14+2]
1050:              	TCB_t *pxTCB;
1051:              
1052:              		taskENTER_CRITICAL();
0012AC  0248DA     CALL vPortEnterCritical
0012AE  000000     NOP
1053:              		{
1054:              			/* If null is passed in here then it is the calling task that is
1055:              			being deleted. */
1056:              			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
0012B0  90001E     MOV [W14+2], W0
0012B2  E00000     CP0 W0
0012B4  3A0002     BRA NZ, .L19
0012B6  804280     MOV pxCurrentTCB, W0
0012B8  370001     BRA .L20
0012BA  90001E     MOV [W14+2], W0
0012BC  780F00     MOV W0, [W14]
1057:              
1058:              			/* Remove task from the ready list. */
1059:              			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
0012BE  E8801E     INC2 [W14], W0
0012C0  0249F0     CALL uxListRemove
0012C2  000000     NOP
1060:              			{
1061:              				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
1062:              			}
1063:              			else
1064:              			{
1065:              				mtCOVERAGE_TEST_MARKER();
1066:              			}
1067:              
1068:              			/* Is the task waiting on an event also? */
1069:              			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
0012C4  78001E     MOV [W14], W0
0012C6  900820     MOV [W0+20], W0
0012C8  E00000     CP0 W0
0012CA  320004     BRA Z, .L21
1070:              			{
1071:              				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
0012CC  78009E     MOV [W14], W1
0012CE  40806C     ADD W1, #0xC, W0
0012D0  0249F0     CALL uxListRemove
0012D2  000000     NOP
1072:              			}
1073:              			else
1074:              			{
1075:              				mtCOVERAGE_TEST_MARKER();
1076:              			}
1077:              
1078:              			/* Increment the uxTaskNumber also so kernel aware debuggers can
1079:              			detect that the task lists need re-generating.  This is done before
1080:              			portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
1081:              			not return. */
1082:              			uxTaskNumber++;
0012D4  804330     MOV uxTaskNumber, W0
0012D6  E80000     INC W0, W0
0012D8  884330     MOV W0, uxTaskNumber
1083:              
1084:              			if( pxTCB == pxCurrentTCB )
0012DA  804280     MOV pxCurrentTCB, W0
0012DC  78009E     MOV [W14], W1
0012DE  508F80     SUB W1, W0, [W15]
0012E0  3A0009     BRA NZ, .L22
1085:              			{
1086:              				/* A task is deleting itself.  This cannot complete within the
1087:              				task itself, as a context switch to another task is required.
1088:              				Place the task in the termination list.  The idle task will
1089:              				check the termination list and free up any memory allocated by
1090:              				the scheduler for the TCB and stack of the deleted task. */
1091:              				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
0012E2  E8801E     INC2 [W14], W0
0012E4  780080     MOV W0, W1
0012E6  21CFA0     MOV #0x1CFA, W0
0012E8  024950     CALL vListInsertEnd
0012EA  000000     NOP
1092:              
1093:              				/* Increment the ucTasksDeleted variable so the idle task knows
1094:              				there is a task that has been deleted and that it should therefore
1095:              				check the xTasksWaitingTermination list. */
1096:              				++uxDeletedTasksWaitingCleanUp;
0012EC  8042B0     MOV uxDeletedTasksWaitingCleanUp, W0
0012EE  E80000     INC W0, W0
0012F0  8842B0     MOV W0, uxDeletedTasksWaitingCleanUp
0012F2  370006     BRA .L23
1097:              
1098:              				/* The pre-delete hook is primarily for the Windows simulator,
1099:              				in which Windows specific clean up operations are performed,
1100:              				after which it is not possible to yield away from this task -
1101:              				hence xYieldPending is used to latch that a context switch is
1102:              				required. */
1103:              				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
1104:              			}
1105:              			else
1106:              			{
1107:              				--uxCurrentNumberOfTasks;
0012F4  8042C0     MOV uxCurrentNumberOfTasks, W0
0012F6  E90000     DEC W0, W0
0012F8  8842C0     MOV W0, uxCurrentNumberOfTasks
1108:              				prvDeleteTCB( pxTCB );
0012FA  78001E     MOV [W14], W0
1109:              
1110:              				/* Reset the next expected unblock time in case it referred to
1111:              				the task that has just been deleted. */
1112:              				prvResetNextTaskUnblockTime();
0012FC  07041D     RCALL prvDeleteTCB
0012FE  070427     RCALL prvResetNextTaskUnblockTime
1113:              			}
1114:              
1115:              			traceTASK_DELETE( pxTCB );
1116:              		}
1117:              		taskEXIT_CRITICAL();
001300  0248F4     CALL vPortExitCritical
001302  000000     NOP
1118:              
1119:              		/* Force a reschedule if it is the currently running task that has just
1120:              		been deleted. */
1121:              		if( xSchedulerRunning != pdFALSE )
001304  8042F0     MOV xSchedulerRunning, W0
001306  E00000     CP0 W0
001308  320007     BRA Z, .L18
1122:              		{
1123:              			if( pxTCB == pxCurrentTCB )
00130A  804280     MOV pxCurrentTCB, W0
00130C  78009E     MOV [W14], W1
00130E  508F80     SUB W1, W0, [W15]
001310  3A0003     BRA NZ, .L18
1124:              			{
1125:              				configASSERT( uxSchedulerSuspended == 0 );
1126:              				portYIELD_WITHIN_API();
001312  0250DC     CALL .Letext0, .LFE1, _vPortYield
001314  000000     NOP
001316  000000     NOP
1127:              			}
1128:              			else
1129:              			{
1130:              				mtCOVERAGE_TEST_MARKER();
1131:              			}
1132:              		}
1133:              	}
001318  FA8000     ULNK
00131A  060000     RETURN
1134:              
1135:              #endif /* INCLUDE_vTaskDelete */
1136:              /*-----------------------------------------------------------*/
1137:              
1138:              #if ( INCLUDE_vTaskDelayUntil == 1 )
1139:              
1140:              	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
1141:              	{
00131C  FA000C     LNK #0xC
00131E  980740     MOV W0, [W14+8]
001320  980751     MOV W1, [W14+10]
1142:              	TickType_t xTimeToWake;
1143:              	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
001322  EB0000     CLR W0
1144:              
1145:              		configASSERT( pxPreviousWakeTime );
1146:              		configASSERT( ( xTimeIncrement > 0U ) );
1147:              		configASSERT( uxSchedulerSuspended == 0 );
1148:              
1149:              		vTaskSuspendAll();
001324  780F00     MOV W0, [W14]
001326  07019B     RCALL vTaskSuspendAll
1150:              		{
1151:              			/* Minor optimisation.  The tick count cannot change in this
1152:              			block. */
1153:              			const TickType_t xConstTickCount = xTickCount;
001328  8042D1     MOV xTickCount, W1
00132A  980711     MOV W1, [W14+2]
1154:              
1155:              			/* Generate the tick time at which the task wants to wake. */
1156:              			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
00132C  90004E     MOV [W14+8], W0
00132E  780090     MOV [W0], W1
001330  90005E     MOV [W14+10], W0
001332  408000     ADD W1, W0, W0
001334  980720     MOV W0, [W14+4]
1157:              
1158:              			if( xConstTickCount < *pxPreviousWakeTime )
001336  90004E     MOV [W14+8], W0
001338  780090     MOV [W0], W1
00133A  90001E     MOV [W14+2], W0
00133C  508F80     SUB W1, W0, [W15]
00133E  36000C     BRA LEU, .L26
1159:              			{
1160:              				/* The tick count has overflowed since this function was
1161:              				lasted called.  In this case the only time we should ever
1162:              				actually delay is if the wake time has also	overflowed,
1163:              				and the wake time is greater than the tick time.  When this
1164:              				is the case it is as if neither time had overflowed. */
1165:              				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
001340  90004E     MOV [W14+8], W0
001342  780090     MOV [W0], W1
001344  90002E     MOV [W14+4], W0
001346  508F80     SUB W1, W0, [W15]
001348  360012     BRA LEU, .L27
00134A  9000AE     MOV [W14+4], W1
00134C  90001E     MOV [W14+2], W0
00134E  508F80     SUB W1, W0, [W15]
001350  36000E     BRA LEU, .L27
1166:              				{
1167:              					xShouldDelay = pdTRUE;
001352  200010     MOV #0x1, W0
001354  780F00     MOV W0, [W14]
001356  37000B     BRA .L27
1168:              				}
1169:              				else
1170:              				{
1171:              					mtCOVERAGE_TEST_MARKER();
1172:              				}
1173:              			}
1174:              			else
1175:              			{
1176:              				/* The tick time has not overflowed.  In this case we will
1177:              				delay if either the wake time has overflowed, and/or the
1178:              				tick time is less than the wake time. */
1179:              				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
001358  90004E     MOV [W14+8], W0
00135A  780090     MOV [W0], W1
00135C  90002E     MOV [W14+4], W0
00135E  508F80     SUB W1, W0, [W15]
001360  3E0004     BRA GTU, .L28
001362  9000AE     MOV [W14+4], W1
001364  90001E     MOV [W14+2], W0
001366  508F80     SUB W1, W0, [W15]
001368  360002     BRA LEU, .L27
1180:              				{
1181:              					xShouldDelay = pdTRUE;
00136A  200010     MOV #0x1, W0
00136C  780F00     MOV W0, [W14]
1182:              				}
1183:              				else
1184:              				{
1185:              					mtCOVERAGE_TEST_MARKER();
1186:              				}
1187:              			}
1188:              
1189:              			/* Update the wake time ready for the next call. */
1190:              			*pxPreviousWakeTime = xTimeToWake;
00136E  90004E     MOV [W14+8], W0
001370  9000AE     MOV [W14+4], W1
001372  780801     MOV W1, [W0]
1191:              
1192:              			if( xShouldDelay != pdFALSE )
001374  78001E     MOV [W14], W0
001376  E00000     CP0 W0
001378  320005     BRA Z, .L29, .LBE2
1193:              			{
1194:              				traceTASK_DELAY_UNTIL( xTimeToWake );
1195:              
1196:              				/* prvAddCurrentTaskToDelayedList() needs the block time, not
1197:              				the time to wake, so subtract the current tick count. */
1198:              				prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
00137A  9000AE     MOV [W14+4], W1
00137C  90001E     MOV [W14+2], W0
00137E  508000     SUB W1, W0, W0
001380  EB0080     CLR W1
1199:              			}
1200:              			else
1201:              			{
1202:              				mtCOVERAGE_TEST_MARKER();
1203:              			}
1204:              		}
1205:              		xAlreadyYielded = xTaskResumeAll();
001382  070601     RCALL prvAddCurrentTaskToDelayedList
001384  070172     RCALL xTaskResumeAll
001386  980730     MOV W0, [W14+6]
1206:              
1207:              		/* Force a reschedule if xTaskResumeAll has not already done so, we may
1208:              		have put ourselves to sleep. */
1209:              		if( xAlreadyYielded == pdFALSE )
001388  90003E     MOV [W14+6], W0
00138A  E00000     CP0 W0
00138C  3A0003     BRA NZ, .L25
1210:              		{
1211:              			portYIELD_WITHIN_API();
00138E  0250DC     CALL .Letext0, .LFE1, _vPortYield
001390  000000     NOP
001392  000000     NOP
1212:              		}
1213:              		else
1214:              		{
1215:              			mtCOVERAGE_TEST_MARKER();
1216:              		}
1217:              	}
001394  FA8000     ULNK
001396  060000     RETURN
1218:              
1219:              #endif /* INCLUDE_vTaskDelayUntil */
1220:              /*-----------------------------------------------------------*/
1221:              
1222:              #if ( INCLUDE_vTaskDelay == 1 )
1223:              
1224:              	void vTaskDelay( const TickType_t xTicksToDelay )
1225:              	{
001398  FA0004     LNK #0x4
00139A  980710     MOV W0, [W14+2]
1226:              	BaseType_t xAlreadyYielded = pdFALSE;
00139C  EB0000     CLR W0
00139E  780F00     MOV W0, [W14]
1227:              
1228:              		/* A delay time of zero just forces a reschedule. */
1229:              		if( xTicksToDelay > ( TickType_t ) 0U )
0013A0  90001E     MOV [W14+2], W0
0013A2  E00000     CP0 W0
1230:              		{
1231:              			configASSERT( uxSchedulerSuspended == 0 );
1232:              			vTaskSuspendAll();
0013A4  320006     BRA Z, .L32
0013A6  07015B     RCALL vTaskSuspendAll
1233:              			{
1234:              				traceTASK_DELAY();
1235:              
1236:              				/* A task that is removed from the event list while the
1237:              				scheduler is suspended will not get placed in the ready
1238:              				list or removed from the blocked list until the scheduler
1239:              				is resumed.
1240:              
1241:              				This task cannot be in an event list as it is the currently
1242:              				executing task. */
1243:              				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
0013A8  EB0080     CLR W1
0013AA  90001E     MOV [W14+2], W0
1244:              			}
1245:              			xAlreadyYielded = xTaskResumeAll();
0013AC  0705EC     RCALL prvAddCurrentTaskToDelayedList
0013AE  07015D     RCALL xTaskResumeAll
0013B0  780F00     MOV W0, [W14]
1246:              		}
1247:              		else
1248:              		{
1249:              			mtCOVERAGE_TEST_MARKER();
1250:              		}
1251:              
1252:              		/* Force a reschedule if xTaskResumeAll has not already done so, we may
1253:              		have put ourselves to sleep. */
1254:              		if( xAlreadyYielded == pdFALSE )
0013B2  78001E     MOV [W14], W0
0013B4  E00000     CP0 W0
0013B6  3A0003     BRA NZ, .L31
1255:              		{
1256:              			portYIELD_WITHIN_API();
0013B8  0250DC     CALL .Letext0, .LFE1, _vPortYield
0013BA  000000     NOP
0013BC  000000     NOP
1257:              		}
1258:              		else
1259:              		{
1260:              			mtCOVERAGE_TEST_MARKER();
1261:              		}
1262:              	}
0013BE  FA8000     ULNK
0013C0  060000     RETURN
1263:              
1264:              #endif /* INCLUDE_vTaskDelay */
1265:              /*-----------------------------------------------------------*/
1266:              
1267:              #if( ( INCLUDE_eTaskGetState == 1 ) || ( configUSE_TRACE_FACILITY == 1 ) )
1268:              
1269:              	eTaskState eTaskGetState( TaskHandle_t xTask )
1270:              	{
1271:              	eTaskState eReturn;
1272:              	List_t *pxStateList;
1273:              	const TCB_t * const pxTCB = ( TCB_t * ) xTask;
1274:              
1275:              		configASSERT( pxTCB );
1276:              
1277:              		if( pxTCB == pxCurrentTCB )
1278:              		{
1279:              			/* The task calling this function is querying its own state. */
1280:              			eReturn = eRunning;
1281:              		}
1282:              		else
1283:              		{
1284:              			taskENTER_CRITICAL();
1285:              			{
1286:              				pxStateList = ( List_t * ) listLIST_ITEM_CONTAINER( &( pxTCB->xStateListItem ) );
1287:              			}
1288:              			taskEXIT_CRITICAL();
1289:              
1290:              			if( ( pxStateList == pxDelayedTaskList ) || ( pxStateList == pxOverflowDelayedTaskList ) )
1291:              			{
1292:              				/* The task being queried is referenced from one of the Blocked
1293:              				lists. */
1294:              				eReturn = eBlocked;
1295:              			}
1296:              
1297:              			#if ( INCLUDE_vTaskSuspend == 1 )
1298:              				else if( pxStateList == &xSuspendedTaskList )
1299:              				{
1300:              					/* The task being queried is referenced from the suspended
1301:              					list.  Is it genuinely suspended or is it block
1302:              					indefinitely? */
1303:              					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL )
1304:              					{
1305:              						eReturn = eSuspended;
1306:              					}
1307:              					else
1308:              					{
1309:              						eReturn = eBlocked;
1310:              					}
1311:              				}
1312:              			#endif
1313:              
1314:              			#if ( INCLUDE_vTaskDelete == 1 )
1315:              				else if( ( pxStateList == &xTasksWaitingTermination ) || ( pxStateList == NULL ) )
1316:              				{
1317:              					/* The task being queried is referenced from the deleted
1318:              					tasks list, or it is not referenced from any lists at
1319:              					all. */
1320:              					eReturn = eDeleted;
1321:              				}
1322:              			#endif
1323:              
1324:              			else /*lint !e525 Negative indentation is intended to make use of pre-processor clearer. */
1325:              			{
1326:              				/* If the task is not in any other state, it must be in the
1327:              				Ready (including pending ready) state. */
1328:              				eReturn = eReady;
1329:              			}
1330:              		}
1331:              
1332:              		return eReturn;
1333:              	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
1334:              
1335:              #endif /* INCLUDE_eTaskGetState */
1336:              /*-----------------------------------------------------------*/
1337:              
1338:              #if ( INCLUDE_uxTaskPriorityGet == 1 )
1339:              
1340:              	UBaseType_t uxTaskPriorityGet( TaskHandle_t xTask )
1341:              	{
1342:              	TCB_t *pxTCB;
1343:              	UBaseType_t uxReturn;
1344:              
1345:              		taskENTER_CRITICAL();
1346:              		{
1347:              			/* If null is passed in here then it is the priority of the that
1348:              			called uxTaskPriorityGet() that is being queried. */
1349:              			pxTCB = prvGetTCBFromHandle( xTask );
1350:              			uxReturn = pxTCB->uxPriority;
1351:              		}
1352:              		taskEXIT_CRITICAL();
1353:              
1354:              		return uxReturn;
1355:              	}
1356:              
1357:              #endif /* INCLUDE_uxTaskPriorityGet */
1358:              /*-----------------------------------------------------------*/
1359:              
1360:              #if ( INCLUDE_uxTaskPriorityGet == 1 )
1361:              
1362:              	UBaseType_t uxTaskPriorityGetFromISR( TaskHandle_t xTask )
1363:              	{
1364:              	TCB_t *pxTCB;
1365:              	UBaseType_t uxReturn, uxSavedInterruptState;
1366:              
1367:              		/* RTOS ports that support interrupt nesting have the concept of a
1368:              		maximum	system call (or maximum API call) interrupt priority.
1369:              		Interrupts that are	above the maximum system call priority are keep
1370:              		permanently enabled, even when the RTOS kernel is in a critical section,
1371:              		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
1372:              		is defined in FreeRTOSConfig.h then
1373:              		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1374:              		failure if a FreeRTOS API function is called from an interrupt that has
1375:              		been assigned a priority above the configured maximum system call
1376:              		priority.  Only FreeRTOS functions that end in FromISR can be called
1377:              		from interrupts	that have been assigned a priority at or (logically)
1378:              		below the maximum system call interrupt priority.  FreeRTOS maintains a
1379:              		separate interrupt safe API to ensure interrupt entry is as fast and as
1380:              		simple as possible.  More information (albeit Cortex-M specific) is
1381:              		provided on the following link:
1382:              		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1383:              		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1384:              
1385:              		uxSavedInterruptState = portSET_INTERRUPT_MASK_FROM_ISR();
1386:              		{
1387:              			/* If null is passed in here then it is the priority of the calling
1388:              			task that is being queried. */
1389:              			pxTCB = prvGetTCBFromHandle( xTask );
1390:              			uxReturn = pxTCB->uxPriority;
1391:              		}
1392:              		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptState );
1393:              
1394:              		return uxReturn;
1395:              	}
1396:              
1397:              #endif /* INCLUDE_uxTaskPriorityGet */
1398:              /*-----------------------------------------------------------*/
1399:              
1400:              #if ( INCLUDE_vTaskPrioritySet == 1 )
1401:              
1402:              	void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority )
1403:              	{
0013C2  FA000C     LNK #0xC
0013C4  980740     MOV W0, [W14+8]
0013C6  980751     MOV W1, [W14+10]
1404:              	TCB_t *pxTCB;
1405:              	UBaseType_t uxCurrentBasePriority, uxPriorityUsedOnEntry;
1406:              	BaseType_t xYieldRequired = pdFALSE;
0013C8  EB0000     CLR W0
0013CA  780F00     MOV W0, [W14]
1407:              
1408:              		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );
1409:              
1410:              		/* Ensure the new priority is valid. */
1411:              		if( uxNewPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
0013CC  90005E     MOV [W14+10], W0
0013CE  500FE3     SUB W0, #0x3, [W15]
0013D0  360002     BRA LEU, .L35
1412:              		{
1413:              			uxNewPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
0013D2  200030     MOV #0x3, W0
0013D4  980750     MOV W0, [W14+10]
1414:              		}
1415:              		else
1416:              		{
1417:              			mtCOVERAGE_TEST_MARKER();
1418:              		}
1419:              
1420:              		taskENTER_CRITICAL();
0013D6  0248DA     CALL vPortEnterCritical
0013D8  000000     NOP
1421:              		{
1422:              			/* If null is passed in here then it is the priority of the calling
1423:              			task that is being changed. */
1424:              			pxTCB = prvGetTCBFromHandle( xTask );
0013DA  90004E     MOV [W14+8], W0
0013DC  E00000     CP0 W0
0013DE  3A0002     BRA NZ, .L36
0013E0  804280     MOV pxCurrentTCB, W0
0013E2  370001     BRA .L37
0013E4  90004E     MOV [W14+8], W0
0013E6  980710     MOV W0, [W14+2]
1425:              
1426:              			traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );
1427:              
1428:              			#if ( configUSE_MUTEXES == 1 )
1429:              			{
1430:              				uxCurrentBasePriority = pxTCB->uxBasePriority;
1431:              			}
1432:              			#else
1433:              			{
1434:              				uxCurrentBasePriority = pxTCB->uxPriority;
0013E8  90001E     MOV [W14+2], W0
0013EA  9008B0     MOV [W0+22], W1
0013EC  980721     MOV W1, [W14+4]
1435:              			}
1436:              			#endif
1437:              
1438:              			if( uxCurrentBasePriority != uxNewPriority )
0013EE  9000AE     MOV [W14+4], W1
0013F0  90005E     MOV [W14+10], W0
0013F2  508F80     SUB W1, W0, [W15]
0013F4  32004A     BRA Z, .L38
1439:              			{
1440:              				/* The priority change may have readied a task of higher
1441:              				priority than the calling task. */
1442:              				if( uxNewPriority > uxCurrentBasePriority )
0013F6  9000DE     MOV [W14+10], W1
0013F8  90002E     MOV [W14+4], W0
0013FA  508F80     SUB W1, W0, [W15]
0013FC  36000C     BRA LEU, .L39
1443:              				{
1444:              					if( pxTCB != pxCurrentTCB )
0013FE  804280     MOV pxCurrentTCB, W0
001400  90009E     MOV [W14+2], W1
001402  508F80     SUB W1, W0, [W15]
001404  32000E     BRA Z, .L40
1445:              					{
1446:              						/* The priority of a task other than the currently
1447:              						running task is being raised.  Is the priority being
1448:              						raised above that of the running task? */
1449:              						if( uxNewPriority >= pxCurrentTCB->uxPriority )
001406  804280     MOV pxCurrentTCB, W0
001408  9008B0     MOV [W0+22], W1
00140A  90005E     MOV [W14+10], W0
00140C  508F80     SUB W1, W0, [W15]
00140E  3E0009     BRA GTU, .L40
1450:              						{
1451:              							xYieldRequired = pdTRUE;
001410  200010     MOV #0x1, W0
001412  780F00     MOV W0, [W14]
001414  370006     BRA .L40
1452:              						}
1453:              						else
1454:              						{
1455:              							mtCOVERAGE_TEST_MARKER();
1456:              						}
1457:              					}
1458:              					else
1459:              					{
1460:              						/* The priority of the running task is being raised,
1461:              						but the running task must already be the highest
1462:              						priority task able to run so no yield is required. */
1463:              					}
1464:              				}
1465:              				else if( pxTCB == pxCurrentTCB )
001416  804280     MOV pxCurrentTCB, W0
001418  90009E     MOV [W14+2], W1
00141A  508F80     SUB W1, W0, [W15]
00141C  3A0002     BRA NZ, .L40
1466:              				{
1467:              					/* Setting the priority of the running task down means
1468:              					there may now be another task of higher priority that
1469:              					is ready to execute. */
1470:              					xYieldRequired = pdTRUE;
00141E  200010     MOV #0x1, W0
001420  780F00     MOV W0, [W14]
1471:              				}
1472:              				else
1473:              				{
1474:              					/* Setting the priority of any other task down does not
1475:              					require a yield as the running task must be above the
1476:              					new priority of the task being modified. */
1477:              				}
1478:              
1479:              				/* Remember the ready list the task might be referenced from
1480:              				before its uxPriority member is changed so the
1481:              				taskRESET_READY_PRIORITY() macro can function correctly. */
1482:              				uxPriorityUsedOnEntry = pxTCB->uxPriority;
001422  90001E     MOV [W14+2], W0
001424  9008B0     MOV [W0+22], W1
001426  980731     MOV W1, [W14+6]
1483:              
1484:              				#if ( configUSE_MUTEXES == 1 )
1485:              				{
1486:              					/* Only change the priority being used if the task is not
1487:              					currently using an inherited priority. */
1488:              					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
1489:              					{
1490:              						pxTCB->uxPriority = uxNewPriority;
1491:              					}
1492:              					else
1493:              					{
1494:              						mtCOVERAGE_TEST_MARKER();
1495:              					}
1496:              
1497:              					/* The base priority gets set whatever. */
1498:              					pxTCB->uxBasePriority = uxNewPriority;
1499:              				}
1500:              				#else
1501:              				{
1502:              					pxTCB->uxPriority = uxNewPriority;
001428  90001E     MOV [W14+2], W0
00142A  9000DE     MOV [W14+10], W1
00142C  980831     MOV W1, [W0+22]
1503:              				}
1504:              				#endif
1505:              
1506:              				/* Only reset the event list item value if the value is not
1507:              				being used for anything else. */
1508:              				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
00142E  90001E     MOV [W14+2], W0
001430  900060     MOV [W0+12], W0
001432  E00000     CP0 W0
001434  350004     BRA LT, .L41
1509:              				{
1510:              					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxNewPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
001436  90005E     MOV [W14+10], W0
001438  1000E4     SUBR W0, #0x4, W1
00143A  90001E     MOV [W14+2], W0
00143C  980061     MOV W1, [W0+12]
1511:              				}
1512:              				else
1513:              				{
1514:              					mtCOVERAGE_TEST_MARKER();
1515:              				}
1516:              
1517:              				/* If the task is in the blocked or suspended list we need do
1518:              				nothing more than change it's priority variable. However, if
1519:              				the task is in a ready list it needs to be removed and placed
1520:              				in the list appropriate to its new priority. */
1521:              				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
00143E  90001E     MOV [W14+2], W0
001440  900150     MOV [W0+10], W2
001442  90003E     MOV [W14+6], W0
001444  B9006A     MUL.SU W0, #10, W0
001446  780080     MOV W0, W1
001448  21CB40     MOV #0x1CB4, W0
00144A  408000     ADD W1, W0, W0
00144C  510F80     SUB W2, W0, [W15]
00144E  3A0017     BRA NZ, .L42
1522:              				{
1523:              					/* The task is currently in its ready list - remove before adding
1524:              					it to it's new ready list.  As we are in a critical section we
1525:              					can do this even if the scheduler is suspended. */
1526:              					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
001450  90001E     MOV [W14+2], W0
001452  E88000     INC2 W0, W0
001454  0249F0     CALL uxListRemove
001456  000000     NOP
1527:              					{
1528:              						/* It is known that the task is in its ready list so
1529:              						there is no need to check again and the port level
1530:              						reset macro can be called directly. */
1531:              						portRESET_READY_PRIORITY( uxPriorityUsedOnEntry, uxTopReadyPriority );
1532:              					}
1533:              					else
1534:              					{
1535:              						mtCOVERAGE_TEST_MARKER();
1536:              					}
1537:              					prvAddTaskToReadyList( pxTCB );
001458  90001E     MOV [W14+2], W0
00145A  9008B0     MOV [W0+22], W1
00145C  8042E0     MOV uxTopReadyPriority, W0
00145E  508F80     SUB W1, W0, [W15]
001460  360003     BRA LEU, .L43
001462  90001E     MOV [W14+2], W0
001464  900830     MOV [W0+22], W0
001466  8842E0     MOV W0, uxTopReadyPriority
001468  90001E     MOV [W14+2], W0
00146A  E88100     INC2 W0, W2
00146C  90001E     MOV [W14+2], W0
00146E  900830     MOV [W0+22], W0
001470  B9006A     MUL.SU W0, #10, W0
001472  780080     MOV W0, W1
001474  21CB40     MOV #0x1CB4, W0
001476  408000     ADD W1, W0, W0
001478  780082     MOV W2, W1
00147A  024950     CALL vListInsertEnd
00147C  000000     NOP
1538:              				}
1539:              				else
1540:              				{
1541:              					mtCOVERAGE_TEST_MARKER();
1542:              				}
1543:              
1544:              				if( xYieldRequired != pdFALSE )
00147E  78001E     MOV [W14], W0
001480  E00000     CP0 W0
001482  320003     BRA Z, .L38
1545:              				{
1546:              					taskYIELD_IF_USING_PREEMPTION();
001484  0250DC     CALL .Letext0, .LFE1, _vPortYield
001486  000000     NOP
001488  000000     NOP
1547:              				}
1548:              				else
1549:              				{
1550:              					mtCOVERAGE_TEST_MARKER();
1551:              				}
1552:              
1553:              				/* Remove compiler warning about unused variables when the port
1554:              				optimised task selection is not being used. */
1555:              				( void ) uxPriorityUsedOnEntry;
1556:              			}
1557:              		}
1558:              		taskEXIT_CRITICAL();
00148A  0248F4     CALL vPortExitCritical
00148C  000000     NOP
1559:              	}
00148E  FA8000     ULNK
001490  060000     RETURN
1560:              
1561:              #endif /* INCLUDE_vTaskPrioritySet */
1562:              /*-----------------------------------------------------------*/
1563:              
1564:              #if ( INCLUDE_vTaskSuspend == 1 )
1565:              
1566:              	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
1567:              	{
001492  FA0004     LNK #0x4
001494  980710     MOV W0, [W14+2]
1568:              	TCB_t *pxTCB;
1569:              
1570:              		taskENTER_CRITICAL();
001496  0248DA     CALL vPortEnterCritical
001498  000000     NOP
1571:              		{
1572:              			/* If null is passed in here then it is the running task that is
1573:              			being suspended. */
1574:              			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
00149A  90001E     MOV [W14+2], W0
00149C  E00000     CP0 W0
00149E  3A0002     BRA NZ, .L45
0014A0  804280     MOV pxCurrentTCB, W0
0014A2  370001     BRA .L46
0014A4  90001E     MOV [W14+2], W0
0014A6  780F00     MOV W0, [W14]
1575:              
1576:              			traceTASK_SUSPEND( pxTCB );
1577:              
1578:              			/* Remove task from the ready/delayed list and place in the
1579:              			suspended list. */
1580:              			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
0014A8  E8801E     INC2 [W14], W0
0014AA  0249F0     CALL uxListRemove
0014AC  000000     NOP
1581:              			{
1582:              				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
1583:              			}
1584:              			else
1585:              			{
1586:              				mtCOVERAGE_TEST_MARKER();
1587:              			}
1588:              
1589:              			/* Is the task waiting on an event also? */
1590:              			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
0014AE  78001E     MOV [W14], W0
0014B0  900820     MOV [W0+20], W0
0014B2  E00000     CP0 W0
0014B4  320004     BRA Z, .L47
1591:              			{
1592:              				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
0014B6  78009E     MOV [W14], W1
0014B8  40806C     ADD W1, #0xC, W0
0014BA  0249F0     CALL uxListRemove
0014BC  000000     NOP
1593:              			}
1594:              			else
1595:              			{
1596:              				mtCOVERAGE_TEST_MARKER();
1597:              			}
1598:              
1599:              			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
0014BE  E8801E     INC2 [W14], W0
0014C0  780080     MOV W0, W1
0014C2  21D040     MOV #0x1D04, W0
0014C4  024950     CALL vListInsertEnd
0014C6  000000     NOP
1600:              		}
1601:              		taskEXIT_CRITICAL();
0014C8  0248F4     CALL vPortExitCritical
0014CA  000000     NOP
1602:              
1603:              		if( xSchedulerRunning != pdFALSE )
0014CC  8042F0     MOV xSchedulerRunning, W0
0014CE  E00000     CP0 W0
0014D0  320005     BRA Z, .L48
1604:              		{
1605:              			/* Reset the next expected unblock time in case it referred to the
1606:              			task that is now in the Suspended state. */
1607:              			taskENTER_CRITICAL();
0014D2  0248DA     CALL vPortEnterCritical
1608:              			{
1609:              				prvResetNextTaskUnblockTime();
0014D4  000000     NOP
0014D6  07033B     RCALL prvResetNextTaskUnblockTime
1610:              			}
1611:              			taskEXIT_CRITICAL();
0014D8  0248F4     CALL vPortExitCritical
0014DA  000000     NOP
1612:              		}
1613:              		else
1614:              		{
1615:              			mtCOVERAGE_TEST_MARKER();
1616:              		}
1617:              
1618:              		if( pxTCB == pxCurrentTCB )
0014DC  804280     MOV pxCurrentTCB, W0
0014DE  78009E     MOV [W14], W1
0014E0  508F80     SUB W1, W0, [W15]
0014E2  3A000E     BRA NZ, .L44
1619:              		{
1620:              			if( xSchedulerRunning != pdFALSE )
0014E4  8042F0     MOV xSchedulerRunning, W0
0014E6  E00000     CP0 W0
0014E8  320004     BRA Z, .L50
1621:              			{
1622:              				/* The current task has just been suspended. */
1623:              				configASSERT( uxSchedulerSuspended == 0 );
1624:              				portYIELD_WITHIN_API();
0014EA  0250DC     CALL .Letext0, .LFE1, _vPortYield
0014EC  000000     NOP
0014EE  000000     NOP
0014F0  370007     BRA .L44
1625:              			}
1626:              			else
1627:              			{
1628:              				/* The scheduler is not running, but the task that was pointed
1629:              				to by pxCurrentTCB has just been suspended and pxCurrentTCB
1630:              				must be adjusted to point to a different task. */
1631:              				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
0014F2  80E821     MOV xSuspendedTaskList, W1
0014F4  8042C0     MOV uxCurrentNumberOfTasks, W0
0014F6  508F80     SUB W1, W0, [W15]
0014F8  3A0002     BRA NZ, .L51
1632:              				{
1633:              					/* No other tasks are ready, so set pxCurrentTCB back to
1634:              					NULL so when the next task is created pxCurrentTCB will
1635:              					be set to point to it no matter what its relative priority
1636:              					is. */
1637:              					pxCurrentTCB = NULL;
0014FA  EF2850     CLR pxCurrentTCB
1638:              				}
1639:              				else
1640:              				{
1641:              					vTaskSwitchContext();
0014FC  370001     BRA .L44
0014FE  0701A4     RCALL vTaskSwitchContext
1642:              				}
1643:              			}
1644:              		}
1645:              		else
1646:              		{
1647:              			mtCOVERAGE_TEST_MARKER();
1648:              		}
1649:              	}
001500  FA8000     ULNK
001502  060000     RETURN
1650:              
1651:              #endif /* INCLUDE_vTaskSuspend */
1652:              /*-----------------------------------------------------------*/
1653:              
1654:              #if ( INCLUDE_vTaskSuspend == 1 )
1655:              
1656:              	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
1657:              	{
001504  FA0006     LNK #0x6
001506  980720     MOV W0, [W14+4]
1658:              	BaseType_t xReturn = pdFALSE;
001508  EB0000     CLR W0
00150A  780F00     MOV W0, [W14]
1659:              	const TCB_t * const pxTCB = ( TCB_t * ) xTask;
00150C  9000AE     MOV [W14+4], W1
00150E  980711     MOV W1, [W14+2]
1660:              
1661:              		/* Accesses xPendingReadyList so must be called from a critical
1662:              		section. */
1663:              
1664:              		/* It does not make sense to check if the calling task is suspended. */
1665:              		configASSERT( xTask );
1666:              
1667:              		/* Is the task being resumed actually in the suspended list? */
1668:              		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
001510  90001E     MOV [W14+2], W0
001512  9000D0     MOV [W0+10], W1
001514  21D040     MOV #0x1D04, W0
001516  508F80     SUB W1, W0, [W15]
001518  3A000B     BRA NZ, .L53
1669:              		{
1670:              			/* Has the task already been resumed from within an ISR? */
1671:              			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
00151A  90001E     MOV [W14+2], W0
00151C  9008A0     MOV [W0+20], W1
00151E  21CF00     MOV #0x1CF0, W0
001520  508F80     SUB W1, W0, [W15]
001522  320006     BRA Z, .L53
1672:              			{
1673:              				/* Is it in the suspended list because it is in the	Suspended
1674:              				state, or because is is blocked with no timeout? */
1675:              				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE )
001524  90001E     MOV [W14+2], W0
001526  900820     MOV [W0+20], W0
001528  E00000     CP0 W0
00152A  3A0002     BRA NZ, .L53
1676:              				{
1677:              					xReturn = pdTRUE;
00152C  200010     MOV #0x1, W0
00152E  780F00     MOV W0, [W14]
1678:              				}
1679:              				else
1680:              				{
1681:              					mtCOVERAGE_TEST_MARKER();
1682:              				}
1683:              			}
1684:              			else
1685:              			{
1686:              				mtCOVERAGE_TEST_MARKER();
1687:              			}
1688:              		}
1689:              		else
1690:              		{
1691:              			mtCOVERAGE_TEST_MARKER();
1692:              		}
1693:              
1694:              		return xReturn;
001530  78001E     MOV [W14], W0
1695:              	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
001532  FA8000     ULNK
001534  060000     RETURN
1696:              
1697:              #endif /* INCLUDE_vTaskSuspend */
1698:              /*-----------------------------------------------------------*/
1699:              
1700:              #if ( INCLUDE_vTaskSuspend == 1 )
1701:              
1702:              	void vTaskResume( TaskHandle_t xTaskToResume )
1703:              	{
001536  FA0004     LNK #0x4
001538  980710     MOV W0, [W14+2]
1704:              	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;
00153A  90009E     MOV [W14+2], W1
00153C  780F01     MOV W1, [W14]
1705:              
1706:              		/* It does not make sense to resume the calling task. */
1707:              		configASSERT( xTaskToResume );
1708:              
1709:              		/* The parameter cannot be NULL as it is impossible to resume the
1710:              		currently executing task. */
1711:              		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
00153E  78001E     MOV [W14], W0
001540  E00000     CP0 W0
001542  32002A     BRA Z, .L54
001544  804280     MOV pxCurrentTCB, W0
001546  78009E     MOV [W14], W1
001548  508F80     SUB W1, W0, [W15]
00154A  320026     BRA Z, .L54
1712:              		{
1713:              			taskENTER_CRITICAL();
00154C  0248DA     CALL vPortEnterCritical
00154E  000000     NOP
1714:              			{
1715:              				if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
001550  78001E     MOV [W14], W0
001552  07FFD8     RCALL prvTaskIsTaskSuspended
001554  E00000     CP0 W0
001556  32001E     BRA Z, .L56
1716:              				{
1717:              					traceTASK_RESUME( pxTCB );
1718:              
1719:              					/* As we are in a critical section we can access the ready
1720:              					lists even if the scheduler is suspended. */
1721:              					( void ) uxListRemove(  &( pxTCB->xStateListItem ) );
001558  E8801E     INC2 [W14], W0
00155A  0249F0     CALL uxListRemove
00155C  000000     NOP
1722:              					prvAddTaskToReadyList( pxTCB );
00155E  78001E     MOV [W14], W0
001560  9008B0     MOV [W0+22], W1
001562  8042E0     MOV uxTopReadyPriority, W0
001564  508F80     SUB W1, W0, [W15]
001566  360003     BRA LEU, .L57
001568  78001E     MOV [W14], W0
00156A  900830     MOV [W0+22], W0
00156C  8842E0     MOV W0, uxTopReadyPriority
00156E  E8811E     INC2 [W14], W2
001570  78001E     MOV [W14], W0
001572  900830     MOV [W0+22], W0
001574  B9006A     MUL.SU W0, #10, W0
001576  780080     MOV W0, W1
001578  21CB40     MOV #0x1CB4, W0
00157A  408000     ADD W1, W0, W0
00157C  780082     MOV W2, W1
00157E  024950     CALL vListInsertEnd
001580  000000     NOP
1723:              
1724:              					/* We may have just resumed a higher priority task. */
1725:              					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
001582  78001E     MOV [W14], W0
001584  9008B0     MOV [W0+22], W1
001586  804280     MOV pxCurrentTCB, W0
001588  900830     MOV [W0+22], W0
00158A  508F80     SUB W1, W0, [W15]
00158C  390003     BRA NC, .L56
1726:              					{
1727:              						/* This yield may not cause the task just resumed to run,
1728:              						but will leave the lists in the correct state for the
1729:              						next yield. */
1730:              						taskYIELD_IF_USING_PREEMPTION();
00158E  0250DC     CALL .Letext0, .LFE1, _vPortYield
001590  000000     NOP
001592  000000     NOP
1731:              					}
1732:              					else
1733:              					{
1734:              						mtCOVERAGE_TEST_MARKER();
1735:              					}
1736:              				}
1737:              				else
1738:              				{
1739:              					mtCOVERAGE_TEST_MARKER();
1740:              				}
1741:              			}
1742:              			taskEXIT_CRITICAL();
001594  0248F4     CALL vPortExitCritical
001596  000000     NOP
1743:              		}
1744:              		else
1745:              		{
1746:              			mtCOVERAGE_TEST_MARKER();
1747:              		}
1748:              	}
001598  FA8000     ULNK
00159A  060000     RETURN
1749:              
1750:              #endif /* INCLUDE_vTaskSuspend */
1751:              
1752:              /*-----------------------------------------------------------*/
1753:              
1754:              #if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )
1755:              
1756:              	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
1757:              	{
00159C  FA0008     LNK #0x8
00159E  980730     MOV W0, [W14+6]
1758:              	BaseType_t xYieldRequired = pdFALSE;
0015A0  EB0000     CLR W0
0015A2  780F00     MOV W0, [W14]
1759:              	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;
0015A4  9000BE     MOV [W14+6], W1
0015A6  980711     MOV W1, [W14+2]
1760:              	UBaseType_t uxSavedInterruptStatus;
1761:              
1762:              		configASSERT( xTaskToResume );
1763:              
1764:              		/* RTOS ports that support interrupt nesting have the concept of a
1765:              		maximum	system call (or maximum API call) interrupt priority.
1766:              		Interrupts that are	above the maximum system call priority are keep
1767:              		permanently enabled, even when the RTOS kernel is in a critical section,
1768:              		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
1769:              		is defined in FreeRTOSConfig.h then
1770:              		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1771:              		failure if a FreeRTOS API function is called from an interrupt that has
1772:              		been assigned a priority above the configured maximum system call
1773:              		priority.  Only FreeRTOS functions that end in FromISR can be called
1774:              		from interrupts	that have been assigned a priority at or (logically)
1775:              		below the maximum system call interrupt priority.  FreeRTOS maintains a
1776:              		separate interrupt safe API to ensure interrupt entry is as fast and as
1777:              		simple as possible.  More information (albeit Cortex-M specific) is
1778:              		provided on the following link:
1779:              		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1780:              		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1781:              
1782:              		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
0015A8  EB0000     CLR W0
0015AA  980720     MOV W0, [W14+4]
1783:              		{
1784:              			if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
0015AC  90001E     MOV [W14+2], W0
0015AE  07FFAA     RCALL prvTaskIsTaskSuspended
0015B0  E00000     CP0 W0
0015B2  320029     BRA Z, .L59
1785:              			{
1786:              				traceTASK_RESUME_FROM_ISR( pxTCB );
1787:              
1788:              				/* Check the ready lists can be accessed. */
1789:              				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
0015B4  804360     MOV uxSchedulerSuspended, W0
0015B6  E00000     CP0 W0
0015B8  3A0020     BRA NZ, .L60
1790:              				{
1791:              					/* Ready lists can be accessed so move the task from the
1792:              					suspended list to the ready list directly. */
1793:              					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
0015BA  90001E     MOV [W14+2], W0
0015BC  9008B0     MOV [W0+22], W1
0015BE  804280     MOV pxCurrentTCB, W0
0015C0  900830     MOV [W0+22], W0
0015C2  508F80     SUB W1, W0, [W15]
0015C4  390002     BRA NC, .L61
1794:              					{
1795:              						xYieldRequired = pdTRUE;
0015C6  200010     MOV #0x1, W0
0015C8  780F00     MOV W0, [W14]
1796:              					}
1797:              					else
1798:              					{
1799:              						mtCOVERAGE_TEST_MARKER();
1800:              					}
1801:              
1802:              					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
0015CA  90001E     MOV [W14+2], W0
0015CC  E88000     INC2 W0, W0
0015CE  0249F0     CALL uxListRemove
0015D0  000000     NOP
1803:              					prvAddTaskToReadyList( pxTCB );
0015D2  90001E     MOV [W14+2], W0
0015D4  9008B0     MOV [W0+22], W1
0015D6  8042E0     MOV uxTopReadyPriority, W0
0015D8  508F80     SUB W1, W0, [W15]
0015DA  360003     BRA LEU, .L62
0015DC  90001E     MOV [W14+2], W0
0015DE  900830     MOV [W0+22], W0
0015E0  8842E0     MOV W0, uxTopReadyPriority
0015E2  90001E     MOV [W14+2], W0
0015E4  E88100     INC2 W0, W2
0015E6  90001E     MOV [W14+2], W0
0015E8  900830     MOV [W0+22], W0
0015EA  B9006A     MUL.SU W0, #10, W0
0015EC  780080     MOV W0, W1
0015EE  21CB40     MOV #0x1CB4, W0
0015F0  408000     ADD W1, W0, W0
0015F2  780082     MOV W2, W1
0015F4  024950     CALL vListInsertEnd
0015F6  000000     NOP
0015F8  370006     BRA .L59
1804:              				}
1805:              				else
1806:              				{
1807:              					/* The delayed or ready lists cannot be accessed so the task
1808:              					is held in the pending ready list until the scheduler is
1809:              					unsuspended. */
1810:              					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
0015FA  90001E     MOV [W14+2], W0
0015FC  40006C     ADD W0, #0xC, W0
0015FE  780080     MOV W0, W1
001600  21CF00     MOV #0x1CF0, W0
001602  024950     CALL vListInsertEnd
001604  000000     NOP
1811:              				}
1812:              			}
1813:              			else
1814:              			{
1815:              				mtCOVERAGE_TEST_MARKER();
1816:              			}
1817:              		}
1818:              		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1819:              
1820:              		return xYieldRequired;
001606  78001E     MOV [W14], W0
1821:              	}
001608  FA8000     ULNK
00160A  060000     RETURN
1822:              
1823:              #endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
1824:              /*-----------------------------------------------------------*/
1825:              
1826:              void vTaskStartScheduler( void )
1827:              {
00160C  FA0002     LNK #0x2
1828:              BaseType_t xReturn;
1829:              
1830:              	/* Add the idle task at the lowest priority. */
1831:              	#if( configSUPPORT_STATIC_ALLOCATION == 1 )
1832:              	{
1833:              		StaticTask_t *pxIdleTaskTCBBuffer = NULL;
1834:              		StackType_t *pxIdleTaskStackBuffer = NULL;
1835:              		uint32_t ulIdleTaskStackSize;
1836:              
1837:              		/* The Idle task is created using user provided RAM - obtain the
1838:              		address of the RAM then create the idle task. */
1839:              		vApplicationGetIdleTaskMemory( &pxIdleTaskTCBBuffer, &pxIdleTaskStackBuffer, &ulIdleTaskStackSize );
1840:              		xIdleTaskHandle = xTaskCreateStatic(	prvIdleTask,
1841:              												"IDLE",
1842:              												ulIdleTaskStackSize,
1843:              												( void * ) NULL,
1844:              												( tskIDLE_PRIORITY | portPRIVILEGE_BIT ),
1845:              												pxIdleTaskStackBuffer,
1846:              												pxIdleTaskTCBBuffer ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
1847:              
1848:              		if( xIdleTaskHandle != NULL )
1849:              		{
1850:              			xReturn = pdPASS;
1851:              		}
1852:              		else
1853:              		{
1854:              			xReturn = pdFAIL;
1855:              		}
1856:              	}
1857:              	#else
1858:              	{
1859:              		/* The Idle task is being created using dynamically allocated RAM. */
1860:              		xReturn = xTaskCreate(	prvIdleTask,
00160E  2086A5     MOV #0x86A, W5
001610  EB0200     CLR W4
001612  EB0180     CLR W3
001614  200732     MOV #0x73, W2
001616  290B61     MOV #0x90B6, W1
001618  21A8C0     MOV #0x1A8C, W0
00161A  07FD66     RCALL xTaskCreate
00161C  780F00     MOV W0, [W14]
1861:              								"IDLE", configMINIMAL_STACK_SIZE,
1862:              								( void * ) NULL,
1863:              								( tskIDLE_PRIORITY | portPRIVILEGE_BIT ),
1864:              								&xIdleTaskHandle ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
1865:              	}
1866:              	#endif /* configSUPPORT_STATIC_ALLOCATION */
1867:              
1868:              	#if ( configUSE_TIMERS == 1 )
1869:              	{
1870:              		if( xReturn == pdPASS )
1871:              		{
1872:              			xReturn = xTimerCreateTimerTask();
1873:              		}
1874:              		else
1875:              		{
1876:              			mtCOVERAGE_TEST_MARKER();
1877:              		}
1878:              	}
1879:              	#endif /* configUSE_TIMERS */
1880:              
1881:              	if( xReturn == pdPASS )
00161E  78001E     MOV [W14], W0
001620  500FE1     SUB W0, #0x1, [W15]
001622  3A000E     BRA NZ, .L63
1882:              	{
1883:              		/* Interrupts are turned off here, to ensure a tick does not occur
1884:              		before or during the call to xPortStartScheduler().  The stacks of
1885:              		the created tasks contain a status word with interrupts switched on
1886:              		so interrupts will automatically get re-enabled when the first task
1887:              		starts to run. */
1888:              		portDISABLE_INTERRUPTS();
001624  800211     MOV SR, W1
001626  2FF1F0     MOV #0xFF1F, W0
001628  608000     AND W1, W0, W0
00162A  A05000     BSET W0, #5
00162C  880210     MOV W0, SR
00162E  000000     NOP
001630  000000     NOP
1889:              
1890:              		#if ( configUSE_NEWLIB_REENTRANT == 1 )
1891:              		{
1892:              			/* Switch Newlib's _impure_ptr variable to point to the _reent
1893:              			structure specific to the task that will run first. */
1894:              			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
1895:              		}
1896:              		#endif /* configUSE_NEWLIB_REENTRANT */
1897:              
1898:              		xNextTaskUnblockTime = portMAX_DELAY;
001632  EB8000     SETM W0
001634  884340     MOV W0, xNextTaskUnblockTime
1899:              		xSchedulerRunning = pdTRUE;
001636  200010     MOV #0x1, W0
001638  8842F0     MOV W0, xSchedulerRunning
1900:              		xTickCount = ( TickType_t ) 0U;
00163A  EF285A     CLR xTickCount
1901:              
1902:              		/* If configGENERATE_RUN_TIME_STATS is defined then the following
1903:              		macro must be defined to configure the timer/counter used to generate
1904:              		the run time counter time base. */
1905:              		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
1906:              
1907:              		/* Setting up the timer tick is hardware specific and thus in the
1908:              		portable interface. */
1909:              		if( xPortStartScheduler() != pdFALSE )
00163C  02487A     CALL xPortStartScheduler
00163E  000000     NOP
1910:              		{
1911:              			/* Should not reach here as if the scheduler is running the
1912:              			function will not return. */
1913:              		}
1914:              		else
1915:              		{
1916:              			/* Should only reach here if a task calls xTaskEndScheduler(). */
1917:              		}
1918:              	}
1919:              	else
1920:              	{
1921:              		/* This line will only be reached if the kernel could not be started,
1922:              		because there was not enough FreeRTOS heap to create the idle task
1923:              		or the timer task. */
1924:              		configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
1925:              	}
1926:              
1927:              	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
1928:              	meaning xIdleTaskHandle is not used anywhere else. */
1929:              	( void ) xIdleTaskHandle;
1930:              }
001640  FA8000     ULNK
001642  060000     RETURN
1931:              /*-----------------------------------------------------------*/
1932:              
1933:              void vTaskEndScheduler( void )
1934:              {
001644  FA0000     LNK #0x0
1935:              	/* Stop the scheduler interrupts and call the portable scheduler end
1936:              	routine so the original ISRs can be restored if necessary.  The port
1937:              	layer must ensure interrupts enable	bit is left in the correct state. */
1938:              	portDISABLE_INTERRUPTS();
001646  800211     MOV SR, W1
001648  2FF1F0     MOV #0xFF1F, W0
00164A  608000     AND W1, W0, W0
00164C  A05000     BSET W0, #5
00164E  880210     MOV W0, SR
001650  000000     NOP
001652  000000     NOP
1939:              	xSchedulerRunning = pdFALSE;
001654  EF285E     CLR xSchedulerRunning
1940:              	vPortEndScheduler();
001656  0248AC     CALL vPortEndScheduler
001658  000000     NOP
1941:              }
00165A  FA8000     ULNK
00165C  060000     RETURN
1942:              /*----------------------------------------------------------*/
1943:              
1944:              void vTaskSuspendAll( void )
1945:              {
00165E  FA0000     LNK #0x0
1946:              	/* A critical section is not required as the variable is of type
1947:              	BaseType_t.  Please read Richard Barry's reply in the following link to a
1948:              	post in the FreeRTOS support forum before reporting this as a bug! -
1949:              	http://goo.gl/wu4acr */
1950:              	++uxSchedulerSuspended;
001660  804360     MOV uxSchedulerSuspended, W0
001662  E80000     INC W0, W0
001664  884360     MOV W0, uxSchedulerSuspended
1951:              }
001666  FA8000     ULNK
001668  060000     RETURN
1952:              /*----------------------------------------------------------*/
1953:              
1954:              #if ( configUSE_TICKLESS_IDLE != 0 )
1955:              
1956:              	static TickType_t prvGetExpectedIdleTime( void )
1957:              	{
1958:              	TickType_t xReturn;
1959:              	UBaseType_t uxHigherPriorityReadyTasks = pdFALSE;
1960:              
1961:              		/* uxHigherPriorityReadyTasks takes care of the case where
1962:              		configUSE_PREEMPTION is 0, so there may be tasks above the idle priority
1963:              		task that are in the Ready state, even though the idle task is
1964:              		running. */
1965:              		#if( configUSE_PORT_OPTIMISED_TASK_SELECTION == 0 )
1966:              		{
1967:              			if( uxTopReadyPriority > tskIDLE_PRIORITY )
1968:              			{
1969:              				uxHigherPriorityReadyTasks = pdTRUE;
1970:              			}
1971:              		}
1972:              		#else
1973:              		{
1974:              			const UBaseType_t uxLeastSignificantBit = ( UBaseType_t ) 0x01;
1975:              
1976:              			/* When port optimised task selection is used the uxTopReadyPriority
1977:              			variable is used as a bit map.  If bits other than the least
1978:              			significant bit are set then there are tasks that have a priority
1979:              			above the idle priority that are in the Ready state.  This takes
1980:              			care of the case where the co-operative scheduler is in use. */
1981:              			if( uxTopReadyPriority > uxLeastSignificantBit )
1982:              			{
1983:              				uxHigherPriorityReadyTasks = pdTRUE;
1984:              			}
1985:              		}
1986:              		#endif
1987:              
1988:              		if( pxCurrentTCB->uxPriority > tskIDLE_PRIORITY )
1989:              		{
1990:              			xReturn = 0;
1991:              		}
1992:              		else if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > 1 )
1993:              		{
1994:              			/* There are other idle priority tasks in the ready state.  If
1995:              			time slicing is used then the very next tick interrupt must be
1996:              			processed. */
1997:              			xReturn = 0;
1998:              		}
1999:              		else if( uxHigherPriorityReadyTasks != pdFALSE )
2000:              		{
2001:              			/* There are tasks in the Ready state that have a priority above the
2002:              			idle priority.  This path can only be reached if
2003:              			configUSE_PREEMPTION is 0. */
2004:              			xReturn = 0;
2005:              		}
2006:              		else
2007:              		{
2008:              			xReturn = xNextTaskUnblockTime - xTickCount;
2009:              		}
2010:              
2011:              		return xReturn;
2012:              	}
2013:              
2014:              #endif /* configUSE_TICKLESS_IDLE */
2015:              /*----------------------------------------------------------*/
2016:              
2017:              BaseType_t xTaskResumeAll( void )
2018:              {
00166A  FA0006     LNK #0x6
2019:              TCB_t *pxTCB = NULL;
00166C  EB0000     CLR W0
00166E  780F00     MOV W0, [W14]
2020:              BaseType_t xAlreadyYielded = pdFALSE;
001670  EB0000     CLR W0
001672  980710     MOV W0, [W14+2]
2021:              
2022:              	/* If uxSchedulerSuspended is zero then this function does not match a
2023:              	previous call to vTaskSuspendAll(). */
2024:              	configASSERT( uxSchedulerSuspended );
2025:              
2026:              	/* It is possible that an ISR caused a task to be removed from an event
2027:              	list while the scheduler was suspended.  If this was the case then the
2028:              	removed task will have been added to the xPendingReadyList.  Once the
2029:              	scheduler has been resumed it is safe to move all the pending ready
2030:              	tasks from this list into their appropriate ready list. */
2031:              	taskENTER_CRITICAL();
001674  0248DA     CALL vPortEnterCritical
001676  000000     NOP
2032:              	{
2033:              		--uxSchedulerSuspended;
001678  804360     MOV uxSchedulerSuspended, W0
00167A  E90000     DEC W0, W0
00167C  884360     MOV W0, uxSchedulerSuspended
2034:              
2035:              		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
00167E  804360     MOV uxSchedulerSuspended, W0
001680  E00000     CP0 W0
001682  3A0048     BRA NZ, .L68
2036:              		{
2037:              			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
001684  8042C0     MOV uxCurrentNumberOfTasks, W0
001686  E00000     CP0 W0
001688  320045     BRA Z, .L68
2038:              			{
2039:              				/* Move any readied tasks from the pending list into the
2040:              				appropriate ready list. */
2041:              				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
00168A  370024     BRA .L69
0016D4  80E780     MOV xPendingReadyList, W0
0016D6  E00000     CP0 W0
0016D8  3AFFD9     BRA NZ, .L71
2042:              				{
2043:              					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
00168C  80E7B0     MOV 0x1CF6, W0
00168E  900030     MOV [W0+6], W0
001690  780F00     MOV W0, [W14]
2044:              					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
001692  78009E     MOV [W14], W1
001694  40806C     ADD W1, #0xC, W0
001696  0249F0     CALL uxListRemove
001698  000000     NOP
2045:              					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
00169A  E8801E     INC2 [W14], W0
00169C  0249F0     CALL uxListRemove
00169E  000000     NOP
2046:              					prvAddTaskToReadyList( pxTCB );
0016A0  78001E     MOV [W14], W0
0016A2  9008B0     MOV [W0+22], W1
0016A4  8042E0     MOV uxTopReadyPriority, W0
0016A6  508F80     SUB W1, W0, [W15]
0016A8  360003     BRA LEU, .L70
0016AA  78001E     MOV [W14], W0
0016AC  900830     MOV [W0+22], W0
0016AE  8842E0     MOV W0, uxTopReadyPriority
0016B0  E8811E     INC2 [W14], W2
0016B2  78001E     MOV [W14], W0
0016B4  900830     MOV [W0+22], W0
0016B6  B9006A     MUL.SU W0, #10, W0
0016B8  780080     MOV W0, W1
0016BA  21CB40     MOV #0x1CB4, W0
0016BC  408000     ADD W1, W0, W0
0016BE  780082     MOV W2, W1
0016C0  024950     CALL vListInsertEnd
0016C2  000000     NOP
2047:              
2048:              					/* If the moved task has a priority higher than the current
2049:              					task then a yield must be performed. */
2050:              					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
0016C4  78001E     MOV [W14], W0
0016C6  9008B0     MOV [W0+22], W1
0016C8  804280     MOV pxCurrentTCB, W0
0016CA  900830     MOV [W0+22], W0
0016CC  508F80     SUB W1, W0, [W15]
0016CE  390002     BRA NC, .L69
2051:              					{
2052:              						xYieldPending = pdTRUE;
0016D0  200010     MOV #0x1, W0
0016D2  884310     MOV W0, xYieldPending
2053:              					}
2054:              					else
2055:              					{
2056:              						mtCOVERAGE_TEST_MARKER();
2057:              					}
2058:              				}
2059:              
2060:              				if( pxTCB != NULL )
0016DA  78001E     MOV [W14], W0
0016DC  E00000     CP0 W0
2061:              				{
2062:              					/* A task was unblocked while the scheduler was suspended,
2063:              					which may have prevented the next unblock time from being
2064:              					re-calculated, in which case re-calculate it now.  Mainly
2065:              					important for low power tickless implementations, where
2066:              					this can prevent an unnecessary exit from low power
2067:              					state. */
2068:              					prvResetNextTaskUnblockTime();
0016DE  320001     BRA Z, .L72, .LBB3
0016E0  070236     RCALL prvResetNextTaskUnblockTime
2069:              				}
2070:              
2071:              				/* If any ticks occurred while the scheduler was suspended then
2072:              				they should be processed now.  This ensures the tick count does
2073:              				not	slip, and that any delayed tasks are resumed at the correct
2074:              				time. */
2075:              				{
2076:              					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
0016E2  804301     MOV uxPendedTicks, W1
0016E4  980721     MOV W1, [W14+4]
2077:              
2078:              					if( uxPendedCounts > ( UBaseType_t ) 0U )
0016E6  90002E     MOV [W14+4], W0
0016E8  E00000     CP0 W0
2079:              					{
2080:              						do
2081:              						{
2082:              							if( xTaskIncrementTick() != pdFALSE )
0016EA  32000C     BRA Z, .L73, .LBE3
0016EC  07003B     RCALL xTaskIncrementTick
0016EE  E00000     CP0 W0
0016F0  320002     BRA Z, .L74
2083:              							{
2084:              								xYieldPending = pdTRUE;
0016F2  200010     MOV #0x1, W0
0016F4  884310     MOV W0, xYieldPending
2085:              							}
2086:              							else
2087:              							{
2088:              								mtCOVERAGE_TEST_MARKER();
2089:              							}
2090:              							--uxPendedCounts;
0016F6  90002E     MOV [W14+4], W0
0016F8  E90000     DEC W0, W0
0016FA  980720     MOV W0, [W14+4]
2091:              						} while( uxPendedCounts > ( UBaseType_t ) 0U );
0016FC  90002E     MOV [W14+4], W0
0016FE  E00000     CP0 W0
001700  3AFFF5     BRA NZ, .L75
2092:              
2093:              						uxPendedTicks = 0;
001702  EF2860     CLR uxPendedTicks
2094:              					}
2095:              					else
2096:              					{
2097:              						mtCOVERAGE_TEST_MARKER();
2098:              					}
2099:              				}
2100:              
2101:              				if( xYieldPending != pdFALSE )
001704  804310     MOV xYieldPending, W0
001706  E00000     CP0 W0
001708  320005     BRA Z, .L68
2102:              				{
2103:              					#if( configUSE_PREEMPTION != 0 )
2104:              					{
2105:              						xAlreadyYielded = pdTRUE;
00170A  200010     MOV #0x1, W0
00170C  980710     MOV W0, [W14+2]
2106:              					}
2107:              					#endif
2108:              					taskYIELD_IF_USING_PREEMPTION();
00170E  0250DC     CALL .Letext0, .LFE1, _vPortYield
001710  000000     NOP
001712  000000     NOP
2109:              				}
2110:              				else
2111:              				{
2112:              					mtCOVERAGE_TEST_MARKER();
2113:              				}
2114:              			}
2115:              		}
2116:              		else
2117:              		{
2118:              			mtCOVERAGE_TEST_MARKER();
2119:              		}
2120:              	}
2121:              	taskEXIT_CRITICAL();
001714  0248F4     CALL vPortExitCritical
001716  000000     NOP
2122:              
2123:              	return xAlreadyYielded;
001718  90001E     MOV [W14+2], W0
2124:              }
00171A  FA8000     ULNK
00171C  060000     RETURN
2125:              /*-----------------------------------------------------------*/
2126:              
2127:              TickType_t xTaskGetTickCount( void )
2128:              {
00171E  FA0002     LNK #0x2
2129:              TickType_t xTicks;
2130:              
2131:              	/* Critical section required if running on a 16 bit processor. */
2132:              	portTICK_TYPE_ENTER_CRITICAL();
001720  0248DA     CALL vPortEnterCritical
001722  000000     NOP
2133:              	{
2134:              		xTicks = xTickCount;
001724  8042D1     MOV xTickCount, W1
001726  780F01     MOV W1, [W14]
2135:              	}
2136:              	portTICK_TYPE_EXIT_CRITICAL();
001728  0248F4     CALL vPortExitCritical
00172A  000000     NOP
2137:              
2138:              	return xTicks;
00172C  78001E     MOV [W14], W0
2139:              }
00172E  FA8000     ULNK
001730  060000     RETURN
2140:              /*-----------------------------------------------------------*/
2141:              
2142:              TickType_t xTaskGetTickCountFromISR( void )
2143:              {
001732  FA0004     LNK #0x4
2144:              TickType_t xReturn;
2145:              UBaseType_t uxSavedInterruptStatus;
2146:              
2147:              	/* RTOS ports that support interrupt nesting have the concept of a maximum
2148:              	system call (or maximum API call) interrupt priority.  Interrupts that are
2149:              	above the maximum system call priority are kept permanently enabled, even
2150:              	when the RTOS kernel is in a critical section, but cannot make any calls to
2151:              	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
2152:              	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
2153:              	failure if a FreeRTOS API function is called from an interrupt that has been
2154:              	assigned a priority above the configured maximum system call priority.
2155:              	Only FreeRTOS functions that end in FromISR can be called from interrupts
2156:              	that have been assigned a priority at or (logically) below the maximum
2157:              	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
2158:              	safe API to ensure interrupt entry is as fast and as simple as possible.
2159:              	More information (albeit Cortex-M specific) is provided on the following
2160:              	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
2161:              	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
2162:              
2163:              	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
001734  EB0000     CLR W0
001736  780F00     MOV W0, [W14]
2164:              	{
2165:              		xReturn = xTickCount;
001738  8042D1     MOV xTickCount, W1
00173A  980711     MOV W1, [W14+2]
2166:              	}
2167:              	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
2168:              
2169:              	return xReturn;
00173C  90001E     MOV [W14+2], W0
2170:              }
00173E  FA8000     ULNK
001740  060000     RETURN
2171:              /*-----------------------------------------------------------*/
2172:              
2173:              UBaseType_t uxTaskGetNumberOfTasks( void )
2174:              {
001742  FA0000     LNK #0x0
2175:              	/* A critical section is not required because the variables are of type
2176:              	BaseType_t. */
2177:              	return uxCurrentNumberOfTasks;
001744  8042C0     MOV uxCurrentNumberOfTasks, W0
2178:              }
001746  FA8000     ULNK
001748  060000     RETURN
2179:              /*-----------------------------------------------------------*/
2180:              
2181:              char *pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
2182:              {
00174A  FA0004     LNK #0x4
00174C  980710     MOV W0, [W14+2]
2183:              TCB_t *pxTCB;
2184:              
2185:              	/* If null is passed in here then the name of the calling task is being
2186:              	queried. */
2187:              	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
00174E  90001E     MOV [W14+2], W0
001750  E00000     CP0 W0
001752  3A0002     BRA NZ, .L80
001754  804280     MOV pxCurrentTCB, W0
001756  370001     BRA .L81
001758  90001E     MOV [W14+2], W0
00175A  780F00     MOV W0, [W14]
2188:              	configASSERT( pxTCB );
2189:              	return &( pxTCB->pcTaskName[ 0 ] );
00175C  78009E     MOV [W14], W1
00175E  40807A     ADD W1, #0x1A, W0
2190:              }
001760  FA8000     ULNK
001762  060000     RETURN
2191:              /*-----------------------------------------------------------*/
2192:              
2193:              #if ( INCLUDE_xTaskGetHandle == 1 )
2194:              
2195:              	static TCB_t *prvSearchForNameWithinSingleList( List_t *pxList, const char pcNameToQuery[] )
2196:              	{
2197:              	TCB_t *pxNextTCB, *pxFirstTCB, *pxReturn = NULL;
2198:              	UBaseType_t x;
2199:              	char cNextChar;
2200:              
2201:              		/* This function is called with the scheduler suspended. */
2202:              
2203:              		if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
2204:              		{
2205:              			listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
2206:              
2207:              			do
2208:              			{
2209:              				listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
2210:              
2211:              				/* Check each character in the name looking for a match or
2212:              				mismatch. */
2213:              				for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
2214:              				{
2215:              					cNextChar = pxNextTCB->pcTaskName[ x ];
2216:              
2217:              					if( cNextChar != pcNameToQuery[ x ] )
2218:              					{
2219:              						/* Characters didn't match. */
2220:              						break;
2221:              					}
2222:              					else if( cNextChar == 0x00 )
2223:              					{
2224:              						/* Both strings terminated, a match must have been
2225:              						found. */
2226:              						pxReturn = pxNextTCB;
2227:              						break;
2228:              					}
2229:              					else
2230:              					{
2231:              						mtCOVERAGE_TEST_MARKER();
2232:              					}
2233:              				}
2234:              
2235:              				if( pxReturn != NULL )
2236:              				{
2237:              					/* The handle has been found. */
2238:              					break;
2239:              				}
2240:              
2241:              			} while( pxNextTCB != pxFirstTCB );
2242:              		}
2243:              		else
2244:              		{
2245:              			mtCOVERAGE_TEST_MARKER();
2246:              		}
2247:              
2248:              		return pxReturn;
2249:              	}
2250:              
2251:              #endif /* INCLUDE_xTaskGetHandle */
2252:              /*-----------------------------------------------------------*/
2253:              
2254:              #if ( INCLUDE_xTaskGetHandle == 1 )
2255:              
2256:              	TaskHandle_t xTaskGetHandle( const char *pcNameToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
2257:              	{
2258:              	UBaseType_t uxQueue = configMAX_PRIORITIES;
2259:              	TCB_t* pxTCB;
2260:              
2261:              		/* Task names will be truncated to configMAX_TASK_NAME_LEN - 1 bytes. */
2262:              		configASSERT( strlen( pcNameToQuery ) < configMAX_TASK_NAME_LEN );
2263:              
2264:              		vTaskSuspendAll();
2265:              		{
2266:              			/* Search the ready lists. */
2267:              			do
2268:              			{
2269:              				uxQueue--;
2270:              				pxTCB = prvSearchForNameWithinSingleList( ( List_t * ) &( pxReadyTasksLists[ uxQueue ] ), pcNameToQuery );
2271:              
2272:              				if( pxTCB != NULL )
2273:              				{
2274:              					/* Found the handle. */
2275:              					break;
2276:              				}
2277:              
2278:              			} while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
2279:              
2280:              			/* Search the delayed lists. */
2281:              			if( pxTCB == NULL )
2282:              			{
2283:              				pxTCB = prvSearchForNameWithinSingleList( ( List_t * ) pxDelayedTaskList, pcNameToQuery );
2284:              			}
2285:              
2286:              			if( pxTCB == NULL )
2287:              			{
2288:              				pxTCB = prvSearchForNameWithinSingleList( ( List_t * ) pxOverflowDelayedTaskList, pcNameToQuery );
2289:              			}
2290:              
2291:              			#if ( INCLUDE_vTaskSuspend == 1 )
2292:              			{
2293:              				if( pxTCB == NULL )
2294:              				{
2295:              					/* Search the suspended list. */
2296:              					pxTCB = prvSearchForNameWithinSingleList( &xSuspendedTaskList, pcNameToQuery );
2297:              				}
2298:              			}
2299:              			#endif
2300:              
2301:              			#if( INCLUDE_vTaskDelete == 1 )
2302:              			{
2303:              				if( pxTCB == NULL )
2304:              				{
2305:              					/* Search the deleted list. */
2306:              					pxTCB = prvSearchForNameWithinSingleList( &xTasksWaitingTermination, pcNameToQuery );
2307:              				}
2308:              			}
2309:              			#endif
2310:              		}
2311:              		( void ) xTaskResumeAll();
2312:              
2313:              		return ( TaskHandle_t ) pxTCB;
2314:              	}
2315:              
2316:              #endif /* INCLUDE_xTaskGetHandle */
2317:              /*-----------------------------------------------------------*/
2318:              
2319:              #if ( configUSE_TRACE_FACILITY == 1 )
2320:              
2321:              	UBaseType_t uxTaskGetSystemState( TaskStatus_t * const pxTaskStatusArray, const UBaseType_t uxArraySize, uint32_t * const pulTotalRunTime )
2322:              	{
2323:              	UBaseType_t uxTask = 0, uxQueue = configMAX_PRIORITIES;
2324:              
2325:              		vTaskSuspendAll();
2326:              		{
2327:              			/* Is there a space in the array for each task in the system? */
2328:              			if( uxArraySize >= uxCurrentNumberOfTasks )
2329:              			{
2330:              				/* Fill in an TaskStatus_t structure with information on each
2331:              				task in the Ready state. */
2332:              				do
2333:              				{
2334:              					uxQueue--;
2335:              					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &( pxReadyTasksLists[ uxQueue ] ), eReady );
2336:              
2337:              				} while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
2338:              
2339:              				/* Fill in an TaskStatus_t structure with information on each
2340:              				task in the Blocked state. */
2341:              				uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxDelayedTaskList, eBlocked );
2342:              				uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxOverflowDelayedTaskList, eBlocked );
2343:              
2344:              				#if( INCLUDE_vTaskDelete == 1 )
2345:              				{
2346:              					/* Fill in an TaskStatus_t structure with information on
2347:              					each task that has been deleted but not yet cleaned up. */
2348:              					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xTasksWaitingTermination, eDeleted );
2349:              				}
2350:              				#endif
2351:              
2352:              				#if ( INCLUDE_vTaskSuspend == 1 )
2353:              				{
2354:              					/* Fill in an TaskStatus_t structure with information on
2355:              					each task in the Suspended state. */
2356:              					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xSuspendedTaskList, eSuspended );
2357:              				}
2358:              				#endif
2359:              
2360:              				#if ( configGENERATE_RUN_TIME_STATS == 1)
2361:              				{
2362:              					if( pulTotalRunTime != NULL )
2363:              					{
2364:              						#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
2365:              							portALT_GET_RUN_TIME_COUNTER_VALUE( ( *pulTotalRunTime ) );
2366:              						#else
2367:              							*pulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
2368:              						#endif
2369:              					}
2370:              				}
2371:              				#else
2372:              				{
2373:              					if( pulTotalRunTime != NULL )
2374:              					{
2375:              						*pulTotalRunTime = 0;
2376:              					}
2377:              				}
2378:              				#endif
2379:              			}
2380:              			else
2381:              			{
2382:              				mtCOVERAGE_TEST_MARKER();
2383:              			}
2384:              		}
2385:              		( void ) xTaskResumeAll();
2386:              
2387:              		return uxTask;
2388:              	}
2389:              
2390:              #endif /* configUSE_TRACE_FACILITY */
2391:              /*----------------------------------------------------------*/
2392:              
2393:              #if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
2394:              
2395:              	TaskHandle_t xTaskGetIdleTaskHandle( void )
2396:              	{
2397:              		/* If xTaskGetIdleTaskHandle() is called before the scheduler has been
2398:              		started, then xIdleTaskHandle will be NULL. */
2399:              		configASSERT( ( xIdleTaskHandle != NULL ) );
2400:              		return xIdleTaskHandle;
2401:              	}
2402:              
2403:              #endif /* INCLUDE_xTaskGetIdleTaskHandle */
2404:              /*----------------------------------------------------------*/
2405:              
2406:              /* This conditional compilation should use inequality to 0, not equality to 1.
2407:              This is to ensure vTaskStepTick() is available when user defined low power mode
2408:              implementations require configUSE_TICKLESS_IDLE to be set to a value other than
2409:              1. */
2410:              #if ( configUSE_TICKLESS_IDLE != 0 )
2411:              
2412:              	void vTaskStepTick( const TickType_t xTicksToJump )
2413:              	{
2414:              		/* Correct the tick count value after a period during which the tick
2415:              		was suppressed.  Note this does *not* call the tick hook function for
2416:              		each stepped tick. */
2417:              		configASSERT( ( xTickCount + xTicksToJump ) <= xNextTaskUnblockTime );
2418:              		xTickCount += xTicksToJump;
2419:              		traceINCREASE_TICK_COUNT( xTicksToJump );
2420:              	}
2421:              
2422:              #endif /* configUSE_TICKLESS_IDLE */
2423:              /*----------------------------------------------------------*/
2424:              
2425:              #if ( INCLUDE_xTaskAbortDelay == 1 )
2426:              
2427:              	BaseType_t xTaskAbortDelay( TaskHandle_t xTask )
2428:              	{
2429:              	TCB_t *pxTCB = ( TCB_t * ) xTask;
2430:              	BaseType_t xReturn = pdFALSE;
2431:              
2432:              		configASSERT( pxTCB );
2433:              
2434:              		vTaskSuspendAll();
2435:              		{
2436:              			/* A task can only be prematurely removed from the Blocked state if
2437:              			it is actually in the Blocked state. */
2438:              			if( eTaskGetState( xTask ) == eBlocked )
2439:              			{
2440:              				/* Remove the reference to the task from the blocked list.  An
2441:              				interrupt won't touch the xStateListItem because the
2442:              				scheduler is suspended. */
2443:              				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
2444:              
2445:              				/* Is the task waiting on an event also?  If so remove it from
2446:              				the event list too.  Interrupts can touch the event list item,
2447:              				even though the scheduler is suspended, so a critical section
2448:              				is used. */
2449:              				taskENTER_CRITICAL();
2450:              				{
2451:              					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
2452:              					{
2453:              						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
2454:              						pxTCB->ucDelayAborted = pdTRUE;
2455:              					}
2456:              					else
2457:              					{
2458:              						mtCOVERAGE_TEST_MARKER();
2459:              					}
2460:              				}
2461:              				taskEXIT_CRITICAL();
2462:              
2463:              				/* Place the unblocked task into the appropriate ready list. */
2464:              				prvAddTaskToReadyList( pxTCB );
2465:              
2466:              				/* A task being unblocked cannot cause an immediate context
2467:              				switch if preemption is turned off. */
2468:              				#if (  configUSE_PREEMPTION == 1 )
2469:              				{
2470:              					/* Preemption is on, but a context switch should only be
2471:              					performed if the unblocked task has a priority that is
2472:              					equal to or higher than the currently executing task. */
2473:              					if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
2474:              					{
2475:              						/* Pend the yield to be performed when the scheduler
2476:              						is unsuspended. */
2477:              						xYieldPending = pdTRUE;
2478:              					}
2479:              					else
2480:              					{
2481:              						mtCOVERAGE_TEST_MARKER();
2482:              					}
2483:              				}
2484:              				#endif /* configUSE_PREEMPTION */
2485:              			}
2486:              			else
2487:              			{
2488:              				mtCOVERAGE_TEST_MARKER();
2489:              			}
2490:              		}
2491:              		xTaskResumeAll();
2492:              
2493:              		return xReturn;
2494:              	}
2495:              
2496:              #endif /* INCLUDE_xTaskAbortDelay */
2497:              /*----------------------------------------------------------*/
2498:              
2499:              BaseType_t xTaskIncrementTick( void )
2500:              {
001764  FA000A     LNK #0xA
2501:              TCB_t * pxTCB;
2502:              TickType_t xItemValue;
2503:              BaseType_t xSwitchRequired = pdFALSE;
001766  EB0000     CLR W0
001768  780F00     MOV W0, [W14]
2504:              
2505:              	/* Called by the portable layer each time a tick interrupt occurs.
2506:              	Increments the tick then checks to see if the new tick value will cause any
2507:              	tasks to be unblocked. */
2508:              	traceTASK_INCREMENT_TICK( xTickCount );
2509:              	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
00176A  804360     MOV uxSchedulerSuspended, W0
00176C  E00000     CP0 W0
00176E  3A0061     BRA NZ, .L83, .LBE4
2510:              	{
2511:              		/* Minor optimisation.  The tick count cannot change in this
2512:              		block. */
2513:              		const TickType_t xConstTickCount = xTickCount + 1;
001770  8042D0     MOV xTickCount, W0
001772  E80000     INC W0, W0
001774  980710     MOV W0, [W14+2]
2514:              
2515:              		/* Increment the RTOS tick, switching the delayed and overflowed
2516:              		delayed lists if it wraps to 0. */
2517:              		xTickCount = xConstTickCount;
001776  90009E     MOV [W14+2], W1
001778  8842D1     MOV W1, xTickCount
2518:              
2519:              		if( xConstTickCount == ( TickType_t ) 0U )
00177A  90001E     MOV [W14+2], W0
00177C  E00000     CP0 W0
00177E  3A000A     BRA NZ, .L84, .LBE5
2520:              		{
2521:              			taskSWITCH_DELAYED_LISTS();
001780  804291     MOV pxDelayedTaskList, W1
001782  980721     MOV W1, [W14+4]
001784  8042A0     MOV pxOverflowDelayedTaskList, W0
001786  884290     MOV W0, pxDelayedTaskList
001788  9000AE     MOV [W14+4], W1
00178A  8842A1     MOV W1, pxOverflowDelayedTaskList
00178C  804320     MOV xNumOfOverflows, W0
00178E  E80000     INC W0, W0
001790  884320     MOV W0, xNumOfOverflows
001792  0701DD     RCALL prvResetNextTaskUnblockTime
2522:              		}
2523:              		else
2524:              		{
2525:              			mtCOVERAGE_TEST_MARKER();
2526:              		}
2527:              
2528:              		/* See if this tick has made a timeout expire.  Tasks are stored in
2529:              		the	queue in the order of their wake time - meaning once one task
2530:              		has been found whose block time has not expired there is no need to
2531:              		look any further down the list. */
2532:              		if( xConstTickCount >= xNextTaskUnblockTime )
001794  804340     MOV xNextTaskUnblockTime, W0
001796  90009E     MOV [W14+2], W1
001798  508F80     SUB W1, W0, [W15]
00179A  39003F     BRA NC, .L85
00179C  370001     BRA .L91
2533:              		{
2534:              			for( ;; )
2535:              			{
2536:              				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
0017A0  804290     MOV pxDelayedTaskList, W0
0017A2  780010     MOV [W0], W0
0017A4  E00000     CP0 W0
0017A6  3A0003     BRA NZ, .L86
2537:              				{
2538:              					/* The delayed list is empty.  Set xNextTaskUnblockTime
2539:              					to the maximum possible value so it is extremely
2540:              					unlikely that the
2541:              					if( xTickCount >= xNextTaskUnblockTime ) test will pass
2542:              					next time through. */
2543:              					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
0017A8  EB8000     SETM W0
0017AA  884340     MOV W0, xNextTaskUnblockTime
2544:              					break;
0017AC  370036     BRA .L85
2545:              				}
2546:              				else
2547:              				{
2548:              					/* The delayed list is not empty, get the value of the
2549:              					item at the head of the delayed list.  This is the time
2550:              					at which the task at the head of the delayed list must
2551:              					be removed from the Blocked state. */
2552:              					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
0017AE  804290     MOV pxDelayedTaskList, W0
0017B0  900030     MOV [W0+6], W0
0017B2  900030     MOV [W0+6], W0
0017B4  980730     MOV W0, [W14+6]
2553:              					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
0017B6  90003E     MOV [W14+6], W0
0017B8  900090     MOV [W0+2], W1
0017BA  980741     MOV W1, [W14+8]
2554:              
2555:              					if( xConstTickCount < xItemValue )
0017BC  90009E     MOV [W14+2], W1
0017BE  90004E     MOV [W14+8], W0
0017C0  508F80     SUB W1, W0, [W15]
0017C2  310003     BRA C, .L87
2556:              					{
2557:              						/* It is not time to unblock this item yet, but the
2558:              						item value is the time at which the task at the head
2559:              						of the blocked list must be removed from the Blocked
2560:              						state -	so record the item value in
2561:              						xNextTaskUnblockTime. */
2562:              						xNextTaskUnblockTime = xItemValue;
0017C4  9000CE     MOV [W14+8], W1
0017C6  884341     MOV W1, xNextTaskUnblockTime
2563:              						break;
0017C8  370028     BRA .L85
2564:              					}
2565:              					else
2566:              					{
2567:              						mtCOVERAGE_TEST_MARKER();
2568:              					}
2569:              
2570:              					/* It is time to remove the item from the Blocked state. */
2571:              					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
0017CA  90003E     MOV [W14+6], W0
0017CC  E88000     INC2 W0, W0
0017CE  0249F0     CALL uxListRemove
0017D0  000000     NOP
2572:              
2573:              					/* Is the task waiting on an event also?  If so remove
2574:              					it from the event list. */
2575:              					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
0017D2  90003E     MOV [W14+6], W0
0017D4  900820     MOV [W0+20], W0
0017D6  E00000     CP0 W0
0017D8  320004     BRA Z, .L88
2576:              					{
2577:              						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
0017DA  90003E     MOV [W14+6], W0
0017DC  40006C     ADD W0, #0xC, W0
0017DE  0249F0     CALL uxListRemove
0017E0  000000     NOP
2578:              					}
2579:              					else
2580:              					{
2581:              						mtCOVERAGE_TEST_MARKER();
2582:              					}
2583:              
2584:              					/* Place the unblocked task into the appropriate ready
2585:              					list. */
2586:              					prvAddTaskToReadyList( pxTCB );
0017E2  90003E     MOV [W14+6], W0
0017E4  9008B0     MOV [W0+22], W1
0017E6  8042E0     MOV uxTopReadyPriority, W0
0017E8  508F80     SUB W1, W0, [W15]
0017EA  360003     BRA LEU, .L89
0017EC  90003E     MOV [W14+6], W0
0017EE  900830     MOV [W0+22], W0
0017F0  8842E0     MOV W0, uxTopReadyPriority
0017F2  90003E     MOV [W14+6], W0
0017F4  E88100     INC2 W0, W2
0017F6  90003E     MOV [W14+6], W0
0017F8  900830     MOV [W0+22], W0
0017FA  B9006A     MUL.SU W0, #10, W0
0017FC  780080     MOV W0, W1
0017FE  21CB40     MOV #0x1CB4, W0
001800  408000     ADD W1, W0, W0
001802  780082     MOV W2, W1
001804  024950     CALL vListInsertEnd
001806  000000     NOP
2587:              
2588:              					/* A task being unblocked cannot cause an immediate
2589:              					context switch if preemption is turned off. */
2590:              					#if (  configUSE_PREEMPTION == 1 )
2591:              					{
2592:              						/* Preemption is on, but a context switch should
2593:              						only be performed if the unblocked task has a
2594:              						priority that is equal to or higher than the
2595:              						currently executing task. */
2596:              						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
001808  90003E     MOV [W14+6], W0
00180A  9008B0     MOV [W0+22], W1
00180C  804280     MOV pxCurrentTCB, W0
00180E  900830     MOV [W0+22], W0
001810  508F80     SUB W1, W0, [W15]
001812  39FFC5     BRA NC, .L94
2597:              						{
2598:              							xSwitchRequired = pdTRUE;
001814  200010     MOV #0x1, W0
001816  780F00     MOV W0, [W14]
2599:              						}
2600:              						else
2601:              						{
2602:              							mtCOVERAGE_TEST_MARKER();
2603:              						}
2604:              					}
2605:              					#endif /* configUSE_PREEMPTION */
2606:              				}
2607:              			}
00179E  000000     NOP
001818  37FFC3     BRA .L91
2608:              		}
2609:              
2610:              		/* Tasks of equal priority to the currently running task will share
2611:              		processing time (time slice) if preemption is on, and the application
2612:              		writer has not explicitly turned time slicing off. */
2613:              		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
2614:              		{
2615:              			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
00181A  804280     MOV pxCurrentTCB, W0
00181C  900830     MOV [W0+22], W0
00181E  B9006A     MUL.SU W0, #10, W0
001820  780080     MOV W0, W1
001822  21CB40     MOV #0x1CB4, W0
001824  408000     ADD W1, W0, W0
001826  780010     MOV [W0], W0
001828  500FE1     SUB W0, #0x1, [W15]
00182A  360006     BRA LEU, .L92
2616:              			{
2617:              				xSwitchRequired = pdTRUE;
00182C  200010     MOV #0x1, W0
00182E  780F00     MOV W0, [W14]
001830  370003     BRA .L92
2618:              			}
2619:              			else
2620:              			{
2621:              				mtCOVERAGE_TEST_MARKER();
2622:              			}
2623:              		}
2624:              		#endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) ) */
2625:              
2626:              		#if ( configUSE_TICK_HOOK == 1 )
2627:              		{
2628:              			/* Guard against the tick hook being called when the pended tick
2629:              			count is being unwound (when the scheduler is being unlocked). */
2630:              			if( uxPendedTicks == ( UBaseType_t ) 0U )
2631:              			{
2632:              				vApplicationTickHook();
2633:              			}
2634:              			else
2635:              			{
2636:              				mtCOVERAGE_TEST_MARKER();
2637:              			}
2638:              		}
2639:              		#endif /* configUSE_TICK_HOOK */
2640:              	}
2641:              	else
2642:              	{
2643:              		++uxPendedTicks;
001832  804300     MOV uxPendedTicks, W0
001834  E80000     INC W0, W0
001836  884300     MOV W0, uxPendedTicks
2644:              
2645:              		/* The tick hook gets called at regular intervals, even if the
2646:              		scheduler is locked. */
2647:              		#if ( configUSE_TICK_HOOK == 1 )
2648:              		{
2649:              			vApplicationTickHook();
2650:              		}
2651:              		#endif
2652:              	}
2653:              
2654:              	#if ( configUSE_PREEMPTION == 1 )
2655:              	{
2656:              		if( xYieldPending != pdFALSE )
001838  804310     MOV xYieldPending, W0
00183A  E00000     CP0 W0
00183C  320002     BRA Z, .L93
2657:              		{
2658:              			xSwitchRequired = pdTRUE;
00183E  200010     MOV #0x1, W0
001840  780F00     MOV W0, [W14]
2659:              		}
2660:              		else
2661:              		{
2662:              			mtCOVERAGE_TEST_MARKER();
2663:              		}
2664:              	}
2665:              	#endif /* configUSE_PREEMPTION */
2666:              
2667:              	return xSwitchRequired;
001842  78001E     MOV [W14], W0
2668:              }
001844  FA8000     ULNK
001846  060000     RETURN
2669:              /*-----------------------------------------------------------*/
2670:              
2671:              #if ( configUSE_APPLICATION_TASK_TAG == 1 )
2672:              
2673:              	void vTaskSetApplicationTaskTag( TaskHandle_t xTask, TaskHookFunction_t pxHookFunction )
2674:              	{
2675:              	TCB_t *xTCB;
2676:              
2677:              		/* If xTask is NULL then it is the task hook of the calling task that is
2678:              		getting set. */
2679:              		if( xTask == NULL )
2680:              		{
2681:              			xTCB = ( TCB_t * ) pxCurrentTCB;
2682:              		}
2683:              		else
2684:              		{
2685:              			xTCB = ( TCB_t * ) xTask;
2686:              		}
2687:              
2688:              		/* Save the hook function in the TCB.  A critical section is required as
2689:              		the value can be accessed from an interrupt. */
2690:              		taskENTER_CRITICAL();
2691:              			xTCB->pxTaskTag = pxHookFunction;
2692:              		taskEXIT_CRITICAL();
2693:              	}
2694:              
2695:              #endif /* configUSE_APPLICATION_TASK_TAG */
2696:              /*-----------------------------------------------------------*/
2697:              
2698:              #if ( configUSE_APPLICATION_TASK_TAG == 1 )
2699:              
2700:              	TaskHookFunction_t xTaskGetApplicationTaskTag( TaskHandle_t xTask )
2701:              	{
2702:              	TCB_t *xTCB;
2703:              	TaskHookFunction_t xReturn;
2704:              
2705:              		/* If xTask is NULL then we are setting our own task hook. */
2706:              		if( xTask == NULL )
2707:              		{
2708:              			xTCB = ( TCB_t * ) pxCurrentTCB;
2709:              		}
2710:              		else
2711:              		{
2712:              			xTCB = ( TCB_t * ) xTask;
2713:              		}
2714:              
2715:              		/* Save the hook function in the TCB.  A critical section is required as
2716:              		the value can be accessed from an interrupt. */
2717:              		taskENTER_CRITICAL();
2718:              		{
2719:              			xReturn = xTCB->pxTaskTag;
2720:              		}
2721:              		taskEXIT_CRITICAL();
2722:              
2723:              		return xReturn;
2724:              	}
2725:              
2726:              #endif /* configUSE_APPLICATION_TASK_TAG */
2727:              /*-----------------------------------------------------------*/
2728:              
2729:              #if ( configUSE_APPLICATION_TASK_TAG == 1 )
2730:              
2731:              	BaseType_t xTaskCallApplicationTaskHook( TaskHandle_t xTask, void *pvParameter )
2732:              	{
2733:              	TCB_t *xTCB;
2734:              	BaseType_t xReturn;
2735:              
2736:              		/* If xTask is NULL then we are calling our own task hook. */
2737:              		if( xTask == NULL )
2738:              		{
2739:              			xTCB = ( TCB_t * ) pxCurrentTCB;
2740:              		}
2741:              		else
2742:              		{
2743:              			xTCB = ( TCB_t * ) xTask;
2744:              		}
2745:              
2746:              		if( xTCB->pxTaskTag != NULL )
2747:              		{
2748:              			xReturn = xTCB->pxTaskTag( pvParameter );
2749:              		}
2750:              		else
2751:              		{
2752:              			xReturn = pdFAIL;
2753:              		}
2754:              
2755:              		return xReturn;
2756:              	}
2757:              
2758:              #endif /* configUSE_APPLICATION_TASK_TAG */
2759:              /*-----------------------------------------------------------*/
2760:              
2761:              void vTaskSwitchContext( void )
2762:              {
001848  FA001A     LNK #0x1A
2763:              	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
00184A  804360     MOV uxSchedulerSuspended, W0
00184C  E00000     CP0 W0
00184E  320003     BRA Z, .L96
2764:              	{
2765:              		/* The scheduler is currently suspended - do not allow a context
2766:              		switch. */
2767:              		xYieldPending = pdTRUE;
001850  200010     MOV #0x1, W0
001852  884310     MOV W0, xYieldPending
001854  370040     BRA .L95, .LBE7
2768:              	}
2769:              	else
2770:              	{
2771:              		xYieldPending = pdFALSE;
001856  EF2862     CLR xYieldPending
2772:              		traceTASK_SWITCHED_OUT();
2773:              
2774:              		#if ( configGENERATE_RUN_TIME_STATS == 1 )
2775:              		{
2776:              				#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
2777:              					portALT_GET_RUN_TIME_COUNTER_VALUE( ulTotalRunTime );
2778:              				#else
2779:              					ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
2780:              				#endif
2781:              
2782:              				/* Add the amount of time the task has been running to the
2783:              				accumulated time so far.  The time the task started running was
2784:              				stored in ulTaskSwitchedInTime.  Note that there is no overflow
2785:              				protection here so count values are only valid until the timer
2786:              				overflows.  The guard against negative values is to protect
2787:              				against suspect run time stat counter implementations - which
2788:              				are provided by the application, not the kernel. */
2789:              				if( ulTotalRunTime > ulTaskSwitchedInTime )
2790:              				{
2791:              					pxCurrentTCB->ulRunTimeCounter += ( ulTotalRunTime - ulTaskSwitchedInTime );
2792:              				}
2793:              				else
2794:              				{
2795:              					mtCOVERAGE_TEST_MARKER();
2796:              				}
2797:              				ulTaskSwitchedInTime = ulTotalRunTime;
2798:              		}
2799:              		#endif /* configGENERATE_RUN_TIME_STATS */
2800:              
2801:              		/* Check for stack overflow, if configured. */
2802:              		taskCHECK_FOR_STACK_OVERFLOW();
001858  804280     MOV pxCurrentTCB, W0
00185A  900870     MOV [W0+30], W0
00185C  980710     MOV W0, [W14+2]
00185E  4700E6     ADD W14, #0x6, W1
001860  290BB2     MOV #0x90BB, W2
001862  090013     REPEAT #0x13
001864  7858B2     MOV.B [W2++], [W1++]
001866  90001E     MOV [W14+2], W0
001868  500074     SUB W0, #0x14, W0
00186A  980710     MOV W0, [W14+2]
00186C  470066     ADD W14, #0x6, W0
00186E  200142     MOV #0x14, W2
001870  780080     MOV W0, W1
001872  90001E     MOV [W14+2], W0
001874  020E6C     CALL _memcmp
001876  000000     NOP
001878  E00000     CP0 W0
00187A  320005     BRA Z, .L98, .LBE6, .LBB7
00187C  804280     MOV pxCurrentTCB, W0
00187E  4000FA     ADD W0, #0x1A, W1
001880  804280     MOV pxCurrentTCB, W0
001882  02413A     CALL vApplicationStackOverflowHook
001884  000000     NOP
2803:              
2804:              		/* Select a new task to run using either the generic C or port
2805:              		optimised asm code. */
2806:              		taskSELECT_HIGHEST_PRIORITY_TASK();
001886  8042E1     MOV uxTopReadyPriority, W1
001888  780F01     MOV W1, [W14]
00188A  370001     BRA .L99
00188C  E90F1E     DEC [W14], [W14]
00188E  78001E     MOV [W14], W0
001890  B9006A     MUL.SU W0, #10, W0
001892  780080     MOV W0, W1
001894  21CB40     MOV #0x1CB4, W0
001896  408000     ADD W1, W0, W0
001898  780010     MOV [W0], W0
00189A  E00000     CP0 W0
00189C  32FFF7     BRA Z, .L100
00189E  78001E     MOV [W14], W0
0018A0  B9006A     MUL.SU W0, #10, W0
0018A2  780080     MOV W0, W1
0018A4  21CB40     MOV #0x1CB4, W0
0018A6  408000     ADD W1, W0, W0
0018A8  980720     MOV W0, [W14+4]
0018AA  90002E     MOV [W14+4], W0
0018AC  900010     MOV [W0+2], W0
0018AE  900090     MOV [W0+2], W1
0018B0  90002E     MOV [W14+4], W0
0018B2  980011     MOV W1, [W0+2]
0018B4  90002E     MOV [W14+4], W0
0018B6  900090     MOV [W0+2], W1
0018B8  90002E     MOV [W14+4], W0
0018BA  400064     ADD W0, #0x4, W0
0018BC  508F80     SUB W1, W0, [W15]
0018BE  3A0005     BRA NZ, .L101
0018C0  90002E     MOV [W14+4], W0
0018C2  900010     MOV [W0+2], W0
0018C4  900090     MOV [W0+2], W1
0018C6  90002E     MOV [W14+4], W0
0018C8  980011     MOV W1, [W0+2]
0018CA  90002E     MOV [W14+4], W0
0018CC  900010     MOV [W0+2], W0
0018CE  900030     MOV [W0+6], W0
0018D0  884280     MOV W0, pxCurrentTCB
0018D2  78011E     MOV [W14], W2
0018D4  8842E2     MOV W2, uxTopReadyPriority
2807:              		traceTASK_SWITCHED_IN();
2808:              
2809:              		#if ( configUSE_NEWLIB_REENTRANT == 1 )
2810:              		{
2811:              			/* Switch Newlib's _impure_ptr variable to point to the _reent
2812:              			structure specific to this task. */
2813:              			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
2814:              		}
2815:              		#endif /* configUSE_NEWLIB_REENTRANT */
2816:              	}
2817:              }
0018D6  FA8000     ULNK
0018D8  060000     RETURN
2818:              /*-----------------------------------------------------------*/
2819:              
2820:              void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
2821:              {
0018DA  FA0004     LNK #0x4
0018DC  780F00     MOV W0, [W14]
0018DE  980711     MOV W1, [W14+2]
2822:              	configASSERT( pxEventList );
2823:              
2824:              	/* THIS FUNCTION MUST BE CALLED WITH EITHER INTERRUPTS DISABLED OR THE
2825:              	SCHEDULER SUSPENDED AND THE QUEUE BEING ACCESSED LOCKED. */
2826:              
2827:              	/* Place the event list item of the TCB in the appropriate event list.
2828:              	This is placed in the list in priority order so the highest priority task
2829:              	is the first to be woken by the event.  The queue that contains the event
2830:              	list is locked, preventing simultaneous access from interrupts. */
2831:              	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
0018E0  804280     MOV pxCurrentTCB, W0
0018E2  40006C     ADD W0, #0xC, W0
0018E4  780080     MOV W0, W1
0018E6  78001E     MOV [W14], W0
0018E8  02498C     CALL vListInsert
0018EA  000000     NOP
2832:              
2833:              	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
0018EC  200011     MOV #0x1, W1
0018EE  90001E     MOV [W14+2], W0
0018F0  07034A     RCALL prvAddCurrentTaskToDelayedList
2834:              }
0018F2  FA8000     ULNK
0018F4  060000     RETURN
2835:              /*-----------------------------------------------------------*/
2836:              
2837:              void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
2838:              {
0018F6  FA0006     LNK #0x6
0018F8  780F00     MOV W0, [W14]
0018FA  980711     MOV W1, [W14+2]
0018FC  980722     MOV W2, [W14+4]
2839:              	configASSERT( pxEventList );
2840:              
2841:              	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
2842:              	the event groups implementation. */
2843:              	configASSERT( uxSchedulerSuspended != 0 );
2844:              
2845:              	/* Store the item value in the event list item.  It is safe to access the
2846:              	event list item here as interrupts won't access the event list item of a
2847:              	task that is not in the Blocked state. */
2848:              	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
0018FE  804280     MOV pxCurrentTCB, W0
001900  90011E     MOV [W14+2], W2
001902  280001     MOV #0x8000, W1
001904  708082     IOR W1, W2, W1
001906  980061     MOV W1, [W0+12]
2849:              
2850:              	/* Place the event list item of the TCB at the end of the appropriate event
2851:              	list.  It is safe to access the event list here because it is part of an
2852:              	event group implementation - and interrupts don't access event groups
2853:              	directly (instead they access them indirectly by pending function calls to
2854:              	the task level). */
2855:              	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
001908  804280     MOV pxCurrentTCB, W0
00190A  40006C     ADD W0, #0xC, W0
00190C  780080     MOV W0, W1
00190E  78001E     MOV [W14], W0
001910  024950     CALL vListInsertEnd
001912  000000     NOP
2856:              
2857:              	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
001914  200011     MOV #0x1, W1
001916  90002E     MOV [W14+4], W0
001918  070336     RCALL prvAddCurrentTaskToDelayedList
2858:              }
00191A  FA8000     ULNK
00191C  060000     RETURN
2859:              /*-----------------------------------------------------------*/
2860:              
2861:              #if( configUSE_TIMERS == 1 )
2862:              
2863:              	void vTaskPlaceOnEventListRestricted( List_t * const pxEventList, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
2864:              	{
2865:              		configASSERT( pxEventList );
2866:              
2867:              		/* This function should not be called by application code hence the
2868:              		'Restricted' in its name.  It is not part of the public API.  It is
2869:              		designed for use by kernel code, and has special calling requirements -
2870:              		it should be called with the scheduler suspended. */
2871:              
2872:              
2873:              		/* Place the event list item of the TCB in the appropriate event list.
2874:              		In this case it is assume that this is the only task that is going to
2875:              		be waiting on this event list, so the faster vListInsertEnd() function
2876:              		can be used in place of vListInsert. */
2877:              		vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
2878:              
2879:              		/* If the task should block indefinitely then set the block time to a
2880:              		value that will be recognised as an indefinite delay inside the
2881:              		prvAddCurrentTaskToDelayedList() function. */
2882:              		if( xWaitIndefinitely != pdFALSE )
2883:              		{
2884:              			xTicksToWait = portMAX_DELAY;
2885:              		}
2886:              
2887:              		traceTASK_DELAY_UNTIL( ( xTickCount + xTicksToWait ) );
2888:              		prvAddCurrentTaskToDelayedList( xTicksToWait, xWaitIndefinitely );
2889:              	}
2890:              
2891:              #endif /* configUSE_TIMERS */
2892:              /*-----------------------------------------------------------*/
2893:              
2894:              BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
2895:              {
00191E  FA0006     LNK #0x6
001920  980720     MOV W0, [W14+4]
2896:              TCB_t *pxUnblockedTCB;
2897:              BaseType_t xReturn;
2898:              
2899:              	/* THIS FUNCTION MUST BE CALLED FROM A CRITICAL SECTION.  It can also be
2900:              	called from a critical section within an ISR. */
2901:              
2902:              	/* The event list is sorted in priority order, so the first in the list can
2903:              	be removed as it is known to be the highest priority.  Remove the TCB from
2904:              	the delayed list, and add it to the ready list.
2905:              
2906:              	If an event is for a queue that is locked then this function will never
2907:              	get called - the lock count on the queue will get modified instead.  This
2908:              	means exclusive access to the event list is guaranteed here.
2909:              
2910:              	This function assumes that a check has already been made to ensure that
2911:              	pxEventList is not empty. */
2912:              	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
001922  90002E     MOV [W14+4], W0
001924  900030     MOV [W0+6], W0
001926  900030     MOV [W0+6], W0
001928  980710     MOV W0, [W14+2]
2913:              	configASSERT( pxUnblockedTCB );
2914:              	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
00192A  90001E     MOV [W14+2], W0
00192C  40006C     ADD W0, #0xC, W0
00192E  0249F0     CALL uxListRemove
001930  000000     NOP
2915:              
2916:              	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
001932  804360     MOV uxSchedulerSuspended, W0
001934  E00000     CP0 W0
001936  3A0018     BRA NZ, .L105
2917:              	{
2918:              		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
001938  90001E     MOV [W14+2], W0
00193A  E88000     INC2 W0, W0
00193C  0249F0     CALL uxListRemove
00193E  000000     NOP
2919:              		prvAddTaskToReadyList( pxUnblockedTCB );
001940  90001E     MOV [W14+2], W0
001942  9008B0     MOV [W0+22], W1
001944  8042E0     MOV uxTopReadyPriority, W0
001946  508F80     SUB W1, W0, [W15]
001948  360003     BRA LEU, .L106
00194A  90001E     MOV [W14+2], W0
00194C  900830     MOV [W0+22], W0
00194E  8842E0     MOV W0, uxTopReadyPriority
001950  90001E     MOV [W14+2], W0
001952  E88100     INC2 W0, W2
001954  90001E     MOV [W14+2], W0
001956  900830     MOV [W0+22], W0
001958  B9006A     MUL.SU W0, #10, W0
00195A  780080     MOV W0, W1
00195C  21CB40     MOV #0x1CB4, W0
00195E  408000     ADD W1, W0, W0
001960  780082     MOV W2, W1
001962  024950     CALL vListInsertEnd
001964  000000     NOP
001966  370006     BRA .L107
2920:              	}
2921:              	else
2922:              	{
2923:              		/* The delayed and ready lists cannot be accessed, so hold this task
2924:              		pending until the scheduler is resumed. */
2925:              		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
001968  90001E     MOV [W14+2], W0
00196A  40006C     ADD W0, #0xC, W0
00196C  780080     MOV W0, W1
00196E  21CF00     MOV #0x1CF0, W0
001970  024950     CALL vListInsertEnd
001972  000000     NOP
2926:              	}
2927:              
2928:              	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
001974  90001E     MOV [W14+2], W0
001976  9008B0     MOV [W0+22], W1
001978  804280     MOV pxCurrentTCB, W0
00197A  900830     MOV [W0+22], W0
00197C  508F80     SUB W1, W0, [W15]
00197E  360005     BRA LEU, .L108
2929:              	{
2930:              		/* Return true if the task removed from the event list has a higher
2931:              		priority than the calling task.  This allows the calling task to know if
2932:              		it should force a context switch now. */
2933:              		xReturn = pdTRUE;
001980  200010     MOV #0x1, W0
001982  780F00     MOV W0, [W14]
2934:              
2935:              		/* Mark that a yield is pending in case the user is not using the
2936:              		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
2937:              		xYieldPending = pdTRUE;
001984  200010     MOV #0x1, W0
001986  884310     MOV W0, xYieldPending
001988  370002     BRA .L109
2938:              	}
2939:              	else
2940:              	{
2941:              		xReturn = pdFALSE;
00198A  EB0000     CLR W0
00198C  780F00     MOV W0, [W14]
2942:              	}
2943:              
2944:              	#if( configUSE_TICKLESS_IDLE != 0 )
2945:              	{
2946:              		/* If a task is blocked on a kernel object then xNextTaskUnblockTime
2947:              		might be set to the blocked task's time out time.  If the task is
2948:              		unblocked for a reason other than a timeout xNextTaskUnblockTime is
2949:              		normally left unchanged, because it is automatically reset to a new
2950:              		value when the tick count equals xNextTaskUnblockTime.  However if
2951:              		tickless idling is used it might be more important to enter sleep mode
2952:              		at the earliest possible time - so reset xNextTaskUnblockTime here to
2953:              		ensure it is updated at the earliest possible time. */
2954:              		prvResetNextTaskUnblockTime();
2955:              	}
2956:              	#endif
2957:              
2958:              	return xReturn;
00198E  78001E     MOV [W14], W0
2959:              }
001990  FA8000     ULNK
001992  060000     RETURN
2960:              /*-----------------------------------------------------------*/
2961:              
2962:              BaseType_t xTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
2963:              {
001994  FA0008     LNK #0x8
001996  980720     MOV W0, [W14+4]
001998  980731     MOV W1, [W14+6]
2964:              TCB_t *pxUnblockedTCB;
2965:              BaseType_t xReturn;
2966:              
2967:              	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
2968:              	the event flags implementation. */
2969:              	configASSERT( uxSchedulerSuspended != pdFALSE );
2970:              
2971:              	/* Store the new item value in the event list. */
2972:              	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
00199A  9000BE     MOV [W14+6], W1
00199C  280000     MOV #0x8000, W0
00199E  700081     IOR W0, W1, W1
0019A0  90002E     MOV [W14+4], W0
0019A2  780801     MOV W1, [W0]
2973:              
2974:              	/* Remove the event list form the event flag.  Interrupts do not access
2975:              	event flags. */
2976:              	pxUnblockedTCB = ( TCB_t * ) listGET_LIST_ITEM_OWNER( pxEventListItem );
0019A4  90002E     MOV [W14+4], W0
0019A6  900030     MOV [W0+6], W0
0019A8  980710     MOV W0, [W14+2]
2977:              	configASSERT( pxUnblockedTCB );
2978:              	( void ) uxListRemove( pxEventListItem );
0019AA  90002E     MOV [W14+4], W0
0019AC  0249F0     CALL uxListRemove
0019AE  000000     NOP
2979:              
2980:              	/* Remove the task from the delayed list and add it to the ready list.  The
2981:              	scheduler is suspended so interrupts will not be accessing the ready
2982:              	lists. */
2983:              	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
0019B0  90001E     MOV [W14+2], W0
0019B2  E88000     INC2 W0, W0
0019B4  0249F0     CALL uxListRemove
0019B6  000000     NOP
2984:              	prvAddTaskToReadyList( pxUnblockedTCB );
0019B8  90001E     MOV [W14+2], W0
0019BA  9008B0     MOV [W0+22], W1
0019BC  8042E0     MOV uxTopReadyPriority, W0
0019BE  508F80     SUB W1, W0, [W15]
0019C0  360003     BRA LEU, .L111
0019C2  90001E     MOV [W14+2], W0
0019C4  900830     MOV [W0+22], W0
0019C6  8842E0     MOV W0, uxTopReadyPriority
0019C8  90001E     MOV [W14+2], W0
0019CA  E88100     INC2 W0, W2
0019CC  90001E     MOV [W14+2], W0
0019CE  900830     MOV [W0+22], W0
0019D0  B9006A     MUL.SU W0, #10, W0
0019D2  780080     MOV W0, W1
0019D4  21CB40     MOV #0x1CB4, W0
0019D6  408000     ADD W1, W0, W0
0019D8  780082     MOV W2, W1
0019DA  024950     CALL vListInsertEnd
0019DC  000000     NOP
2985:              
2986:              	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
0019DE  90001E     MOV [W14+2], W0
0019E0  9008B0     MOV [W0+22], W1
0019E2  804280     MOV pxCurrentTCB, W0
0019E4  900830     MOV [W0+22], W0
0019E6  508F80     SUB W1, W0, [W15]
0019E8  360005     BRA LEU, .L112
2987:              	{
2988:              		/* Return true if the task removed from the event list has
2989:              		a higher priority than the calling task.  This allows
2990:              		the calling task to know if it should force a context
2991:              		switch now. */
2992:              		xReturn = pdTRUE;
0019EA  200010     MOV #0x1, W0
0019EC  780F00     MOV W0, [W14]
2993:              
2994:              		/* Mark that a yield is pending in case the user is not using the
2995:              		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
2996:              		xYieldPending = pdTRUE;
0019EE  200010     MOV #0x1, W0
0019F0  884310     MOV W0, xYieldPending
0019F2  370002     BRA .L113
2997:              	}
2998:              	else
2999:              	{
3000:              		xReturn = pdFALSE;
0019F4  EB0000     CLR W0
0019F6  780F00     MOV W0, [W14]
3001:              	}
3002:              
3003:              	return xReturn;
0019F8  78001E     MOV [W14], W0
3004:              }
0019FA  FA8000     ULNK
0019FC  060000     RETURN
3005:              /*-----------------------------------------------------------*/
3006:              
3007:              void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
3008:              {
0019FE  FA0002     LNK #0x2
001A00  780F00     MOV W0, [W14]
3009:              	configASSERT( pxTimeOut );
3010:              	pxTimeOut->xOverflowCount = xNumOfOverflows;
001A02  804321     MOV xNumOfOverflows, W1
001A04  78001E     MOV [W14], W0
001A06  780801     MOV W1, [W0]
3011:              	pxTimeOut->xTimeOnEntering = xTickCount;
001A08  8042D1     MOV xTickCount, W1
001A0A  78001E     MOV [W14], W0
001A0C  980011     MOV W1, [W0+2]
3012:              }
001A0E  FA8000     ULNK
001A10  060000     RETURN
3013:              /*-----------------------------------------------------------*/
3014:              
3015:              BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
3016:              {
001A12  FA0008     LNK #0x8
001A14  980720     MOV W0, [W14+4]
001A16  980731     MOV W1, [W14+6]
3017:              BaseType_t xReturn;
3018:              
3019:              	configASSERT( pxTimeOut );
3020:              	configASSERT( pxTicksToWait );
3021:              
3022:              	taskENTER_CRITICAL();
001A18  0248DA     CALL vPortEnterCritical
001A1A  000000     NOP
3023:              	{
3024:              		/* Minor optimisation.  The tick count cannot change in this block. */
3025:              		const TickType_t xConstTickCount = xTickCount;
001A1C  8042D1     MOV xTickCount, W1
001A1E  980711     MOV W1, [W14+2]
3026:              
3027:              		#if( INCLUDE_xTaskAbortDelay == 1 )
3028:              			if( pxCurrentTCB->ucDelayAborted != pdFALSE )
3029:              			{
3030:              				/* The delay was aborted, which is not the same as a time out,
3031:              				but has the same result. */
3032:              				pxCurrentTCB->ucDelayAborted = pdFALSE;
3033:              				xReturn = pdTRUE;
3034:              			}
3035:              			else
3036:              		#endif
3037:              
3038:              		#if ( INCLUDE_vTaskSuspend == 1 )
3039:              			if( *pxTicksToWait == portMAX_DELAY )
001A20  90003E     MOV [W14+6], W0
001A22  780010     MOV [W0], W0
001A24  400FE1     ADD W0, #0x1, [W15]
001A26  3A0003     BRA NZ, .L116
3040:              			{
3041:              				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
3042:              				specified is the maximum block time then the task should block
3043:              				indefinitely, and therefore never time out. */
3044:              				xReturn = pdFALSE;
001A28  EB0000     CLR W0
001A2A  780F00     MOV W0, [W14]
001A2C  370025     BRA .L117, .LBE9
3045:              			}
3046:              			else
3047:              		#endif
3048:              
3049:              		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
001A2E  90002E     MOV [W14+4], W0
001A30  780090     MOV [W0], W1
001A32  804320     MOV xNumOfOverflows, W0
001A34  508F80     SUB W1, W0, [W15]
001A36  320008     BRA Z, .L118
001A38  90002E     MOV [W14+4], W0
001A3A  900090     MOV [W0+2], W1
001A3C  90001E     MOV [W14+2], W0
001A3E  508F80     SUB W1, W0, [W15]
001A40  3E0003     BRA GTU, .L118
3050:              		{
3051:              			/* The tick count is greater than the time at which
3052:              			vTaskSetTimeout() was called, but has also overflowed since
3053:              			vTaskSetTimeOut() was called.  It must have wrapped all the way
3054:              			around and gone past again. This passed since vTaskSetTimeout()
3055:              			was called. */
3056:              			xReturn = pdTRUE;
001A42  200010     MOV #0x1, W0
001A44  780F00     MOV W0, [W14]
001A46  370018     BRA .L117, .LBE9
3057:              		}
3058:              		else if( ( ( TickType_t ) ( xConstTickCount - pxTimeOut->xTimeOnEntering ) ) < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
001A48  90002E     MOV [W14+4], W0
001A4A  900010     MOV [W0+2], W0
001A4C  90009E     MOV [W14+2], W1
001A4E  508080     SUB W1, W0, W1
001A50  90003E     MOV [W14+6], W0
001A52  780010     MOV [W0], W0
001A54  508F80     SUB W1, W0, [W15]
001A56  31000E     BRA C, .L119
3059:              		{
3060:              			/* Not a genuine timeout. Adjust parameters for time remaining. */
3061:              			*pxTicksToWait -= ( xConstTickCount - pxTimeOut->xTimeOnEntering );
001A58  90003E     MOV [W14+6], W0
001A5A  780090     MOV [W0], W1
001A5C  90002E     MOV [W14+4], W0
001A5E  900110     MOV [W0+2], W2
001A60  90001E     MOV [W14+2], W0
001A62  510000     SUB W2, W0, W0
001A64  408080     ADD W1, W0, W1
001A66  90003E     MOV [W14+6], W0
001A68  780801     MOV W1, [W0]
3062:              			vTaskSetTimeOutState( pxTimeOut );
001A6A  90002E     MOV [W14+4], W0
001A6C  07FFC8     RCALL vTaskSetTimeOutState
3063:              			xReturn = pdFALSE;
001A6E  EB0000     CLR W0
001A70  780F00     MOV W0, [W14]
001A72  370002     BRA .L117, .LBE9
3064:              		}
3065:              		else
3066:              		{
3067:              			xReturn = pdTRUE;
001A74  200010     MOV #0x1, W0
001A76  780F00     MOV W0, [W14]
3068:              		}
3069:              	}
3070:              	taskEXIT_CRITICAL();
001A78  0248F4     CALL vPortExitCritical
001A7A  000000     NOP
3071:              
3072:              	return xReturn;
001A7C  78001E     MOV [W14], W0
3073:              }
001A7E  FA8000     ULNK
001A80  060000     RETURN
3074:              /*-----------------------------------------------------------*/
3075:              
3076:              void vTaskMissedYield( void )
3077:              {
001A82  FA0000     LNK #0x0
3078:              	xYieldPending = pdTRUE;
001A84  200010     MOV #0x1, W0
001A86  884310     MOV W0, xYieldPending
3079:              }
001A88  FA8000     ULNK
001A8A  060000     RETURN
3080:              /*-----------------------------------------------------------*/
3081:              
3082:              #if ( configUSE_TRACE_FACILITY == 1 )
3083:              
3084:              	UBaseType_t uxTaskGetTaskNumber( TaskHandle_t xTask )
3085:              	{
3086:              	UBaseType_t uxReturn;
3087:              	TCB_t *pxTCB;
3088:              
3089:              		if( xTask != NULL )
3090:              		{
3091:              			pxTCB = ( TCB_t * ) xTask;
3092:              			uxReturn = pxTCB->uxTaskNumber;
3093:              		}
3094:              		else
3095:              		{
3096:              			uxReturn = 0U;
3097:              		}
3098:              
3099:              		return uxReturn;
3100:              	}
3101:              
3102:              #endif /* configUSE_TRACE_FACILITY */
3103:              /*-----------------------------------------------------------*/
3104:              
3105:              #if ( configUSE_TRACE_FACILITY == 1 )
3106:              
3107:              	void vTaskSetTaskNumber( TaskHandle_t xTask, const UBaseType_t uxHandle )
3108:              	{
3109:              	TCB_t *pxTCB;
3110:              
3111:              		if( xTask != NULL )
3112:              		{
3113:              			pxTCB = ( TCB_t * ) xTask;
3114:              			pxTCB->uxTaskNumber = uxHandle;
3115:              		}
3116:              	}
3117:              
3118:              #endif /* configUSE_TRACE_FACILITY */
3119:              
3120:              /*
3121:               * -----------------------------------------------------------
3122:               * The Idle task.
3123:               * ----------------------------------------------------------
3124:               *
3125:               * The portTASK_FUNCTION() macro is used to allow port/compiler specific
3126:               * language extensions.  The equivalent prototype for this function is:
3127:               *
3128:               * void prvIdleTask( void *pvParameters );
3129:               *
3130:               */
3131:              static portTASK_FUNCTION( prvIdleTask, pvParameters )
3132:              {
001A8C  FA0002     LNK #0x2
3133:              	/* Stop warnings. */
3134:              	( void ) pvParameters;
3135:              
3136:              	/** THIS IS THE RTOS IDLE TASK - WHICH IS CREATED AUTOMATICALLY WHEN THE
3137:              	SCHEDULER IS STARTED. **/
3138:              
3139:              	for( ;; )
3140:              	{
3141:              		/* See if any tasks have deleted themselves - if so then the idle task
3142:              		is responsible for freeing the deleted task's TCB and stack. */
3143:              		prvCheckTasksWaitingTermination();
001A8E  780F00     MOV W0, [W14]
001A90  07002D     RCALL prvCheckTasksWaitingTermination
3144:              
3145:              		#if ( configUSE_PREEMPTION == 0 )
3146:              		{
3147:              			/* If we are not using preemption we keep forcing a task switch to
3148:              			see if any other task has become available.  If we are using
3149:              			preemption we don't need to do this as any task becoming available
3150:              			will automatically get the processor anyway. */
3151:              			taskYIELD();
3152:              		}
3153:              		#endif /* configUSE_PREEMPTION */
3154:              
3155:              		#if ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) )
3156:              		{
3157:              			/* When using preemption tasks of equal priority will be
3158:              			timesliced.  If a task that is sharing the idle priority is ready
3159:              			to run then the idle task should yield before the end of the
3160:              			timeslice.
3161:              
3162:              			A critical region is not required here as we are just reading from
3163:              			the list, and an occasional incorrect value will not matter.  If
3164:              			the ready list at the idle priority contains more than one task
3165:              			then a task other than the idle task is ready to execute. */
3166:              			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
001A92  80E5A0     MOV pxReadyTasksLists, W0
001A94  500FE1     SUB W0, #0x1, [W15]
001A96  360003     BRA LEU, .L122, .LBB10
3167:              			{
3168:              				taskYIELD();
001A98  0250DC     CALL .Letext0, .LFE1, _vPortYield
001A9A  000000     NOP
001A9C  000000     NOP
3169:              			}
3170:              			else
3171:              			{
3172:              				mtCOVERAGE_TEST_MARKER();
3173:              			}
3174:              		}
3175:              		#endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) ) */
3176:              
3177:              		#if ( configUSE_IDLE_HOOK == 1 )
3178:              		{
3179:              			extern void vApplicationIdleHook( void );
3180:              
3181:              			/* Call the user defined function from within the idle task.  This
3182:              			allows the application designer to add background functionality
3183:              			without the overhead of a separate task.
3184:              			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
3185:              			CALL A FUNCTION THAT MIGHT BLOCK. */
3186:              			vApplicationIdleHook();
001A9E  024134     CALL vApplicationIdleHook
001AA0  000000     NOP
3187:              		}
3188:              		#endif /* configUSE_IDLE_HOOK */
3189:              
3190:              		/* This conditional compilation should use inequality to 0, not equality
3191:              		to 1.  This is to ensure portSUPPRESS_TICKS_AND_SLEEP() is called when
3192:              		user defined low power mode	implementations require
3193:              		configUSE_TICKLESS_IDLE to be set to a value other than 1. */
3194:              		#if ( configUSE_TICKLESS_IDLE != 0 )
3195:              		{
3196:              		TickType_t xExpectedIdleTime;
3197:              
3198:              			/* It is not desirable to suspend then resume the scheduler on
3199:              			each iteration of the idle task.  Therefore, a preliminary
3200:              			test of the expected idle time is performed without the
3201:              			scheduler suspended.  The result here is not necessarily
3202:              			valid. */
3203:              			xExpectedIdleTime = prvGetExpectedIdleTime();
3204:              
3205:              			if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
3206:              			{
3207:              				vTaskSuspendAll();
3208:              				{
3209:              					/* Now the scheduler is suspended, the expected idle
3210:              					time can be sampled again, and this time its value can
3211:              					be used. */
3212:              					configASSERT( xNextTaskUnblockTime >= xTickCount );
3213:              					xExpectedIdleTime = prvGetExpectedIdleTime();
3214:              
3215:              					if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
3216:              					{
3217:              						traceLOW_POWER_IDLE_BEGIN();
3218:              						portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime );
3219:              						traceLOW_POWER_IDLE_END();
3220:              					}
3221:              					else
3222:              					{
3223:              						mtCOVERAGE_TEST_MARKER();
3224:              					}
3225:              				}
3226:              				( void ) xTaskResumeAll();
3227:              			}
3228:              			else
3229:              			{
3230:              				mtCOVERAGE_TEST_MARKER();
3231:              			}
3232:              		}
3233:              		#endif /* configUSE_TICKLESS_IDLE */
3234:              	}
001AA2  37FFF6     BRA .L123
3235:              }
3236:              /*-----------------------------------------------------------*/
3237:              
3238:              #if( configUSE_TICKLESS_IDLE != 0 )
3239:              
3240:              	eSleepModeStatus eTaskConfirmSleepModeStatus( void )
3241:              	{
3242:              	/* The idle task exists in addition to the application tasks. */
3243:              	const UBaseType_t uxNonApplicationTasks = 1;
3244:              	eSleepModeStatus eReturn = eStandardSleep;
3245:              
3246:              		if( listCURRENT_LIST_LENGTH( &xPendingReadyList ) != 0 )
3247:              		{
3248:              			/* A task was made ready while the scheduler was suspended. */
3249:              			eReturn = eAbortSleep;
3250:              		}
3251:              		else if( xYieldPending != pdFALSE )
3252:              		{
3253:              			/* A yield was pended while the scheduler was suspended. */
3254:              			eReturn = eAbortSleep;
3255:              		}
3256:              		else
3257:              		{
3258:              			/* If all the tasks are in the suspended list (which might mean they
3259:              			have an infinite block time rather than actually being suspended)
3260:              			then it is safe to turn all clocks off and just wait for external
3261:              			interrupts. */
3262:              			if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == ( uxCurrentNumberOfTasks - uxNonApplicationTasks ) )
3263:              			{
3264:              				eReturn = eNoTasksWaitingTimeout;
3265:              			}
3266:              			else
3267:              			{
3268:              				mtCOVERAGE_TEST_MARKER();
3269:              			}
3270:              		}
3271:              
3272:              		return eReturn;
3273:              	}
3274:              
3275:              #endif /* configUSE_TICKLESS_IDLE */
3276:              /*-----------------------------------------------------------*/
3277:              
3278:              #if ( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
3279:              
3280:              	void vTaskSetThreadLocalStoragePointer( TaskHandle_t xTaskToSet, BaseType_t xIndex, void *pvValue )
3281:              	{
3282:              	TCB_t *pxTCB;
3283:              
3284:              		if( xIndex < configNUM_THREAD_LOCAL_STORAGE_POINTERS )
3285:              		{
3286:              			pxTCB = prvGetTCBFromHandle( xTaskToSet );
3287:              			pxTCB->pvThreadLocalStoragePointers[ xIndex ] = pvValue;
3288:              		}
3289:              	}
3290:              
3291:              #endif /* configNUM_THREAD_LOCAL_STORAGE_POINTERS */
3292:              /*-----------------------------------------------------------*/
3293:              
3294:              #if ( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
3295:              
3296:              	void *pvTaskGetThreadLocalStoragePointer( TaskHandle_t xTaskToQuery, BaseType_t xIndex )
3297:              	{
3298:              	void *pvReturn = NULL;
3299:              	TCB_t *pxTCB;
3300:              
3301:              		if( xIndex < configNUM_THREAD_LOCAL_STORAGE_POINTERS )
3302:              		{
3303:              			pxTCB = prvGetTCBFromHandle( xTaskToQuery );
3304:              			pvReturn = pxTCB->pvThreadLocalStoragePointers[ xIndex ];
3305:              		}
3306:              		else
3307:              		{
3308:              			pvReturn = NULL;
3309:              		}
3310:              
3311:              		return pvReturn;
3312:              	}
3313:              
3314:              #endif /* configNUM_THREAD_LOCAL_STORAGE_POINTERS */
3315:              /*-----------------------------------------------------------*/
3316:              
3317:              #if ( portUSING_MPU_WRAPPERS == 1 )
3318:              
3319:              	void vTaskAllocateMPURegions( TaskHandle_t xTaskToModify, const MemoryRegion_t * const xRegions )
3320:              	{
3321:              	TCB_t *pxTCB;
3322:              
3323:              		/* If null is passed in here then we are modifying the MPU settings of
3324:              		the calling task. */
3325:              		pxTCB = prvGetTCBFromHandle( xTaskToModify );
3326:              
3327:              		vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, NULL, 0 );
3328:              	}
3329:              
3330:              #endif /* portUSING_MPU_WRAPPERS */
3331:              /*-----------------------------------------------------------*/
3332:              
3333:              static void prvInitialiseTaskLists( void )
3334:              {
001AA4  FA0002     LNK #0x2
3335:              UBaseType_t uxPriority;
3336:              
3337:              	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
001AA6  EB0000     CLR W0
001AA8  780F00     MOV W0, [W14]
001AAA  370008     BRA .L125
001ABA  E80F1E     INC [W14], [W14]
001ABC  78001E     MOV [W14], W0
001ABE  500FE3     SUB W0, #0x3, [W15]
001AC0  36FFF5     BRA LEU, .L126
3338:              	{
3339:              		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
001AAC  78001E     MOV [W14], W0
001AAE  B9006A     MUL.SU W0, #10, W0
001AB0  780080     MOV W0, W1
001AB2  21CB40     MOV #0x1CB4, W0
001AB4  408000     ADD W1, W0, W0
001AB6  024910     CALL vListInitialise
001AB8  000000     NOP
3340:              	}
3341:              
3342:              	vListInitialise( &xDelayedTaskList1 );
001AC2  21CDC0     MOV #0x1CDC, W0
001AC4  024910     CALL vListInitialise
001AC6  000000     NOP
3343:              	vListInitialise( &xDelayedTaskList2 );
001AC8  21CE60     MOV #0x1CE6, W0
001ACA  024910     CALL vListInitialise
001ACC  000000     NOP
3344:              	vListInitialise( &xPendingReadyList );
001ACE  21CF00     MOV #0x1CF0, W0
001AD0  024910     CALL vListInitialise
001AD2  000000     NOP
3345:              
3346:              	#if ( INCLUDE_vTaskDelete == 1 )
3347:              	{
3348:              		vListInitialise( &xTasksWaitingTermination );
001AD4  21CFA0     MOV #0x1CFA, W0
001AD6  024910     CALL vListInitialise
001AD8  000000     NOP
3349:              	}
3350:              	#endif /* INCLUDE_vTaskDelete */
3351:              
3352:              	#if ( INCLUDE_vTaskSuspend == 1 )
3353:              	{
3354:              		vListInitialise( &xSuspendedTaskList );
001ADA  21D040     MOV #0x1D04, W0
001ADC  024910     CALL vListInitialise
001ADE  000000     NOP
3355:              	}
3356:              	#endif /* INCLUDE_vTaskSuspend */
3357:              
3358:              	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
3359:              	using list2. */
3360:              	pxDelayedTaskList = &xDelayedTaskList1;
001AE0  21CDC0     MOV #0x1CDC, W0
001AE2  884290     MOV W0, pxDelayedTaskList
3361:              	pxOverflowDelayedTaskList = &xDelayedTaskList2;
001AE4  21CE60     MOV #0x1CE6, W0
001AE6  8842A0     MOV W0, pxOverflowDelayedTaskList
3362:              }
001AE8  FA8000     ULNK
001AEA  060000     RETURN
3363:              /*-----------------------------------------------------------*/
3364:              
3365:              static void prvCheckTasksWaitingTermination( void )
3366:              {
001AEC  FA0004     LNK #0x4
3367:              
3368:              	/** THIS FUNCTION IS CALLED FROM THE RTOS IDLE TASK **/
3369:              
3370:              	#if ( INCLUDE_vTaskDelete == 1 )
3371:              	{
3372:              		BaseType_t xListIsEmpty;
3373:              
3374:              		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
3375:              		too often in the idle task. */
3376:              		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
001B2E  8042B0     MOV uxDeletedTasksWaitingCleanUp, W0
001B30  E00000     CP0 W0
001B32  3AFFDE     BRA NZ, .L129
3377:              		{
3378:              			vTaskSuspendAll();
001AEE  37001F     BRA .L128, .LBE12
001AF0  07FDB6     RCALL vTaskSuspendAll
3379:              			{
3380:              				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
001AF2  80E7D0     MOV xTasksWaitingTermination, W0
001AF4  A7F000     BTSC W0, #15
001AF6  EA0000     NEG W0, W0
001AF8  E90F00     DEC W0, [W14]
001AFA  78001E     MOV [W14], W0
001AFC  DE004F     LSR W0, #15, W0
3381:              			}
3382:              			( void ) xTaskResumeAll();
001AFE  780F00     MOV W0, [W14]
001B00  07FDB4     RCALL xTaskResumeAll
3383:              
3384:              			if( xListIsEmpty == pdFALSE )
001B02  78001E     MOV [W14], W0
001B04  E00000     CP0 W0
001B06  3A0013     BRA NZ, .L128, .LBE12
3385:              			{
3386:              				TCB_t *pxTCB;
3387:              
3388:              				taskENTER_CRITICAL();
001B08  0248DA     CALL vPortEnterCritical
001B0A  000000     NOP
3389:              				{
3390:              					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
001B0C  80E800     MOV 0x1D00, W0
001B0E  900030     MOV [W0+6], W0
001B10  980710     MOV W0, [W14+2]
3391:              					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
001B12  90001E     MOV [W14+2], W0
001B14  E88000     INC2 W0, W0
001B16  0249F0     CALL uxListRemove
001B18  000000     NOP
3392:              					--uxCurrentNumberOfTasks;
001B1A  8042C0     MOV uxCurrentNumberOfTasks, W0
001B1C  E90000     DEC W0, W0
001B1E  8842C0     MOV W0, uxCurrentNumberOfTasks
3393:              					--uxDeletedTasksWaitingCleanUp;
001B20  8042B0     MOV uxDeletedTasksWaitingCleanUp, W0
001B22  E90000     DEC W0, W0
001B24  8842B0     MOV W0, uxDeletedTasksWaitingCleanUp
3394:              				}
3395:              				taskEXIT_CRITICAL();
001B26  0248F4     CALL vPortExitCritical
001B28  000000     NOP
3396:              
3397:              				prvDeleteTCB( pxTCB );
001B2A  90001E     MOV [W14+2], W0
001B2C  070005     RCALL prvDeleteTCB
3398:              			}
3399:              			else
3400:              			{
3401:              				mtCOVERAGE_TEST_MARKER();
3402:              			}
3403:              		}
3404:              	}
3405:              	#endif /* INCLUDE_vTaskDelete */
3406:              }
001B34  FA8000     ULNK
001B36  060000     RETURN
3407:              /*-----------------------------------------------------------*/
3408:              
3409:              #if( configUSE_TRACE_FACILITY == 1 )
3410:              
3411:              	void vTaskGetInfo( TaskHandle_t xTask, TaskStatus_t *pxTaskStatus, BaseType_t xGetFreeStackSpace, eTaskState eState )
3412:              	{
3413:              	TCB_t *pxTCB;
3414:              
3415:              		/* xTask is NULL then get the state of the calling task. */
3416:              		pxTCB = prvGetTCBFromHandle( xTask );
3417:              
3418:              		pxTaskStatus->xHandle = ( TaskHandle_t ) pxTCB;
3419:              		pxTaskStatus->pcTaskName = ( const char * ) &( pxTCB->pcTaskName [ 0 ] );
3420:              		pxTaskStatus->uxCurrentPriority = pxTCB->uxPriority;
3421:              		pxTaskStatus->pxStackBase = pxTCB->pxStack;
3422:              		pxTaskStatus->xTaskNumber = pxTCB->uxTCBNumber;
3423:              
3424:              		#if ( INCLUDE_vTaskSuspend == 1 )
3425:              		{
3426:              			/* If the task is in the suspended list then there is a chance it is
3427:              			actually just blocked indefinitely - so really it should be reported as
3428:              			being in the Blocked state. */
3429:              			if( pxTaskStatus->eCurrentState == eSuspended )
3430:              			{
3431:              				vTaskSuspendAll();
3432:              				{
3433:              					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
3434:              					{
3435:              						pxTaskStatus->eCurrentState = eBlocked;
3436:              					}
3437:              				}
3438:              				xTaskResumeAll();
3439:              			}
3440:              		}
3441:              		#endif /* INCLUDE_vTaskSuspend */
3442:              
3443:              		#if ( configUSE_MUTEXES == 1 )
3444:              		{
3445:              			pxTaskStatus->uxBasePriority = pxTCB->uxBasePriority;
3446:              		}
3447:              		#else
3448:              		{
3449:              			pxTaskStatus->uxBasePriority = 0;
3450:              		}
3451:              		#endif
3452:              
3453:              		#if ( configGENERATE_RUN_TIME_STATS == 1 )
3454:              		{
3455:              			pxTaskStatus->ulRunTimeCounter = pxTCB->ulRunTimeCounter;
3456:              		}
3457:              		#else
3458:              		{
3459:              			pxTaskStatus->ulRunTimeCounter = 0;
3460:              		}
3461:              		#endif
3462:              
3463:              		/* Obtaining the task state is a little fiddly, so is only done if the value
3464:              		of eState passed into this function is eInvalid - otherwise the state is
3465:              		just set to whatever is passed in. */
3466:              		if( eState != eInvalid )
3467:              		{
3468:              			pxTaskStatus->eCurrentState = eState;
3469:              		}
3470:              		else
3471:              		{
3472:              			pxTaskStatus->eCurrentState = eTaskGetState( xTask );
3473:              		}
3474:              
3475:              		/* Obtaining the stack space takes some time, so the xGetFreeStackSpace
3476:              		parameter is provided to allow it to be skipped. */
3477:              		if( xGetFreeStackSpace != pdFALSE )
3478:              		{
3479:              			#if ( portSTACK_GROWTH > 0 )
3480:              			{
3481:              				pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxTCB->pxEndOfStack );
3482:              			}
3483:              			#else
3484:              			{
3485:              				pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxTCB->pxStack );
3486:              			}
3487:              			#endif
3488:              		}
3489:              		else
3490:              		{
3491:              			pxTaskStatus->usStackHighWaterMark = 0;
3492:              		}
3493:              	}
3494:              
3495:              #endif /* configUSE_TRACE_FACILITY */
3496:              /*-----------------------------------------------------------*/
3497:              
3498:              #if ( configUSE_TRACE_FACILITY == 1 )
3499:              
3500:              	static UBaseType_t prvListTasksWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, eTaskState eState )
3501:              	{
3502:              	volatile TCB_t *pxNextTCB, *pxFirstTCB;
3503:              	UBaseType_t uxTask = 0;
3504:              
3505:              		if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
3506:              		{
3507:              			listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
3508:              
3509:              			/* Populate an TaskStatus_t structure within the
3510:              			pxTaskStatusArray array for each task that is referenced from
3511:              			pxList.  See the definition of TaskStatus_t in task.h for the
3512:              			meaning of each TaskStatus_t structure member. */
3513:              			do
3514:              			{
3515:              				listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
3516:              				vTaskGetInfo( ( TaskHandle_t ) pxNextTCB, &( pxTaskStatusArray[ uxTask ] ), pdTRUE, eState );
3517:              				uxTask++;
3518:              			} while( pxNextTCB != pxFirstTCB );
3519:              		}
3520:              		else
3521:              		{
3522:              			mtCOVERAGE_TEST_MARKER();
3523:              		}
3524:              
3525:              		return uxTask;
3526:              	}
3527:              
3528:              #endif /* configUSE_TRACE_FACILITY */
3529:              /*-----------------------------------------------------------*/
3530:              
3531:              #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
3532:              
3533:              	static uint16_t prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte )
3534:              	{
3535:              	uint32_t ulCount = 0U;
3536:              
3537:              		while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
3538:              		{
3539:              			pucStackByte -= portSTACK_GROWTH;
3540:              			ulCount++;
3541:              		}
3542:              
3543:              		ulCount /= ( uint32_t ) sizeof( StackType_t ); /*lint !e961 Casting is not redundant on smaller architectures. */
3544:              
3545:              		return ( uint16_t ) ulCount;
3546:              	}
3547:              
3548:              #endif /* ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) ) */
3549:              /*-----------------------------------------------------------*/
3550:              
3551:              #if ( INCLUDE_uxTaskGetStackHighWaterMark == 1 )
3552:              
3553:              	UBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask )
3554:              	{
3555:              	TCB_t *pxTCB;
3556:              	uint8_t *pucEndOfStack;
3557:              	UBaseType_t uxReturn;
3558:              
3559:              		pxTCB = prvGetTCBFromHandle( xTask );
3560:              
3561:              		#if portSTACK_GROWTH < 0
3562:              		{
3563:              			pucEndOfStack = ( uint8_t * ) pxTCB->pxStack;
3564:              		}
3565:              		#else
3566:              		{
3567:              			pucEndOfStack = ( uint8_t * ) pxTCB->pxEndOfStack;
3568:              		}
3569:              		#endif
3570:              
3571:              		uxReturn = ( UBaseType_t ) prvTaskCheckFreeStackSpace( pucEndOfStack );
3572:              
3573:              		return uxReturn;
3574:              	}
3575:              
3576:              #endif /* INCLUDE_uxTaskGetStackHighWaterMark */
3577:              /*-----------------------------------------------------------*/
3578:              
3579:              #if ( INCLUDE_vTaskDelete == 1 )
3580:              
3581:              	static void prvDeleteTCB( TCB_t *pxTCB )
3582:              	{
001B38  FA0002     LNK #0x2
001B3A  780F00     MOV W0, [W14]
3583:              		/* This call is required specifically for the TriCore port.  It must be
3584:              		above the vPortFree() calls.  The call is also used by ports/demos that
3585:              		want to allocate and clean RAM statically. */
3586:              		portCLEAN_UP_TCB( pxTCB );
3587:              
3588:              		/* Free up the memory allocated by the scheduler for the task.  It is up
3589:              		to the task to free any memory allocated at the application level. */
3590:              		#if ( configUSE_NEWLIB_REENTRANT == 1 )
3591:              		{
3592:              			_reclaim_reent( &( pxTCB->xNewLib_reent ) );
3593:              		}
3594:              		#endif /* configUSE_NEWLIB_REENTRANT */
3595:              
3596:              		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
3597:              		{
3598:              			/* The task can only have been allocated dynamically - free both
3599:              			the stack and TCB. */
3600:              			vPortFree( pxTCB->pxStack );
001B3C  78001E     MOV [W14], W0
001B3E  900840     MOV [W0+24], W0
001B40  023D68     CALL vPortFree
001B42  000000     NOP
3601:              			vPortFree( pxTCB );
001B44  78001E     MOV [W14], W0
001B46  023D68     CALL vPortFree
001B48  000000     NOP
3602:              		}
3603:              		#elif( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE == 1 )
3604:              		{
3605:              			/* The task could have been allocated statically or dynamically, so
3606:              			check what was statically allocated before trying to free the
3607:              			memory. */
3608:              			if( pxTCB->ucStaticallyAllocated == tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB )
3609:              			{
3610:              				/* Both the stack and TCB were allocated dynamically, so both
3611:              				must be freed. */
3612:              				vPortFree( pxTCB->pxStack );
3613:              				vPortFree( pxTCB );
3614:              			}
3615:              			else if( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_ONLY )
3616:              			{
3617:              				/* Only the stack was statically allocated, so the TCB is the
3618:              				only memory that must be freed. */
3619:              				vPortFree( pxTCB );
3620:              			}
3621:              			else
3622:              			{
3623:              				/* Neither the stack nor the TCB were allocated dynamically, so
3624:              				nothing needs to be freed. */
3625:              				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	)
3626:              				mtCOVERAGE_TEST_MARKER();
3627:              			}
3628:              		}
3629:              		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
3630:              	}
001B4A  FA8000     ULNK
001B4C  060000     RETURN
3631:              
3632:              #endif /* INCLUDE_vTaskDelete */
3633:              /*-----------------------------------------------------------*/
3634:              
3635:              static void prvResetNextTaskUnblockTime( void )
3636:              {
001B4E  FA0002     LNK #0x2
3637:              TCB_t *pxTCB;
3638:              
3639:              	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
001B50  804290     MOV pxDelayedTaskList, W0
001B52  780010     MOV [W0], W0
001B54  E00000     CP0 W0
001B56  3A0003     BRA NZ, .L132
3640:              	{
3641:              		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
3642:              		the maximum possible value so it is	extremely unlikely that the
3643:              		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
3644:              		there is an item in the delayed list. */
3645:              		xNextTaskUnblockTime = portMAX_DELAY;
001B58  EB8000     SETM W0
001B5A  884340     MOV W0, xNextTaskUnblockTime
001B5C  370007     BRA .L131
3646:              	}
3647:              	else
3648:              	{
3649:              		/* The new current delayed list is not empty, get the value of
3650:              		the item at the head of the delayed list.  This is the time at
3651:              		which the task at the head of the delayed list should be removed
3652:              		from the Blocked state. */
3653:              		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
001B5E  804290     MOV pxDelayedTaskList, W0
001B60  900030     MOV [W0+6], W0
001B62  900030     MOV [W0+6], W0
001B64  780F00     MOV W0, [W14]
3654:              		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
001B66  78001E     MOV [W14], W0
001B68  900010     MOV [W0+2], W0
001B6A  884340     MOV W0, xNextTaskUnblockTime
3655:              	}
3656:              }
001B6C  FA8000     ULNK
001B6E  060000     RETURN
3657:              /*-----------------------------------------------------------*/
3658:              
3659:              #if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )
3660:              
3661:              	TaskHandle_t xTaskGetCurrentTaskHandle( void )
3662:              	{
3663:              	TaskHandle_t xReturn;
3664:              
3665:              		/* A critical section is not required as this is not called from
3666:              		an interrupt and the current TCB will always be the same for any
3667:              		individual execution thread. */
3668:              		xReturn = pxCurrentTCB;
3669:              
3670:              		return xReturn;
3671:              	}
3672:              
3673:              #endif /* ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) ) */
3674:              /*-----------------------------------------------------------*/
3675:              
3676:              #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
3677:              
3678:              	BaseType_t xTaskGetSchedulerState( void )
3679:              	{
3680:              	BaseType_t xReturn;
3681:              
3682:              		if( xSchedulerRunning == pdFALSE )
3683:              		{
3684:              			xReturn = taskSCHEDULER_NOT_STARTED;
3685:              		}
3686:              		else
3687:              		{
3688:              			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
3689:              			{
3690:              				xReturn = taskSCHEDULER_RUNNING;
3691:              			}
3692:              			else
3693:              			{
3694:              				xReturn = taskSCHEDULER_SUSPENDED;
3695:              			}
3696:              		}
3697:              
3698:              		return xReturn;
3699:              	}
3700:              
3701:              #endif /* ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) ) */
3702:              /*-----------------------------------------------------------*/
3703:              
3704:              #if ( configUSE_MUTEXES == 1 )
3705:              
3706:              	void vTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
3707:              	{
3708:              	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
3709:              
3710:              		/* If the mutex was given back by an interrupt while the queue was
3711:              		locked then the mutex holder might now be NULL. */
3712:              		if( pxMutexHolder != NULL )
3713:              		{
3714:              			/* If the holder of the mutex has a priority below the priority of
3715:              			the task attempting to obtain the mutex then it will temporarily
3716:              			inherit the priority of the task attempting to obtain the mutex. */
3717:              			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
3718:              			{
3719:              				/* Adjust the mutex holder state to account for its new
3720:              				priority.  Only reset the event list item value if the value is
3721:              				not	being used for anything else. */
3722:              				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
3723:              				{
3724:              					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
3725:              				}
3726:              				else
3727:              				{
3728:              					mtCOVERAGE_TEST_MARKER();
3729:              				}
3730:              
3731:              				/* If the task being modified is in the ready state it will need
3732:              				to be moved into a new list. */
3733:              				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
3734:              				{
3735:              					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
3736:              					{
3737:              						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
3738:              					}
3739:              					else
3740:              					{
3741:              						mtCOVERAGE_TEST_MARKER();
3742:              					}
3743:              
3744:              					/* Inherit the priority before being moved into the new list. */
3745:              					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
3746:              					prvAddTaskToReadyList( pxTCB );
3747:              				}
3748:              				else
3749:              				{
3750:              					/* Just inherit the priority. */
3751:              					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
3752:              				}
3753:              
3754:              				traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
3755:              			}
3756:              			else
3757:              			{
3758:              				mtCOVERAGE_TEST_MARKER();
3759:              			}
3760:              		}
3761:              		else
3762:              		{
3763:              			mtCOVERAGE_TEST_MARKER();
3764:              		}
3765:              	}
3766:              
3767:              #endif /* configUSE_MUTEXES */
3768:              /*-----------------------------------------------------------*/
3769:              
3770:              #if ( configUSE_MUTEXES == 1 )
3771:              
3772:              	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
3773:              	{
3774:              	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
3775:              	BaseType_t xReturn = pdFALSE;
3776:              
3777:              		if( pxMutexHolder != NULL )
3778:              		{
3779:              			/* A task can only have an inherited priority if it holds the mutex.
3780:              			If the mutex is held by a task then it cannot be given from an
3781:              			interrupt, and if a mutex is given by the holding task then it must
3782:              			be the running state task. */
3783:              			configASSERT( pxTCB == pxCurrentTCB );
3784:              
3785:              			configASSERT( pxTCB->uxMutexesHeld );
3786:              			( pxTCB->uxMutexesHeld )--;
3787:              
3788:              			/* Has the holder of the mutex inherited the priority of another
3789:              			task? */
3790:              			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
3791:              			{
3792:              				/* Only disinherit if no other mutexes are held. */
3793:              				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
3794:              				{
3795:              					/* A task can only have an inherited priority if it holds
3796:              					the mutex.  If the mutex is held by a task then it cannot be
3797:              					given from an interrupt, and if a mutex is given by the
3798:              					holding	task then it must be the running state task.  Remove
3799:              					the	holding task from the ready	list. */
3800:              					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
3801:              					{
3802:              						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
3803:              					}
3804:              					else
3805:              					{
3806:              						mtCOVERAGE_TEST_MARKER();
3807:              					}
3808:              
3809:              					/* Disinherit the priority before adding the task into the
3810:              					new	ready list. */
3811:              					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
3812:              					pxTCB->uxPriority = pxTCB->uxBasePriority;
3813:              
3814:              					/* Reset the event list item value.  It cannot be in use for
3815:              					any other purpose if this task is running, and it must be
3816:              					running to give back the mutex. */
3817:              					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
3818:              					prvAddTaskToReadyList( pxTCB );
3819:              
3820:              					/* Return true to indicate that a context switch is required.
3821:              					This is only actually required in the corner case whereby
3822:              					multiple mutexes were held and the mutexes were given back
3823:              					in an order different to that in which they were taken.
3824:              					If a context switch did not occur when the first mutex was
3825:              					returned, even if a task was waiting on it, then a context
3826:              					switch should occur when the last mutex is returned whether
3827:              					a task is waiting on it or not. */
3828:              					xReturn = pdTRUE;
3829:              				}
3830:              				else
3831:              				{
3832:              					mtCOVERAGE_TEST_MARKER();
3833:              				}
3834:              			}
3835:              			else
3836:              			{
3837:              				mtCOVERAGE_TEST_MARKER();
3838:              			}
3839:              		}
3840:              		else
3841:              		{
3842:              			mtCOVERAGE_TEST_MARKER();
3843:              		}
3844:              
3845:              		return xReturn;
3846:              	}
3847:              
3848:              #endif /* configUSE_MUTEXES */
3849:              /*-----------------------------------------------------------*/
3850:              
3851:              #if ( portCRITICAL_NESTING_IN_TCB == 1 )
3852:              
3853:              	void vTaskEnterCritical( void )
3854:              	{
3855:              		portDISABLE_INTERRUPTS();
3856:              
3857:              		if( xSchedulerRunning != pdFALSE )
3858:              		{
3859:              			( pxCurrentTCB->uxCriticalNesting )++;
3860:              
3861:              			/* This is not the interrupt safe version of the enter critical
3862:              			function so	assert() if it is being called from an interrupt
3863:              			context.  Only API functions that end in "FromISR" can be used in an
3864:              			interrupt.  Only assert if the critical nesting count is 1 to
3865:              			protect against recursive calls if the assert function also uses a
3866:              			critical section. */
3867:              			if( pxCurrentTCB->uxCriticalNesting == 1 )
3868:              			{
3869:              				portASSERT_IF_IN_ISR();
3870:              			}
3871:              		}
3872:              		else
3873:              		{
3874:              			mtCOVERAGE_TEST_MARKER();
3875:              		}
3876:              	}
3877:              
3878:              #endif /* portCRITICAL_NESTING_IN_TCB */
3879:              /*-----------------------------------------------------------*/
3880:              
3881:              #if ( portCRITICAL_NESTING_IN_TCB == 1 )
3882:              
3883:              	void vTaskExitCritical( void )
3884:              	{
3885:              		if( xSchedulerRunning != pdFALSE )
3886:              		{
3887:              			if( pxCurrentTCB->uxCriticalNesting > 0U )
3888:              			{
3889:              				( pxCurrentTCB->uxCriticalNesting )--;
3890:              
3891:              				if( pxCurrentTCB->uxCriticalNesting == 0U )
3892:              				{
3893:              					portENABLE_INTERRUPTS();
3894:              				}
3895:              				else
3896:              				{
3897:              					mtCOVERAGE_TEST_MARKER();
3898:              				}
3899:              			}
3900:              			else
3901:              			{
3902:              				mtCOVERAGE_TEST_MARKER();
3903:              			}
3904:              		}
3905:              		else
3906:              		{
3907:              			mtCOVERAGE_TEST_MARKER();
3908:              		}
3909:              	}
3910:              
3911:              #endif /* portCRITICAL_NESTING_IN_TCB */
3912:              /*-----------------------------------------------------------*/
3913:              
3914:              #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) )
3915:              
3916:              	static char *prvWriteNameToBuffer( char *pcBuffer, const char *pcTaskName )
3917:              	{
3918:              	size_t x;
3919:              
3920:              		/* Start by copying the entire string. */
3921:              		strcpy( pcBuffer, pcTaskName );
3922:              
3923:              		/* Pad the end of the string with spaces to ensure columns line up when
3924:              		printed out. */
3925:              		for( x = strlen( pcBuffer ); x < ( size_t ) ( configMAX_TASK_NAME_LEN - 1 ); x++ )
3926:              		{
3927:              			pcBuffer[ x ] = ' ';
3928:              		}
3929:              
3930:              		/* Terminate. */
3931:              		pcBuffer[ x ] = 0x00;
3932:              
3933:              		/* Return the new end of string. */
3934:              		return &( pcBuffer[ x ] );
3935:              	}
3936:              
3937:              #endif /* ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) */
3938:              /*-----------------------------------------------------------*/
3939:              
3940:              #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) )
3941:              
3942:              	void vTaskList( char * pcWriteBuffer )
3943:              	{
3944:              	TaskStatus_t *pxTaskStatusArray;
3945:              	volatile UBaseType_t uxArraySize, x;
3946:              	char cStatus;
3947:              
3948:              		/*
3949:              		 * PLEASE NOTE:
3950:              		 *
3951:              		 * This function is provided for convenience only, and is used by many
3952:              		 * of the demo applications.  Do not consider it to be part of the
3953:              		 * scheduler.
3954:              		 *
3955:              		 * vTaskList() calls uxTaskGetSystemState(), then formats part of the
3956:              		 * uxTaskGetSystemState() output into a human readable table that
3957:              		 * displays task names, states and stack usage.
3958:              		 *
3959:              		 * vTaskList() has a dependency on the sprintf() C library function that
3960:              		 * might bloat the code size, use a lot of stack, and provide different
3961:              		 * results on different platforms.  An alternative, tiny, third party,
3962:              		 * and limited functionality implementation of sprintf() is provided in
3963:              		 * many of the FreeRTOS/Demo sub-directories in a file called
3964:              		 * printf-stdarg.c (note printf-stdarg.c does not provide a full
3965:              		 * snprintf() implementation!).
3966:              		 *
3967:              		 * It is recommended that production systems call uxTaskGetSystemState()
3968:              		 * directly to get access to raw stats data, rather than indirectly
3969:              		 * through a call to vTaskList().
3970:              		 */
3971:              
3972:              
3973:              		/* Make sure the write buffer does not contain a string. */
3974:              		*pcWriteBuffer = 0x00;
3975:              
3976:              		/* Take a snapshot of the number of tasks in case it changes while this
3977:              		function is executing. */
3978:              		uxArraySize = uxCurrentNumberOfTasks;
3979:              
3980:              		/* Allocate an array index for each task.  NOTE!  if
3981:              		configSUPPORT_DYNAMIC_ALLOCATION is set to 0 then pvPortMalloc() will
3982:              		equate to NULL. */
3983:              		pxTaskStatusArray = pvPortMalloc( uxCurrentNumberOfTasks * sizeof( TaskStatus_t ) );
3984:              
3985:              		if( pxTaskStatusArray != NULL )
3986:              		{
3987:              			/* Generate the (binary) data. */
3988:              			uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, NULL );
3989:              
3990:              			/* Create a human readable table from the binary data. */
3991:              			for( x = 0; x < uxArraySize; x++ )
3992:              			{
3993:              				switch( pxTaskStatusArray[ x ].eCurrentState )
3994:              				{
3995:              					case eReady:		cStatus = tskREADY_CHAR;
3996:              										break;
3997:              
3998:              					case eBlocked:		cStatus = tskBLOCKED_CHAR;
3999:              										break;
4000:              
4001:              					case eSuspended:	cStatus = tskSUSPENDED_CHAR;
4002:              										break;
4003:              
4004:              					case eDeleted:		cStatus = tskDELETED_CHAR;
4005:              										break;
4006:              
4007:              					default:			/* Should not get here, but it is included
4008:              										to prevent static checking errors. */
4009:              										cStatus = 0x00;
4010:              										break;
4011:              				}
4012:              
4013:              				/* Write the task name to the string, padding with spaces so it
4014:              				can be printed in tabular form more easily. */
4015:              				pcWriteBuffer = prvWriteNameToBuffer( pcWriteBuffer, pxTaskStatusArray[ x ].pcTaskName );
4016:              
4017:              				/* Write the rest of the string. */
4018:              				sprintf( pcWriteBuffer, "\t%c\t%u\t%u\t%u\r\n", cStatus, ( unsigned int ) pxTaskStatusArray[ x ].uxCurrentPriority, ( unsigned int ) pxTaskStatusArray[ x ].usStackHighWaterMark, ( unsigned int ) pxTaskStatusArray[ x ].xTaskNumber );
4019:              				pcWriteBuffer += strlen( pcWriteBuffer );
4020:              			}
4021:              
4022:              			/* Free the array again.  NOTE!  If configSUPPORT_DYNAMIC_ALLOCATION
4023:              			is 0 then vPortFree() will be #defined to nothing. */
4024:              			vPortFree( pxTaskStatusArray );
4025:              		}
4026:              		else
4027:              		{
4028:              			mtCOVERAGE_TEST_MARKER();
4029:              		}
4030:              	}
4031:              
4032:              #endif /* ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) ) */
4033:              /*----------------------------------------------------------*/
4034:              
4035:              #if ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) )
4036:              
4037:              	void vTaskGetRunTimeStats( char *pcWriteBuffer )
4038:              	{
4039:              	TaskStatus_t *pxTaskStatusArray;
4040:              	volatile UBaseType_t uxArraySize, x;
4041:              	uint32_t ulTotalTime, ulStatsAsPercentage;
4042:              
4043:              		#if( configUSE_TRACE_FACILITY != 1 )
4044:              		{
4045:              			#error configUSE_TRACE_FACILITY must also be set to 1 in FreeRTOSConfig.h to use vTaskGetRunTimeStats().
4046:              		}
4047:              		#endif
4048:              
4049:              		/*
4050:              		 * PLEASE NOTE:
4051:              		 *
4052:              		 * This function is provided for convenience only, and is used by many
4053:              		 * of the demo applications.  Do not consider it to be part of the
4054:              		 * scheduler.
4055:              		 *
4056:              		 * vTaskGetRunTimeStats() calls uxTaskGetSystemState(), then formats part
4057:              		 * of the uxTaskGetSystemState() output into a human readable table that
4058:              		 * displays the amount of time each task has spent in the Running state
4059:              		 * in both absolute and percentage terms.
4060:              		 *
4061:              		 * vTaskGetRunTimeStats() has a dependency on the sprintf() C library
4062:              		 * function that might bloat the code size, use a lot of stack, and
4063:              		 * provide different results on different platforms.  An alternative,
4064:              		 * tiny, third party, and limited functionality implementation of
4065:              		 * sprintf() is provided in many of the FreeRTOS/Demo sub-directories in
4066:              		 * a file called printf-stdarg.c (note printf-stdarg.c does not provide
4067:              		 * a full snprintf() implementation!).
4068:              		 *
4069:              		 * It is recommended that production systems call uxTaskGetSystemState()
4070:              		 * directly to get access to raw stats data, rather than indirectly
4071:              		 * through a call to vTaskGetRunTimeStats().
4072:              		 */
4073:              
4074:              		/* Make sure the write buffer does not contain a string. */
4075:              		*pcWriteBuffer = 0x00;
4076:              
4077:              		/* Take a snapshot of the number of tasks in case it changes while this
4078:              		function is executing. */
4079:              		uxArraySize = uxCurrentNumberOfTasks;
4080:              
4081:              		/* Allocate an array index for each task.  NOTE!  If
4082:              		configSUPPORT_DYNAMIC_ALLOCATION is set to 0 then pvPortMalloc() will
4083:              		equate to NULL. */
4084:              		pxTaskStatusArray = pvPortMalloc( uxCurrentNumberOfTasks * sizeof( TaskStatus_t ) );
4085:              
4086:              		if( pxTaskStatusArray != NULL )
4087:              		{
4088:              			/* Generate the (binary) data. */
4089:              			uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, &ulTotalTime );
4090:              
4091:              			/* For percentage calculations. */
4092:              			ulTotalTime /= 100UL;
4093:              
4094:              			/* Avoid divide by zero errors. */
4095:              			if( ulTotalTime > 0 )
4096:              			{
4097:              				/* Create a human readable table from the binary data. */
4098:              				for( x = 0; x < uxArraySize; x++ )
4099:              				{
4100:              					/* What percentage of the total run time has the task used?
4101:              					This will always be rounded down to the nearest integer.
4102:              					ulTotalRunTimeDiv100 has already been divided by 100. */
4103:              					ulStatsAsPercentage = pxTaskStatusArray[ x ].ulRunTimeCounter / ulTotalTime;
4104:              
4105:              					/* Write the task name to the string, padding with
4106:              					spaces so it can be printed in tabular form more
4107:              					easily. */
4108:              					pcWriteBuffer = prvWriteNameToBuffer( pcWriteBuffer, pxTaskStatusArray[ x ].pcTaskName );
4109:              
4110:              					if( ulStatsAsPercentage > 0UL )
4111:              					{
4112:              						#ifdef portLU_PRINTF_SPECIFIER_REQUIRED
4113:              						{
4114:              							sprintf( pcWriteBuffer, "\t%lu\t\t%lu%%\r\n", pxTaskStatusArray[ x ].ulRunTimeCounter, ulStatsAsPercentage );
4115:              						}
4116:              						#else
4117:              						{
4118:              							/* sizeof( int ) == sizeof( long ) so a smaller
4119:              							printf() library can be used. */
4120:              							sprintf( pcWriteBuffer, "\t%u\t\t%u%%\r\n", ( unsigned int ) pxTaskStatusArray[ x ].ulRunTimeCounter, ( unsigned int ) ulStatsAsPercentage );
4121:              						}
4122:              						#endif
4123:              					}
4124:              					else
4125:              					{
4126:              						/* If the percentage is zero here then the task has
4127:              						consumed less than 1% of the total run time. */
4128:              						#ifdef portLU_PRINTF_SPECIFIER_REQUIRED
4129:              						{
4130:              							sprintf( pcWriteBuffer, "\t%lu\t\t<1%%\r\n", pxTaskStatusArray[ x ].ulRunTimeCounter );
4131:              						}
4132:              						#else
4133:              						{
4134:              							/* sizeof( int ) == sizeof( long ) so a smaller
4135:              							printf() library can be used. */
4136:              							sprintf( pcWriteBuffer, "\t%u\t\t<1%%\r\n", ( unsigned int ) pxTaskStatusArray[ x ].ulRunTimeCounter );
4137:              						}
4138:              						#endif
4139:              					}
4140:              
4141:              					pcWriteBuffer += strlen( pcWriteBuffer );
4142:              				}
4143:              			}
4144:              			else
4145:              			{
4146:              				mtCOVERAGE_TEST_MARKER();
4147:              			}
4148:              
4149:              			/* Free the array again.  NOTE!  If configSUPPORT_DYNAMIC_ALLOCATION
4150:              			is 0 then vPortFree() will be #defined to nothing. */
4151:              			vPortFree( pxTaskStatusArray );
4152:              		}
4153:              		else
4154:              		{
4155:              			mtCOVERAGE_TEST_MARKER();
4156:              		}
4157:              	}
4158:              
4159:              #endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) ) */
4160:              /*-----------------------------------------------------------*/
4161:              
4162:              TickType_t uxTaskResetEventItemValue( void )
4163:              {
001B70  FA0002     LNK #0x2
4164:              TickType_t uxReturn;
4165:              
4166:              	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
001B72  804280     MOV pxCurrentTCB, W0
001B74  9000E0     MOV [W0+12], W1
001B76  780F01     MOV W1, [W14]
4167:              
4168:              	/* Reset the event list item to its normal value - so it can be used with
4169:              	queues and semaphores. */
4170:              	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
001B78  804280     MOV pxCurrentTCB, W0
001B7A  804281     MOV pxCurrentTCB, W1
001B7C  9008B1     MOV [W1+22], W1
001B7E  1080E4     SUBR W1, #0x4, W1
001B80  980061     MOV W1, [W0+12]
4171:              
4172:              	return uxReturn;
001B82  78001E     MOV [W14], W0
4173:              }
001B84  FA8000     ULNK
001B86  060000     RETURN
4174:              /*-----------------------------------------------------------*/
4175:              
4176:              #if ( configUSE_MUTEXES == 1 )
4177:              
4178:              	void *pvTaskIncrementMutexHeldCount( void )
4179:              	{
4180:              		/* If xSemaphoreCreateMutex() is called before any tasks have been created
4181:              		then pxCurrentTCB will be NULL. */
4182:              		if( pxCurrentTCB != NULL )
4183:              		{
4184:              			( pxCurrentTCB->uxMutexesHeld )++;
4185:              		}
4186:              
4187:              		return pxCurrentTCB;
4188:              	}
4189:              
4190:              #endif /* configUSE_MUTEXES */
4191:              /*-----------------------------------------------------------*/
4192:              
4193:              #if( configUSE_TASK_NOTIFICATIONS == 1 )
4194:              
4195:              	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
4196:              	{
001B88  FA0008     LNK #0x8
001B8A  980720     MOV W0, [W14+4]
001B8C  980731     MOV W1, [W14+6]
4197:              	uint32_t ulReturn;
4198:              
4199:              		taskENTER_CRITICAL();
001B8E  0248DA     CALL vPortEnterCritical
001B90  000000     NOP
4200:              		{
4201:              			/* Only block if the notification count is not already non-zero. */
4202:              			if( pxCurrentTCB->ulNotifiedValue == 0UL )
001B92  804280     MOV pxCurrentTCB, W0
001B94  901090     MOV [W0+34], W1
001B96  901000     MOV [W0+32], W0
001B98  500FE0     SUB W0, #0x0, [W15]
001B9A  588FE0     SUBB W1, #0x0, [W15]
001B9C  3A000C     BRA NZ, .L136
4203:              			{
4204:              				/* Mark this task as waiting for a notification. */
4205:              				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
001B9E  804280     MOV pxCurrentTCB, W0
001BA0  B3C011     MOV.B #0x1, W1
001BA2  986041     MOV.B W1, [W0+36]
4206:              
4207:              				if( xTicksToWait > ( TickType_t ) 0 )
001BA4  90003E     MOV [W14+6], W0
001BA6  E00000     CP0 W0
001BA8  320006     BRA Z, .L136
4208:              				{
4209:              					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
001BAA  200011     MOV #0x1, W1
001BAC  90003E     MOV [W14+6], W0
001BAE  0701EB     RCALL prvAddCurrentTaskToDelayedList
4210:              					traceTASK_NOTIFY_TAKE_BLOCK();
4211:              
4212:              					/* All ports are written to allow a yield in a critical
4213:              					section (some will yield immediately, others wait until the
4214:              					critical section exits) - but it is not something that
4215:              					application code should ever do. */
4216:              					portYIELD_WITHIN_API();
001BB0  0250DC     CALL .Letext0, .LFE1, _vPortYield
001BB2  000000     NOP
001BB4  000000     NOP
4217:              				}
4218:              				else
4219:              				{
4220:              					mtCOVERAGE_TEST_MARKER();
4221:              				}
4222:              			}
4223:              			else
4224:              			{
4225:              				mtCOVERAGE_TEST_MARKER();
4226:              			}
4227:              		}
4228:              		taskEXIT_CRITICAL();
001BB6  0248F4     CALL vPortExitCritical
001BB8  000000     NOP
4229:              
4230:              		taskENTER_CRITICAL();
001BBA  0248DA     CALL vPortEnterCritical
001BBC  000000     NOP
4231:              		{
4232:              			traceTASK_NOTIFY_TAKE();
4233:              			ulReturn = pxCurrentTCB->ulNotifiedValue;
001BBE  804280     MOV pxCurrentTCB, W0
001BC0  901100     MOV [W0+32], W2
001BC2  901190     MOV [W0+34], W3
001BC4  BE8F02     MOV.D W2, [W14]
4234:              
4235:              			if( ulReturn != 0UL )
001BC6  BE001E     MOV.D [W14], W0
001BC8  500FE0     SUB W0, #0x0, [W15]
001BCA  588FE0     SUBB W1, #0x0, [W15]
001BCC  32000F     BRA Z, .L137
4236:              			{
4237:              				if( xClearCountOnExit != pdFALSE )
001BCE  90002E     MOV [W14+4], W0
001BD0  E00000     CP0 W0
001BD2  320005     BRA Z, .L138
4238:              				{
4239:              					pxCurrentTCB->ulNotifiedValue = 0UL;
001BD4  804282     MOV pxCurrentTCB, W2
001BD6  B80060     MUL.UU W0, #0, W0
001BD8  981100     MOV W0, [W2+32]
001BDA  981111     MOV W1, [W2+34]
001BDC  370007     BRA .L137
4240:              				}
4241:              				else
4242:              				{
4243:              					pxCurrentTCB->ulNotifiedValue = ulReturn - 1;
001BDE  804282     MOV pxCurrentTCB, W2
001BE0  EB8200     SETM W4
001BE2  EB8280     SETM W5
001BE4  42003E     ADD W4, [W14++], W0
001BE6  4A80AE     ADDC W5, [W14--], W1
001BE8  981100     MOV W0, [W2+32]
001BEA  981111     MOV W1, [W2+34]
4244:              				}
4245:              			}
4246:              			else
4247:              			{
4248:              				mtCOVERAGE_TEST_MARKER();
4249:              			}
4250:              
4251:              			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
001BEC  804280     MOV pxCurrentTCB, W0
001BEE  EB4080     CLR.B W1
001BF0  986041     MOV.B W1, [W0+36]
4252:              		}
4253:              		taskEXIT_CRITICAL();
001BF2  0248F4     CALL vPortExitCritical
001BF4  000000     NOP
4254:              
4255:              		return ulReturn;
001BF6  BE001E     MOV.D [W14], W0
4256:              	}
001BF8  FA8000     ULNK
001BFA  060000     RETURN
4257:              
4258:              #endif /* configUSE_TASK_NOTIFICATIONS */
4259:              /*-----------------------------------------------------------*/
4260:              
4261:              #if( configUSE_TASK_NOTIFICATIONS == 1 )
4262:              
4263:              	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
4264:              	{
001BFC  FA000E     LNK #0xE
001BFE  980710     MOV W0, [W14+2]
001C00  980721     MOV W1, [W14+4]
001C02  980732     MOV W2, [W14+6]
001C04  980743     MOV W3, [W14+8]
001C06  980754     MOV W4, [W14+10]
001C08  980765     MOV W5, [W14+12]
4265:              	BaseType_t xReturn;
4266:              
4267:              		taskENTER_CRITICAL();
001C0A  0248DA     CALL vPortEnterCritical
001C0C  000000     NOP
4268:              		{
4269:              			/* Only block if a notification is not already pending. */
4270:              			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
001C0E  804280     MOV pxCurrentTCB, W0
001C10  906040     MOV.B [W0+36], W0
001C12  504FE2     SUB.B W0, #0x2, [W15]
001C14  320022     BRA Z, .L140
4271:              			{
4272:              				/* Clear bits in the task's notification value as bits may get
4273:              				set	by the notifying task or interrupt.  This can be used to
4274:              				clear the value to zero. */
4275:              				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
001C16  804284     MOV pxCurrentTCB, W4
001C18  901104     MOV [W4+32], W2
001C1A  901194     MOV [W4+34], W3
001C1C  90001E     MOV [W14+2], W0
001C1E  9000AE     MOV [W14+4], W1
001C20  EA8000     COM W0, W0
001C22  EA8081     COM W1, W1
001C24  780282     MOV W2, W5
001C26  780103     MOV W3, W2
001C28  780180     MOV W0, W3
001C2A  780001     MOV W1, W0
001C2C  628283     AND W5, W3, W5
001C2E  610000     AND W2, W0, W0
001C30  EB0080     CLR W1
001C32  DD00C0     SL W0, #0, W1
001C34  200000     MOV #0x0, W0
001C36  BE0100     MOV.D W0, W2
001C38  B82861     MUL.UU W5, #1, W0
001C3A  710100     IOR W2, W0, W2
001C3C  718181     IOR W3, W1, W3
001C3E  981202     MOV W2, [W4+32]
001C40  981213     MOV W3, [W4+34]
4276:              
4277:              				/* Mark this task as waiting for a notification. */
4278:              				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
001C42  804280     MOV pxCurrentTCB, W0
001C44  B3C011     MOV.B #0x1, W1
001C46  986041     MOV.B W1, [W0+36]
4279:              
4280:              				if( xTicksToWait > ( TickType_t ) 0 )
001C48  90006E     MOV [W14+12], W0
001C4A  E00000     CP0 W0
001C4C  320006     BRA Z, .L140
4281:              				{
4282:              					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
001C4E  200011     MOV #0x1, W1
001C50  90006E     MOV [W14+12], W0
001C52  070199     RCALL prvAddCurrentTaskToDelayedList
4283:              					traceTASK_NOTIFY_WAIT_BLOCK();
4284:              
4285:              					/* All ports are written to allow a yield in a critical
4286:              					section (some will yield immediately, others wait until the
4287:              					critical section exits) - but it is not something that
4288:              					application code should ever do. */
4289:              					portYIELD_WITHIN_API();
001C54  0250DC     CALL .Letext0, .LFE1, _vPortYield
001C56  000000     NOP
001C58  000000     NOP
4290:              				}
4291:              				else
4292:              				{
4293:              					mtCOVERAGE_TEST_MARKER();
4294:              				}
4295:              			}
4296:              			else
4297:              			{
4298:              				mtCOVERAGE_TEST_MARKER();
4299:              			}
4300:              		}
4301:              		taskEXIT_CRITICAL();
001C5A  0248F4     CALL vPortExitCritical
001C5C  000000     NOP
4302:              
4303:              		taskENTER_CRITICAL();
001C5E  0248DA     CALL vPortEnterCritical
001C60  000000     NOP
4304:              		{
4305:              			traceTASK_NOTIFY_WAIT();
4306:              
4307:              			if( pulNotificationValue != NULL )
001C62  90005E     MOV [W14+10], W0
001C64  E00000     CP0 W0
001C66  320005     BRA Z, .L141
4308:              			{
4309:              				/* Output the current notification value, which may or may not
4310:              				have changed. */
4311:              				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
001C68  804280     MOV pxCurrentTCB, W0
001C6A  901090     MOV [W0+34], W1
001C6C  901000     MOV [W0+32], W0
001C6E  90015E     MOV [W14+10], W2
001C70  BE8900     MOV.D W0, [W2]
4312:              			}
4313:              
4314:              			/* If ucNotifyValue is set then either the task never entered the
4315:              			blocked state (because a notification was already pending) or the
4316:              			task unblocked because of a notification.  Otherwise the task
4317:              			unblocked because of a timeout. */
4318:              			if( pxCurrentTCB->ucNotifyState == taskWAITING_NOTIFICATION )
001C72  804280     MOV pxCurrentTCB, W0
001C74  906040     MOV.B [W0+36], W0
001C76  504FE1     SUB.B W0, #0x1, [W15]
001C78  3A0003     BRA NZ, .L142
4319:              			{
4320:              				/* A notification was not received. */
4321:              				xReturn = pdFALSE;
001C7A  EB0000     CLR W0
001C7C  780F00     MOV W0, [W14]
001C7E  370018     BRA .L143
4322:              			}
4323:              			else
4324:              			{
4325:              				/* A notification was already pending or a notification was
4326:              				received while the task was waiting. */
4327:              				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
001C80  804284     MOV pxCurrentTCB, W4
001C82  901104     MOV [W4+32], W2
001C84  901194     MOV [W4+34], W3
001C86  90003E     MOV [W14+6], W0
001C88  9000CE     MOV [W14+8], W1
001C8A  EA8000     COM W0, W0
001C8C  EA8081     COM W1, W1
001C8E  780282     MOV W2, W5
001C90  780103     MOV W3, W2
001C92  780180     MOV W0, W3
001C94  780001     MOV W1, W0
001C96  628283     AND W5, W3, W5
001C98  610000     AND W2, W0, W0
001C9A  EB0080     CLR W1
001C9C  DD00C0     SL W0, #0, W1
001C9E  200000     MOV #0x0, W0
001CA0  BE0100     MOV.D W0, W2
001CA2  B82861     MUL.UU W5, #1, W0
001CA4  710100     IOR W2, W0, W2
001CA6  718181     IOR W3, W1, W3
001CA8  981202     MOV W2, [W4+32]
001CAA  981213     MOV W3, [W4+34]
4328:              				xReturn = pdTRUE;
001CAC  200010     MOV #0x1, W0
001CAE  780F00     MOV W0, [W14]
4329:              			}
4330:              
4331:              			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
001CB0  804280     MOV pxCurrentTCB, W0
001CB2  EB4080     CLR.B W1
001CB4  986041     MOV.B W1, [W0+36]
4332:              		}
4333:              		taskEXIT_CRITICAL();
001CB6  0248F4     CALL vPortExitCritical
001CB8  000000     NOP
4334:              
4335:              		return xReturn;
001CBA  78001E     MOV [W14], W0
4336:              	}
001CBC  FA8000     ULNK
001CBE  060000     RETURN
4337:              
4338:              #endif /* configUSE_TASK_NOTIFICATIONS */
4339:              /*-----------------------------------------------------------*/
4340:              
4341:              #if( configUSE_TASK_NOTIFICATIONS == 1 )
4342:              
4343:              	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
4344:              	{
001CC0  FA0010     LNK #0x10
001CC2  980730     MOV W0, [W14+6]
001CC4  980742     MOV W2, [W14+8]
001CC6  980753     MOV W3, [W14+10]
001CC8  980761     MOV W1, [W14+12]
001CCA  980774     MOV W4, [W14+14]
4345:              	TCB_t * pxTCB;
4346:              	BaseType_t xReturn = pdPASS;
001CCC  200010     MOV #0x1, W0
001CCE  780F00     MOV W0, [W14]
4347:              	uint8_t ucOriginalNotifyState;
4348:              
4349:              		configASSERT( xTaskToNotify );
4350:              		pxTCB = ( TCB_t * ) xTaskToNotify;
001CD0  9000BE     MOV [W14+6], W1
001CD2  980711     MOV W1, [W14+2]
4351:              
4352:              		taskENTER_CRITICAL();
001CD4  0248DA     CALL vPortEnterCritical
001CD6  000000     NOP
4353:              		{
4354:              			if( pulPreviousNotificationValue != NULL )
001CD8  90007E     MOV [W14+14], W0
001CDA  E00000     CP0 W0
001CDC  320005     BRA Z, .L145
4355:              			{
4356:              				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
001CDE  90001E     MOV [W14+2], W0
001CE0  901090     MOV [W0+34], W1
001CE2  901000     MOV [W0+32], W0
001CE4  90017E     MOV [W14+14], W2
001CE6  BE8900     MOV.D W0, [W2]
4357:              			}
4358:              
4359:              			ucOriginalNotifyState = pxTCB->ucNotifyState;
001CE8  90001E     MOV [W14+2], W0
001CEA  906140     MOV.B [W0+36], W2
001CEC  984742     MOV.B W2, [W14+4]
4360:              
4361:              			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
001CEE  90001E     MOV [W14+2], W0
001CF0  B3C021     MOV.B #0x2, W1
001CF2  986041     MOV.B W1, [W0+36]
4362:              
4363:              			switch( eAction )
001CF4  90006E     MOV [W14+12], W0
001CF6  500FE2     SUB W0, #0x2, [W15]
001CF8  320017     BRA Z, .L149
001CFA  500FE2     SUB W0, #0x2, [W15]
001CFC  3E0005     BRA GTU, .L152
001CFE  E00000     CP0 W0
001D00  32002E     BRA Z, .L157
001D02  500FE1     SUB W0, #0x1, [W15]
001D04  320006     BRA Z, .L148
001D06  37002C     BRA .L146
001D08  500FE3     SUB W0, #0x3, [W15]
001D0A  320017     BRA Z, .L150
001D0C  500FE4     SUB W0, #0x4, [W15]
001D0E  32001B     BRA Z, .L151
001D10  370027     BRA .L146
4364:              			{
4365:              				case eSetBits	:
4366:              					pxTCB->ulNotifiedValue |= ulValue;
001D12  90001E     MOV [W14+2], W0
001D14  901100     MOV [W0+32], W2
001D16  901190     MOV [W0+34], W3
001D18  90004E     MOV [W14+8], W0
001D1A  9000DE     MOV [W14+10], W1
001D1C  710000     IOR W2, W0, W0
001D1E  718081     IOR W3, W1, W1
001D20  90011E     MOV [W14+2], W2
001D22  981100     MOV W0, [W2+32]
001D24  981111     MOV W1, [W2+34]
4367:              					break;
001D26  37001C     BRA .L146
4368:              
4369:              				case eIncrement	:
4370:              					( pxTCB->ulNotifiedValue )++;
001D28  90001E     MOV [W14+2], W0
001D2A  901090     MOV [W0+34], W1
001D2C  901000     MOV [W0+32], W0
001D2E  400061     ADD W0, #0x1, W0
001D30  4880E0     ADDC W1, #0x0, W1
001D32  90011E     MOV [W14+2], W2
001D34  981100     MOV W0, [W2+32]
001D36  981111     MOV W1, [W2+34]
4371:              					break;
001D38  370013     BRA .L146
4372:              
4373:              				case eSetValueWithOverwrite	:
4374:              					pxTCB->ulNotifiedValue = ulValue;
001D3A  90001E     MOV [W14+2], W0
001D3C  90014E     MOV [W14+8], W2
001D3E  9001DE     MOV [W14+10], W3
001D40  981002     MOV W2, [W0+32]
001D42  981013     MOV W3, [W0+34]
4375:              					break;
001D44  37000D     BRA .L146
4376:              
4377:              				case eSetValueWithoutOverwrite :
4378:              					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
001D46  90404E     MOV.B [W14+4], W0
001D48  504FE2     SUB.B W0, #0x2, [W15]
001D4A  320006     BRA Z, .L153
4379:              					{
4380:              						pxTCB->ulNotifiedValue = ulValue;
001D4C  90001E     MOV [W14+2], W0
001D4E  90014E     MOV [W14+8], W2
001D50  9001DE     MOV [W14+10], W3
001D52  981002     MOV W2, [W0+32]
001D54  981013     MOV W3, [W0+34]
4381:              					}
4382:              					else
4383:              					{
4384:              						/* The value could not be written to the task. */
4385:              						xReturn = pdFAIL;
001D58  EB0000     CLR W0
001D5A  780F00     MOV W0, [W14]
4386:              					}
4387:              					break;
001D56  370004     BRA .L146
001D5C  370001     BRA .L146
4388:              
4389:              				case eNoAction:
4390:              					/* The task is being notified without its notify value being
4391:              					updated. */
4392:              					break;
001D5E  000000     NOP
4393:              			}
4394:              
4395:              			traceTASK_NOTIFY();
4396:              
4397:              			/* If the task is in the blocked state specifically to wait for a
4398:              			notification then unblock it now. */
4399:              			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
001D60  90404E     MOV.B [W14+4], W0
001D62  504FE1     SUB.B W0, #0x1, [W15]
001D64  3A0020     BRA NZ, .L155
4400:              			{
4401:              				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
001D66  90001E     MOV [W14+2], W0
001D68  E88000     INC2 W0, W0
001D6A  0249F0     CALL uxListRemove
001D6C  000000     NOP
4402:              				prvAddTaskToReadyList( pxTCB );
001D6E  90001E     MOV [W14+2], W0
001D70  9008B0     MOV [W0+22], W1
001D72  8042E0     MOV uxTopReadyPriority, W0
001D74  508F80     SUB W1, W0, [W15]
001D76  360003     BRA LEU, .L156
001D78  90001E     MOV [W14+2], W0
001D7A  900830     MOV [W0+22], W0
001D7C  8842E0     MOV W0, uxTopReadyPriority
001D7E  90001E     MOV [W14+2], W0
001D80  E88100     INC2 W0, W2
001D82  90001E     MOV [W14+2], W0
001D84  900830     MOV [W0+22], W0
001D86  B9006A     MUL.SU W0, #10, W0
001D88  780080     MOV W0, W1
001D8A  21CB40     MOV #0x1CB4, W0
001D8C  408000     ADD W1, W0, W0
001D8E  780082     MOV W2, W1
001D90  024950     CALL vListInsertEnd
001D92  000000     NOP
4403:              
4404:              				/* The task should not have been on an event list. */
4405:              				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
4406:              
4407:              				#if( configUSE_TICKLESS_IDLE != 0 )
4408:              				{
4409:              					/* If a task is blocked waiting for a notification then
4410:              					xNextTaskUnblockTime might be set to the blocked task's time
4411:              					out time.  If the task is unblocked for a reason other than
4412:              					a timeout xNextTaskUnblockTime is normally left unchanged,
4413:              					because it will automatically get reset to a new value when
4414:              					the tick count equals xNextTaskUnblockTime.  However if
4415:              					tickless idling is used it might be more important to enter
4416:              					sleep mode at the earliest possible time - so reset
4417:              					xNextTaskUnblockTime here to ensure it is updated at the
4418:              					earliest possible time. */
4419:              					prvResetNextTaskUnblockTime();
4420:              				}
4421:              				#endif
4422:              
4423:              				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
001D94  90001E     MOV [W14+2], W0
001D96  9008B0     MOV [W0+22], W1
001D98  804280     MOV pxCurrentTCB, W0
001D9A  900830     MOV [W0+22], W0
001D9C  508F80     SUB W1, W0, [W15]
001D9E  360003     BRA LEU, .L155
4424:              				{
4425:              					/* The notified task has a priority above the currently
4426:              					executing task so a yield is required. */
4427:              					taskYIELD_IF_USING_PREEMPTION();
001DA0  0250DC     CALL .Letext0, .LFE1, _vPortYield
001DA2  000000     NOP
001DA4  000000     NOP
4428:              				}
4429:              				else
4430:              				{
4431:              					mtCOVERAGE_TEST_MARKER();
4432:              				}
4433:              			}
4434:              			else
4435:              			{
4436:              				mtCOVERAGE_TEST_MARKER();
4437:              			}
4438:              		}
4439:              		taskEXIT_CRITICAL();
001DA6  0248F4     CALL vPortExitCritical
001DA8  000000     NOP
4440:              
4441:              		return xReturn;
001DAA  78001E     MOV [W14], W0
4442:              	}
001DAC  FA8000     ULNK
001DAE  060000     RETURN
4443:              
4444:              #endif /* configUSE_TASK_NOTIFICATIONS */
4445:              /*-----------------------------------------------------------*/
4446:              
4447:              #if( configUSE_TASK_NOTIFICATIONS == 1 )
4448:              
4449:              	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
4450:              	{
001DB0  FA0014     LNK #0x14
001DB2  980740     MOV W0, [W14+8]
001DB4  980752     MOV W2, [W14+10]
001DB6  980763     MOV W3, [W14+12]
001DB8  980771     MOV W1, [W14+14]
001DBA  980F04     MOV W4, [W14+16]
001DBC  980F15     MOV W5, [W14+18]
4451:              	TCB_t * pxTCB;
4452:              	uint8_t ucOriginalNotifyState;
4453:              	BaseType_t xReturn = pdPASS;
001DBE  200010     MOV #0x1, W0
001DC0  780F00     MOV W0, [W14]
4454:              	UBaseType_t uxSavedInterruptStatus;
4455:              
4456:              		configASSERT( xTaskToNotify );
4457:              
4458:              		/* RTOS ports that support interrupt nesting have the concept of a
4459:              		maximum	system call (or maximum API call) interrupt priority.
4460:              		Interrupts that are	above the maximum system call priority are keep
4461:              		permanently enabled, even when the RTOS kernel is in a critical section,
4462:              		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
4463:              		is defined in FreeRTOSConfig.h then
4464:              		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
4465:              		failure if a FreeRTOS API function is called from an interrupt that has
4466:              		been assigned a priority above the configured maximum system call
4467:              		priority.  Only FreeRTOS functions that end in FromISR can be called
4468:              		from interrupts	that have been assigned a priority at or (logically)
4469:              		below the maximum system call interrupt priority.  FreeRTOS maintains a
4470:              		separate interrupt safe API to ensure interrupt entry is as fast and as
4471:              		simple as possible.  More information (albeit Cortex-M specific) is
4472:              		provided on the following link:
4473:              		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
4474:              		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
4475:              
4476:              		pxTCB = ( TCB_t * ) xTaskToNotify;
001DC2  9000CE     MOV [W14+8], W1
001DC4  980711     MOV W1, [W14+2]
4477:              
4478:              		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
001DC6  EB0000     CLR W0
001DC8  980720     MOV W0, [W14+4]
4479:              		{
4480:              			if( pulPreviousNotificationValue != NULL )
001DCA  90080E     MOV [W14+16], W0
001DCC  E00000     CP0 W0
001DCE  320005     BRA Z, .L159
4481:              			{
4482:              				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
001DD0  90001E     MOV [W14+2], W0
001DD2  901090     MOV [W0+34], W1
001DD4  901000     MOV [W0+32], W0
001DD6  90090E     MOV [W14+16], W2
001DD8  BE8900     MOV.D W0, [W2]
4483:              			}
4484:              
4485:              			ucOriginalNotifyState = pxTCB->ucNotifyState;
001DDA  90001E     MOV [W14+2], W0
001DDC  906140     MOV.B [W0+36], W2
001DDE  984762     MOV.B W2, [W14+6]
4486:              			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
001DE0  90001E     MOV [W14+2], W0
001DE2  B3C021     MOV.B #0x2, W1
001DE4  986041     MOV.B W1, [W0+36]
4487:              
4488:              			switch( eAction )
001DE6  90007E     MOV [W14+14], W0
001DE8  500FE2     SUB W0, #0x2, [W15]
001DEA  320017     BRA Z, .L163
001DEC  500FE2     SUB W0, #0x2, [W15]
001DEE  3E0005     BRA GTU, .L166
001DF0  E00000     CP0 W0
001DF2  32002E     BRA Z, .L174
001DF4  500FE1     SUB W0, #0x1, [W15]
001DF6  320006     BRA Z, .L162
001DF8  37002C     BRA .L160
001DFA  500FE3     SUB W0, #0x3, [W15]
001DFC  320017     BRA Z, .L164
001DFE  500FE4     SUB W0, #0x4, [W15]
001E00  32001B     BRA Z, .L165
001E02  370027     BRA .L160
4489:              			{
4490:              				case eSetBits	:
4491:              					pxTCB->ulNotifiedValue |= ulValue;
001E04  90001E     MOV [W14+2], W0
001E06  901100     MOV [W0+32], W2
001E08  901190     MOV [W0+34], W3
001E0A  90005E     MOV [W14+10], W0
001E0C  9000EE     MOV [W14+12], W1
001E0E  710000     IOR W2, W0, W0
001E10  718081     IOR W3, W1, W1
001E12  90011E     MOV [W14+2], W2
001E14  981100     MOV W0, [W2+32]
001E16  981111     MOV W1, [W2+34]
4492:              					break;
001E18  37001C     BRA .L160
4493:              
4494:              				case eIncrement	:
4495:              					( pxTCB->ulNotifiedValue )++;
001E1A  90001E     MOV [W14+2], W0
001E1C  901090     MOV [W0+34], W1
001E1E  901000     MOV [W0+32], W0
001E20  400061     ADD W0, #0x1, W0
001E22  4880E0     ADDC W1, #0x0, W1
001E24  90011E     MOV [W14+2], W2
001E26  981100     MOV W0, [W2+32]
001E28  981111     MOV W1, [W2+34]
4496:              					break;
001E2A  370013     BRA .L160
4497:              
4498:              				case eSetValueWithOverwrite	:
4499:              					pxTCB->ulNotifiedValue = ulValue;
001E2C  90001E     MOV [W14+2], W0
001E2E  90015E     MOV [W14+10], W2
001E30  9001EE     MOV [W14+12], W3
001E32  981002     MOV W2, [W0+32]
001E34  981013     MOV W3, [W0+34]
4500:              					break;
001E36  37000D     BRA .L160
4501:              
4502:              				case eSetValueWithoutOverwrite :
4503:              					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
001E38  90406E     MOV.B [W14+6], W0
001E3A  504FE2     SUB.B W0, #0x2, [W15]
001E3C  320006     BRA Z, .L167
4504:              					{
4505:              						pxTCB->ulNotifiedValue = ulValue;
001E3E  90001E     MOV [W14+2], W0
001E40  90015E     MOV [W14+10], W2
001E42  9001EE     MOV [W14+12], W3
001E44  981002     MOV W2, [W0+32]
001E46  981013     MOV W3, [W0+34]
4506:              					}
4507:              					else
4508:              					{
4509:              						/* The value could not be written to the task. */
4510:              						xReturn = pdFAIL;
001E4A  EB0000     CLR W0
001E4C  780F00     MOV W0, [W14]
4511:              					}
4512:              					break;
001E48  370004     BRA .L160
001E4E  370001     BRA .L160
4513:              
4514:              				case eNoAction :
4515:              					/* The task is being notified without its notify value being
4516:              					updated. */
4517:              					break;
001E50  000000     NOP
4518:              			}
4519:              
4520:              			traceTASK_NOTIFY_FROM_ISR();
4521:              
4522:              			/* If the task is in the blocked state specifically to wait for a
4523:              			notification then unblock it now. */
4524:              			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
001E52  90406E     MOV.B [W14+6], W0
001E54  504FE1     SUB.B W0, #0x1, [W15]
001E56  3A0030     BRA NZ, .L169
4525:              			{
4526:              				/* The task should not have been on an event list. */
4527:              				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
4528:              
4529:              				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
001E58  804360     MOV uxSchedulerSuspended, W0
001E5A  E00000     CP0 W0
001E5C  3A0018     BRA NZ, .L170
4530:              				{
4531:              					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
001E5E  90001E     MOV [W14+2], W0
001E60  E88000     INC2 W0, W0
001E62  0249F0     CALL uxListRemove
001E64  000000     NOP
4532:              					prvAddTaskToReadyList( pxTCB );
001E66  90001E     MOV [W14+2], W0
001E68  9008B0     MOV [W0+22], W1
001E6A  8042E0     MOV uxTopReadyPriority, W0
001E6C  508F80     SUB W1, W0, [W15]
001E6E  360003     BRA LEU, .L171
001E70  90001E     MOV [W14+2], W0
001E72  900830     MOV [W0+22], W0
001E74  8842E0     MOV W0, uxTopReadyPriority
001E76  90001E     MOV [W14+2], W0
001E78  E88100     INC2 W0, W2
001E7A  90001E     MOV [W14+2], W0
001E7C  900830     MOV [W0+22], W0
001E7E  B9006A     MUL.SU W0, #10, W0
001E80  780080     MOV W0, W1
001E82  21CB40     MOV #0x1CB4, W0
001E84  408000     ADD W1, W0, W0
001E86  780082     MOV W2, W1
001E88  024950     CALL vListInsertEnd
001E8A  000000     NOP
001E8C  370006     BRA .L172
4533:              				}
4534:              				else
4535:              				{
4536:              					/* The delayed and ready lists cannot be accessed, so hold
4537:              					this task pending until the scheduler is resumed. */
4538:              					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
001E8E  90001E     MOV [W14+2], W0
001E90  40006C     ADD W0, #0xC, W0
001E92  780080     MOV W0, W1
001E94  21CF00     MOV #0x1CF0, W0
001E96  024950     CALL vListInsertEnd
001E98  000000     NOP
4539:              				}
4540:              
4541:              				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
001E9A  90001E     MOV [W14+2], W0
001E9C  9008B0     MOV [W0+22], W1
001E9E  804280     MOV pxCurrentTCB, W0
001EA0  900830     MOV [W0+22], W0
001EA2  508F80     SUB W1, W0, [W15]
001EA4  360009     BRA LEU, .L169
4542:              				{
4543:              					/* The notified task has a priority above the currently
4544:              					executing task so a yield is required. */
4545:              					if( pxHigherPriorityTaskWoken != NULL )
001EA6  90081E     MOV [W14+18], W0
001EA8  E00000     CP0 W0
001EAA  320004     BRA Z, .L173
4546:              					{
4547:              						*pxHigherPriorityTaskWoken = pdTRUE;
001EAC  90081E     MOV [W14+18], W0
001EAE  200011     MOV #0x1, W1
001EB0  780801     MOV W1, [W0]
001EB2  370002     BRA .L169
4548:              					}
4549:              					else
4550:              					{
4551:              						/* Mark that a yield is pending in case the user is not
4552:              						using the "xHigherPriorityTaskWoken" parameter to an ISR
4553:              						safe FreeRTOS function. */
4554:              						xYieldPending = pdTRUE;
001EB4  200010     MOV #0x1, W0
001EB6  884310     MOV W0, xYieldPending
4555:              					}
4556:              				}
4557:              				else
4558:              				{
4559:              					mtCOVERAGE_TEST_MARKER();
4560:              				}
4561:              			}
4562:              		}
4563:              		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
4564:              
4565:              		return xReturn;
001EB8  78001E     MOV [W14], W0
4566:              	}
001EBA  FA8000     ULNK
001EBC  060000     RETURN
4567:              
4568:              #endif /* configUSE_TASK_NOTIFICATIONS */
4569:              /*-----------------------------------------------------------*/
4570:              
4571:              #if( configUSE_TASK_NOTIFICATIONS == 1 )
4572:              
4573:              	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
4574:              	{
001EBE  FA000A     LNK #0xA
001EC0  980730     MOV W0, [W14+6]
001EC2  980741     MOV W1, [W14+8]
4575:              	TCB_t * pxTCB;
4576:              	uint8_t ucOriginalNotifyState;
4577:              	UBaseType_t uxSavedInterruptStatus;
4578:              
4579:              		configASSERT( xTaskToNotify );
4580:              
4581:              		/* RTOS ports that support interrupt nesting have the concept of a
4582:              		maximum	system call (or maximum API call) interrupt priority.
4583:              		Interrupts that are	above the maximum system call priority are keep
4584:              		permanently enabled, even when the RTOS kernel is in a critical section,
4585:              		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
4586:              		is defined in FreeRTOSConfig.h then
4587:              		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
4588:              		failure if a FreeRTOS API function is called from an interrupt that has
4589:              		been assigned a priority above the configured maximum system call
4590:              		priority.  Only FreeRTOS functions that end in FromISR can be called
4591:              		from interrupts	that have been assigned a priority at or (logically)
4592:              		below the maximum system call interrupt priority.  FreeRTOS maintains a
4593:              		separate interrupt safe API to ensure interrupt entry is as fast and as
4594:              		simple as possible.  More information (albeit Cortex-M specific) is
4595:              		provided on the following link:
4596:              		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
4597:              		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
4598:              
4599:              		pxTCB = ( TCB_t * ) xTaskToNotify;
001EC4  9000BE     MOV [W14+6], W1
001EC6  780F01     MOV W1, [W14]
4600:              
4601:              		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
001EC8  EB0000     CLR W0
001ECA  980710     MOV W0, [W14+2]
4602:              		{
4603:              			ucOriginalNotifyState = pxTCB->ucNotifyState;
001ECC  78001E     MOV [W14], W0
001ECE  9060C0     MOV.B [W0+36], W1
001ED0  984741     MOV.B W1, [W14+4]
4604:              			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
001ED2  78001E     MOV [W14], W0
001ED4  B3C021     MOV.B #0x2, W1
001ED6  986041     MOV.B W1, [W0+36]
4605:              
4606:              			/* 'Giving' is equivalent to incrementing a count in a counting
4607:              			semaphore. */
4608:              			( pxTCB->ulNotifiedValue )++;
001ED8  78001E     MOV [W14], W0
001EDA  901090     MOV [W0+34], W1
001EDC  901000     MOV [W0+32], W0
001EDE  400061     ADD W0, #0x1, W0
001EE0  4880E0     ADDC W1, #0x0, W1
001EE2  78011E     MOV [W14], W2
001EE4  981100     MOV W0, [W2+32]
001EE6  981111     MOV W1, [W2+34]
4609:              
4610:              			traceTASK_NOTIFY_GIVE_FROM_ISR();
4611:              
4612:              			/* If the task is in the blocked state specifically to wait for a
4613:              			notification then unblock it now. */
4614:              			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
001EE8  90404E     MOV.B [W14+4], W0
001EEA  504FE1     SUB.B W0, #0x1, [W15]
001EEC  3A002E     BRA NZ, .L175
4615:              			{
4616:              				/* The task should not have been on an event list. */
4617:              				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
4618:              
4619:              				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
001EEE  804360     MOV uxSchedulerSuspended, W0
001EF0  E00000     CP0 W0
001EF2  3A0016     BRA NZ, .L177
4620:              				{
4621:              					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
001EF4  E8801E     INC2 [W14], W0
001EF6  0249F0     CALL uxListRemove
001EF8  000000     NOP
4622:              					prvAddTaskToReadyList( pxTCB );
001EFA  78001E     MOV [W14], W0
001EFC  9008B0     MOV [W0+22], W1
001EFE  8042E0     MOV uxTopReadyPriority, W0
001F00  508F80     SUB W1, W0, [W15]
001F02  360003     BRA LEU, .L178
001F04  78001E     MOV [W14], W0
001F06  900830     MOV [W0+22], W0
001F08  8842E0     MOV W0, uxTopReadyPriority
001F0A  E8811E     INC2 [W14], W2
001F0C  78001E     MOV [W14], W0
001F0E  900830     MOV [W0+22], W0
001F10  B9006A     MUL.SU W0, #10, W0
001F12  780080     MOV W0, W1
001F14  21CB40     MOV #0x1CB4, W0
001F16  408000     ADD W1, W0, W0
001F18  780082     MOV W2, W1
001F1A  024950     CALL vListInsertEnd
001F1C  000000     NOP
001F1E  370006     BRA .L179
4623:              				}
4624:              				else
4625:              				{
4626:              					/* The delayed and ready lists cannot be accessed, so hold
4627:              					this task pending until the scheduler is resumed. */
4628:              					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
001F20  78009E     MOV [W14], W1
001F22  40806C     ADD W1, #0xC, W0
001F24  780080     MOV W0, W1
001F26  21CF00     MOV #0x1CF0, W0
001F28  024950     CALL vListInsertEnd
001F2A  000000     NOP
4629:              				}
4630:              
4631:              				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
001F2C  78001E     MOV [W14], W0
001F2E  9008B0     MOV [W0+22], W1
001F30  804280     MOV pxCurrentTCB, W0
001F32  900830     MOV [W0+22], W0
001F34  508F80     SUB W1, W0, [W15]
001F36  360009     BRA LEU, .L175
4632:              				{
4633:              					/* The notified task has a priority above the currently
4634:              					executing task so a yield is required. */
4635:              					if( pxHigherPriorityTaskWoken != NULL )
001F38  90004E     MOV [W14+8], W0
001F3A  E00000     CP0 W0
001F3C  320004     BRA Z, .L180
4636:              					{
4637:              						*pxHigherPriorityTaskWoken = pdTRUE;
001F3E  90004E     MOV [W14+8], W0
001F40  200011     MOV #0x1, W1
001F42  780801     MOV W1, [W0]
001F44  370002     BRA .L175
4638:              					}
4639:              					else
4640:              					{
4641:              						/* Mark that a yield is pending in case the user is not
4642:              						using the "xHigherPriorityTaskWoken" parameter in an ISR
4643:              						safe FreeRTOS function. */
4644:              						xYieldPending = pdTRUE;
001F46  200010     MOV #0x1, W0
001F48  884310     MOV W0, xYieldPending
4645:              					}
4646:              				}
4647:              				else
4648:              				{
4649:              					mtCOVERAGE_TEST_MARKER();
4650:              				}
4651:              			}
4652:              		}
4653:              		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
4654:              	}
001F4A  FA8000     ULNK
001F4C  060000     RETURN
4655:              
4656:              #endif /* configUSE_TASK_NOTIFICATIONS */
4657:              
4658:              /*-----------------------------------------------------------*/
4659:              
4660:              #if( configUSE_TASK_NOTIFICATIONS == 1 )
4661:              
4662:              	BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask )
4663:              	{
001F4E  FA0006     LNK #0x6
001F50  980720     MOV W0, [W14+4]
4664:              	TCB_t *pxTCB;
4665:              	BaseType_t xReturn;
4666:              
4667:              		/* If null is passed in here then it is the calling task that is having
4668:              		its notification state cleared. */
4669:              		pxTCB = prvGetTCBFromHandle( xTask );
001F52  90002E     MOV [W14+4], W0
001F54  E00000     CP0 W0
001F56  3A0002     BRA NZ, .L182
001F58  804280     MOV pxCurrentTCB, W0
001F5A  370001     BRA .L183
001F5C  90002E     MOV [W14+4], W0
001F5E  980710     MOV W0, [W14+2]
4670:              
4671:              		taskENTER_CRITICAL();
001F60  0248DA     CALL vPortEnterCritical
001F62  000000     NOP
4672:              		{
4673:              			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
001F64  90001E     MOV [W14+2], W0
001F66  906040     MOV.B [W0+36], W0
001F68  504FE2     SUB.B W0, #0x2, [W15]
001F6A  3A0006     BRA NZ, .L184
4674:              			{
4675:              				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
001F6C  90001E     MOV [W14+2], W0
001F6E  EB4080     CLR.B W1
001F70  986041     MOV.B W1, [W0+36]
4676:              				xReturn = pdPASS;
001F72  200010     MOV #0x1, W0
001F74  780F00     MOV W0, [W14]
001F76  370002     BRA .L185
4677:              			}
4678:              			else
4679:              			{
4680:              				xReturn = pdFAIL;
001F78  EB0000     CLR W0
001F7A  780F00     MOV W0, [W14]
4681:              			}
4682:              		}
4683:              		taskEXIT_CRITICAL();
001F7C  0248F4     CALL vPortExitCritical
001F7E  000000     NOP
4684:              
4685:              		return xReturn;
001F80  78001E     MOV [W14], W0
4686:              	}
001F82  FA8000     ULNK
001F84  060000     RETURN
4687:              
4688:              #endif /* configUSE_TASK_NOTIFICATIONS */
4689:              /*-----------------------------------------------------------*/
4690:              
4691:              
4692:              static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
4693:              {
001F86  FA0008     LNK #0x8
001F88  980720     MOV W0, [W14+4]
001F8A  980731     MOV W1, [W14+6]
4694:              TickType_t xTimeToWake;
4695:              const TickType_t xConstTickCount = xTickCount;
001F8C  8042D1     MOV xTickCount, W1
001F8E  780F01     MOV W1, [W14]
4696:              
4697:              	#if( INCLUDE_xTaskAbortDelay == 1 )
4698:              	{
4699:              		/* About to enter a delayed list, so ensure the ucDelayAborted flag is
4700:              		reset to pdFALSE so it can be detected as having been set to pdTRUE
4701:              		when the task leaves the Blocked state. */
4702:              		pxCurrentTCB->ucDelayAborted = pdFALSE;
4703:              	}
4704:              	#endif
4705:              
4706:              	/* Remove the task from the ready list before adding it to the blocked list
4707:              	as the same list item is used for both lists. */
4708:              	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
001F90  804280     MOV pxCurrentTCB, W0
001F92  E88000     INC2 W0, W0
001F94  0249F0     CALL uxListRemove
001F96  000000     NOP
4709:              	{
4710:              		/* The current task must be in a ready list, so there is no need to
4711:              		check, and the port reset macro can be called directly. */
4712:              		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
4713:              	}
4714:              	else
4715:              	{
4716:              		mtCOVERAGE_TEST_MARKER();
4717:              	}
4718:              
4719:              	#if ( INCLUDE_vTaskSuspend == 1 )
4720:              	{
4721:              		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
001F98  90002E     MOV [W14+4], W0
001F9A  400FE1     ADD W0, #0x1, [W15]
001F9C  3A000A     BRA NZ, .L187
001F9E  90003E     MOV [W14+6], W0
001FA0  E00000     CP0 W0
001FA2  320007     BRA Z, .L187
4722:              		{
4723:              			/* Add the task to the suspended task list instead of a delayed task
4724:              			list to ensure it is not woken by a timing event.  It will block
4725:              			indefinitely. */
4726:              			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
001FA4  804280     MOV pxCurrentTCB, W0
001FA6  E88000     INC2 W0, W0
001FA8  780080     MOV W0, W1
001FAA  21D040     MOV #0x1D04, W0
001FAC  024950     CALL vListInsertEnd
001FAE  000000     NOP
001FB0  37001A     BRA .L186
4727:              		}
4728:              		else
4729:              		{
4730:              			/* Calculate the time at which the task should be woken if the event
4731:              			does not occur.  This may overflow but this doesn't matter, the
4732:              			kernel will manage it correctly. */
4733:              			xTimeToWake = xConstTickCount + xTicksToWait;
001FB2  90002E     MOV [W14+4], W0
001FB4  40001E     ADD W0, [W14], W0
001FB6  980710     MOV W0, [W14+2]
4734:              
4735:              			/* The list item will be inserted in wake time order. */
4736:              			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
001FB8  804280     MOV pxCurrentTCB, W0
001FBA  90009E     MOV [W14+2], W1
001FBC  980011     MOV W1, [W0+2]
4737:              
4738:              			if( xTimeToWake < xConstTickCount )
001FBE  90001E     MOV [W14+2], W0
001FC0  500F9E     SUB W0, [W14], [W15]
001FC2  310006     BRA C, .L189
4739:              			{
4740:              				/* Wake time has overflowed.  Place this item in the overflow
4741:              				list. */
4742:              				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
001FC4  804280     MOV pxCurrentTCB, W0
001FC6  E88080     INC2 W0, W1
001FC8  8042A0     MOV pxOverflowDelayedTaskList, W0
001FCA  02498C     CALL vListInsert
001FCC  000000     NOP
001FCE  37000B     BRA .L186
4743:              			}
4744:              			else
4745:              			{
4746:              				/* The wake time has not overflowed, so the current block list
4747:              				is used. */
4748:              				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
001FD0  804280     MOV pxCurrentTCB, W0
001FD2  E88080     INC2 W0, W1
001FD4  804290     MOV pxDelayedTaskList, W0
001FD6  02498C     CALL vListInsert
001FD8  000000     NOP
4749:              
4750:              				/* If the task entering the blocked state was placed at the
4751:              				head of the list of blocked tasks then xNextTaskUnblockTime
4752:              				needs to be updated too. */
4753:              				if( xTimeToWake < xNextTaskUnblockTime )
001FDA  804340     MOV xNextTaskUnblockTime, W0
001FDC  90009E     MOV [W14+2], W1
001FDE  508F80     SUB W1, W0, [W15]
001FE0  310002     BRA C, .L186
4754:              				{
4755:              					xNextTaskUnblockTime = xTimeToWake;
001FE2  90009E     MOV [W14+2], W1
001FE4  884341     MOV W1, xNextTaskUnblockTime
4756:              				}
4757:              				else
4758:              				{
4759:              					mtCOVERAGE_TEST_MARKER();
4760:              				}
4761:              			}
4762:              		}
4763:              	}
4764:              	#else /* INCLUDE_vTaskSuspend */
4765:              	{
4766:              		/* Calculate the time at which the task should be woken if the event
4767:              		does not occur.  This may overflow but this doesn't matter, the kernel
4768:              		will manage it correctly. */
4769:              		xTimeToWake = xConstTickCount + xTicksToWait;
4770:              
4771:              		/* The list item will be inserted in wake time order. */
4772:              		listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
4773:              
4774:              		if( xTimeToWake < xConstTickCount )
4775:              		{
4776:              			/* Wake time has overflowed.  Place this item in the overflow list. */
4777:              			vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
4778:              		}
4779:              		else
4780:              		{
4781:              			/* The wake time has not overflowed, so the current block list is used. */
4782:              			vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
4783:              
4784:              			/* If the task entering the blocked state was placed at the head of the
4785:              			list of blocked tasks then xNextTaskUnblockTime needs to be updated
4786:              			too. */
4787:              			if( xTimeToWake < xNextTaskUnblockTime )
4788:              			{
4789:              				xNextTaskUnblockTime = xTimeToWake;
4790:              			}
4791:              			else
4792:              			{
4793:              				mtCOVERAGE_TEST_MARKER();
4794:              			}
4795:              		}
4796:              
4797:              		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
4798:              		( void ) xCanBlockIndefinitely;
4799:              	}
4800:              	#endif /* INCLUDE_vTaskSuspend */
4801:              }
001FE6  FA8000     ULNK
001FE8  060000     RETURN
4802:              
4803:              
4804:              #ifdef FREERTOS_MODULE_TEST
4805:              	#include "tasks_test_access_functions.h"
4806:              #endif
4807:              
---  /home/zxc/Documents/WCGRTOS/Source/queue.c  --------------------------------------------------------
1:                 /*
2:                     FreeRTOS V9.0.0 - Copyright (C) 2016 Real Time Engineers Ltd.
3:                     All rights reserved
4:                 
5:                     VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
6:                 
7:                     This file is part of the FreeRTOS distribution.
8:                 
9:                     FreeRTOS is free software; you can redistribute it and/or modify it under
10:                    the terms of the GNU General Public License (version 2) as published by the
11:                    Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
12:                
13:                    ***************************************************************************
14:                    >>!   NOTE: The modification to the GPL is included to allow you to     !<<
15:                    >>!   distribute a combined work that includes FreeRTOS without being   !<<
16:                    >>!   obliged to provide the source code for proprietary components     !<<
17:                    >>!   outside of the FreeRTOS kernel.                                   !<<
18:                    ***************************************************************************
19:                
20:                    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
21:                    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
22:                    FOR A PARTICULAR PURPOSE.  Full license text is available on the following
23:                    link: http://www.freertos.org/a00114.html
24:                
25:                    ***************************************************************************
26:                     *                                                                       *
27:                     *    FreeRTOS provides completely free yet professionally developed,    *
28:                     *    robust, strictly quality controlled, supported, and cross          *
29:                     *    platform software that is more than just the market leader, it     *
30:                     *    is the industry's de facto standard.                               *
31:                     *                                                                       *
32:                     *    Help yourself get started quickly while simultaneously helping     *
33:                     *    to support the FreeRTOS project by purchasing a FreeRTOS           *
34:                     *    tutorial book, reference manual, or both:                          *
35:                     *    http://www.FreeRTOS.org/Documentation                              *
36:                     *                                                                       *
37:                    ***************************************************************************
38:                
39:                    http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
40:                    the FAQ page "My application does not run, what could be wrong?".  Have you
41:                    defined configASSERT()?
42:                
43:                    http://www.FreeRTOS.org/support - In return for receiving this top quality
44:                    embedded software for free we request you assist our global community by
45:                    participating in the support forum.
46:                
47:                    http://www.FreeRTOS.org/training - Investing in training allows your team to
48:                    be as productive as possible as early as possible.  Now you can receive
49:                    FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
50:                    Ltd, and the world's leading authority on the world's leading RTOS.
51:                
52:                    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
53:                    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
54:                    compatible FAT file system, and our tiny thread aware UDP/IP stack.
55:                
56:                    http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
57:                    Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
58:                
59:                    http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
60:                    Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
61:                    licenses offer ticketed support, indemnification and commercial middleware.
62:                
63:                    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
64:                    engineered and independently SIL3 certified version for use in safety and
65:                    mission critical applications that require provable dependability.
66:                
67:                    1 tab == 4 spaces!
68:                */
69:                
70:                #include <stdlib.h>
71:                #include <string.h>
72:                
73:                /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
74:                all the API functions to use the MPU wrappers.  That should only be done when
75:                task.h is included from an application file. */
76:                #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
77:                
78:                #include "FreeRTOS.h"
79:                #include "task.h"
80:                #include "queue.h"
81:                
82:                #if ( configUSE_CO_ROUTINES == 1 )
83:                	#include "croutine.h"
84:                #endif
85:                
86:                /* Lint e961 and e750 are suppressed as a MISRA exception justified because the
87:                MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined for the
88:                header files above, but not in this file, in order to generate the correct
89:                privileged Vs unprivileged linkage and placement. */
90:                #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750. */
91:                
92:                
93:                /* Constants used with the cRxLock and cTxLock structure members. */
94:                #define queueUNLOCKED					( ( int8_t ) -1 )
95:                #define queueLOCKED_UNMODIFIED			( ( int8_t ) 0 )
96:                
97:                /* When the Queue_t structure is used to represent a base queue its pcHead and
98:                pcTail members are used as pointers into the queue storage area.  When the
99:                Queue_t structure is used to represent a mutex pcHead and pcTail pointers are
100:               not necessary, and the pcHead pointer is set to NULL to indicate that the
101:               pcTail pointer actually points to the mutex holder (if any).  Map alternative
102:               names to the pcHead and pcTail structure members to ensure the readability of
103:               the code is maintained despite this dual use of two structure members.  An
104:               alternative implementation would be to use a union, but use of a union is
105:               against the coding standard (although an exception to the standard has been
106:               permitted where the dual use also significantly changes the type of the
107:               structure member). */
108:               #define pxMutexHolder					pcTail
109:               #define uxQueueType						pcHead
110:               #define queueQUEUE_IS_MUTEX				NULL
111:               
112:               /* Semaphores do not actually store or copy data, so have an item size of
113:               zero. */
114:               #define queueSEMAPHORE_QUEUE_ITEM_LENGTH ( ( UBaseType_t ) 0 )
115:               #define queueMUTEX_GIVE_BLOCK_TIME		 ( ( TickType_t ) 0U )
116:               
117:               #if( configUSE_PREEMPTION == 0 )
118:               	/* If the cooperative scheduler is being used then a yield should not be
119:               	performed just because a higher priority task has been woken. */
120:               	#define queueYIELD_IF_USING_PREEMPTION()
121:               #else
122:               	#define queueYIELD_IF_USING_PREEMPTION() portYIELD_WITHIN_API()
123:               #endif
124:               
125:               /*
126:                * Definition of the queue used by the scheduler.
127:                * Items are queued by copy, not reference.  See the following link for the
128:                * rationale: http://www.freertos.org/Embedded-RTOS-Queues.html
129:                */
130:               typedef struct QueueDefinition
131:               {
132:               	int8_t *pcHead;					/*< Points to the beginning of the queue storage area. */
133:               	int8_t *pcTail;					/*< Points to the byte at the end of the queue storage area.  Once more byte is allocated than necessary to store the queue items, this is used as a marker. */
134:               	int8_t *pcWriteTo;				/*< Points to the free next place in the storage area. */
135:               
136:               	union							/* Use of a union is an exception to the coding standard to ensure two mutually exclusive structure members don't appear simultaneously (wasting RAM). */
137:               	{
138:               		int8_t *pcReadFrom;			/*< Points to the last place that a queued item was read from when the structure is used as a queue. */
139:               		UBaseType_t uxRecursiveCallCount;/*< Maintains a count of the number of times a recursive mutex has been recursively 'taken' when the structure is used as a mutex. */
140:               	} u;
141:               
142:               	List_t xTasksWaitingToSend;		/*< List of tasks that are blocked waiting to post onto this queue.  Stored in priority order. */
143:               	List_t xTasksWaitingToReceive;	/*< List of tasks that are blocked waiting to read from this queue.  Stored in priority order. */
144:               
145:               	volatile UBaseType_t uxMessagesWaiting;/*< The number of items currently in the queue. */
146:               	UBaseType_t uxLength;			/*< The length of the queue defined as the number of items it will hold, not the number of bytes. */
147:               	UBaseType_t uxItemSize;			/*< The size of each items that the queue will hold. */
148:               
149:               	volatile int8_t cRxLock;		/*< Stores the number of items received from the queue (removed from the queue) while the queue was locked.  Set to queueUNLOCKED when the queue is not locked. */
150:               	volatile int8_t cTxLock;		/*< Stores the number of items transmitted to the queue (added to the queue) while the queue was locked.  Set to queueUNLOCKED when the queue is not locked. */
151:               
152:               	#if( ( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
153:               		uint8_t ucStaticallyAllocated;	/*< Set to pdTRUE if the memory used by the queue was statically allocated to ensure no attempt is made to free the memory. */
154:               	#endif
155:               
156:               	#if ( configUSE_QUEUE_SETS == 1 )
157:               		struct QueueDefinition *pxQueueSetContainer;
158:               	#endif
159:               
160:               	#if ( configUSE_TRACE_FACILITY == 1 )
161:               		UBaseType_t uxQueueNumber;
162:               		uint8_t ucQueueType;
163:               	#endif
164:               
165:               } xQUEUE;
166:               
167:               /* The old xQUEUE name is maintained above then typedefed to the new Queue_t
168:               name below to enable the use of older kernel aware debuggers. */
169:               typedef xQUEUE Queue_t;
170:               
171:               /*-----------------------------------------------------------*/
172:               
173:               /*
174:                * The queue registry is just a means for kernel aware debuggers to locate
175:                * queue structures.  It has no other purpose so is an optional component.
176:                */
177:               #if ( configQUEUE_REGISTRY_SIZE > 0 )
178:               
179:               	/* The type stored within the queue registry array.  This allows a name
180:               	to be assigned to each queue making kernel aware debugging a little
181:               	more user friendly. */
182:               	typedef struct QUEUE_REGISTRY_ITEM
183:               	{
184:               		const char *pcQueueName; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
185:               		QueueHandle_t xHandle;
186:               	} xQueueRegistryItem;
187:               
188:               	/* The old xQueueRegistryItem name is maintained above then typedefed to the
189:               	new xQueueRegistryItem name below to enable the use of older kernel aware
190:               	debuggers. */
191:               	typedef xQueueRegistryItem QueueRegistryItem_t;
192:               
193:               	/* The queue registry is simply an array of QueueRegistryItem_t structures.
194:               	The pcQueueName member of a structure being NULL is indicative of the
195:               	array position being vacant. */
196:               	PRIVILEGED_DATA QueueRegistryItem_t xQueueRegistry[ configQUEUE_REGISTRY_SIZE ];
197:               
198:               #endif /* configQUEUE_REGISTRY_SIZE */
199:               
200:               /*
201:                * Unlocks a queue locked by a call to prvLockQueue.  Locking a queue does not
202:                * prevent an ISR from adding or removing items to the queue, but does prevent
203:                * an ISR from removing tasks from the queue event lists.  If an ISR finds a
204:                * queue is locked it will instead increment the appropriate queue lock count
205:                * to indicate that a task may require unblocking.  When the queue in unlocked
206:                * these lock counts are inspected, and the appropriate action taken.
207:                */
208:               static void prvUnlockQueue( Queue_t * const pxQueue ) PRIVILEGED_FUNCTION;
209:               
210:               /*
211:                * Uses a critical section to determine if there is any data in a queue.
212:                *
213:                * @return pdTRUE if the queue contains no items, otherwise pdFALSE.
214:                */
215:               static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue ) PRIVILEGED_FUNCTION;
216:               
217:               /*
218:                * Uses a critical section to determine if there is any space in a queue.
219:                *
220:                * @return pdTRUE if there is no space, otherwise pdFALSE;
221:                */
222:               static BaseType_t prvIsQueueFull( const Queue_t *pxQueue ) PRIVILEGED_FUNCTION;
223:               
224:               /*
225:                * Copies an item into the queue, either at the front of the queue or the
226:                * back of the queue.
227:                */
228:               static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition ) PRIVILEGED_FUNCTION;
229:               
230:               /*
231:                * Copies an item out of a queue.
232:                */
233:               static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer ) PRIVILEGED_FUNCTION;
234:               
235:               #if ( configUSE_QUEUE_SETS == 1 )
236:               	/*
237:               	 * Checks to see if a queue is a member of a queue set, and if so, notifies
238:               	 * the queue set that the queue contains data.
239:               	 */
240:               	static BaseType_t prvNotifyQueueSetContainer( const Queue_t * const pxQueue, const BaseType_t xCopyPosition ) PRIVILEGED_FUNCTION;
241:               #endif
242:               
243:               /*
244:                * Called after a Queue_t structure has been allocated either statically or
245:                * dynamically to fill in the structure's members.
246:                */
247:               static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, const uint8_t ucQueueType, Queue_t *pxNewQueue ) PRIVILEGED_FUNCTION;
248:               
249:               /*
250:                * Mutexes are a special type of queue.  When a mutex is created, first the
251:                * queue is created, then prvInitialiseMutex() is called to configure the queue
252:                * as a mutex.
253:                */
254:               #if( configUSE_MUTEXES == 1 )
255:               	static void prvInitialiseMutex( Queue_t *pxNewQueue ) PRIVILEGED_FUNCTION;
256:               #endif
257:               
258:               /*-----------------------------------------------------------*/
259:               
260:               /*
261:                * Macro to mark a queue as locked.  Locking a queue prevents an ISR from
262:                * accessing the queue event lists.
263:                */
264:               #define prvLockQueue( pxQueue )								\
265:               	taskENTER_CRITICAL();									\
266:               	{														\
267:               		if( ( pxQueue )->cRxLock == queueUNLOCKED )			\
268:               		{													\
269:               			( pxQueue )->cRxLock = queueLOCKED_UNMODIFIED;	\
270:               		}													\
271:               		if( ( pxQueue )->cTxLock == queueUNLOCKED )			\
272:               		{													\
273:               			( pxQueue )->cTxLock = queueLOCKED_UNMODIFIED;	\
274:               		}													\
275:               	}														\
276:               	taskEXIT_CRITICAL()
277:               /*-----------------------------------------------------------*/
278:               
279:               BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
280:               {
001FEA  FA0006     LNK #0x6
001FEC  980710     MOV W0, [W14+2]
001FEE  980721     MOV W1, [W14+4]
281:               Queue_t * const pxQueue = ( Queue_t * ) xQueue;
001FF0  90009E     MOV [W14+2], W1
001FF2  780F01     MOV W1, [W14]
282:               
283:               	configASSERT( pxQueue );
284:               
285:               	taskENTER_CRITICAL();
001FF4  0248DA     CALL vPortEnterCritical
001FF6  000000     NOP
286:               	{
287:               		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
001FF8  78001E     MOV [W14], W0
001FFA  780110     MOV [W0], W2
001FFC  78001E     MOV [W14], W0
001FFE  9008F0     MOV [W0+30], W1
002000  78001E     MOV [W14], W0
002002  901000     MOV [W0+32], W0
002004  B98800     MUL.SS W1, W0, W0
002006  780000     MOV W0, W0
002008  410080     ADD W2, W0, W1
00200A  78001E     MOV [W14], W0
00200C  980011     MOV W1, [W0+2]
288:               		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
00200E  78001E     MOV [W14], W0
002010  EB0080     CLR W1
002012  980861     MOV W1, [W0+28]
289:               		pxQueue->pcWriteTo = pxQueue->pcHead;
002014  78001E     MOV [W14], W0
002016  780090     MOV [W0], W1
002018  78001E     MOV [W14], W0
00201A  980021     MOV W1, [W0+4]
290:               		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
00201C  78001E     MOV [W14], W0
00201E  780110     MOV [W0], W2
002020  78001E     MOV [W14], W0
002022  900870     MOV [W0+30], W0
002024  E90080     DEC W0, W1
002026  78001E     MOV [W14], W0
002028  901000     MOV [W0+32], W0
00202A  B98800     MUL.SS W1, W0, W0
00202C  780000     MOV W0, W0
00202E  410080     ADD W2, W0, W1
002030  78001E     MOV [W14], W0
002032  980031     MOV W1, [W0+6]
291:               		pxQueue->cRxLock = queueUNLOCKED;
002034  78001E     MOV [W14], W0
002036  EBC080     SETM.B W1
002038  986021     MOV.B W1, [W0+34]
292:               		pxQueue->cTxLock = queueUNLOCKED;
00203A  78001E     MOV [W14], W0
00203C  EBC080     SETM.B W1
00203E  986031     MOV.B W1, [W0+35]
293:               
294:               		if( xNewQueue == pdFALSE )
002040  90002E     MOV [W14+4], W0
002042  E00000     CP0 W0
002044  3A000E     BRA NZ, .L2
295:               		{
296:               			/* If there are tasks blocked waiting to read from the queue, then
297:               			the tasks will remain blocked as after this function exits the queue
298:               			will still be empty.  If there are tasks blocked waiting to write to
299:               			the queue, then one should be unblocked as after this function exits
300:               			it will be possible to write to it. */
301:               			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
002046  78001E     MOV [W14], W0
002048  900040     MOV [W0+8], W0
00204A  E00000     CP0 W0
00204C  320012     BRA Z, .L3
302:               			{
303:               				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
00204E  78009E     MOV [W14], W1
002050  408068     ADD W1, #0x8, W0
002052  02191E     CALL xTaskRemoveFromEventList
002054  000000     NOP
002056  E00000     CP0 W0
002058  32000C     BRA Z, .L3
304:               				{
305:               					queueYIELD_IF_USING_PREEMPTION();
00205A  0250DC     CALL .Letext0, .LFE1, _vPortYield
00205C  000000     NOP
00205E  000000     NOP
002060  370008     BRA .L3
306:               				}
307:               				else
308:               				{
309:               					mtCOVERAGE_TEST_MARKER();
310:               				}
311:               			}
312:               			else
313:               			{
314:               				mtCOVERAGE_TEST_MARKER();
315:               			}
316:               		}
317:               		else
318:               		{
319:               			/* Ensure the event queues start in the correct state. */
320:               			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
002062  78009E     MOV [W14], W1
002064  408068     ADD W1, #0x8, W0
002066  024910     CALL vListInitialise
002068  000000     NOP
321:               			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
00206A  78009E     MOV [W14], W1
00206C  408072     ADD W1, #0x12, W0
00206E  024910     CALL vListInitialise
002070  000000     NOP
322:               		}
323:               	}
324:               	taskEXIT_CRITICAL();
002072  0248F4     CALL vPortExitCritical
002074  000000     NOP
325:               
326:               	/* A value is returned for calling semantic consistency with previous
327:               	versions. */
328:               	return pdPASS;
002076  200010     MOV #0x1, W0
329:               }
002078  FA8000     ULNK
00207A  060000     RETURN
330:               /*-----------------------------------------------------------*/
331:               
332:               #if( configSUPPORT_STATIC_ALLOCATION == 1 )
333:               
334:               	QueueHandle_t xQueueGenericCreateStatic( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, StaticQueue_t *pxStaticQueue, const uint8_t ucQueueType )
335:               	{
336:               	Queue_t *pxNewQueue;
337:               
338:               		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
339:               
340:               		/* The StaticQueue_t structure and the queue storage area must be
341:               		supplied. */
342:               		configASSERT( pxStaticQueue != NULL );
343:               
344:               		/* A queue storage area should be provided if the item size is not 0, and
345:               		should not be provided if the item size is 0. */
346:               		configASSERT( !( ( pucQueueStorage != NULL ) && ( uxItemSize == 0 ) ) );
347:               		configASSERT( !( ( pucQueueStorage == NULL ) && ( uxItemSize != 0 ) ) );
348:               
349:               		#if( configASSERT_DEFINED == 1 )
350:               		{
351:               			/* Sanity check that the size of the structure used to declare a
352:               			variable of type StaticQueue_t or StaticSemaphore_t equals the size of
353:               			the real queue and semaphore structures. */
354:               			volatile size_t xSize = sizeof( StaticQueue_t );
355:               			configASSERT( xSize == sizeof( Queue_t ) );
356:               		}
357:               		#endif /* configASSERT_DEFINED */
358:               
359:               		/* The address of a statically allocated queue was passed in, use it.
360:               		The address of a statically allocated storage area was also passed in
361:               		but is already set. */
362:               		pxNewQueue = ( Queue_t * ) pxStaticQueue; /*lint !e740 Unusual cast is ok as the structures are designed to have the same alignment, and the size is checked by an assert. */
363:               
364:               		if( pxNewQueue != NULL )
365:               		{
366:               			#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
367:               			{
368:               				/* Queues can be allocated wither statically or dynamically, so
369:               				note this queue was allocated statically in case the queue is
370:               				later deleted. */
371:               				pxNewQueue->ucStaticallyAllocated = pdTRUE;
372:               			}
373:               			#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
374:               
375:               			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
376:               		}
377:               
378:               		return pxNewQueue;
379:               	}
380:               
381:               #endif /* configSUPPORT_STATIC_ALLOCATION */
382:               /*-----------------------------------------------------------*/
383:               
384:               #if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
385:               
386:               	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
387:               	{
00207C  FA000C     LNK #0xC
00207E  980730     MOV W0, [W14+6]
002080  980741     MOV W1, [W14+8]
002082  984F22     MOV.B W2, [W14+10]
388:               	Queue_t *pxNewQueue;
389:               	size_t xQueueSizeInBytes;
390:               	uint8_t *pucQueueStorage;
391:               
392:               		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
393:               
394:               		if( uxItemSize == ( UBaseType_t ) 0 )
002084  90004E     MOV [W14+8], W0
002086  E00000     CP0 W0
002088  3A0003     BRA NZ, .L5
395:               		{
396:               			/* There is not going to be a queue storage area. */
397:               			xQueueSizeInBytes = ( size_t ) 0;
00208A  EB0000     CLR W0
00208C  780F00     MOV W0, [W14]
00208E  370005     BRA .L6
398:               		}
399:               		else
400:               		{
401:               			/* Allocate enough space to hold the maximum number of items that
402:               			can be in the queue at any time. */
403:               			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
002090  9000BE     MOV [W14+6], W1
002092  90004E     MOV [W14+8], W0
002094  B98800     MUL.SS W1, W0, W0
002096  780000     MOV W0, W0
002098  780F00     MOV W0, [W14]
404:               		}
405:               
406:               		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
00209A  200241     MOV #0x24, W1
00209C  40801E     ADD W1, [W14], W0
00209E  023C80     CALL pvPortMalloc
0020A0  000000     NOP
0020A2  980710     MOV W0, [W14+2]
407:               
408:               		if( pxNewQueue != NULL )
0020A4  90001E     MOV [W14+2], W0
0020A6  E00000     CP0 W0
0020A8  320009     BRA Z, .L7
409:               		{
410:               			/* Jump past the queue structure to find the location of the queue
411:               			storage area. */
412:               			pucQueueStorage = ( ( uint8_t * ) pxNewQueue ) + sizeof( Queue_t );
0020AA  90001E     MOV [W14+2], W0
0020AC  B00240     ADD #0x24, W0
0020AE  980720     MOV W0, [W14+4]
413:               
414:               			#if( configSUPPORT_STATIC_ALLOCATION == 1 )
415:               			{
416:               				/* Queues can be created either statically or dynamically, so
417:               				note this task was created dynamically in case it is later
418:               				deleted. */
419:               				pxNewQueue->ucStaticallyAllocated = pdFALSE;
420:               			}
421:               			#endif /* configSUPPORT_STATIC_ALLOCATION */
422:               
423:               			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
0020B0  90021E     MOV [W14+2], W4
0020B2  9049AE     MOV.B [W14+10], W3
0020B4  90012E     MOV [W14+4], W2
0020B6  9000CE     MOV [W14+8], W1
0020B8  90003E     MOV [W14+6], W0
0020BA  070003     RCALL _prvInitialiseNewQueue, .LFE1, .LFB2
424:               		}
425:               
426:               		return pxNewQueue;
0020BC  90001E     MOV [W14+2], W0
427:               	}
0020BE  FA8000     ULNK
0020C0  060000     RETURN
428:               
429:               #endif /* configSUPPORT_STATIC_ALLOCATION */
430:               /*-----------------------------------------------------------*/
431:               
432:               static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, const uint8_t ucQueueType, Queue_t *pxNewQueue )
433:               {
0020C2  FA000A     LNK #0xA
0020C4  780F00     MOV W0, [W14]
0020C6  980711     MOV W1, [W14+2]
0020C8  980722     MOV W2, [W14+4]
0020CA  984763     MOV.B W3, [W14+6]
0020CC  980744     MOV W4, [W14+8]
434:               	/* Remove compiler warnings about unused parameters should
435:               	configUSE_TRACE_FACILITY not be set to 1. */
436:               	( void ) ucQueueType;
437:               
438:               	if( uxItemSize == ( UBaseType_t ) 0 )
0020CE  90001E     MOV [W14+2], W0
0020D0  E00000     CP0 W0
0020D2  3A0004     BRA NZ, .L9
439:               	{
440:               		/* No RAM was allocated for the queue storage area, but PC head cannot
441:               		be set to NULL because NULL is used as a key to say the queue is used as
442:               		a mutex.  Therefore just set pcHead to point to the queue as a benign
443:               		value that is known to be within the memory map. */
444:               		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
0020D4  9000CE     MOV [W14+8], W1
0020D6  90004E     MOV [W14+8], W0
0020D8  780801     MOV W1, [W0]
0020DA  370003     BRA .L10
445:               	}
446:               	else
447:               	{
448:               		/* Set the head to the start of the queue storage area. */
449:               		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
0020DC  9000AE     MOV [W14+4], W1
0020DE  90004E     MOV [W14+8], W0
0020E0  780801     MOV W1, [W0]
450:               	}
451:               
452:               	/* Initialise the queue members as described where the queue type is
453:               	defined. */
454:               	pxNewQueue->uxLength = uxQueueLength;
0020E2  90004E     MOV [W14+8], W0
0020E4  78009E     MOV [W14], W1
0020E6  980871     MOV W1, [W0+30]
455:               	pxNewQueue->uxItemSize = uxItemSize;
0020E8  90004E     MOV [W14+8], W0
0020EA  90009E     MOV [W14+2], W1
0020EC  981001     MOV W1, [W0+32]
456:               	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
0020EE  200011     MOV #0x1, W1
0020F0  90004E     MOV [W14+8], W0
0020F2  07FF7B     RCALL xQueueGenericReset
457:               
458:               	#if ( configUSE_TRACE_FACILITY == 1 )
459:               	{
460:               		pxNewQueue->ucQueueType = ucQueueType;
461:               	}
462:               	#endif /* configUSE_TRACE_FACILITY */
463:               
464:               	#if( configUSE_QUEUE_SETS == 1 )
465:               	{
466:               		pxNewQueue->pxQueueSetContainer = NULL;
467:               	}
468:               	#endif /* configUSE_QUEUE_SETS */
469:               
470:               	traceQUEUE_CREATE( pxNewQueue );
471:               }
0020F4  FA8000     ULNK
0020F6  060000     RETURN
472:               /*-----------------------------------------------------------*/
473:               
474:               #if( configUSE_MUTEXES == 1 )
475:               
476:               	static void prvInitialiseMutex( Queue_t *pxNewQueue )
477:               	{
478:               		if( pxNewQueue != NULL )
479:               		{
480:               			/* The queue create function will set all the queue structure members
481:               			correctly for a generic queue, but this function is creating a
482:               			mutex.  Overwrite those members that need to be set differently -
483:               			in particular the information required for priority inheritance. */
484:               			pxNewQueue->pxMutexHolder = NULL;
485:               			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
486:               
487:               			/* In case this is a recursive mutex. */
488:               			pxNewQueue->u.uxRecursiveCallCount = 0;
489:               
490:               			traceCREATE_MUTEX( pxNewQueue );
491:               
492:               			/* Start with the semaphore in the expected state. */
493:               			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
494:               		}
495:               		else
496:               		{
497:               			traceCREATE_MUTEX_FAILED();
498:               		}
499:               	}
500:               
501:               #endif /* configUSE_MUTEXES */
502:               /*-----------------------------------------------------------*/
503:               
504:               #if( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
505:               
506:               	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
507:               	{
508:               	Queue_t *pxNewQueue;
509:               	const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;
510:               
511:               		pxNewQueue = ( Queue_t * ) xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
512:               		prvInitialiseMutex( pxNewQueue );
513:               
514:               		return pxNewQueue;
515:               	}
516:               
517:               #endif /* configUSE_MUTEXES */
518:               /*-----------------------------------------------------------*/
519:               
520:               #if( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
521:               
522:               	QueueHandle_t xQueueCreateMutexStatic( const uint8_t ucQueueType, StaticQueue_t *pxStaticQueue )
523:               	{
524:               	Queue_t *pxNewQueue;
525:               	const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;
526:               
527:               		/* Prevent compiler warnings about unused parameters if
528:               		configUSE_TRACE_FACILITY does not equal 1. */
529:               		( void ) ucQueueType;
530:               
531:               		pxNewQueue = ( Queue_t * ) xQueueGenericCreateStatic( uxMutexLength, uxMutexSize, NULL, pxStaticQueue, ucQueueType );
532:               		prvInitialiseMutex( pxNewQueue );
533:               
534:               		return pxNewQueue;
535:               	}
536:               
537:               #endif /* configUSE_MUTEXES */
538:               /*-----------------------------------------------------------*/
539:               
540:               #if ( ( configUSE_MUTEXES == 1 ) && ( INCLUDE_xSemaphoreGetMutexHolder == 1 ) )
541:               
542:               	void* xQueueGetMutexHolder( QueueHandle_t xSemaphore )
543:               	{
544:               	void *pxReturn;
545:               
546:               		/* This function is called by xSemaphoreGetMutexHolder(), and should not
547:               		be called directly.  Note:  This is a good way of determining if the
548:               		calling task is the mutex holder, but not a good way of determining the
549:               		identity of the mutex holder, as the holder may change between the
550:               		following critical section exiting and the function returning. */
551:               		taskENTER_CRITICAL();
552:               		{
553:               			if( ( ( Queue_t * ) xSemaphore )->uxQueueType == queueQUEUE_IS_MUTEX )
554:               			{
555:               				pxReturn = ( void * ) ( ( Queue_t * ) xSemaphore )->pxMutexHolder;
556:               			}
557:               			else
558:               			{
559:               				pxReturn = NULL;
560:               			}
561:               		}
562:               		taskEXIT_CRITICAL();
563:               
564:               		return pxReturn;
565:               	} /*lint !e818 xSemaphore cannot be a pointer to const because it is a typedef. */
566:               
567:               #endif
568:               /*-----------------------------------------------------------*/
569:               
570:               #if ( configUSE_RECURSIVE_MUTEXES == 1 )
571:               
572:               	BaseType_t xQueueGiveMutexRecursive( QueueHandle_t xMutex )
573:               	{
574:               	BaseType_t xReturn;
575:               	Queue_t * const pxMutex = ( Queue_t * ) xMutex;
576:               
577:               		configASSERT( pxMutex );
578:               
579:               		/* If this is the task that holds the mutex then pxMutexHolder will not
580:               		change outside of this task.  If this task does not hold the mutex then
581:               		pxMutexHolder can never coincidentally equal the tasks handle, and as
582:               		this is the only condition we are interested in it does not matter if
583:               		pxMutexHolder is accessed simultaneously by another task.  Therefore no
584:               		mutual exclusion is required to test the pxMutexHolder variable. */
585:               		if( pxMutex->pxMutexHolder == ( void * ) xTaskGetCurrentTaskHandle() ) /*lint !e961 Not a redundant cast as TaskHandle_t is a typedef. */
586:               		{
587:               			traceGIVE_MUTEX_RECURSIVE( pxMutex );
588:               
589:               			/* uxRecursiveCallCount cannot be zero if pxMutexHolder is equal to
590:               			the task handle, therefore no underflow check is required.  Also,
591:               			uxRecursiveCallCount is only modified by the mutex holder, and as
592:               			there can only be one, no mutual exclusion is required to modify the
593:               			uxRecursiveCallCount member. */
594:               			( pxMutex->u.uxRecursiveCallCount )--;
595:               
596:               			/* Has the recursive call count unwound to 0? */
597:               			if( pxMutex->u.uxRecursiveCallCount == ( UBaseType_t ) 0 )
598:               			{
599:               				/* Return the mutex.  This will automatically unblock any other
600:               				task that might be waiting to access the mutex. */
601:               				( void ) xQueueGenericSend( pxMutex, NULL, queueMUTEX_GIVE_BLOCK_TIME, queueSEND_TO_BACK );
602:               			}
603:               			else
604:               			{
605:               				mtCOVERAGE_TEST_MARKER();
606:               			}
607:               
608:               			xReturn = pdPASS;
609:               		}
610:               		else
611:               		{
612:               			/* The mutex cannot be given because the calling task is not the
613:               			holder. */
614:               			xReturn = pdFAIL;
615:               
616:               			traceGIVE_MUTEX_RECURSIVE_FAILED( pxMutex );
617:               		}
618:               
619:               		return xReturn;
620:               	}
621:               
622:               #endif /* configUSE_RECURSIVE_MUTEXES */
623:               /*-----------------------------------------------------------*/
624:               
625:               #if ( configUSE_RECURSIVE_MUTEXES == 1 )
626:               
627:               	BaseType_t xQueueTakeMutexRecursive( QueueHandle_t xMutex, TickType_t xTicksToWait )
628:               	{
629:               	BaseType_t xReturn;
630:               	Queue_t * const pxMutex = ( Queue_t * ) xMutex;
631:               
632:               		configASSERT( pxMutex );
633:               
634:               		/* Comments regarding mutual exclusion as per those within
635:               		xQueueGiveMutexRecursive(). */
636:               
637:               		traceTAKE_MUTEX_RECURSIVE( pxMutex );
638:               
639:               		if( pxMutex->pxMutexHolder == ( void * ) xTaskGetCurrentTaskHandle() ) /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
640:               		{
641:               			( pxMutex->u.uxRecursiveCallCount )++;
642:               			xReturn = pdPASS;
643:               		}
644:               		else
645:               		{
646:               			xReturn = xQueueGenericReceive( pxMutex, NULL, xTicksToWait, pdFALSE );
647:               
648:               			/* pdPASS will only be returned if the mutex was successfully
649:               			obtained.  The calling task may have entered the Blocked state
650:               			before reaching here. */
651:               			if( xReturn != pdFAIL )
652:               			{
653:               				( pxMutex->u.uxRecursiveCallCount )++;
654:               			}
655:               			else
656:               			{
657:               				traceTAKE_MUTEX_RECURSIVE_FAILED( pxMutex );
658:               			}
659:               		}
660:               
661:               		return xReturn;
662:               	}
663:               
664:               #endif /* configUSE_RECURSIVE_MUTEXES */
665:               /*-----------------------------------------------------------*/
666:               
667:               #if( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
668:               
669:               	QueueHandle_t xQueueCreateCountingSemaphoreStatic( const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount, StaticQueue_t *pxStaticQueue )
670:               	{
671:               	QueueHandle_t xHandle;
672:               
673:               		configASSERT( uxMaxCount != 0 );
674:               		configASSERT( uxInitialCount <= uxMaxCount );
675:               
676:               		xHandle = xQueueGenericCreateStatic( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, NULL, pxStaticQueue, queueQUEUE_TYPE_COUNTING_SEMAPHORE );
677:               
678:               		if( xHandle != NULL )
679:               		{
680:               			( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
681:               
682:               			traceCREATE_COUNTING_SEMAPHORE();
683:               		}
684:               		else
685:               		{
686:               			traceCREATE_COUNTING_SEMAPHORE_FAILED();
687:               		}
688:               
689:               		return xHandle;
690:               	}
691:               
692:               #endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
693:               /*-----------------------------------------------------------*/
694:               
695:               #if( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
696:               
697:               	QueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount )
698:               	{
699:               	QueueHandle_t xHandle;
700:               
701:               		configASSERT( uxMaxCount != 0 );
702:               		configASSERT( uxInitialCount <= uxMaxCount );
703:               
704:               		xHandle = xQueueGenericCreate( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUNTING_SEMAPHORE );
705:               
706:               		if( xHandle != NULL )
707:               		{
708:               			( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
709:               
710:               			traceCREATE_COUNTING_SEMAPHORE();
711:               		}
712:               		else
713:               		{
714:               			traceCREATE_COUNTING_SEMAPHORE_FAILED();
715:               		}
716:               
717:               		return xHandle;
718:               	}
719:               
720:               #endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
721:               /*-----------------------------------------------------------*/
722:               
723:               BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
724:               {
0020F8  FA0012     LNK #0x12
0020FA  980750     MOV W0, [W14+10]
0020FC  980761     MOV W1, [W14+12]
0020FE  980772     MOV W2, [W14+14]
002100  980F03     MOV W3, [W14+16]
725:               BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
002102  EB0000     CLR W0
002104  780F00     MOV W0, [W14]
726:               TimeOut_t xTimeOut;
727:               Queue_t * const pxQueue = ( Queue_t * ) xQueue;
002106  9000DE     MOV [W14+10], W1
002108  980711     MOV W1, [W14+2]
00210A  370001     BRA .L24
728:               
729:               	configASSERT( pxQueue );
730:               	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
731:               	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
732:               	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
733:               	{
734:               		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
735:               	}
736:               	#endif
737:               
738:               
739:               	/* This function relaxes the coding standard somewhat to allow return
740:               	statements within the function itself.  This is done in the interest
741:               	of execution time efficiency. */
742:               	for( ;; )
743:               	{
744:               		taskENTER_CRITICAL();
00210E  0248DA     CALL vPortEnterCritical
002110  000000     NOP
745:               		{
746:               			/* Is there room on the queue now?  The running task must be the
747:               			highest priority task wanting to access the queue.  If the head item
748:               			in the queue is to be overwritten then it does not matter if the
749:               			queue is full. */
750:               			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
002112  90001E     MOV [W14+2], W0
002114  9008E0     MOV [W0+28], W1
002116  90001E     MOV [W14+2], W0
002118  900870     MOV [W0+30], W0
00211A  508F80     SUB W1, W0, [W15]
00211C  390003     BRA NC, .L12
00211E  90080E     MOV [W14+16], W0
002120  500FE2     SUB W0, #0x2, [W15]
002122  3A001D     BRA NZ, .L13
751:               			{
752:               				traceQUEUE_SEND( pxQueue );
753:               				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
002124  90090E     MOV [W14+16], W2
002126  9000EE     MOV [W14+12], W1
002128  90001E     MOV [W14+2], W0
00212A  0701E9     RCALL _prvCopyDataToQueue, .LFE12, .LFB13
00212C  980720     MOV W0, [W14+4]
754:               
755:               				#if ( configUSE_QUEUE_SETS == 1 )
756:               				{
757:               					if( pxQueue->pxQueueSetContainer != NULL )
758:               					{
759:               						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) != pdFALSE )
760:               						{
761:               							/* The queue is a member of a queue set, and posting
762:               							to the queue set caused a higher priority task to
763:               							unblock. A context switch is required. */
764:               							queueYIELD_IF_USING_PREEMPTION();
765:               						}
766:               						else
767:               						{
768:               							mtCOVERAGE_TEST_MARKER();
769:               						}
770:               					}
771:               					else
772:               					{
773:               						/* If there was a task waiting for data to arrive on the
774:               						queue then unblock it now. */
775:               						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
776:               						{
777:               							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
778:               							{
779:               								/* The unblocked task has a priority higher than
780:               								our own so yield immediately.  Yes it is ok to
781:               								do this from within the critical section - the
782:               								kernel takes care of that. */
783:               								queueYIELD_IF_USING_PREEMPTION();
784:               							}
785:               							else
786:               							{
787:               								mtCOVERAGE_TEST_MARKER();
788:               							}
789:               						}
790:               						else if( xYieldRequired != pdFALSE )
791:               						{
792:               							/* This path is a special case that will only get
793:               							executed if the task was holding multiple mutexes
794:               							and the mutexes were given back in an order that is
795:               							different to that in which they were taken. */
796:               							queueYIELD_IF_USING_PREEMPTION();
797:               						}
798:               						else
799:               						{
800:               							mtCOVERAGE_TEST_MARKER();
801:               						}
802:               					}
803:               				}
804:               				#else /* configUSE_QUEUE_SETS */
805:               				{
806:               					/* If there was a task waiting for data to arrive on the
807:               					queue then unblock it now. */
808:               					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
00212E  90001E     MOV [W14+2], W0
002130  900810     MOV [W0+18], W0
002132  E00000     CP0 W0
002134  32000A     BRA Z, .L14
809:               					{
810:               						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
002136  90001E     MOV [W14+2], W0
002138  400072     ADD W0, #0x12, W0
00213A  02191E     CALL xTaskRemoveFromEventList
00213C  000000     NOP
00213E  E00000     CP0 W0
002140  32000A     BRA Z, .L15
811:               						{
812:               							/* The unblocked task has a priority higher than
813:               							our own so yield immediately.  Yes it is ok to do
814:               							this from within the critical section - the kernel
815:               							takes care of that. */
816:               							queueYIELD_IF_USING_PREEMPTION();
002142  0250DC     CALL .Letext0, .LFE1, _vPortYield
002144  000000     NOP
002146  000000     NOP
002148  370006     BRA .L15
817:               						}
818:               						else
819:               						{
820:               							mtCOVERAGE_TEST_MARKER();
821:               						}
822:               					}
823:               					else if( xYieldRequired != pdFALSE )
00214A  90002E     MOV [W14+4], W0
00214C  E00000     CP0 W0
00214E  320003     BRA Z, .L15
824:               					{
825:               						/* This path is a special case that will only get
826:               						executed if the task was holding multiple mutexes and
827:               						the mutexes were given back in an order that is
828:               						different to that in which they were taken. */
829:               						queueYIELD_IF_USING_PREEMPTION();
002150  0250DC     CALL .Letext0, .LFE1, _vPortYield
002152  000000     NOP
002154  000000     NOP
830:               					}
831:               					else
832:               					{
833:               						mtCOVERAGE_TEST_MARKER();
834:               					}
835:               				}
836:               				#endif /* configUSE_QUEUE_SETS */
837:               
838:               				taskEXIT_CRITICAL();
002156  0248F4     CALL vPortExitCritical
002158  000000     NOP
839:               				return pdPASS;
00215A  200010     MOV #0x1, W0
00215C  370048     BRA .L16
840:               			}
841:               			else
842:               			{
843:               				if( xTicksToWait == ( TickType_t ) 0 )
00215E  90007E     MOV [W14+14], W0
002160  E00000     CP0 W0
002162  3A0004     BRA NZ, .L17
844:               				{
845:               					/* The queue was full and no block time is specified (or
846:               					the block time has expired) so leave now. */
847:               					taskEXIT_CRITICAL();
002164  0248F4     CALL vPortExitCritical
002166  000000     NOP
848:               
849:               					/* Return to the original privilege level before exiting
850:               					the function. */
851:               					traceQUEUE_SEND_FAILED( pxQueue );
852:               					return errQUEUE_FULL;
002168  EB0000     CLR W0
00216A  370041     BRA .L16
853:               				}
854:               				else if( xEntryTimeSet == pdFALSE )
00216C  78001E     MOV [W14], W0
00216E  E00000     CP0 W0
002170  3A0005     BRA NZ, .L18
855:               				{
856:               					/* The queue was full and a block time was specified so
857:               					configure the timeout structure. */
858:               					vTaskSetTimeOutState( &xTimeOut );
002172  470066     ADD W14, #0x6, W0
002174  0219FE     CALL vTaskSetTimeOutState
002176  000000     NOP
859:               					xEntryTimeSet = pdTRUE;
002178  200010     MOV #0x1, W0
00217A  780F00     MOV W0, [W14]
860:               				}
861:               				else
862:               				{
863:               					/* Entry time was already set. */
864:               					mtCOVERAGE_TEST_MARKER();
865:               				}
866:               			}
867:               		}
868:               		taskEXIT_CRITICAL();
00217C  0248F4     CALL vPortExitCritical
00217E  000000     NOP
869:               
870:               		/* Interrupts and other tasks can send to and receive from the queue
871:               		now the critical section has been exited. */
872:               
873:               		vTaskSuspendAll();
002180  02165E     CALL vTaskSuspendAll
002182  000000     NOP
874:               		prvLockQueue( pxQueue );
002184  0248DA     CALL vPortEnterCritical
002186  000000     NOP
002188  90001E     MOV [W14+2], W0
00218A  906020     MOV.B [W0+34], W0
00218C  404FE1     ADD.B W0, #0x1, [W15]
00218E  3A0003     BRA NZ, .L19
002190  90001E     MOV [W14+2], W0
002192  EB4080     CLR.B W1
002194  986021     MOV.B W1, [W0+34]
002196  90001E     MOV [W14+2], W0
002198  906030     MOV.B [W0+35], W0
00219A  404FE1     ADD.B W0, #0x1, [W15]
00219C  3A0003     BRA NZ, .L20
00219E  90001E     MOV [W14+2], W0
0021A0  EB4080     CLR.B W1
0021A2  986031     MOV.B W1, [W0+35]
0021A4  0248F4     CALL vPortExitCritical
0021A6  000000     NOP
875:               
876:               		/* Update the timeout state to see if it has expired yet. */
877:               		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
0021A8  4700EE     ADD W14, #0xE, W1
0021AA  470066     ADD W14, #0x6, W0
0021AC  021A12     CALL xTaskCheckForTimeOut
0021AE  000000     NOP
0021B0  E00000     CP0 W0
0021B2  3A0018     BRA NZ, .L21
878:               		{
879:               			if( prvIsQueueFull( pxQueue ) != pdFALSE )
0021B4  90001E     MOV [W14+2], W0
0021B6  07027B     RCALL _prvIsQueueFull, .LFE17, .LFB18
0021B8  E00000     CP0 W0
0021BA  32000F     BRA Z, .L22
880:               			{
881:               				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
882:               				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
0021BC  9000FE     MOV [W14+14], W1
0021BE  90001E     MOV [W14+2], W0
0021C0  400068     ADD W0, #0x8, W0
0021C2  0218DA     CALL vTaskPlaceOnEventList
0021C4  000000     NOP
883:               
884:               				/* Unlocking the queue means queue events can effect the
885:               				event list.  It is possible	that interrupts occurring now
886:               				remove this task from the event	list again - but as the
887:               				scheduler is suspended the task will go onto the pending
888:               				ready last instead of the actual ready list. */
889:               				prvUnlockQueue( pxQueue );
0021C6  90001E     MOV [W14+2], W0
0021C8  070212     RCALL _prvUnlockQueue, .LFE14, .LFB15
890:               
891:               				/* Resuming the scheduler will move tasks from the pending
892:               				ready list into the ready list - so it is feasible that this
893:               				task is already in a ready list before it yields - in which
894:               				case the yield will not cause a context switch unless there
895:               				is also a higher priority task in the pending ready list. */
896:               				if( xTaskResumeAll() == pdFALSE )
0021CA  02166A     CALL xTaskResumeAll
0021CC  000000     NOP
0021CE  E00000     CP0 W0
0021D0  3AFF9D     BRA NZ, .L25
897:               				{
898:               					portYIELD_WITHIN_API();
0021D2  0250DC     CALL .Letext0, .LFE1, _vPortYield
0021D4  000000     NOP
0021D6  000000     NOP
899:               				}
900:               			}
901:               			else
902:               			{
903:               				/* Try again. */
904:               				prvUnlockQueue( pxQueue );
0021DA  90001E     MOV [W14+2], W0
0021DC  070208     RCALL _prvUnlockQueue, .LFE14, .LFB15
905:               				( void ) xTaskResumeAll();
0021DE  02166A     CALL xTaskResumeAll
0021E0  000000     NOP
906:               			}
907:               		}
908:               		else
909:               		{
910:               			/* The timeout has expired. */
911:               			prvUnlockQueue( pxQueue );
0021E4  90001E     MOV [W14+2], W0
0021E6  070203     RCALL _prvUnlockQueue, .LFE14, .LFB15
912:               			( void ) xTaskResumeAll();
0021E8  02166A     CALL xTaskResumeAll
0021EA  000000     NOP
913:               
914:               			traceQUEUE_SEND_FAILED( pxQueue );
915:               			return errQUEUE_FULL;
0021EC  EB0000     CLR W0
916:               		}
917:               	}
00210C  000000     NOP
0021D8  37FF9A     BRA .L24
0021E2  37FF95     BRA .L24
918:               }
0021EE  FA8000     ULNK
0021F0  060000     RETURN
919:               /*-----------------------------------------------------------*/
920:               
921:               BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
922:               {
0021F2  FA0010     LNK #0x10
0021F4  980740     MOV W0, [W14+8]
0021F6  980751     MOV W1, [W14+10]
0021F8  980762     MOV W2, [W14+12]
0021FA  980773     MOV W3, [W14+14]
923:               BaseType_t xReturn;
924:               UBaseType_t uxSavedInterruptStatus;
925:               Queue_t * const pxQueue = ( Queue_t * ) xQueue;
0021FC  9000CE     MOV [W14+8], W1
0021FE  980711     MOV W1, [W14+2]
926:               
927:               	configASSERT( pxQueue );
928:               	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
929:               	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
930:               
931:               	/* RTOS ports that support interrupt nesting have the concept of a maximum
932:               	system call (or maximum API call) interrupt priority.  Interrupts that are
933:               	above the maximum system call priority are kept permanently enabled, even
934:               	when the RTOS kernel is in a critical section, but cannot make any calls to
935:               	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
936:               	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
937:               	failure if a FreeRTOS API function is called from an interrupt that has been
938:               	assigned a priority above the configured maximum system call priority.
939:               	Only FreeRTOS functions that end in FromISR can be called from interrupts
940:               	that have been assigned a priority at or (logically) below the maximum
941:               	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
942:               	safe API to ensure interrupt entry is as fast and as simple as possible.
943:               	More information (albeit Cortex-M specific) is provided on the following
944:               	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
945:               	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
946:               
947:               	/* Similar to xQueueGenericSend, except without blocking if there is no room
948:               	in the queue.  Also don't directly wake a task that was blocked on a queue
949:               	read, instead return a flag to say whether a context switch is required or
950:               	not (i.e. has a task with a higher priority than us been woken by this
951:               	post). */
952:               	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
002200  EB0000     CLR W0
002202  980720     MOV W0, [W14+4]
953:               	{
954:               		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
002204  90001E     MOV [W14+2], W0
002206  9008E0     MOV [W0+28], W1
002208  90001E     MOV [W14+2], W0
00220A  900870     MOV [W0+30], W0
00220C  508F80     SUB W1, W0, [W15]
00220E  390003     BRA NC, .L27, .LBB2
002210  90007E     MOV [W14+14], W0
002212  500FE2     SUB W0, #0x2, [W15]
002214  3A0023     BRA NZ, .L28
955:               		{
00225A  370002     BRA .L31
956:               			const int8_t cTxLock = pxQueue->cTxLock;
002216  90001E     MOV [W14+2], W0
002218  9060B0     MOV.B [W0+35], W1
00221A  984761     MOV.B W1, [W14+6]
957:               
958:               			traceQUEUE_SEND_FROM_ISR( pxQueue );
959:               
960:               			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
961:               			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
962:               			in a task disinheriting a priority and prvCopyDataToQueue() can be
963:               			called here even though the disinherit function does not check if
964:               			the scheduler is suspended before accessing the ready lists. */
965:               			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
00221C  90017E     MOV [W14+14], W2
00221E  9000DE     MOV [W14+10], W1
002220  90001E     MOV [W14+2], W0
002222  07016D     RCALL _prvCopyDataToQueue, .LFE12, .LFB13
966:               
967:               			/* The event list is not altered if the queue is locked.  This will
968:               			be done when the queue is unlocked later. */
969:               			if( cTxLock == queueUNLOCKED )
002224  90406E     MOV.B [W14+6], W0
002226  404FE1     ADD.B W0, #0x1, [W15]
002228  3A0011     BRA NZ, .L29
970:               			{
971:               				#if ( configUSE_QUEUE_SETS == 1 )
972:               				{
973:               					if( pxQueue->pxQueueSetContainer != NULL )
974:               					{
975:               						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) != pdFALSE )
976:               						{
977:               							/* The queue is a member of a queue set, and posting
978:               							to the queue set caused a higher priority task to
979:               							unblock.  A context switch is required. */
980:               							if( pxHigherPriorityTaskWoken != NULL )
981:               							{
982:               								*pxHigherPriorityTaskWoken = pdTRUE;
983:               							}
984:               							else
985:               							{
986:               								mtCOVERAGE_TEST_MARKER();
987:               							}
988:               						}
989:               						else
990:               						{
991:               							mtCOVERAGE_TEST_MARKER();
992:               						}
993:               					}
994:               					else
995:               					{
996:               						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
997:               						{
998:               							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
999:               							{
1000:              								/* The task waiting has a higher priority so
1001:              								record that a context switch is required. */
1002:              								if( pxHigherPriorityTaskWoken != NULL )
1003:              								{
1004:              									*pxHigherPriorityTaskWoken = pdTRUE;
1005:              								}
1006:              								else
1007:              								{
1008:              									mtCOVERAGE_TEST_MARKER();
1009:              								}
1010:              							}
1011:              							else
1012:              							{
1013:              								mtCOVERAGE_TEST_MARKER();
1014:              							}
1015:              						}
1016:              						else
1017:              						{
1018:              							mtCOVERAGE_TEST_MARKER();
1019:              						}
1020:              					}
1021:              				}
1022:              				#else /* configUSE_QUEUE_SETS */
1023:              				{
1024:              					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
00222A  90001E     MOV [W14+2], W0
00222C  900810     MOV [W0+18], W0
00222E  E00000     CP0 W0
002230  320012     BRA Z, .L30
1025:              					{
1026:              						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
002232  90001E     MOV [W14+2], W0
002234  400072     ADD W0, #0x12, W0
002236  02191E     CALL xTaskRemoveFromEventList
002238  000000     NOP
00223A  E00000     CP0 W0
00223C  32000C     BRA Z, .L30
1027:              						{
1028:              							/* The task waiting has a higher priority so record that a
1029:              							context	switch is required. */
1030:              							if( pxHigherPriorityTaskWoken != NULL )
00223E  90006E     MOV [W14+12], W0
002240  E00000     CP0 W0
002242  320009     BRA Z, .L30
1031:              							{
1032:              								*pxHigherPriorityTaskWoken = pdTRUE;
002244  90006E     MOV [W14+12], W0
002246  200011     MOV #0x1, W1
002248  780801     MOV W1, [W0]
00224A  370005     BRA .L30
1033:              							}
1034:              							else
1035:              							{
1036:              								mtCOVERAGE_TEST_MARKER();
1037:              							}
1038:              						}
1039:              						else
1040:              						{
1041:              							mtCOVERAGE_TEST_MARKER();
1042:              						}
1043:              					}
1044:              					else
1045:              					{
1046:              						mtCOVERAGE_TEST_MARKER();
1047:              					}
1048:              				}
1049:              				#endif /* configUSE_QUEUE_SETS */
1050:              			}
1051:              			else
1052:              			{
1053:              				/* Increment the lock count so the task that unlocks the queue
1054:              				knows that data was posted while it was locked. */
1055:              				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
00224C  90406E     MOV.B [W14+6], W0
00224E  E84000     INC.B W0, W0
002250  784080     MOV.B W0, W1
002252  90001E     MOV [W14+2], W0
002254  986031     MOV.B W1, [W0+35]
1056:              			}
1057:              
1058:              			xReturn = pdPASS;
002256  200010     MOV #0x1, W0
002258  780F00     MOV W0, [W14]
1059:              		}
1060:              		else
1061:              		{
1062:              			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
1063:              			xReturn = errQUEUE_FULL;
00225C  EB0000     CLR W0
00225E  780F00     MOV W0, [W14]
1064:              		}
1065:              	}
1066:              	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1067:              
1068:              	return xReturn;
002260  78001E     MOV [W14], W0
1069:              }
002262  FA8000     ULNK
002264  060000     RETURN
1070:              /*-----------------------------------------------------------*/
1071:              
1072:              BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
1073:              {
002266  FA000E     LNK #0xE
002268  980750     MOV W0, [W14+10]
00226A  980761     MOV W1, [W14+12]
1074:              BaseType_t xReturn;
1075:              UBaseType_t uxSavedInterruptStatus;
1076:              Queue_t * const pxQueue = ( Queue_t * ) xQueue;
00226C  9000DE     MOV [W14+10], W1
00226E  980711     MOV W1, [W14+2]
1077:              
1078:              	/* Similar to xQueueGenericSendFromISR() but used with semaphores where the
1079:              	item size is 0.  Don't directly wake a task that was blocked on a queue
1080:              	read, instead return a flag to say whether a context switch is required or
1081:              	not (i.e. has a task with a higher priority than us been woken by this
1082:              	post). */
1083:              
1084:              	configASSERT( pxQueue );
1085:              
1086:              	/* xQueueGenericSendFromISR() should be used instead of xQueueGiveFromISR()
1087:              	if the item size is not 0. */
1088:              	configASSERT( pxQueue->uxItemSize == 0 );
1089:              
1090:              	/* Normally a mutex would not be given from an interrupt, especially if
1091:              	there is a mutex holder, as priority inheritance makes no sense for an
1092:              	interrupts, only tasks. */
1093:              	configASSERT( !( ( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX ) && ( pxQueue->pxMutexHolder != NULL ) ) );
1094:              
1095:              	/* RTOS ports that support interrupt nesting have the concept of a maximum
1096:              	system call (or maximum API call) interrupt priority.  Interrupts that are
1097:              	above the maximum system call priority are kept permanently enabled, even
1098:              	when the RTOS kernel is in a critical section, but cannot make any calls to
1099:              	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
1100:              	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1101:              	failure if a FreeRTOS API function is called from an interrupt that has been
1102:              	assigned a priority above the configured maximum system call priority.
1103:              	Only FreeRTOS functions that end in FromISR can be called from interrupts
1104:              	that have been assigned a priority at or (logically) below the maximum
1105:              	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
1106:              	safe API to ensure interrupt entry is as fast and as simple as possible.
1107:              	More information (albeit Cortex-M specific) is provided on the following
1108:              	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1109:              	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1110:              
1111:              	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
002270  EB0000     CLR W0
002272  980720     MOV W0, [W14+4]
1112:              	{
1113:              		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
002274  90001E     MOV [W14+2], W0
002276  9008E0     MOV [W0+28], W1
002278  980731     MOV W1, [W14+6]
1114:              
1115:              		/* When the queue is used to implement a semaphore no data is ever
1116:              		moved through the queue but it is still valid to see if the queue 'has
1117:              		space'. */
1118:              		if( uxMessagesWaiting < pxQueue->uxLength )
00227A  90001E     MOV [W14+2], W0
00227C  9008F0     MOV [W0+30], W1
00227E  90003E     MOV [W14+6], W0
002280  508F80     SUB W1, W0, [W15]
002282  360023     BRA LEU, .L33, .LBE4
1119:              		{
1120:              			const int8_t cTxLock = pxQueue->cTxLock;
002284  90001E     MOV [W14+2], W0
002286  9060B0     MOV.B [W0+35], W1
002288  984F01     MOV.B W1, [W14+8]
1121:              
1122:              			traceQUEUE_SEND_FROM_ISR( pxQueue );
1123:              
1124:              			/* A task can only have an inherited priority if it is a mutex
1125:              			holder - and if there is a mutex holder then the mutex cannot be
1126:              			given from an ISR.  As this is the ISR version of the function it
1127:              			can be assumed there is no mutex holder and no need to determine if
1128:              			priority disinheritance is needed.  Simply increase the count of
1129:              			messages (semaphores) available. */
1130:              			pxQueue->uxMessagesWaiting = uxMessagesWaiting + 1;
00228A  90003E     MOV [W14+6], W0
00228C  E80080     INC W0, W1
00228E  90001E     MOV [W14+2], W0
002290  980861     MOV W1, [W0+28]
1131:              
1132:              			/* The event list is not altered if the queue is locked.  This will
1133:              			be done when the queue is unlocked later. */
1134:              			if( cTxLock == queueUNLOCKED )
002292  90480E     MOV.B [W14+8], W0
002294  404FE1     ADD.B W0, #0x1, [W15]
002296  3A0011     BRA NZ, .L34
1135:              			{
1136:              				#if ( configUSE_QUEUE_SETS == 1 )
1137:              				{
1138:              					if( pxQueue->pxQueueSetContainer != NULL )
1139:              					{
1140:              						if( prvNotifyQueueSetContainer( pxQueue, queueSEND_TO_BACK ) != pdFALSE )
1141:              						{
1142:              							/* The semaphore is a member of a queue set, and
1143:              							posting	to the queue set caused a higher priority
1144:              							task to	unblock.  A context switch is required. */
1145:              							if( pxHigherPriorityTaskWoken != NULL )
1146:              							{
1147:              								*pxHigherPriorityTaskWoken = pdTRUE;
1148:              							}
1149:              							else
1150:              							{
1151:              								mtCOVERAGE_TEST_MARKER();
1152:              							}
1153:              						}
1154:              						else
1155:              						{
1156:              							mtCOVERAGE_TEST_MARKER();
1157:              						}
1158:              					}
1159:              					else
1160:              					{
1161:              						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1162:              						{
1163:              							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
1164:              							{
1165:              								/* The task waiting has a higher priority so
1166:              								record that a context switch is required. */
1167:              								if( pxHigherPriorityTaskWoken != NULL )
1168:              								{
1169:              									*pxHigherPriorityTaskWoken = pdTRUE;
1170:              								}
1171:              								else
1172:              								{
1173:              									mtCOVERAGE_TEST_MARKER();
1174:              								}
1175:              							}
1176:              							else
1177:              							{
1178:              								mtCOVERAGE_TEST_MARKER();
1179:              							}
1180:              						}
1181:              						else
1182:              						{
1183:              							mtCOVERAGE_TEST_MARKER();
1184:              						}
1185:              					}
1186:              				}
1187:              				#else /* configUSE_QUEUE_SETS */
1188:              				{
1189:              					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
002298  90001E     MOV [W14+2], W0
00229A  900810     MOV [W0+18], W0
00229C  E00000     CP0 W0
00229E  320012     BRA Z, .L35
1190:              					{
1191:              						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
0022A0  90001E     MOV [W14+2], W0
0022A2  400072     ADD W0, #0x12, W0
0022A4  02191E     CALL xTaskRemoveFromEventList
0022A6  000000     NOP
0022A8  E00000     CP0 W0
0022AA  32000C     BRA Z, .L35
1192:              						{
1193:              							/* The task waiting has a higher priority so record that a
1194:              							context	switch is required. */
1195:              							if( pxHigherPriorityTaskWoken != NULL )
0022AC  90006E     MOV [W14+12], W0
0022AE  E00000     CP0 W0
0022B0  320009     BRA Z, .L35
1196:              							{
1197:              								*pxHigherPriorityTaskWoken = pdTRUE;
0022B2  90006E     MOV [W14+12], W0
0022B4  200011     MOV #0x1, W1
0022B6  780801     MOV W1, [W0]
0022B8  370005     BRA .L35
1198:              							}
1199:              							else
1200:              							{
1201:              								mtCOVERAGE_TEST_MARKER();
1202:              							}
1203:              						}
1204:              						else
1205:              						{
1206:              							mtCOVERAGE_TEST_MARKER();
1207:              						}
1208:              					}
1209:              					else
1210:              					{
1211:              						mtCOVERAGE_TEST_MARKER();
1212:              					}
1213:              				}
1214:              				#endif /* configUSE_QUEUE_SETS */
1215:              			}
1216:              			else
1217:              			{
1218:              				/* Increment the lock count so the task that unlocks the queue
1219:              				knows that data was posted while it was locked. */
1220:              				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
0022BA  90480E     MOV.B [W14+8], W0
0022BC  E84000     INC.B W0, W0
0022BE  784080     MOV.B W0, W1
0022C0  90001E     MOV [W14+2], W0
0022C2  986031     MOV.B W1, [W0+35]
1221:              			}
1222:              
1223:              			xReturn = pdPASS;
0022C4  200010     MOV #0x1, W0
0022C6  780F00     MOV W0, [W14]
0022C8  370002     BRA .L36, .LBE3
1224:              		}
1225:              		else
1226:              		{
1227:              			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
1228:              			xReturn = errQUEUE_FULL;
0022CA  EB0000     CLR W0
0022CC  780F00     MOV W0, [W14]
1229:              		}
1230:              	}
1231:              	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1232:              
1233:              	return xReturn;
0022CE  78001E     MOV [W14], W0
1234:              }
0022D0  FA8000     ULNK
0022D2  060000     RETURN
1235:              /*-----------------------------------------------------------*/
1236:              
1237:              BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
1238:              {
0022D4  FA0014     LNK #0x14
0022D6  980760     MOV W0, [W14+12]
0022D8  980771     MOV W1, [W14+14]
0022DA  980F02     MOV W2, [W14+16]
0022DC  980F13     MOV W3, [W14+18]
1239:              BaseType_t xEntryTimeSet = pdFALSE;
0022DE  EB0000     CLR W0
0022E0  780F00     MOV W0, [W14]
1240:              TimeOut_t xTimeOut;
1241:              int8_t *pcOriginalReadPosition;
1242:              Queue_t * const pxQueue = ( Queue_t * ) xQueue;
0022E2  9000EE     MOV [W14+12], W1
0022E4  980711     MOV W1, [W14+2]
0022E6  370003     BRA .L49
1243:              
1244:              	configASSERT( pxQueue );
1245:              	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
1246:              	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
1247:              	{
1248:              		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
1249:              	}
1250:              	#endif
1251:              
1252:              	/* This function relaxes the coding standard somewhat to allow return
1253:              	statements within the function itself.  This is done in the interest
1254:              	of execution time efficiency. */
1255:              
1256:              	for( ;; )
1257:              	{
1258:              		taskENTER_CRITICAL();
0022EE  0248DA     CALL vPortEnterCritical
0022F0  000000     NOP
1259:              		{
1260:              			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
0022F2  90001E     MOV [W14+2], W0
0022F4  9008E0     MOV [W0+28], W1
0022F6  980721     MOV W1, [W14+4]
1261:              
1262:              			/* Is there data in the queue now?  To be running the calling task
1263:              			must be the highest priority task wanting to access the queue. */
1264:              			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
0022F8  90002E     MOV [W14+4], W0
0022FA  E00000     CP0 W0
0022FC  32002F     BRA Z, .L38
1265:              			{
1266:              				/* Remember the read position in case the queue is only being
1267:              				peeked. */
1268:              				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
0022FE  90001E     MOV [W14+2], W0
002300  9000B0     MOV [W0+6], W1
002302  980731     MOV W1, [W14+6]
1269:              
1270:              				prvCopyDataFromQueue( pxQueue, pvBuffer );
002304  9000FE     MOV [W14+14], W1
002306  90001E     MOV [W14+2], W0
002308  07014F     RCALL _prvCopyDataFromQueue, .LFE13, .LFB14
1271:              
1272:              				if( xJustPeeking == pdFALSE )
00230A  90081E     MOV [W14+18], W0
00230C  E00000     CP0 W0
00230E  3A0012     BRA NZ, .L39
1273:              				{
1274:              					traceQUEUE_RECEIVE( pxQueue );
1275:              
1276:              					/* Actually removing data, not just peeking. */
1277:              					pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
002310  90002E     MOV [W14+4], W0
002312  E90080     DEC W0, W1
002314  90001E     MOV [W14+2], W0
002316  980861     MOV W1, [W0+28]
1278:              
1279:              					#if ( configUSE_MUTEXES == 1 )
1280:              					{
1281:              						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
1282:              						{
1283:              							/* Record the information required to implement
1284:              							priority inheritance should it become necessary. */
1285:              							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
1286:              						}
1287:              						else
1288:              						{
1289:              							mtCOVERAGE_TEST_MARKER();
1290:              						}
1291:              					}
1292:              					#endif /* configUSE_MUTEXES */
1293:              
1294:              					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
002318  90001E     MOV [W14+2], W0
00231A  900040     MOV [W0+8], W0
00231C  E00000     CP0 W0
00231E  32001A     BRA Z, .L40
1295:              					{
1296:              						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
002320  90001E     MOV [W14+2], W0
002322  400068     ADD W0, #0x8, W0
002324  02191E     CALL xTaskRemoveFromEventList
002326  000000     NOP
002328  E00000     CP0 W0
00232A  320014     BRA Z, .L40
1297:              						{
1298:              							queueYIELD_IF_USING_PREEMPTION();
00232C  0250DC     CALL .Letext0, .LFE1, _vPortYield
00232E  000000     NOP
002330  000000     NOP
002332  370010     BRA .L40
1299:              						}
1300:              						else
1301:              						{
1302:              							mtCOVERAGE_TEST_MARKER();
1303:              						}
1304:              					}
1305:              					else
1306:              					{
1307:              						mtCOVERAGE_TEST_MARKER();
1308:              					}
1309:              				}
1310:              				else
1311:              				{
1312:              					traceQUEUE_PEEK( pxQueue );
1313:              
1314:              					/* The data is not being removed, so reset the read
1315:              					pointer. */
1316:              					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
002334  90001E     MOV [W14+2], W0
002336  9000BE     MOV [W14+6], W1
002338  980031     MOV W1, [W0+6]
1317:              
1318:              					/* The data is being left in the queue, so see if there are
1319:              					any other tasks waiting for the data. */
1320:              					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
00233A  90001E     MOV [W14+2], W0
00233C  900810     MOV [W0+18], W0
00233E  E00000     CP0 W0
002340  320009     BRA Z, .L40
1321:              					{
1322:              						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
002342  90001E     MOV [W14+2], W0
002344  400072     ADD W0, #0x12, W0
002346  02191E     CALL xTaskRemoveFromEventList
002348  000000     NOP
00234A  E00000     CP0 W0
00234C  320003     BRA Z, .L40
1323:              						{
1324:              							/* The task waiting has a higher priority than this task. */
1325:              							queueYIELD_IF_USING_PREEMPTION();
00234E  0250DC     CALL .Letext0, .LFE1, _vPortYield
002350  000000     NOP
002352  000000     NOP
1326:              						}
1327:              						else
1328:              						{
1329:              							mtCOVERAGE_TEST_MARKER();
1330:              						}
1331:              					}
1332:              					else
1333:              					{
1334:              						mtCOVERAGE_TEST_MARKER();
1335:              					}
1336:              				}
1337:              
1338:              				taskEXIT_CRITICAL();
002354  0248F4     CALL vPortExitCritical
002356  000000     NOP
1339:              				return pdPASS;
002358  200010     MOV #0x1, W0
00235A  37004C     BRA .L41
1340:              			}
1341:              			else
1342:              			{
1343:              				if( xTicksToWait == ( TickType_t ) 0 )
00235C  90080E     MOV [W14+16], W0
00235E  E00000     CP0 W0
002360  3A0004     BRA NZ, .L42
1344:              				{
1345:              					/* The queue was empty and no block time is specified (or
1346:              					the block time has expired) so leave now. */
1347:              					taskEXIT_CRITICAL();
002362  0248F4     CALL vPortExitCritical
002364  000000     NOP
1348:              					traceQUEUE_RECEIVE_FAILED( pxQueue );
1349:              					return errQUEUE_EMPTY;
002366  EB0000     CLR W0
002368  370045     BRA .L41
1350:              				}
1351:              				else if( xEntryTimeSet == pdFALSE )
00236A  78001E     MOV [W14], W0
00236C  E00000     CP0 W0
00236E  3A0005     BRA NZ, .L43, .LBE5
1352:              				{
1353:              					/* The queue was empty and a block time was specified so
1354:              					configure the timeout structure. */
1355:              					vTaskSetTimeOutState( &xTimeOut );
002370  470068     ADD W14, #0x8, W0
002372  0219FE     CALL vTaskSetTimeOutState
002374  000000     NOP
1356:              					xEntryTimeSet = pdTRUE;
002376  200010     MOV #0x1, W0
002378  780F00     MOV W0, [W14]
1357:              				}
1358:              				else
1359:              				{
1360:              					/* Entry time was already set. */
1361:              					mtCOVERAGE_TEST_MARKER();
1362:              				}
1363:              			}
1364:              		}
1365:              		taskEXIT_CRITICAL();
00237A  0248F4     CALL vPortExitCritical
00237C  000000     NOP
1366:              
1367:              		/* Interrupts and other tasks can send to and receive from the queue
1368:              		now the critical section has been exited. */
1369:              
1370:              		vTaskSuspendAll();
00237E  02165E     CALL vTaskSuspendAll
002380  000000     NOP
1371:              		prvLockQueue( pxQueue );
002382  0248DA     CALL vPortEnterCritical
002384  000000     NOP
002386  90001E     MOV [W14+2], W0
002388  906020     MOV.B [W0+34], W0
00238A  404FE1     ADD.B W0, #0x1, [W15]
00238C  3A0003     BRA NZ, .L44
00238E  90001E     MOV [W14+2], W0
002390  EB4080     CLR.B W1
002392  986021     MOV.B W1, [W0+34]
002394  90001E     MOV [W14+2], W0
002396  906030     MOV.B [W0+35], W0
002398  404FE1     ADD.B W0, #0x1, [W15]
00239A  3A0003     BRA NZ, .L45
00239C  90001E     MOV [W14+2], W0
00239E  EB4080     CLR.B W1
0023A0  986031     MOV.B W1, [W0+35]
0023A2  0248F4     CALL vPortExitCritical
0023A4  000000     NOP
1372:              
1373:              		/* Update the timeout state to see if it has expired yet. */
1374:              		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
0023A6  4700F0     ADD W14, #0x10, W1
0023A8  470068     ADD W14, #0x8, W0
0023AA  021A12     CALL xTaskCheckForTimeOut
0023AC  000000     NOP
0023AE  E00000     CP0 W0
0023B0  3A0018     BRA NZ, .L46
1375:              		{
1376:              			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
0023B2  90001E     MOV [W14+2], W0
0023B4  07015C     RCALL _prvIsQueueEmpty, .LFE15, .LFB16
0023B6  E00000     CP0 W0
0023B8  32000F     BRA Z, .L47
1377:              			{
1378:              				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
1379:              
1380:              				#if ( configUSE_MUTEXES == 1 )
1381:              				{
1382:              					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
1383:              					{
1384:              						taskENTER_CRITICAL();
1385:              						{
1386:              							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
1387:              						}
1388:              						taskEXIT_CRITICAL();
1389:              					}
1390:              					else
1391:              					{
1392:              						mtCOVERAGE_TEST_MARKER();
1393:              					}
1394:              				}
1395:              				#endif
1396:              
1397:              				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
0023BA  90088E     MOV [W14+16], W1
0023BC  90001E     MOV [W14+2], W0
0023BE  400072     ADD W0, #0x12, W0
0023C0  0218DA     CALL vTaskPlaceOnEventList
0023C2  000000     NOP
1398:              				prvUnlockQueue( pxQueue );
0023C4  90001E     MOV [W14+2], W0
0023C6  070113     RCALL _prvUnlockQueue, .LFE14, .LFB15
1399:              				if( xTaskResumeAll() == pdFALSE )
0023C8  02166A     CALL xTaskResumeAll
0023CA  000000     NOP
0023CC  E00000     CP0 W0
0023CE  3AFF8C     BRA NZ, .L50
1400:              				{
1401:              					portYIELD_WITHIN_API();
0023D0  0250DC     CALL .Letext0, .LFE1, _vPortYield
0023D2  000000     NOP
0023D4  000000     NOP
1402:              				}
1403:              				else
1404:              				{
1405:              					mtCOVERAGE_TEST_MARKER();
1406:              				}
1407:              			}
1408:              			else
1409:              			{
1410:              				/* Try again. */
1411:              				prvUnlockQueue( pxQueue );
0023D8  90001E     MOV [W14+2], W0
0023DA  070109     RCALL _prvUnlockQueue, .LFE14, .LFB15
1412:              				( void ) xTaskResumeAll();
0023DC  02166A     CALL xTaskResumeAll
0023DE  000000     NOP
1413:              			}
1414:              		}
1415:              		else
1416:              		{
1417:              			prvUnlockQueue( pxQueue );
0023E2  90001E     MOV [W14+2], W0
0023E4  070104     RCALL _prvUnlockQueue, .LFE14, .LFB15
1418:              			( void ) xTaskResumeAll();
0023E6  02166A     CALL xTaskResumeAll
0023E8  000000     NOP
1419:              
1420:              			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
0023EA  90001E     MOV [W14+2], W0
0023EC  070140     RCALL _prvIsQueueEmpty, .LFE15, .LFB16
0023EE  E00000     CP0 W0
0023F0  32FF7D     BRA Z, .L51
1421:              			{
1422:              				traceQUEUE_RECEIVE_FAILED( pxQueue );
1423:              				return errQUEUE_EMPTY;
0023F2  EB0000     CLR W0
1424:              			}
1425:              			else
1426:              			{
1427:              				mtCOVERAGE_TEST_MARKER();
1428:              			}
1429:              		}
1430:              	}
0022E8  000000     NOP
0022EA  370001     BRA .L49
0022EC  000000     NOP
0023D6  37FF8B     BRA .L49
0023E0  37FF86     BRA .L49
1431:              }
0023F4  FA8000     ULNK
0023F6  060000     RETURN
1432:              /*-----------------------------------------------------------*/
1433:              
1434:              BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
1435:              {
0023F8  FA0010     LNK #0x10
0023FA  980750     MOV W0, [W14+10]
0023FC  980761     MOV W1, [W14+12]
0023FE  980772     MOV W2, [W14+14]
1436:              BaseType_t xReturn;
1437:              UBaseType_t uxSavedInterruptStatus;
1438:              Queue_t * const pxQueue = ( Queue_t * ) xQueue;
002400  9000DE     MOV [W14+10], W1
002402  980711     MOV W1, [W14+2]
1439:              
1440:              	configASSERT( pxQueue );
1441:              	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
1442:              
1443:              	/* RTOS ports that support interrupt nesting have the concept of a maximum
1444:              	system call (or maximum API call) interrupt priority.  Interrupts that are
1445:              	above the maximum system call priority are kept permanently enabled, even
1446:              	when the RTOS kernel is in a critical section, but cannot make any calls to
1447:              	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
1448:              	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1449:              	failure if a FreeRTOS API function is called from an interrupt that has been
1450:              	assigned a priority above the configured maximum system call priority.
1451:              	Only FreeRTOS functions that end in FromISR can be called from interrupts
1452:              	that have been assigned a priority at or (logically) below the maximum
1453:              	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
1454:              	safe API to ensure interrupt entry is as fast and as simple as possible.
1455:              	More information (albeit Cortex-M specific) is provided on the following
1456:              	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1457:              	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1458:              
1459:              	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
002404  EB0000     CLR W0
002406  980720     MOV W0, [W14+4]
1460:              	{
1461:              		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
002408  90001E     MOV [W14+2], W0
00240A  9008E0     MOV [W0+28], W1
00240C  980731     MOV W1, [W14+6]
1462:              
1463:              		/* Cannot block in an ISR, so check there is data available. */
1464:              		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
00240E  90003E     MOV [W14+6], W0
002410  E00000     CP0 W0
002412  320026     BRA Z, .L53, .LBE7
1465:              		{
1466:              			const int8_t cRxLock = pxQueue->cRxLock;
002414  90001E     MOV [W14+2], W0
002416  9060A0     MOV.B [W0+34], W1
002418  984F01     MOV.B W1, [W14+8]
1467:              
1468:              			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );
1469:              
1470:              			prvCopyDataFromQueue( pxQueue, pvBuffer );
00241A  9000EE     MOV [W14+12], W1
00241C  90001E     MOV [W14+2], W0
00241E  0700C4     RCALL _prvCopyDataFromQueue, .LFE13, .LFB14
1471:              			pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
002420  90003E     MOV [W14+6], W0
002422  E90080     DEC W0, W1
002424  90001E     MOV [W14+2], W0
002426  980861     MOV W1, [W0+28]
1472:              
1473:              			/* If the queue is locked the event list will not be modified.
1474:              			Instead update the lock count so the task that unlocks the queue
1475:              			will know that an ISR has removed data while the queue was
1476:              			locked. */
1477:              			if( cRxLock == queueUNLOCKED )
002428  90480E     MOV.B [W14+8], W0
00242A  404FE1     ADD.B W0, #0x1, [W15]
00242C  3A0011     BRA NZ, .L54
1478:              			{
1479:              				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
00242E  90001E     MOV [W14+2], W0
002430  900040     MOV [W0+8], W0
002432  E00000     CP0 W0
002434  320012     BRA Z, .L55
1480:              				{
1481:              					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
002436  90001E     MOV [W14+2], W0
002438  400068     ADD W0, #0x8, W0
00243A  02191E     CALL xTaskRemoveFromEventList
00243C  000000     NOP
00243E  E00000     CP0 W0
002440  32000C     BRA Z, .L55
1482:              					{
1483:              						/* The task waiting has a higher priority than us so
1484:              						force a context switch. */
1485:              						if( pxHigherPriorityTaskWoken != NULL )
002442  90007E     MOV [W14+14], W0
002444  E00000     CP0 W0
002446  320009     BRA Z, .L55
1486:              						{
1487:              							*pxHigherPriorityTaskWoken = pdTRUE;
002448  90007E     MOV [W14+14], W0
00244A  200011     MOV #0x1, W1
00244C  780801     MOV W1, [W0]
00244E  370005     BRA .L55
1488:              						}
1489:              						else
1490:              						{
1491:              							mtCOVERAGE_TEST_MARKER();
1492:              						}
1493:              					}
1494:              					else
1495:              					{
1496:              						mtCOVERAGE_TEST_MARKER();
1497:              					}
1498:              				}
1499:              				else
1500:              				{
1501:              					mtCOVERAGE_TEST_MARKER();
1502:              				}
1503:              			}
1504:              			else
1505:              			{
1506:              				/* Increment the lock count so the task that unlocks the queue
1507:              				knows that data was removed while it was locked. */
1508:              				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
002450  90480E     MOV.B [W14+8], W0
002452  E84000     INC.B W0, W0
002454  784080     MOV.B W0, W1
002456  90001E     MOV [W14+2], W0
002458  986021     MOV.B W1, [W0+34]
1509:              			}
1510:              
1511:              			xReturn = pdPASS;
00245A  200010     MOV #0x1, W0
00245C  780F00     MOV W0, [W14]
00245E  370002     BRA .L56, .LBE6
1512:              		}
1513:              		else
1514:              		{
1515:              			xReturn = pdFAIL;
002460  EB0000     CLR W0
002462  780F00     MOV W0, [W14]
1516:              			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
1517:              		}
1518:              	}
1519:              	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1520:              
1521:              	return xReturn;
002464  78001E     MOV [W14], W0
1522:              }
002466  FA8000     ULNK
002468  060000     RETURN
1523:              /*-----------------------------------------------------------*/
1524:              
1525:              BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
1526:              {
00246A  FA000C     LNK #0xC
00246C  980740     MOV W0, [W14+8]
00246E  980751     MOV W1, [W14+10]
1527:              BaseType_t xReturn;
1528:              UBaseType_t uxSavedInterruptStatus;
1529:              int8_t *pcOriginalReadPosition;
1530:              Queue_t * const pxQueue = ( Queue_t * ) xQueue;
002470  9000CE     MOV [W14+8], W1
002472  980711     MOV W1, [W14+2]
1531:              
1532:              	configASSERT( pxQueue );
1533:              	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
1534:              	configASSERT( pxQueue->uxItemSize != 0 ); /* Can't peek a semaphore. */
1535:              
1536:              	/* RTOS ports that support interrupt nesting have the concept of a maximum
1537:              	system call (or maximum API call) interrupt priority.  Interrupts that are
1538:              	above the maximum system call priority are kept permanently enabled, even
1539:              	when the RTOS kernel is in a critical section, but cannot make any calls to
1540:              	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
1541:              	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1542:              	failure if a FreeRTOS API function is called from an interrupt that has been
1543:              	assigned a priority above the configured maximum system call priority.
1544:              	Only FreeRTOS functions that end in FromISR can be called from interrupts
1545:              	that have been assigned a priority at or (logically) below the maximum
1546:              	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
1547:              	safe API to ensure interrupt entry is as fast and as simple as possible.
1548:              	More information (albeit Cortex-M specific) is provided on the following
1549:              	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1550:              	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1551:              
1552:              	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
002474  EB0000     CLR W0
002476  980720     MOV W0, [W14+4]
1553:              	{
1554:              		/* Cannot block in an ISR, so check there is data available. */
1555:              		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
002478  90001E     MOV [W14+2], W0
00247A  900860     MOV [W0+28], W0
00247C  E00000     CP0 W0
00247E  32000C     BRA Z, .L58
1556:              		{
1557:              			traceQUEUE_PEEK_FROM_ISR( pxQueue );
1558:              
1559:              			/* Remember the read position so it can be reset as nothing is
1560:              			actually being removed from the queue. */
1561:              			pcOriginalReadPosition = pxQueue->u.pcReadFrom;
002480  90001E     MOV [W14+2], W0
002482  9000B0     MOV [W0+6], W1
002484  980731     MOV W1, [W14+6]
1562:              			prvCopyDataFromQueue( pxQueue, pvBuffer );
002486  9000DE     MOV [W14+10], W1
002488  90001E     MOV [W14+2], W0
00248A  07008E     RCALL _prvCopyDataFromQueue, .LFE13, .LFB14
1563:              			pxQueue->u.pcReadFrom = pcOriginalReadPosition;
00248C  90001E     MOV [W14+2], W0
00248E  9000BE     MOV [W14+6], W1
002490  980031     MOV W1, [W0+6]
1564:              
1565:              			xReturn = pdPASS;
002492  200010     MOV #0x1, W0
002494  780F00     MOV W0, [W14]
002496  370002     BRA .L59
1566:              		}
1567:              		else
1568:              		{
1569:              			xReturn = pdFAIL;
002498  EB0000     CLR W0
00249A  780F00     MOV W0, [W14]
1570:              			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
1571:              		}
1572:              	}
1573:              	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1574:              
1575:              	return xReturn;
00249C  78001E     MOV [W14], W0
1576:              }
00249E  FA8000     ULNK
0024A0  060000     RETURN
1577:              /*-----------------------------------------------------------*/
1578:              
1579:              UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
1580:              {
0024A2  FA0004     LNK #0x4
0024A4  980710     MOV W0, [W14+2]
1581:              UBaseType_t uxReturn;
1582:              
1583:              	configASSERT( xQueue );
1584:              
1585:              	taskENTER_CRITICAL();
0024A6  0248DA     CALL vPortEnterCritical
0024A8  000000     NOP
1586:              	{
1587:              		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
0024AA  90001E     MOV [W14+2], W0
0024AC  9008E0     MOV [W0+28], W1
0024AE  780F01     MOV W1, [W14]
1588:              	}
1589:              	taskEXIT_CRITICAL();
0024B0  0248F4     CALL vPortExitCritical
0024B2  000000     NOP
1590:              
1591:              	return uxReturn;
0024B4  78001E     MOV [W14], W0
1592:              } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
0024B6  FA8000     ULNK
0024B8  060000     RETURN
1593:              /*-----------------------------------------------------------*/
1594:              
1595:              UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
1596:              {
0024BA  FA0006     LNK #0x6
0024BC  980720     MOV W0, [W14+4]
1597:              UBaseType_t uxReturn;
1598:              Queue_t *pxQueue;
1599:              
1600:              	pxQueue = ( Queue_t * ) xQueue;
0024BE  9000AE     MOV [W14+4], W1
0024C0  780F01     MOV W1, [W14]
1601:              	configASSERT( pxQueue );
1602:              
1603:              	taskENTER_CRITICAL();
0024C2  0248DA     CALL vPortEnterCritical
0024C4  000000     NOP
1604:              	{
1605:              		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
0024C6  78001E     MOV [W14], W0
0024C8  9008F0     MOV [W0+30], W1
0024CA  78001E     MOV [W14], W0
0024CC  900860     MOV [W0+28], W0
0024CE  508000     SUB W1, W0, W0
0024D0  980710     MOV W0, [W14+2]
1606:              	}
1607:              	taskEXIT_CRITICAL();
0024D2  0248F4     CALL vPortExitCritical
0024D4  000000     NOP
1608:              
1609:              	return uxReturn;
0024D6  90001E     MOV [W14+2], W0
1610:              } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
0024D8  FA8000     ULNK
0024DA  060000     RETURN
1611:              /*-----------------------------------------------------------*/
1612:              
1613:              UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
1614:              {
0024DC  FA0004     LNK #0x4
0024DE  980710     MOV W0, [W14+2]
1615:              UBaseType_t uxReturn;
1616:              
1617:              	configASSERT( xQueue );
1618:              
1619:              	uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
0024E0  90001E     MOV [W14+2], W0
0024E2  9008E0     MOV [W0+28], W1
0024E4  780F01     MOV W1, [W14]
1620:              
1621:              	return uxReturn;
0024E6  78001E     MOV [W14], W0
1622:              } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
0024E8  FA8000     ULNK
0024EA  060000     RETURN
1623:              /*-----------------------------------------------------------*/
1624:              
1625:              void vQueueDelete( QueueHandle_t xQueue )
1626:              {
0024EC  FA0004     LNK #0x4
0024EE  980710     MOV W0, [W14+2]
1627:              Queue_t * const pxQueue = ( Queue_t * ) xQueue;
0024F0  90009E     MOV [W14+2], W1
0024F2  780F01     MOV W1, [W14]
1628:              
1629:              	configASSERT( pxQueue );
1630:              	traceQUEUE_DELETE( pxQueue );
1631:              
1632:              	#if ( configQUEUE_REGISTRY_SIZE > 0 )
1633:              	{
1634:              		vQueueUnregisterQueue( pxQueue );
1635:              	}
1636:              	#endif
1637:              
1638:              	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
1639:              	{
1640:              		/* The queue can only have been allocated dynamically - free it
1641:              		again. */
1642:              		vPortFree( pxQueue );
0024F4  78001E     MOV [W14], W0
0024F6  023D68     CALL vPortFree
0024F8  000000     NOP
1643:              	}
1644:              	#elif( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
1645:              	{
1646:              		/* The queue could have been allocated statically or dynamically, so
1647:              		check before attempting to free the memory. */
1648:              		if( pxQueue->ucStaticallyAllocated == ( uint8_t ) pdFALSE )
1649:              		{
1650:              			vPortFree( pxQueue );
1651:              		}
1652:              		else
1653:              		{
1654:              			mtCOVERAGE_TEST_MARKER();
1655:              		}
1656:              	}
1657:              	#else
1658:              	{
1659:              		/* The queue must have been statically allocated, so is not going to be
1660:              		deleted.  Avoid compiler warnings about the unused parameter. */
1661:              		( void ) pxQueue;
1662:              	}
1663:              	#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
1664:              }
0024FA  FA8000     ULNK
0024FC  060000     RETURN
1665:              /*-----------------------------------------------------------*/
1666:              
1667:              #if ( configUSE_TRACE_FACILITY == 1 )
1668:              
1669:              	UBaseType_t uxQueueGetQueueNumber( QueueHandle_t xQueue )
1670:              	{
1671:              		return ( ( Queue_t * ) xQueue )->uxQueueNumber;
1672:              	}
1673:              
1674:              #endif /* configUSE_TRACE_FACILITY */
1675:              /*-----------------------------------------------------------*/
1676:              
1677:              #if ( configUSE_TRACE_FACILITY == 1 )
1678:              
1679:              	void vQueueSetQueueNumber( QueueHandle_t xQueue, UBaseType_t uxQueueNumber )
1680:              	{
1681:              		( ( Queue_t * ) xQueue )->uxQueueNumber = uxQueueNumber;
1682:              	}
1683:              
1684:              #endif /* configUSE_TRACE_FACILITY */
1685:              /*-----------------------------------------------------------*/
1686:              
1687:              #if ( configUSE_TRACE_FACILITY == 1 )
1688:              
1689:              	uint8_t ucQueueGetQueueType( QueueHandle_t xQueue )
1690:              	{
1691:              		return ( ( Queue_t * ) xQueue )->ucQueueType;
1692:              	}
1693:              
1694:              #endif /* configUSE_TRACE_FACILITY */
1695:              /*-----------------------------------------------------------*/
1696:              
1697:              static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
1698:              {
0024FE  FA000A     LNK #0xA
002500  980720     MOV W0, [W14+4]
002502  980731     MOV W1, [W14+6]
002504  980742     MOV W2, [W14+8]
1699:              BaseType_t xReturn = pdFALSE;
002506  EB0000     CLR W0
002508  980710     MOV W0, [W14+2]
1700:              UBaseType_t uxMessagesWaiting;
1701:              
1702:              	/* This function is called from a critical section. */
1703:              
1704:              	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
00250A  90002E     MOV [W14+4], W0
00250C  9008E0     MOV [W0+28], W1
00250E  780F01     MOV W1, [W14]
1705:              
1706:              	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
002510  90002E     MOV [W14+4], W0
002512  901000     MOV [W0+32], W0
002514  E00000     CP0 W0
002516  320042     BRA Z, .L65
1707:              	{
1708:              		#if ( configUSE_MUTEXES == 1 )
1709:              		{
1710:              			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
1711:              			{
1712:              				/* The mutex is no longer being held. */
1713:              				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
1714:              				pxQueue->pxMutexHolder = NULL;
1715:              			}
1716:              			else
1717:              			{
1718:              				mtCOVERAGE_TEST_MARKER();
1719:              			}
1720:              		}
1721:              		#endif /* configUSE_MUTEXES */
1722:              	}
1723:              	else if( xPosition == queueSEND_TO_BACK )
002518  90004E     MOV [W14+8], W0
00251A  E00000     CP0 W0
00251C  3A001A     BRA NZ, .L66
1724:              	{
1725:              		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
00251E  90002E     MOV [W14+4], W0
002520  901080     MOV [W0+32], W1
002522  90002E     MOV [W14+4], W0
002524  900020     MOV [W0+4], W0
002526  780101     MOV W1, W2
002528  9000BE     MOV [W14+6], W1
00252A  020E9E     CALL _memcpy
00252C  000000     NOP
1726:              		pxQueue->pcWriteTo += pxQueue->uxItemSize;
00252E  90002E     MOV [W14+4], W0
002530  9000A0     MOV [W0+4], W1
002532  90002E     MOV [W14+4], W0
002534  901000     MOV [W0+32], W0
002536  408080     ADD W1, W0, W1
002538  90002E     MOV [W14+4], W0
00253A  980021     MOV W1, [W0+4]
1727:              		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
00253C  90002E     MOV [W14+4], W0
00253E  9000A0     MOV [W0+4], W1
002540  90002E     MOV [W14+4], W0
002542  900010     MOV [W0+2], W0
002544  508F80     SUB W1, W0, [W15]
002546  39002A     BRA NC, .L65
1728:              		{
1729:              			pxQueue->pcWriteTo = pxQueue->pcHead;
002548  90002E     MOV [W14+4], W0
00254A  780090     MOV [W0], W1
00254C  90002E     MOV [W14+4], W0
00254E  980021     MOV W1, [W0+4]
002550  370025     BRA .L65
1730:              		}
1731:              		else
1732:              		{
1733:              			mtCOVERAGE_TEST_MARKER();
1734:              		}
1735:              	}
1736:              	else
1737:              	{
1738:              		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
002552  90002E     MOV [W14+4], W0
002554  901080     MOV [W0+32], W1
002556  90002E     MOV [W14+4], W0
002558  900030     MOV [W0+6], W0
00255A  780101     MOV W1, W2
00255C  9000BE     MOV [W14+6], W1
00255E  020E9E     CALL _memcpy
002560  000000     NOP
1739:              		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
002562  90002E     MOV [W14+4], W0
002564  9000B0     MOV [W0+6], W1
002566  90002E     MOV [W14+4], W0
002568  901000     MOV [W0+32], W0
00256A  EA0000     NEG W0, W0
00256C  408080     ADD W1, W0, W1
00256E  90002E     MOV [W14+4], W0
002570  980031     MOV W1, [W0+6]
1740:              		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
002572  90002E     MOV [W14+4], W0
002574  9000B0     MOV [W0+6], W1
002576  90002E     MOV [W14+4], W0
002578  780010     MOV [W0], W0
00257A  508F80     SUB W1, W0, [W15]
00257C  310008     BRA C, .L67
1741:              		{
1742:              			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
00257E  90002E     MOV [W14+4], W0
002580  900090     MOV [W0+2], W1
002582  90002E     MOV [W14+4], W0
002584  901000     MOV [W0+32], W0
002586  EA0000     NEG W0, W0
002588  408080     ADD W1, W0, W1
00258A  90002E     MOV [W14+4], W0
00258C  980031     MOV W1, [W0+6]
1743:              		}
1744:              		else
1745:              		{
1746:              			mtCOVERAGE_TEST_MARKER();
1747:              		}
1748:              
1749:              		if( xPosition == queueOVERWRITE )
00258E  90004E     MOV [W14+8], W0
002590  500FE2     SUB W0, #0x2, [W15]
002592  3A0004     BRA NZ, .L65
1750:              		{
1751:              			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
002594  78001E     MOV [W14], W0
002596  E00000     CP0 W0
002598  320001     BRA Z, .L65
1752:              			{
1753:              				/* An item is not being added but overwritten, so subtract
1754:              				one from the recorded number of items in the queue so when
1755:              				one is added again below the number of recorded items remains
1756:              				correct. */
1757:              				--uxMessagesWaiting;
00259A  E90F1E     DEC [W14], [W14]
1758:              			}
1759:              			else
1760:              			{
1761:              				mtCOVERAGE_TEST_MARKER();
1762:              			}
1763:              		}
1764:              		else
1765:              		{
1766:              			mtCOVERAGE_TEST_MARKER();
1767:              		}
1768:              	}
1769:              
1770:              	pxQueue->uxMessagesWaiting = uxMessagesWaiting + 1;
00259C  E8009E     INC [W14], W1
00259E  90002E     MOV [W14+4], W0
0025A0  980861     MOV W1, [W0+28]
1771:              
1772:              	return xReturn;
0025A2  90001E     MOV [W14+2], W0
1773:              }
0025A4  FA8000     ULNK
0025A6  060000     RETURN
1774:              /*-----------------------------------------------------------*/
1775:              
1776:              static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
1777:              {
0025A8  FA0004     LNK #0x4
0025AA  780F00     MOV W0, [W14]
0025AC  980711     MOV W1, [W14+2]
1778:              	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
0025AE  78001E     MOV [W14], W0
0025B0  901000     MOV [W0+32], W0
0025B2  E00000     CP0 W0
0025B4  32001A     BRA Z, .L68
1779:              	{
1780:              		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
0025B6  78001E     MOV [W14], W0
0025B8  9000B0     MOV [W0+6], W1
0025BA  78001E     MOV [W14], W0
0025BC  901000     MOV [W0+32], W0
0025BE  408080     ADD W1, W0, W1
0025C0  78001E     MOV [W14], W0
0025C2  980031     MOV W1, [W0+6]
1781:              		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
0025C4  78001E     MOV [W14], W0
0025C6  9000B0     MOV [W0+6], W1
0025C8  78001E     MOV [W14], W0
0025CA  900010     MOV [W0+2], W0
0025CC  508F80     SUB W1, W0, [W15]
0025CE  390004     BRA NC, .L70
1782:              		{
1783:              			pxQueue->u.pcReadFrom = pxQueue->pcHead;
0025D0  78001E     MOV [W14], W0
0025D2  780090     MOV [W0], W1
0025D4  78001E     MOV [W14], W0
0025D6  980031     MOV W1, [W0+6]
1784:              		}
1785:              		else
1786:              		{
1787:              			mtCOVERAGE_TEST_MARKER();
1788:              		}
1789:              		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
0025D8  78001E     MOV [W14], W0
0025DA  901080     MOV [W0+32], W1
0025DC  78001E     MOV [W14], W0
0025DE  900030     MOV [W0+6], W0
0025E0  780101     MOV W1, W2
0025E2  780080     MOV W0, W1
0025E4  90001E     MOV [W14+2], W0
0025E6  020E9E     CALL _memcpy
0025E8  000000     NOP
1790:              	}
1791:              }
0025EA  FA8000     ULNK
0025EC  060000     RETURN
1792:              /*-----------------------------------------------------------*/
1793:              
1794:              static void prvUnlockQueue( Queue_t * const pxQueue )
1795:              {
0025EE  FA0004     LNK #0x4
0025F0  980710     MOV W0, [W14+2]
1796:              	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED. */
1797:              
1798:              	/* The lock counts contains the number of extra data items placed or
1799:              	removed from the queue while the queue was locked.  When a queue is
1800:              	locked items can be added or removed, but the event lists cannot be
1801:              	updated. */
1802:              	taskENTER_CRITICAL();
0025F2  0248DA     CALL vPortEnterCritical
0025F4  000000     NOP
1803:              	{
1804:              		int8_t cTxLock = pxQueue->cTxLock;
0025F6  90001E     MOV [W14+2], W0
0025F8  9060B0     MOV.B [W0+35], W1
0025FA  784F01     MOV.B W1, [W14]
1805:              
1806:              		/* See if data was added to the queue while it was locked. */
1807:              		while( cTxLock > queueLOCKED_UNMODIFIED )
0025FC  37000D     BRA .L72
002618  78401E     MOV.B [W14], W0
00261A  E00400     CP0.B W0
00261C  3CFFF0     BRA GT, .L76
00261E  370001     BRA .L75
1808:              		{
1809:              			/* Data was posted while the queue was locked.  Are any tasks
1810:              			blocked waiting for data to become available? */
1811:              			#if ( configUSE_QUEUE_SETS == 1 )
1812:              			{
1813:              				if( pxQueue->pxQueueSetContainer != NULL )
1814:              				{
1815:              					if( prvNotifyQueueSetContainer( pxQueue, queueSEND_TO_BACK ) != pdFALSE )
1816:              					{
1817:              						/* The queue is a member of a queue set, and posting to
1818:              						the queue set caused a higher priority task to unblock.
1819:              						A context switch is required. */
1820:              						vTaskMissedYield();
1821:              					}
1822:              					else
1823:              					{
1824:              						mtCOVERAGE_TEST_MARKER();
1825:              					}
1826:              				}
1827:              				else
1828:              				{
1829:              					/* Tasks that are removed from the event list will get
1830:              					added to the pending ready list as the scheduler is still
1831:              					suspended. */
1832:              					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1833:              					{
1834:              						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
1835:              						{
1836:              							/* The task waiting has a higher priority so record that a
1837:              							context	switch is required. */
1838:              							vTaskMissedYield();
1839:              						}
1840:              						else
1841:              						{
1842:              							mtCOVERAGE_TEST_MARKER();
1843:              						}
1844:              					}
1845:              					else
1846:              					{
1847:              						break;
1848:              					}
1849:              				}
1850:              			}
1851:              			#else /* configUSE_QUEUE_SETS */
1852:              			{
1853:              				/* Tasks that are removed from the event list will get added to
1854:              				the pending ready list as the scheduler is still suspended. */
1855:              				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
0025FE  90001E     MOV [W14+2], W0
002600  900810     MOV [W0+18], W0
002602  E00000     CP0 W0
002604  32000D     BRA Z, .L82
1856:              				{
1857:              					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
002606  90001E     MOV [W14+2], W0
002608  400072     ADD W0, #0x12, W0
00260A  02191E     CALL xTaskRemoveFromEventList
00260C  000000     NOP
00260E  E00000     CP0 W0
002610  320002     BRA Z, .L74
1858:              					{
1859:              						/* The task waiting has a higher priority so record that
1860:              						a context switch is required. */
1861:              						vTaskMissedYield();
002612  021A82     CALL vTaskMissedYield
002614  000000     NOP
1862:              					}
1863:              					else
1864:              					{
1865:              						mtCOVERAGE_TEST_MARKER();
1866:              					}
1867:              				}
1868:              				else
1869:              				{
1870:              					break;
002620  000000     NOP
1871:              				}
1872:              			}
1873:              			#endif /* configUSE_QUEUE_SETS */
1874:              
1875:              			--cTxLock;
002616  E94F1E     DEC.B [W14], [W14]
1876:              		}
1877:              
1878:              		pxQueue->cTxLock = queueUNLOCKED;
002622  90001E     MOV [W14+2], W0
002624  EBC080     SETM.B W1
002626  986031     MOV.B W1, [W0+35]
1879:              	}
1880:              	taskEXIT_CRITICAL();
002628  0248F4     CALL vPortExitCritical
00262A  000000     NOP
1881:              
1882:              	/* Do the same for the Rx lock. */
1883:              	taskENTER_CRITICAL();
00262C  0248DA     CALL vPortEnterCritical
00262E  000000     NOP
1884:              	{
1885:              		int8_t cRxLock = pxQueue->cRxLock;
002630  90001E     MOV [W14+2], W0
002632  9060A0     MOV.B [W0+34], W1
002634  984711     MOV.B W1, [W14+1]
1886:              
1887:              		while( cRxLock > queueLOCKED_UNMODIFIED )
002636  37000F     BRA .L77
002656  90401E     MOV.B [W14+1], W0
002658  E00400     CP0.B W0
00265A  3CFFEE     BRA GT, .L81
00265C  370001     BRA .L80
1888:              		{
1889:              			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
002638  90001E     MOV [W14+2], W0
00263A  900040     MOV [W0+8], W0
00263C  E00000     CP0 W0
00263E  32000F     BRA Z, .L83
1890:              			{
1891:              				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
002640  90001E     MOV [W14+2], W0
002642  400068     ADD W0, #0x8, W0
002644  02191E     CALL xTaskRemoveFromEventList
002646  000000     NOP
002648  E00000     CP0 W0
00264A  320002     BRA Z, .L79
1892:              				{
1893:              					vTaskMissedYield();
00264C  021A82     CALL vTaskMissedYield
00264E  000000     NOP
1894:              				}
1895:              				else
1896:              				{
1897:              					mtCOVERAGE_TEST_MARKER();
1898:              				}
1899:              
1900:              				--cRxLock;
002650  90401E     MOV.B [W14+1], W0
002652  E94000     DEC.B W0, W0
002654  984710     MOV.B W0, [W14+1]
1901:              			}
1902:              			else
1903:              			{
1904:              				break;
00265E  000000     NOP
1905:              			}
1906:              		}
1907:              
1908:              		pxQueue->cRxLock = queueUNLOCKED;
002660  90001E     MOV [W14+2], W0
002662  EBC080     SETM.B W1
002664  986021     MOV.B W1, [W0+34]
1909:              	}
1910:              	taskEXIT_CRITICAL();
002666  0248F4     CALL vPortExitCritical
002668  000000     NOP
1911:              }
00266A  FA8000     ULNK
00266C  060000     RETURN
1912:              /*-----------------------------------------------------------*/
1913:              
1914:              static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
1915:              {
00266E  FA0004     LNK #0x4
002670  980710     MOV W0, [W14+2]
1916:              BaseType_t xReturn;
1917:              
1918:              	taskENTER_CRITICAL();
002672  0248DA     CALL vPortEnterCritical
002674  000000     NOP
1919:              	{
1920:              		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
002676  90001E     MOV [W14+2], W0
002678  900860     MOV [W0+28], W0
00267A  E00000     CP0 W0
00267C  3A0003     BRA NZ, .L85
1921:              		{
1922:              			xReturn = pdTRUE;
00267E  200010     MOV #0x1, W0
002680  780F00     MOV W0, [W14]
002682  370002     BRA .L86
1923:              		}
1924:              		else
1925:              		{
1926:              			xReturn = pdFALSE;
002684  EB0000     CLR W0
002686  780F00     MOV W0, [W14]
1927:              		}
1928:              	}
1929:              	taskEXIT_CRITICAL();
002688  0248F4     CALL vPortExitCritical
00268A  000000     NOP
1930:              
1931:              	return xReturn;
00268C  78001E     MOV [W14], W0
1932:              }
00268E  FA8000     ULNK
002690  060000     RETURN
1933:              /*-----------------------------------------------------------*/
1934:              
1935:              BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
1936:              {
002692  FA0004     LNK #0x4
002694  980710     MOV W0, [W14+2]
1937:              BaseType_t xReturn;
1938:              
1939:              	configASSERT( xQueue );
1940:              	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( UBaseType_t ) 0 )
002696  90001E     MOV [W14+2], W0
002698  900860     MOV [W0+28], W0
00269A  E00000     CP0 W0
00269C  3A0003     BRA NZ, .L88
1941:              	{
1942:              		xReturn = pdTRUE;
00269E  200010     MOV #0x1, W0
0026A0  780F00     MOV W0, [W14]
0026A2  370002     BRA .L89
1943:              	}
1944:              	else
1945:              	{
1946:              		xReturn = pdFALSE;
0026A4  EB0000     CLR W0
0026A6  780F00     MOV W0, [W14]
1947:              	}
1948:              
1949:              	return xReturn;
0026A8  78001E     MOV [W14], W0
1950:              } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
0026AA  FA8000     ULNK
0026AC  060000     RETURN
1951:              /*-----------------------------------------------------------*/
1952:              
1953:              static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
1954:              {
0026AE  FA0004     LNK #0x4
0026B0  980710     MOV W0, [W14+2]
1955:              BaseType_t xReturn;
1956:              
1957:              	taskENTER_CRITICAL();
0026B2  0248DA     CALL vPortEnterCritical
0026B4  000000     NOP
1958:              	{
1959:              		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
0026B6  90001E     MOV [W14+2], W0
0026B8  9008E0     MOV [W0+28], W1
0026BA  90001E     MOV [W14+2], W0
0026BC  900870     MOV [W0+30], W0
0026BE  508F80     SUB W1, W0, [W15]
0026C0  3A0003     BRA NZ, .L91
1960:              		{
1961:              			xReturn = pdTRUE;
0026C2  200010     MOV #0x1, W0
0026C4  780F00     MOV W0, [W14]
0026C6  370002     BRA .L92
1962:              		}
1963:              		else
1964:              		{
1965:              			xReturn = pdFALSE;
0026C8  EB0000     CLR W0
0026CA  780F00     MOV W0, [W14]
1966:              		}
1967:              	}
1968:              	taskEXIT_CRITICAL();
0026CC  0248F4     CALL vPortExitCritical
0026CE  000000     NOP
1969:              
1970:              	return xReturn;
0026D0  78001E     MOV [W14], W0
1971:              }
0026D2  FA8000     ULNK
0026D4  060000     RETURN
1972:              /*-----------------------------------------------------------*/
1973:              
1974:              BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
1975:              {
0026D6  FA0004     LNK #0x4
0026D8  980710     MOV W0, [W14+2]
1976:              BaseType_t xReturn;
1977:              
1978:              	configASSERT( xQueue );
1979:              	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( ( Queue_t * ) xQueue )->uxLength )
0026DA  90001E     MOV [W14+2], W0
0026DC  9008E0     MOV [W0+28], W1
0026DE  90001E     MOV [W14+2], W0
0026E0  900870     MOV [W0+30], W0
0026E2  508F80     SUB W1, W0, [W15]
0026E4  3A0003     BRA NZ, .L94
1980:              	{
1981:              		xReturn = pdTRUE;
0026E6  200010     MOV #0x1, W0
0026E8  780F00     MOV W0, [W14]
0026EA  370002     BRA .L95
1982:              	}
1983:              	else
1984:              	{
1985:              		xReturn = pdFALSE;
0026EC  EB0000     CLR W0
0026EE  780F00     MOV W0, [W14]
1986:              	}
1987:              
1988:              	return xReturn;
0026F0  78001E     MOV [W14], W0
1989:              } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
0026F2  FA8000     ULNK
0026F4  060000     RETURN
1990:              /*-----------------------------------------------------------*/
1991:              
1992:              #if ( configUSE_CO_ROUTINES == 1 )
1993:              
1994:              	BaseType_t xQueueCRSend( QueueHandle_t xQueue, const void *pvItemToQueue, TickType_t xTicksToWait )
1995:              	{
1996:              	BaseType_t xReturn;
1997:              	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
1998:              
1999:              		/* If the queue is already full we may have to block.  A critical section
2000:              		is required to prevent an interrupt removing something from the queue
2001:              		between the check to see if the queue is full and blocking on the queue. */
2002:              		portDISABLE_INTERRUPTS();
2003:              		{
2004:              			if( prvIsQueueFull( pxQueue ) != pdFALSE )
2005:              			{
2006:              				/* The queue is full - do we want to block or just leave without
2007:              				posting? */
2008:              				if( xTicksToWait > ( TickType_t ) 0 )
2009:              				{
2010:              					/* As this is called from a coroutine we cannot block directly, but
2011:              					return indicating that we need to block. */
2012:              					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToSend ) );
2013:              					portENABLE_INTERRUPTS();
2014:              					return errQUEUE_BLOCKED;
2015:              				}
2016:              				else
2017:              				{
2018:              					portENABLE_INTERRUPTS();
2019:              					return errQUEUE_FULL;
2020:              				}
2021:              			}
2022:              		}
2023:              		portENABLE_INTERRUPTS();
2024:              
2025:              		portDISABLE_INTERRUPTS();
2026:              		{
2027:              			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
2028:              			{
2029:              				/* There is room in the queue, copy the data into the queue. */
2030:              				prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
2031:              				xReturn = pdPASS;
2032:              
2033:              				/* Were any co-routines waiting for data to become available? */
2034:              				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
2035:              				{
2036:              					/* In this instance the co-routine could be placed directly
2037:              					into the ready list as we are within a critical section.
2038:              					Instead the same pending ready list mechanism is used as if
2039:              					the event were caused from within an interrupt. */
2040:              					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
2041:              					{
2042:              						/* The co-routine waiting has a higher priority so record
2043:              						that a yield might be appropriate. */
2044:              						xReturn = errQUEUE_YIELD;
2045:              					}
2046:              					else
2047:              					{
2048:              						mtCOVERAGE_TEST_MARKER();
2049:              					}
2050:              				}
2051:              				else
2052:              				{
2053:              					mtCOVERAGE_TEST_MARKER();
2054:              				}
2055:              			}
2056:              			else
2057:              			{
2058:              				xReturn = errQUEUE_FULL;
2059:              			}
2060:              		}
2061:              		portENABLE_INTERRUPTS();
2062:              
2063:              		return xReturn;
2064:              	}
2065:              
2066:              #endif /* configUSE_CO_ROUTINES */
2067:              /*-----------------------------------------------------------*/
2068:              
2069:              #if ( configUSE_CO_ROUTINES == 1 )
2070:              
2071:              	BaseType_t xQueueCRReceive( QueueHandle_t xQueue, void *pvBuffer, TickType_t xTicksToWait )
2072:              	{
2073:              	BaseType_t xReturn;
2074:              	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
2075:              
2076:              		/* If the queue is already empty we may have to block.  A critical section
2077:              		is required to prevent an interrupt adding something to the queue
2078:              		between the check to see if the queue is empty and blocking on the queue. */
2079:              		portDISABLE_INTERRUPTS();
2080:              		{
2081:              			if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
2082:              			{
2083:              				/* There are no messages in the queue, do we want to block or just
2084:              				leave with nothing? */
2085:              				if( xTicksToWait > ( TickType_t ) 0 )
2086:              				{
2087:              					/* As this is a co-routine we cannot block directly, but return
2088:              					indicating that we need to block. */
2089:              					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToReceive ) );
2090:              					portENABLE_INTERRUPTS();
2091:              					return errQUEUE_BLOCKED;
2092:              				}
2093:              				else
2094:              				{
2095:              					portENABLE_INTERRUPTS();
2096:              					return errQUEUE_FULL;
2097:              				}
2098:              			}
2099:              			else
2100:              			{
2101:              				mtCOVERAGE_TEST_MARKER();
2102:              			}
2103:              		}
2104:              		portENABLE_INTERRUPTS();
2105:              
2106:              		portDISABLE_INTERRUPTS();
2107:              		{
2108:              			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
2109:              			{
2110:              				/* Data is available from the queue. */
2111:              				pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
2112:              				if( pxQueue->u.pcReadFrom >= pxQueue->pcTail )
2113:              				{
2114:              					pxQueue->u.pcReadFrom = pxQueue->pcHead;
2115:              				}
2116:              				else
2117:              				{
2118:              					mtCOVERAGE_TEST_MARKER();
2119:              				}
2120:              				--( pxQueue->uxMessagesWaiting );
2121:              				( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
2122:              
2123:              				xReturn = pdPASS;
2124:              
2125:              				/* Were any co-routines waiting for space to become available? */
2126:              				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
2127:              				{
2128:              					/* In this instance the co-routine could be placed directly
2129:              					into the ready list as we are within a critical section.
2130:              					Instead the same pending ready list mechanism is used as if
2131:              					the event were caused from within an interrupt. */
2132:              					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
2133:              					{
2134:              						xReturn = errQUEUE_YIELD;
2135:              					}
2136:              					else
2137:              					{
2138:              						mtCOVERAGE_TEST_MARKER();
2139:              					}
2140:              				}
2141:              				else
2142:              				{
2143:              					mtCOVERAGE_TEST_MARKER();
2144:              				}
2145:              			}
2146:              			else
2147:              			{
2148:              				xReturn = pdFAIL;
2149:              			}
2150:              		}
2151:              		portENABLE_INTERRUPTS();
2152:              
2153:              		return xReturn;
2154:              	}
2155:              
2156:              #endif /* configUSE_CO_ROUTINES */
2157:              /*-----------------------------------------------------------*/
2158:              
2159:              #if ( configUSE_CO_ROUTINES == 1 )
2160:              
2161:              	BaseType_t xQueueCRSendFromISR( QueueHandle_t xQueue, const void *pvItemToQueue, BaseType_t xCoRoutinePreviouslyWoken )
2162:              	{
2163:              	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
2164:              
2165:              		/* Cannot block within an ISR so if there is no space on the queue then
2166:              		exit without doing anything. */
2167:              		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
2168:              		{
2169:              			prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
2170:              
2171:              			/* We only want to wake one co-routine per ISR, so check that a
2172:              			co-routine has not already been woken. */
2173:              			if( xCoRoutinePreviouslyWoken == pdFALSE )
2174:              			{
2175:              				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
2176:              				{
2177:              					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
2178:              					{
2179:              						return pdTRUE;
2180:              					}
2181:              					else
2182:              					{
2183:              						mtCOVERAGE_TEST_MARKER();
2184:              					}
2185:              				}
2186:              				else
2187:              				{
2188:              					mtCOVERAGE_TEST_MARKER();
2189:              				}
2190:              			}
2191:              			else
2192:              			{
2193:              				mtCOVERAGE_TEST_MARKER();
2194:              			}
2195:              		}
2196:              		else
2197:              		{
2198:              			mtCOVERAGE_TEST_MARKER();
2199:              		}
2200:              
2201:              		return xCoRoutinePreviouslyWoken;
2202:              	}
2203:              
2204:              #endif /* configUSE_CO_ROUTINES */
2205:              /*-----------------------------------------------------------*/
2206:              
2207:              #if ( configUSE_CO_ROUTINES == 1 )
2208:              
2209:              	BaseType_t xQueueCRReceiveFromISR( QueueHandle_t xQueue, void *pvBuffer, BaseType_t *pxCoRoutineWoken )
2210:              	{
2211:              	BaseType_t xReturn;
2212:              	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
2213:              
2214:              		/* We cannot block from an ISR, so check there is data available. If
2215:              		not then just leave without doing anything. */
2216:              		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
2217:              		{
2218:              			/* Copy the data from the queue. */
2219:              			pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
2220:              			if( pxQueue->u.pcReadFrom >= pxQueue->pcTail )
2221:              			{
2222:              				pxQueue->u.pcReadFrom = pxQueue->pcHead;
2223:              			}
2224:              			else
2225:              			{
2226:              				mtCOVERAGE_TEST_MARKER();
2227:              			}
2228:              			--( pxQueue->uxMessagesWaiting );
2229:              			( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
2230:              
2231:              			if( ( *pxCoRoutineWoken ) == pdFALSE )
2232:              			{
2233:              				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
2234:              				{
2235:              					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
2236:              					{
2237:              						*pxCoRoutineWoken = pdTRUE;
2238:              					}
2239:              					else
2240:              					{
2241:              						mtCOVERAGE_TEST_MARKER();
2242:              					}
2243:              				}
2244:              				else
2245:              				{
2246:              					mtCOVERAGE_TEST_MARKER();
2247:              				}
2248:              			}
2249:              			else
2250:              			{
2251:              				mtCOVERAGE_TEST_MARKER();
2252:              			}
2253:              
2254:              			xReturn = pdPASS;
2255:              		}
2256:              		else
2257:              		{
2258:              			xReturn = pdFAIL;
2259:              		}
2260:              
2261:              		return xReturn;
2262:              	}
2263:              
2264:              #endif /* configUSE_CO_ROUTINES */
2265:              /*-----------------------------------------------------------*/
2266:              
2267:              #if ( configQUEUE_REGISTRY_SIZE > 0 )
2268:              
2269:              	void vQueueAddToRegistry( QueueHandle_t xQueue, const char *pcQueueName ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
2270:              	{
2271:              	UBaseType_t ux;
2272:              
2273:              		/* See if there is an empty space in the registry.  A NULL name denotes
2274:              		a free slot. */
2275:              		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
2276:              		{
2277:              			if( xQueueRegistry[ ux ].pcQueueName == NULL )
2278:              			{
2279:              				/* Store the information on this queue. */
2280:              				xQueueRegistry[ ux ].pcQueueName = pcQueueName;
2281:              				xQueueRegistry[ ux ].xHandle = xQueue;
2282:              
2283:              				traceQUEUE_REGISTRY_ADD( xQueue, pcQueueName );
2284:              				break;
2285:              			}
2286:              			else
2287:              			{
2288:              				mtCOVERAGE_TEST_MARKER();
2289:              			}
2290:              		}
2291:              	}
2292:              
2293:              #endif /* configQUEUE_REGISTRY_SIZE */
2294:              /*-----------------------------------------------------------*/
2295:              
2296:              #if ( configQUEUE_REGISTRY_SIZE > 0 )
2297:              
2298:              	const char *pcQueueGetName( QueueHandle_t xQueue ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
2299:              	{
2300:              	UBaseType_t ux;
2301:              	const char *pcReturn = NULL; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
2302:              
2303:              		/* Note there is nothing here to protect against another task adding or
2304:              		removing entries from the registry while it is being searched. */
2305:              		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
2306:              		{
2307:              			if( xQueueRegistry[ ux ].xHandle == xQueue )
2308:              			{
2309:              				pcReturn = xQueueRegistry[ ux ].pcQueueName;
2310:              				break;
2311:              			}
2312:              			else
2313:              			{
2314:              				mtCOVERAGE_TEST_MARKER();
2315:              			}
2316:              		}
2317:              
2318:              		return pcReturn;
2319:              	}
2320:              
2321:              #endif /* configQUEUE_REGISTRY_SIZE */
2322:              /*-----------------------------------------------------------*/
2323:              
2324:              #if ( configQUEUE_REGISTRY_SIZE > 0 )
2325:              
2326:              	void vQueueUnregisterQueue( QueueHandle_t xQueue )
2327:              	{
2328:              	UBaseType_t ux;
2329:              
2330:              		/* See if the handle of the queue being unregistered in actually in the
2331:              		registry. */
2332:              		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
2333:              		{
2334:              			if( xQueueRegistry[ ux ].xHandle == xQueue )
2335:              			{
2336:              				/* Set the name to NULL to show that this slot if free again. */
2337:              				xQueueRegistry[ ux ].pcQueueName = NULL;
2338:              
2339:              				/* Set the handle to NULL to ensure the same queue handle cannot
2340:              				appear in the registry twice if it is added, removed, then
2341:              				added again. */
2342:              				xQueueRegistry[ ux ].xHandle = ( QueueHandle_t ) 0;
2343:              				break;
2344:              			}
2345:              			else
2346:              			{
2347:              				mtCOVERAGE_TEST_MARKER();
2348:              			}
2349:              		}
2350:              
2351:              	} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
2352:              
2353:              #endif /* configQUEUE_REGISTRY_SIZE */
2354:              /*-----------------------------------------------------------*/
2355:              
2356:              #if ( configUSE_TIMERS == 1 )
2357:              
2358:              	void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
2359:              	{
2360:              	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
2361:              
2362:              		/* This function should not be called by application code hence the
2363:              		'Restricted' in its name.  It is not part of the public API.  It is
2364:              		designed for use by kernel code, and has special calling requirements.
2365:              		It can result in vListInsert() being called on a list that can only
2366:              		possibly ever have one item in it, so the list will be fast, but even
2367:              		so it should be called with the scheduler locked and not from a critical
2368:              		section. */
2369:              
2370:              		/* Only do anything if there are no messages in the queue.  This function
2371:              		will not actually cause the task to block, just place it on a blocked
2372:              		list.  It will not block until the scheduler is unlocked - at which
2373:              		time a yield will be performed.  If an item is added to the queue while
2374:              		the queue is locked, and the calling task blocks on the queue, then the
2375:              		calling task will be immediately unblocked when the queue is unlocked. */
2376:              		prvLockQueue( pxQueue );
2377:              		if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
2378:              		{
2379:              			/* There is nothing in the queue, block for the specified period. */
2380:              			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
2381:              		}
2382:              		else
2383:              		{
2384:              			mtCOVERAGE_TEST_MARKER();
2385:              		}
2386:              		prvUnlockQueue( pxQueue );
2387:              	}
2388:              
2389:              #endif /* configUSE_TIMERS */
2390:              /*-----------------------------------------------------------*/
2391:              
2392:              #if( ( configUSE_QUEUE_SETS == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
2393:              
2394:              	QueueSetHandle_t xQueueCreateSet( const UBaseType_t uxEventQueueLength )
2395:              	{
2396:              	QueueSetHandle_t pxQueue;
2397:              
2398:              		pxQueue = xQueueGenericCreate( uxEventQueueLength, sizeof( Queue_t * ), queueQUEUE_TYPE_SET );
2399:              
2400:              		return pxQueue;
2401:              	}
2402:              
2403:              #endif /* configUSE_QUEUE_SETS */
2404:              /*-----------------------------------------------------------*/
2405:              
2406:              #if ( configUSE_QUEUE_SETS == 1 )
2407:              
2408:              	BaseType_t xQueueAddToSet( QueueSetMemberHandle_t xQueueOrSemaphore, QueueSetHandle_t xQueueSet )
2409:              	{
2410:              	BaseType_t xReturn;
2411:              
2412:              		taskENTER_CRITICAL();
2413:              		{
2414:              			if( ( ( Queue_t * ) xQueueOrSemaphore )->pxQueueSetContainer != NULL )
2415:              			{
2416:              				/* Cannot add a queue/semaphore to more than one queue set. */
2417:              				xReturn = pdFAIL;
2418:              			}
2419:              			else if( ( ( Queue_t * ) xQueueOrSemaphore )->uxMessagesWaiting != ( UBaseType_t ) 0 )
2420:              			{
2421:              				/* Cannot add a queue/semaphore to a queue set if there are already
2422:              				items in the queue/semaphore. */
2423:              				xReturn = pdFAIL;
2424:              			}
2425:              			else
2426:              			{
2427:              				( ( Queue_t * ) xQueueOrSemaphore )->pxQueueSetContainer = xQueueSet;
2428:              				xReturn = pdPASS;
2429:              			}
2430:              		}
2431:              		taskEXIT_CRITICAL();
2432:              
2433:              		return xReturn;
2434:              	}
2435:              
2436:              #endif /* configUSE_QUEUE_SETS */
2437:              /*-----------------------------------------------------------*/
2438:              
2439:              #if ( configUSE_QUEUE_SETS == 1 )
2440:              
2441:              	BaseType_t xQueueRemoveFromSet( QueueSetMemberHandle_t xQueueOrSemaphore, QueueSetHandle_t xQueueSet )
2442:              	{
2443:              	BaseType_t xReturn;
2444:              	Queue_t * const pxQueueOrSemaphore = ( Queue_t * ) xQueueOrSemaphore;
2445:              
2446:              		if( pxQueueOrSemaphore->pxQueueSetContainer != xQueueSet )
2447:              		{
2448:              			/* The queue was not a member of the set. */
2449:              			xReturn = pdFAIL;
2450:              		}
2451:              		else if( pxQueueOrSemaphore->uxMessagesWaiting != ( UBaseType_t ) 0 )
2452:              		{
2453:              			/* It is dangerous to remove a queue from a set when the queue is
2454:              			not empty because the queue set will still hold pending events for
2455:              			the queue. */
2456:              			xReturn = pdFAIL;
2457:              		}
2458:              		else
2459:              		{
2460:              			taskENTER_CRITICAL();
2461:              			{
2462:              				/* The queue is no longer contained in the set. */
2463:              				pxQueueOrSemaphore->pxQueueSetContainer = NULL;
2464:              			}
2465:              			taskEXIT_CRITICAL();
2466:              			xReturn = pdPASS;
2467:              		}
2468:              
2469:              		return xReturn;
2470:              	} /*lint !e818 xQueueSet could not be declared as pointing to const as it is a typedef. */
2471:              
2472:              #endif /* configUSE_QUEUE_SETS */
2473:              /*-----------------------------------------------------------*/
2474:              
2475:              #if ( configUSE_QUEUE_SETS == 1 )
2476:              
2477:              	QueueSetMemberHandle_t xQueueSelectFromSet( QueueSetHandle_t xQueueSet, TickType_t const xTicksToWait )
2478:              	{
2479:              	QueueSetMemberHandle_t xReturn = NULL;
2480:              
2481:              		( void ) xQueueGenericReceive( ( QueueHandle_t ) xQueueSet, &xReturn, xTicksToWait, pdFALSE ); /*lint !e961 Casting from one typedef to another is not redundant. */
2482:              		return xReturn;
2483:              	}
2484:              
2485:              #endif /* configUSE_QUEUE_SETS */
2486:              /*-----------------------------------------------------------*/
2487:              
2488:              #if ( configUSE_QUEUE_SETS == 1 )
2489:              
2490:              	QueueSetMemberHandle_t xQueueSelectFromSetFromISR( QueueSetHandle_t xQueueSet )
2491:              	{
2492:              	QueueSetMemberHandle_t xReturn = NULL;
2493:              
2494:              		( void ) xQueueReceiveFromISR( ( QueueHandle_t ) xQueueSet, &xReturn, NULL ); /*lint !e961 Casting from one typedef to another is not redundant. */
2495:              		return xReturn;
2496:              	}
2497:              
2498:              #endif /* configUSE_QUEUE_SETS */
2499:              /*-----------------------------------------------------------*/
2500:              
2501:              #if ( configUSE_QUEUE_SETS == 1 )
2502:              
2503:              	static BaseType_t prvNotifyQueueSetContainer( const Queue_t * const pxQueue, const BaseType_t xCopyPosition )
2504:              	{
2505:              	Queue_t *pxQueueSetContainer = pxQueue->pxQueueSetContainer;
2506:              	BaseType_t xReturn = pdFALSE;
2507:              
2508:              		/* This function must be called form a critical section. */
2509:              
2510:              		configASSERT( pxQueueSetContainer );
2511:              		configASSERT( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength );
2512:              
2513:              		if( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength )
2514:              		{
2515:              			const int8_t cTxLock = pxQueueSetContainer->cTxLock;
2516:              
2517:              			traceQUEUE_SEND( pxQueueSetContainer );
2518:              
2519:              			/* The data copied is the handle of the queue that contains data. */
2520:              			xReturn = prvCopyDataToQueue( pxQueueSetContainer, &pxQueue, xCopyPosition );
2521:              
2522:              			if( cTxLock == queueUNLOCKED )
2523:              			{
2524:              				if( listLIST_IS_EMPTY( &( pxQueueSetContainer->xTasksWaitingToReceive ) ) == pdFALSE )
2525:              				{
2526:              					if( xTaskRemoveFromEventList( &( pxQueueSetContainer->xTasksWaitingToReceive ) ) != pdFALSE )
2527:              					{
2528:              						/* The task waiting has a higher priority. */
2529:              						xReturn = pdTRUE;
2530:              					}
2531:              					else
2532:              					{
2533:              						mtCOVERAGE_TEST_MARKER();
2534:              					}
2535:              				}
2536:              				else
2537:              				{
2538:              					mtCOVERAGE_TEST_MARKER();
2539:              				}
2540:              			}
2541:              			else
2542:              			{
2543:              				pxQueueSetContainer->cTxLock = ( int8_t ) ( cTxLock + 1 );
2544:              			}
2545:              		}
2546:              		else
2547:              		{
2548:              			mtCOVERAGE_TEST_MARKER();
2549:              		}
2550:              
2551:              		return xReturn;
2552:              	}
2553:              
2554:              #endif /* configUSE_QUEUE_SETS */
2555:              
2556:              
2557:              
2558:              
2559:              
2560:              
2561:              
2562:              
2563:              
2564:              
2565:              
2566:              
---  /home/zxc/Documents/WCGRTOS/Source/portable/MemMang/heap_4.c  --------------------------------------
1:                 /*
2:                     FreeRTOS V9.0.0 - Copyright (C) 2016 Real Time Engineers Ltd.
3:                     All rights reserved
4:                 
5:                     VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
6:                 
7:                     This file is part of the FreeRTOS distribution.
8:                 
9:                     FreeRTOS is free software; you can redistribute it and/or modify it under
10:                    the terms of the GNU General Public License (version 2) as published by the
11:                    Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
12:                
13:                    ***************************************************************************
14:                    >>!   NOTE: The modification to the GPL is included to allow you to     !<<
15:                    >>!   distribute a combined work that includes FreeRTOS without being   !<<
16:                    >>!   obliged to provide the source code for proprietary components     !<<
17:                    >>!   outside of the FreeRTOS kernel.                                   !<<
18:                    ***************************************************************************
19:                
20:                    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
21:                    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
22:                    FOR A PARTICULAR PURPOSE.  Full license text is available on the following
23:                    link: http://www.freertos.org/a00114.html
24:                
25:                    ***************************************************************************
26:                     *                                                                       *
27:                     *    FreeRTOS provides completely free yet professionally developed,    *
28:                     *    robust, strictly quality controlled, supported, and cross          *
29:                     *    platform software that is more than just the market leader, it     *
30:                     *    is the industry's de facto standard.                               *
31:                     *                                                                       *
32:                     *    Help yourself get started quickly while simultaneously helping     *
33:                     *    to support the FreeRTOS project by purchasing a FreeRTOS           *
34:                     *    tutorial book, reference manual, or both:                          *
35:                     *    http://www.FreeRTOS.org/Documentation                              *
36:                     *                                                                       *
37:                    ***************************************************************************
38:                
39:                    http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
40:                    the FAQ page "My application does not run, what could be wrong?".  Have you
41:                    defined configASSERT()?
42:                
43:                    http://www.FreeRTOS.org/support - In return for receiving this top quality
44:                    embedded software for free we request you assist our global community by
45:                    participating in the support forum.
46:                
47:                    http://www.FreeRTOS.org/training - Investing in training allows your team to
48:                    be as productive as possible as early as possible.  Now you can receive
49:                    FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
50:                    Ltd, and the world's leading authority on the world's leading RTOS.
51:                
52:                    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
53:                    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
54:                    compatible FAT file system, and our tiny thread aware UDP/IP stack.
55:                
56:                    http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
57:                    Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
58:                
59:                    http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
60:                    Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
61:                    licenses offer ticketed support, indemnification and commercial middleware.
62:                
63:                    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
64:                    engineered and independently SIL3 certified version for use in safety and
65:                    mission critical applications that require provable dependability.
66:                
67:                    1 tab == 4 spaces!
68:                */
69:                
70:                /*
71:                 * A sample implementation of pvPortMalloc() and vPortFree() that combines
72:                 * (coalescences) adjacent memory blocks as they are freed, and in so doing
73:                 * limits memory fragmentation.
74:                 *
75:                 * See heap_1.c, heap_2.c and heap_3.c for alternative implementations, and the
76:                 * memory management pages of http://www.FreeRTOS.org for more information.
77:                 */
78:                #include <stdlib.h>
79:                
80:                /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
81:                all the API functions to use the MPU wrappers.  That should only be done when
82:                task.h is included from an application file. */
83:                #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
84:                
85:                #include "FreeRTOS.h"
86:                #include "task.h"
87:                
88:                #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE
89:                
90:                #if( configSUPPORT_DYNAMIC_ALLOCATION == 0 )
91:                	#error This file must not be used if configSUPPORT_DYNAMIC_ALLOCATION is 0
92:                #endif
93:                
94:                /* Block sizes must not get too small. */
95:                #define heapMINIMUM_BLOCK_SIZE	( ( size_t ) ( xHeapStructSize << 1 ) )
96:                
97:                /* Assumes 8bit bytes! */
98:                #define heapBITS_PER_BYTE		( ( size_t ) 8 )
99:                
100:               /* Allocate the memory for the heap. */
101:               #if( configAPPLICATION_ALLOCATED_HEAP == 1 )
102:               	/* The application writer has already defined the array used for the RTOS
103:               	heap - probably so it can be placed in a special segment or address. */
104:               	extern uint8_t ucHeap[ configTOTAL_HEAP_SIZE ];
105:               #else
106:               	static uint8_t ucHeap[ configTOTAL_HEAP_SIZE ];
107:               #endif /* configAPPLICATION_ALLOCATED_HEAP */
108:               
109:               /* Define the linked list structure.  This is used to link free blocks in order
110:               of their memory address. */
111:               typedef struct A_BLOCK_LINK
112:               {
113:               	struct A_BLOCK_LINK *pxNextFreeBlock;	/*<< The next free block in the list. */
114:               	size_t xBlockSize;						/*<< The size of the free block. */
115:               } BlockLink_t;
116:               
117:               /*-----------------------------------------------------------*/
118:               
119:               /*
120:                * Inserts a block of memory that is being freed into the correct position in
121:                * the list of free memory blocks.  The block being freed will be merged with
122:                * the block in front it and/or the block behind it if the memory blocks are
123:                * adjacent to each other.
124:                */
125:               static void prvInsertBlockIntoFreeList( BlockLink_t *pxBlockToInsert );
126:               
127:               /*
128:                * Called automatically to setup the required heap structures the first time
129:                * pvPortMalloc() is called.
130:                */
131:               static void prvHeapInit( void );
132:               
133:               /*-----------------------------------------------------------*/
134:               
135:               /* The size of the structure placed at the beginning of each allocated memory
136:               block must by correctly byte aligned. */
137:               static const size_t xHeapStructSize	= ( sizeof( BlockLink_t ) + ( ( size_t ) ( portBYTE_ALIGNMENT - 1 ) ) ) & ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
138:               
139:               /* Create a couple of list links to mark the start and end of the list. */
140:               static BlockLink_t xStart, *pxEnd = NULL;
141:               
142:               /* Keeps track of the number of free bytes remaining, but says nothing about
143:               fragmentation. */
144:               static size_t xFreeBytesRemaining = 0U;
145:               static size_t xMinimumEverFreeBytesRemaining = 0U;
146:               
147:               /* Gets set to the top bit of an size_t type.  When this bit in the xBlockSize
148:               member of an BlockLink_t structure is set then the block belongs to the
149:               application.  When the bit is free the block is still part of the free heap
150:               space. */
151:               static size_t xBlockAllocatedBit = 0;
152:               
153:               /*-----------------------------------------------------------*/
154:               
155:               void *pvPortMalloc( size_t xWantedSize )
156:               {
003C80  FA000A     LNK #0xA
003C82  980740     MOV W0, [W14+8]
157:               BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
158:               void *pvReturn = NULL;
003C84  EB0000     CLR W0
003C86  980720     MOV W0, [W14+4]
159:               
160:               	vTaskSuspendAll();
003C88  02165E     CALL vTaskSuspendAll
003C8A  000000     NOP
161:               	{
162:               		/* If this is the first call to malloc then the heap will require
163:               		initialisation to setup the list of free blocks. */
164:               		if( pxEnd == NULL )
003C8C  804480     MOV pxEnd, W0
003C8E  E00000     CP0 W0
165:               		{
166:               			prvHeapInit();
003C90  3A0001     BRA NZ, .L2
003C92  07009F     RCALL _prvHeapInit, .LFE4, .LFB5
167:               		}
168:               		else
169:               		{
170:               			mtCOVERAGE_TEST_MARKER();
171:               		}
172:               
173:               		/* Check the requested block size is not so large that the top bit is
174:               		set.  The top bit of the block size member of the BlockLink_t structure
175:               		is used to determine who owns the block - the application or the
176:               		kernel, so it must be free. */
177:               		if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
003C94  8044B1     MOV xBlockAllocatedBit, W1
003C96  90004E     MOV [W14+8], W0
003C98  608000     AND W1, W0, W0
003C9A  E00000     CP0 W0
003C9C  3A0060     BRA NZ, .L3
178:               		{
179:               			/* The wanted size is increased so it can contain a BlockLink_t
180:               			structure in addition to the requested amount of bytes. */
181:               			if( xWantedSize > 0 )
003C9E  90004E     MOV [W14+8], W0
003CA0  E00000     CP0 W0
003CA2  32000D     BRA Z, .L4
182:               			{
183:               				xWantedSize += xHeapStructSize;
003CA4  848730     MOV 0x90E6, W0
003CA6  9000CE     MOV [W14+8], W1
003CA8  408000     ADD W1, W0, W0
003CAA  980740     MOV W0, [W14+8]
184:               
185:               				/* Ensure that blocks are always aligned to the required number
186:               				of bytes. */
187:               				if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )
003CAC  90004E     MOV [W14+8], W0
003CAE  600061     AND W0, #0x1, W0
003CB0  784000     MOV.B W0, W0
003CB2  E00400     CP0.B W0
003CB4  320004     BRA Z, .L4
188:               				{
189:               					/* Byte alignment required. */
190:               					xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
003CB6  90004E     MOV [W14+8], W0
003CB8  A10000     BCLR W0, #0
003CBA  E88000     INC2 W0, W0
003CBC  980740     MOV W0, [W14+8]
191:               					configASSERT( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) == 0 );
192:               				}
193:               				else
194:               				{
195:               					mtCOVERAGE_TEST_MARKER();
196:               				}
197:               			}
198:               			else
199:               			{
200:               				mtCOVERAGE_TEST_MARKER();
201:               			}
202:               
203:               			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
003CBE  90004E     MOV [W14+8], W0
003CC0  E00000     CP0 W0
003CC2  32004D     BRA Z, .L3
003CC4  804490     MOV xFreeBytesRemaining, W0
003CC6  9000CE     MOV [W14+8], W1
003CC8  508F80     SUB W1, W0, [W15]
003CCA  3E0049     BRA GTU, .L3
204:               			{
205:               				/* Traverse the list from the start	(lowest address) block until
206:               				one	of adequate size is found. */
207:               				pxPreviousBlock = &xStart;
003CCC  2088C0     MOV #0x88C, W0
003CCE  980710     MOV W0, [W14+2]
208:               				pxBlock = xStart.pxNextFreeBlock;
003CD0  804461     MOV xStart, W1
003CD2  780F01     MOV W1, [W14]
209:               				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
003CD4  370004     BRA .L5
003CDE  78001E     MOV [W14], W0
003CE0  900090     MOV [W0+2], W1
003CE2  90004E     MOV [W14+8], W0
003CE4  508F80     SUB W1, W0, [W15]
003CE6  310004     BRA C, .L6
003CE8  78001E     MOV [W14], W0
003CEA  780010     MOV [W0], W0
003CEC  E00000     CP0 W0
003CEE  3AFFF3     BRA NZ, .L7
210:               				{
211:               					pxPreviousBlock = pxBlock;
003CD6  78009E     MOV [W14], W1
003CD8  980711     MOV W1, [W14+2]
212:               					pxBlock = pxBlock->pxNextFreeBlock;
003CDA  78001E     MOV [W14], W0
003CDC  780F10     MOV [W0], [W14]
213:               				}
214:               
215:               				/* If the end marker was reached then a block of adequate size
216:               				was	not found. */
217:               				if( pxBlock != pxEnd )
003CF0  804480     MOV pxEnd, W0
003CF2  78009E     MOV [W14], W1
003CF4  508F80     SUB W1, W0, [W15]
003CF6  320033     BRA Z, .L3
218:               				{
219:               					/* Return the memory space pointed to - jumping over the
220:               					BlockLink_t structure at its start. */
221:               					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
003CF8  90001E     MOV [W14+2], W0
003CFA  780090     MOV [W0], W1
003CFC  848730     MOV 0x90E6, W0
003CFE  408000     ADD W1, W0, W0
003D00  980720     MOV W0, [W14+4]
222:               
223:               					/* This block is being returned for use so must be taken out
224:               					of the list of free blocks. */
225:               					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
003D02  78001E     MOV [W14], W0
003D04  780090     MOV [W0], W1
003D06  90001E     MOV [W14+2], W0
003D08  780801     MOV W1, [W0]
226:               
227:               					/* If the block is larger than required it can be split into
228:               					two. */
229:               					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
003D0A  78001E     MOV [W14], W0
003D0C  900090     MOV [W0+2], W1
003D0E  90004E     MOV [W14+8], W0
003D10  508080     SUB W1, W0, W1
003D12  848730     MOV 0x90E6, W0
003D14  400000     ADD W0, W0, W0
003D16  508F80     SUB W1, W0, [W15]
003D18  36000E     BRA LEU, .L8
230:               					{
231:               						/* This block is to be split into two.  Create a new
232:               						block following the number of bytes requested. The void
233:               						cast is used to prevent byte alignment warnings from the
234:               						compiler. */
235:               						pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
003D1A  90004E     MOV [W14+8], W0
003D1C  40001E     ADD W0, [W14], W0
003D1E  980730     MOV W0, [W14+6]
236:               						configASSERT( ( ( ( size_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0 );
237:               
238:               						/* Calculate the sizes of two blocks split from the
239:               						single block. */
240:               						pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
003D20  78001E     MOV [W14], W0
003D22  900090     MOV [W0+2], W1
003D24  90004E     MOV [W14+8], W0
003D26  508080     SUB W1, W0, W1
003D28  90003E     MOV [W14+6], W0
003D2A  980011     MOV W1, [W0+2]
241:               						pxBlock->xBlockSize = xWantedSize;
003D2C  78001E     MOV [W14], W0
003D2E  9000CE     MOV [W14+8], W1
003D30  980011     MOV W1, [W0+2]
242:               
243:               						/* Insert the new block into the list of free blocks. */
244:               						prvInsertBlockIntoFreeList( pxNewBlockLink );
003D32  90003E     MOV [W14+6], W0
003D34  070085     RCALL _prvInsertBlockIntoFreeList, .LFE5, .LFB6
245:               					}
246:               					else
247:               					{
248:               						mtCOVERAGE_TEST_MARKER();
249:               					}
250:               
251:               					xFreeBytesRemaining -= pxBlock->xBlockSize;
003D36  804491     MOV xFreeBytesRemaining, W1
003D38  78001E     MOV [W14], W0
003D3A  900010     MOV [W0+2], W0
003D3C  508000     SUB W1, W0, W0
003D3E  884490     MOV W0, xFreeBytesRemaining
252:               
253:               					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
003D40  804491     MOV xFreeBytesRemaining, W1
003D42  8044A0     MOV xMinimumEverFreeBytesRemaining, W0
003D44  508F80     SUB W1, W0, [W15]
003D46  310002     BRA C, .L9
254:               					{
255:               						xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
003D48  804490     MOV xFreeBytesRemaining, W0
003D4A  8844A0     MOV W0, xMinimumEverFreeBytesRemaining
256:               					}
257:               					else
258:               					{
259:               						mtCOVERAGE_TEST_MARKER();
260:               					}
261:               
262:               					/* The block is being returned - it is allocated and owned
263:               					by the application and has no "next" block. */
264:               					pxBlock->xBlockSize |= xBlockAllocatedBit;
003D4C  78001E     MOV [W14], W0
003D4E  900090     MOV [W0+2], W1
003D50  8044B0     MOV xBlockAllocatedBit, W0
003D52  700081     IOR W0, W1, W1
003D54  78001E     MOV [W14], W0
003D56  980011     MOV W1, [W0+2]
265:               					pxBlock->pxNextFreeBlock = NULL;
003D58  78001E     MOV [W14], W0
003D5A  EB0080     CLR W1
003D5C  780801     MOV W1, [W0]
266:               				}
267:               				else
268:               				{
269:               					mtCOVERAGE_TEST_MARKER();
270:               				}
271:               			}
272:               			else
273:               			{
274:               				mtCOVERAGE_TEST_MARKER();
275:               			}
276:               		}
277:               		else
278:               		{
279:               			mtCOVERAGE_TEST_MARKER();
280:               		}
281:               
282:               		traceMALLOC( pvReturn, xWantedSize );
283:               	}
284:               	( void ) xTaskResumeAll();
003D5E  02166A     CALL xTaskResumeAll
003D60  000000     NOP
285:               
286:               	#if( configUSE_MALLOC_FAILED_HOOK == 1 )
287:               	{
288:               		if( pvReturn == NULL )
289:               		{
290:               			extern void vApplicationMallocFailedHook( void );
291:               			vApplicationMallocFailedHook();
292:               		}
293:               		else
294:               		{
295:               			mtCOVERAGE_TEST_MARKER();
296:               		}
297:               	}
298:               	#endif
299:               
300:               	configASSERT( ( ( ( size_t ) pvReturn ) & ( size_t ) portBYTE_ALIGNMENT_MASK ) == 0 );
301:               	return pvReturn;
003D62  90002E     MOV [W14+4], W0
302:               }
003D64  FA8000     ULNK
003D66  060000     RETURN
303:               /*-----------------------------------------------------------*/
304:               
305:               void vPortFree( void *pv )
306:               {
003D68  FA0006     LNK #0x6
003D6A  980720     MOV W0, [W14+4]
307:               uint8_t *puc = ( uint8_t * ) pv;
003D6C  9000AE     MOV [W14+4], W1
003D6E  780F01     MOV W1, [W14]
308:               BlockLink_t *pxLink;
309:               
310:               	if( pv != NULL )
003D70  90002E     MOV [W14+4], W0
003D72  E00000     CP0 W0
003D74  320021     BRA Z, .L10
311:               	{
312:               		/* The memory being freed will have an BlockLink_t structure immediately
313:               		before it. */
314:               		puc -= xHeapStructSize;
003D76  848730     MOV 0x90E6, W0
003D78  EA0000     NEG W0, W0
003D7A  400F1E     ADD W0, [W14], [W14]
315:               
316:               		/* This casting is to keep the compiler from issuing warnings. */
317:               		pxLink = ( void * ) puc;
003D7C  78009E     MOV [W14], W1
003D7E  980711     MOV W1, [W14+2]
318:               
319:               		/* Check the block is actually allocated. */
320:               		configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
321:               		configASSERT( pxLink->pxNextFreeBlock == NULL );
322:               
323:               		if( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 )
003D80  90001E     MOV [W14+2], W0
003D82  900090     MOV [W0+2], W1
003D84  8044B0     MOV xBlockAllocatedBit, W0
003D86  608000     AND W1, W0, W0
003D88  E00000     CP0 W0
003D8A  320016     BRA Z, .L10
324:               		{
325:               			if( pxLink->pxNextFreeBlock == NULL )
003D8C  90001E     MOV [W14+2], W0
003D8E  780010     MOV [W0], W0
003D90  E00000     CP0 W0
003D92  3A0012     BRA NZ, .L10
326:               			{
327:               				/* The block is being returned to the heap - it is no longer
328:               				allocated. */
329:               				pxLink->xBlockSize &= ~xBlockAllocatedBit;
003D94  90001E     MOV [W14+2], W0
003D96  900090     MOV [W0+2], W1
003D98  8044B0     MOV xBlockAllocatedBit, W0
003D9A  EA8000     COM W0, W0
003D9C  608080     AND W1, W0, W1
003D9E  90001E     MOV [W14+2], W0
003DA0  980011     MOV W1, [W0+2]
330:               
331:               				vTaskSuspendAll();
003DA2  02165E     CALL vTaskSuspendAll
003DA4  000000     NOP
332:               				{
333:               					/* Add this block to the list of free blocks. */
334:               					xFreeBytesRemaining += pxLink->xBlockSize;
003DA6  90001E     MOV [W14+2], W0
003DA8  900090     MOV [W0+2], W1
003DAA  804490     MOV xFreeBytesRemaining, W0
003DAC  408000     ADD W1, W0, W0
003DAE  884490     MOV W0, xFreeBytesRemaining
335:               					traceFREE( pv, pxLink->xBlockSize );
336:               					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
003DB0  90001E     MOV [W14+2], W0
003DB2  070046     RCALL _prvInsertBlockIntoFreeList, .LFE5, .LFB6
337:               				}
338:               				( void ) xTaskResumeAll();
003DB4  02166A     CALL xTaskResumeAll
003DB6  000000     NOP
339:               			}
340:               			else
341:               			{
342:               				mtCOVERAGE_TEST_MARKER();
343:               			}
344:               		}
345:               		else
346:               		{
347:               			mtCOVERAGE_TEST_MARKER();
348:               		}
349:               	}
350:               }
003DB8  FA8000     ULNK
003DBA  060000     RETURN
351:               /*-----------------------------------------------------------*/
352:               
353:               size_t xPortGetFreeHeapSize( void )
354:               {
003DBC  FA0000     LNK #0x0
355:               	return xFreeBytesRemaining;
003DBE  804490     MOV xFreeBytesRemaining, W0
356:               }
003DC0  FA8000     ULNK
003DC2  060000     RETURN
357:               /*-----------------------------------------------------------*/
358:               
359:               size_t xPortGetMinimumEverFreeHeapSize( void )
360:               {
003DC4  FA0000     LNK #0x0
361:               	return xMinimumEverFreeBytesRemaining;
003DC6  8044A0     MOV xMinimumEverFreeBytesRemaining, W0
362:               }
003DC8  FA8000     ULNK
003DCA  060000     RETURN
363:               /*-----------------------------------------------------------*/
364:               
365:               void vPortInitialiseBlocks( void )
366:               {
003DCC  FA0000     LNK #0x0
367:               	/* This just exists to keep the linker quiet. */
368:               }
003DCE  FA8000     ULNK
003DD0  060000     RETURN
369:               /*-----------------------------------------------------------*/
370:               
371:               static void prvHeapInit( void )
372:               {
003DD2  FA0008     LNK #0x8
373:               BlockLink_t *pxFirstFreeBlock;
374:               uint8_t *pucAlignedHeap;
375:               size_t uxAddress;
376:               size_t xTotalHeapSize = configTOTAL_HEAP_SIZE;
003DD4  214000     MOV #0x1400, W0
003DD6  980710     MOV W0, [W14+2]
377:               
378:               	/* Ensure the heap starts on a correctly aligned boundary. */
379:               	uxAddress = ( size_t ) ucHeap;
003DD8  208B40     MOV #0x8B4, W0
003DDA  780F00     MOV W0, [W14]
380:               
381:               	if( ( uxAddress & portBYTE_ALIGNMENT_MASK ) != 0 )
003DDC  78001E     MOV [W14], W0
003DDE  600061     AND W0, #0x1, W0
003DE0  784000     MOV.B W0, W0
003DE2  E00400     CP0.B W0
003DE4  320007     BRA Z, .L16
382:               	{
383:               		uxAddress += ( portBYTE_ALIGNMENT - 1 );
003DE6  E80F1E     INC [W14], [W14]
384:               		uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
003DE8  A1001E     BCLR [W14], #0
385:               		xTotalHeapSize -= uxAddress - ( size_t ) ucHeap;
003DEA  90001E     MOV [W14+2], W0
003DEC  50009E     SUB W0, [W14], W1
003DEE  208B40     MOV #0x8B4, W0
003DF0  408000     ADD W1, W0, W0
003DF2  980710     MOV W0, [W14+2]
386:               	}
387:               
388:               	pucAlignedHeap = ( uint8_t * ) uxAddress;
003DF4  78009E     MOV [W14], W1
003DF6  980721     MOV W1, [W14+4]
389:               
390:               	/* xStart is used to hold a pointer to the first item in the list of free
391:               	blocks.  The void cast is used to prevent compiler warnings. */
392:               	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
003DF8  90002E     MOV [W14+4], W0
003DFA  884460     MOV W0, xStart
393:               	xStart.xBlockSize = ( size_t ) 0;
003DFC  EF288E     CLR 0x88E
394:               
395:               	/* pxEnd is used to mark the end of the list of free blocks and is inserted
396:               	at the end of the heap space. */
397:               	uxAddress = ( ( size_t ) pucAlignedHeap ) + xTotalHeapSize;
003DFE  9000AE     MOV [W14+4], W1
003E00  90001E     MOV [W14+2], W0
003E02  408F00     ADD W1, W0, [W14]
398:               	uxAddress -= xHeapStructSize;
003E04  848730     MOV 0x90E6, W0
003E06  100F1E     SUBR W0, [W14], [W14]
399:               	uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
003E08  A1001E     BCLR [W14], #0
400:               	pxEnd = ( void * ) uxAddress;
003E0A  78001E     MOV [W14], W0
003E0C  884480     MOV W0, pxEnd
401:               	pxEnd->xBlockSize = 0;
003E0E  804480     MOV pxEnd, W0
003E10  EB0080     CLR W1
003E12  980011     MOV W1, [W0+2]
402:               	pxEnd->pxNextFreeBlock = NULL;
003E14  804480     MOV pxEnd, W0
003E16  EB0080     CLR W1
003E18  780801     MOV W1, [W0]
403:               
404:               	/* To start with there is a single free block that is sized to take up the
405:               	entire heap space, minus the space taken by pxEnd. */
406:               	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
003E1A  9000AE     MOV [W14+4], W1
003E1C  980731     MOV W1, [W14+6]
407:               	pxFirstFreeBlock->xBlockSize = uxAddress - ( size_t ) pxFirstFreeBlock;
003E1E  90003E     MOV [W14+6], W0
003E20  10009E     SUBR W0, [W14], W1
003E22  90003E     MOV [W14+6], W0
003E24  980011     MOV W1, [W0+2]
408:               	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
003E26  804481     MOV pxEnd, W1
003E28  90003E     MOV [W14+6], W0
003E2A  780801     MOV W1, [W0]
409:               
410:               	/* Only one block exists - and it covers the entire usable heap space. */
411:               	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
003E2C  90003E     MOV [W14+6], W0
003E2E  900010     MOV [W0+2], W0
003E30  8844A0     MOV W0, xMinimumEverFreeBytesRemaining
412:               	xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
003E32  90003E     MOV [W14+6], W0
003E34  900010     MOV [W0+2], W0
003E36  884490     MOV W0, xFreeBytesRemaining
413:               
414:               	/* Work out the position of the top bit in a size_t variable. */
415:               	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
003E38  280000     MOV #0x8000, W0
003E3A  8844B0     MOV W0, xBlockAllocatedBit
416:               }
003E3C  FA8000     ULNK
003E3E  060000     RETURN
417:               /*-----------------------------------------------------------*/
418:               
419:               static void prvInsertBlockIntoFreeList( BlockLink_t *pxBlockToInsert )
420:               {
003E40  FA0006     LNK #0x6
003E42  980720     MOV W0, [W14+4]
421:               BlockLink_t *pxIterator;
422:               uint8_t *puc;
423:               
424:               	/* Iterate through the list until a block is found that has a higher address
425:               	than the block being inserted. */
426:               	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
003E44  2088C0     MOV #0x88C, W0
003E46  780F00     MOV W0, [W14]
003E48  370002     BRA .L18
003E4A  78001E     MOV [W14], W0
003E4C  780F10     MOV [W0], [W14]
003E4E  78001E     MOV [W14], W0
003E50  780090     MOV [W0], W1
003E52  90002E     MOV [W14+4], W0
003E54  508F80     SUB W1, W0, [W15]
003E56  39FFF9     BRA NC, .L19
427:               	{
428:               		/* Nothing to do here, just iterate to the right position. */
429:               	}
430:               
431:               	/* Do the block being inserted, and the block it is being inserted after
432:               	make a contiguous block of memory? */
433:               	puc = ( uint8_t * ) pxIterator;
003E58  78009E     MOV [W14], W1
003E5A  980711     MOV W1, [W14+2]
434:               	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
003E5C  78001E     MOV [W14], W0
003E5E  900010     MOV [W0+2], W0
003E60  90009E     MOV [W14+2], W1
003E62  408080     ADD W1, W0, W1
003E64  90002E     MOV [W14+4], W0
003E66  508F80     SUB W1, W0, [W15]
003E68  3A0009     BRA NZ, .L20
435:               	{
436:               		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
003E6A  78001E     MOV [W14], W0
003E6C  900090     MOV [W0+2], W1
003E6E  90002E     MOV [W14+4], W0
003E70  900010     MOV [W0+2], W0
003E72  408080     ADD W1, W0, W1
003E74  78001E     MOV [W14], W0
003E76  980011     MOV W1, [W0+2]
437:               		pxBlockToInsert = pxIterator;
003E78  78009E     MOV [W14], W1
003E7A  980721     MOV W1, [W14+4]
438:               	}
439:               	else
440:               	{
441:               		mtCOVERAGE_TEST_MARKER();
442:               	}
443:               
444:               	/* Do the block being inserted, and the block it is being inserted before
445:               	make a contiguous block of memory? */
446:               	puc = ( uint8_t * ) pxBlockToInsert;
003E7C  9000AE     MOV [W14+4], W1
003E7E  980711     MOV W1, [W14+2]
447:               	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
003E80  90002E     MOV [W14+4], W0
003E82  900010     MOV [W0+2], W0
003E84  90009E     MOV [W14+2], W1
003E86  408080     ADD W1, W0, W1
003E88  78001E     MOV [W14], W0
003E8A  780010     MOV [W0], W0
003E8C  508F80     SUB W1, W0, [W15]
003E8E  3A0017     BRA NZ, .L21
448:               	{
449:               		if( pxIterator->pxNextFreeBlock != pxEnd )
003E90  78001E     MOV [W14], W0
003E92  780090     MOV [W0], W1
003E94  804480     MOV pxEnd, W0
003E96  508F80     SUB W1, W0, [W15]
003E98  32000E     BRA Z, .L22
450:               		{
451:               			/* Form one big block from the two blocks. */
452:               			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
003E9A  90002E     MOV [W14+4], W0
003E9C  900090     MOV [W0+2], W1
003E9E  78001E     MOV [W14], W0
003EA0  780010     MOV [W0], W0
003EA2  900010     MOV [W0+2], W0
003EA4  408080     ADD W1, W0, W1
003EA6  90002E     MOV [W14+4], W0
003EA8  980011     MOV W1, [W0+2]
453:               			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
003EAA  78001E     MOV [W14], W0
003EAC  780010     MOV [W0], W0
003EAE  780090     MOV [W0], W1
003EB0  90002E     MOV [W14+4], W0
003EB2  780801     MOV W1, [W0]
003EB4  370008     BRA .L23
454:               		}
455:               		else
456:               		{
457:               			pxBlockToInsert->pxNextFreeBlock = pxEnd;
003EB6  804481     MOV pxEnd, W1
003EB8  90002E     MOV [W14+4], W0
003EBA  780801     MOV W1, [W0]
003EBC  370004     BRA .L23
458:               		}
459:               	}
460:               	else
461:               	{
462:               		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
003EBE  78001E     MOV [W14], W0
003EC0  780090     MOV [W0], W1
003EC2  90002E     MOV [W14+4], W0
003EC4  780801     MOV W1, [W0]
463:               	}
464:               
465:               	/* If the block being inserted plugged a gab, so was merged with the block
466:               	before and the block after, then it's pxNextFreeBlock pointer will have
467:               	already been set, and should not be set here as that would make it point
468:               	to itself. */
469:               	if( pxIterator != pxBlockToInsert )
003EC6  90002E     MOV [W14+4], W0
003EC8  78009E     MOV [W14], W1
003ECA  508F80     SUB W1, W0, [W15]
003ECC  320003     BRA Z, .L17
470:               	{
471:               		pxIterator->pxNextFreeBlock = pxBlockToInsert;
003ECE  78001E     MOV [W14], W0
003ED0  9000AE     MOV [W14+4], W1
003ED2  780801     MOV W1, [W0]
472:               	}
473:               	else
474:               	{
475:               		mtCOVERAGE_TEST_MARKER();
476:               	}
477:               }
003ED4  FA8000     ULNK
003ED6  060000     RETURN
478:               
---  /home/zxc/Documents/WCGRTOS/Source/portable/MPLAB/PIC24_dsPIC/portasm_PIC24.S  ---------------------
                                                  1:     /*
                                                  2:         FreeRTOS V9.0.0 - Copyright (C) 2016 Real Time Engineers Ltd.
                                                  3:         All rights reserved
                                                  4:     
                                                  5:         VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
                                                  6:     
                                                  7:         This file is part of the FreeRTOS distribution.
                                                  8:     
                                                  9:         FreeRTOS is free software; you can redistribute it and/or modify it under
                                                  10:        the terms of the GNU General Public License (version 2) as published by the
                                                  11:        Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
                                                  12:    
                                                  13:        ***************************************************************************
                                                  14:        >>!   NOTE: The modification to the GPL is included to allow you to     !<<
                                                  15:        >>!   distribute a combined work that includes FreeRTOS without being   !<<
                                                  16:        >>!   obliged to provide the source code for proprietary components     !<<
                                                  17:        >>!   outside of the FreeRTOS kernel.                                   !<<
                                                  18:        ***************************************************************************
                                                  19:    
                                                  20:        FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
                                                  21:        WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
                                                  22:        FOR A PARTICULAR PURPOSE.  Full license text is available on the following
                                                  23:        link: http://www.freertos.org/a00114.html
                                                  24:    
                                                  25:        ***************************************************************************
                                                  26:         *                                                                       *
                                                  27:         *    FreeRTOS provides completely free yet professionally developed,    *
                                                  28:         *    robust, strictly quality controlled, supported, and cross          *
                                                  29:         *    platform software that is more than just the market leader, it     *
                                                  30:         *    is the industry's de facto standard.                               *
                                                  31:         *                                                                       *
                                                  32:         *    Help yourself get started quickly while simultaneously helping     *
                                                  33:         *    to support the FreeRTOS project by purchasing a FreeRTOS           *
                                                  34:         *    tutorial book, reference manual, or both:                          *
                                                  35:         *    http://www.FreeRTOS.org/Documentation                              *
                                                  36:         *                                                                       *
                                                  37:        ***************************************************************************
                                                  38:    
                                                  39:        http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
                                                  40:        the FAQ page "My application does not run, what could be wrong?".  Have you
                                                  41:        defined configASSERT()?
                                                  42:    
                                                  43:        http://www.FreeRTOS.org/support - In return for receiving this top quality
                                                  44:        embedded software for free we request you assist our global community by
                                                  45:        participating in the support forum.
                                                  46:    
                                                  47:        http://www.FreeRTOS.org/training - Investing in training allows your team to
                                                  48:        be as productive as possible as early as possible.  Now you can receive
                                                  49:        FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
                                                  50:        Ltd, and the world's leading authority on the world's leading RTOS.
                                                  51:    
                                                  52:        http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
                                                  53:        including FreeRTOS+Trace - an indispensable productivity tool, a DOS
                                                  54:        compatible FAT file system, and our tiny thread aware UDP/IP stack.
                                                  55:    
                                                  56:        http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
                                                  57:        Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
                                                  58:    
                                                  59:        http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
                                                  60:        Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
                                                  61:        licenses offer ticketed support, indemnification and commercial middleware.
                                                  62:    
                                                  63:        http://www.SafeRTOS.com - High Integrity Systems also provide a safety
                                                  64:        engineered and independently SIL3 certified version for use in safety and
                                                  65:        mission critical applications that require provable dependability.
                                                  66:    
                                                  67:        1 tab == 4 spaces!
                                                  68:    */
                                                  69:    
                                                  70:    #if defined( __PIC24E__ ) || defined ( __PIC24F__ ) || defined( __PIC24FK__ ) || defined( __PIC24H__ )
                                                  71:    
                                                  72:            .global _vPortYield
                                                  73:    		.extern _vTaskSwitchContext
                                                  74:    		.extern uxCriticalNesting
                                                  75:    
                                                  76:    _vPortYield:
                                                  77:    
0050DC  F80042     PUSH SR                        78:    		PUSH	SR						/* Save the SR used by the task.... */
0050DE  781F80     MOV W0, [W15++]                79:    		PUSH	W0						/* ....then disable interrupts. */
0050E0  200200     MOV #0x20, W0                  80:    		MOV		#32, W0
0050E2  880210     MOV W0, SR                     81:    		MOV		W0, SR
0050E4  781F81     MOV W1, [W15++]                82:    		PUSH	W1						/* Save registers to the stack. */
0050E6  BE9F82     MOV.D W2, [W15++]              83:    		PUSH.D	W2
0050E8  BE9F84     MOV.D W4, [W15++]              84:    		PUSH.D	W4
0050EA  BE9F86     MOV.D W6, [W15++]              85:    		PUSH.D	W6
0050EC  BE9F88     MOV.D W8, [W15++]              86:    		PUSH.D 	W8
0050EE  BE9F8A     MOV.D W10, [W15++]             87:    		PUSH.D 	W10
0050F0  BE9F8C     MOV.D W12, [W15++]             88:    		PUSH.D	W12
0050F2  781F8E     MOV W14, [W15++]               89:    		PUSH	W14
0050F4  F80036     PUSH RCOUNT                    90:    		PUSH	RCOUNT
0050F6  F80054     PUSH TBLPAG                    91:    		PUSH	TBLPAG
                                                  92:    
0050F8  F80044     PUSH CORCON                    93:    		PUSH	CORCON
                                                  94:    		#ifdef __HAS_EDS__
0050FA  F80032     PUSH DSRPAG                    95:    			PUSH	DSRPAG
0050FC  F80034     PUSH DSWPAG                    96:    			PUSH	DSWPAG
                                                  97:    		#else
                                                  98:    			PUSH	PSVPAG
                                                  99:    		#endif /* __HAS_EDS__ */
0050FE  804570     MOV 0x8AE, W0                  100:   		MOV		_uxCriticalNesting, W0		/* Save the critical nesting counter for the task. */
005100  781F80     MOV W0, [W15++]                101:   		PUSH	W0
005102  804280     MOV 0x850, W0                  102:   		MOV		_pxCurrentTCB, W0			/* Save the new top of stack into the TCB. */
005104  78080F     MOV W15, [W0]                  103:   		MOV		W15, [W0]
                                                  104:   
005106  021848     CALL 0x1848                    105:   		call 	_vTaskSwitchContext
                                                  106:   
00510A  804280     MOV 0x850, W0                  107:   		MOV		_pxCurrentTCB, W0			/* Restore the stack pointer for the task. */
00510C  780790     MOV [W0], W15                  108:   		MOV		[W0], W15
00510E  78004F     MOV [--W15], W0                109:   		POP		W0							/* Restore the critical nesting counter for the task. */
005110  884570     MOV W0, 0x8AE                  110:   		MOV		W0, _uxCriticalNesting
                                                  111:   		#ifdef __HAS_EDS__
005112  F90034     POP DSWPAG                     112:   			POP		DSWPAG
005114  F90032     POP DSRPAG                     113:   			POP		DSRPAG
                                                  114:   		#else
                                                  115:   			POP		PSVPAG
                                                  116:   		#endif /* __HAS_EDS__ */
005116  F90044     POP CORCON                     117:   		POP		CORCON
005118  F90054     POP TBLPAG                     118:   		POP		TBLPAG
00511A  F90036     POP RCOUNT                     119:   		POP		RCOUNT						/* Restore the registers from the stack. */
00511C  78074F     MOV [--W15], W14               120:   		POP		W14
00511E  BE064F     MOV.D [--W15], W12             121:   		POP.D	W12
005120  BE054F     MOV.D [--W15], W10             122:   		POP.D	W10
005122  BE044F     MOV.D [--W15], W8              123:   		POP.D	W8
005124  BE034F     MOV.D [--W15], W6              124:   		POP.D	W6
005126  BE024F     MOV.D [--W15], W4              125:   		POP.D	W4
005128  BE014F     MOV.D [--W15], W2              126:   		POP.D	W2
00512A  BE004F     MOV.D [--W15], W0              127:   		POP.D	W0
00512C  F90042     POP SR                         128:   		POP		SR
                                                  129:   
00512E  060000     RETURN                         130:           return
                                                  131:   
                                                  132:           .end
                                                  133:   		
                                                  134:   #endif /* defined( __PIC24E__ ) || defined ( __PIC24F__ ) || defined( __PIC24FK__ ) || defined( __PIC24H__ ) */
---  /home/zxc/Documents/WCGRTOS/Source/portable/MPLAB/PIC24_dsPIC/port.c  ------------------------------
1:                 /*
2:                     FreeRTOS V9.0.0 - Copyright (C) 2016 Real Time Engineers Ltd.
3:                     All rights reserved
4:                 
5:                     VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
6:                 
7:                     This file is part of the FreeRTOS distribution.
8:                 
9:                     FreeRTOS is free software; you can redistribute it and/or modify it under
10:                    the terms of the GNU General Public License (version 2) as published by the
11:                    Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
12:                
13:                    ***************************************************************************
14:                    >>!   NOTE: The modification to the GPL is included to allow you to     !<<
15:                    >>!   distribute a combined work that includes FreeRTOS without being   !<<
16:                    >>!   obliged to provide the source code for proprietary components     !<<
17:                    >>!   outside of the FreeRTOS kernel.                                   !<<
18:                    ***************************************************************************
19:                
20:                    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
21:                    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
22:                    FOR A PARTICULAR PURPOSE.  Full license text is available on the following
23:                    link: http://www.freertos.org/a00114.html
24:                
25:                    ***************************************************************************
26:                     *                                                                       *
27:                     *    FreeRTOS provides completely free yet professionally developed,    *
28:                     *    robust, strictly quality controlled, supported, and cross          *
29:                     *    platform software that is more than just the market leader, it     *
30:                     *    is the industry's de facto standard.                               *
31:                     *                                                                       *
32:                     *    Help yourself get started quickly while simultaneously helping     *
33:                     *    to support the FreeRTOS project by purchasing a FreeRTOS           *
34:                     *    tutorial book, reference manual, or both:                          *
35:                     *    http://www.FreeRTOS.org/Documentation                              *
36:                     *                                                                       *
37:                    ***************************************************************************
38:                
39:                    http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
40:                    the FAQ page "My application does not run, what could be wrong?".  Have you
41:                    defined configASSERT()?
42:                
43:                    http://www.FreeRTOS.org/support - In return for receiving this top quality
44:                    embedded software for free we request you assist our global community by
45:                    participating in the support forum.
46:                
47:                    http://www.FreeRTOS.org/training - Investing in training allows your team to
48:                    be as productive as possible as early as possible.  Now you can receive
49:                    FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
50:                    Ltd, and the world's leading authority on the world's leading RTOS.
51:                
52:                    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
53:                    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
54:                    compatible FAT file system, and our tiny thread aware UDP/IP stack.
55:                
56:                    http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
57:                    Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
58:                
59:                    http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
60:                    Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
61:                    licenses offer ticketed support, indemnification and commercial middleware.
62:                
63:                    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
64:                    engineered and independently SIL3 certified version for use in safety and
65:                    mission critical applications that require provable dependability.
66:                
67:                    1 tab == 4 spaces!
68:                */
69:                
70:                /*
71:                	Changes from V4.2.1
72:                
73:                	+ Introduced the configKERNEL_INTERRUPT_PRIORITY definition.
74:                */
75:                
76:                /*-----------------------------------------------------------
77:                 * Implementation of functions defined in portable.h for the PIC24 port.
78:                 *----------------------------------------------------------*/
79:                
80:                /* Scheduler include files. */
81:                #include "FreeRTOS.h"
82:                #include "task.h"
83:                
84:                /* Hardware specifics. */
85:                #define portBIT_SET 1
86:                #define portTIMER_PRESCALE 8
87:                #define portINITIAL_SR	0
88:                
89:                /* Defined for backward compatability with project created prior to
90:                FreeRTOS.org V4.3.0. */
91:                #ifndef configKERNEL_INTERRUPT_PRIORITY
92:                	#define configKERNEL_INTERRUPT_PRIORITY 1
93:                #endif
94:                
95:                /* Use _T1Interrupt as the interrupt handler name if the application writer has
96:                not provided their own. */
97:                #ifndef configTICK_INTERRUPT_HANDLER
98:                	#define configTICK_INTERRUPT_HANDLER _T1Interrupt
99:                #endif /* configTICK_INTERRUPT_HANDLER */
100:               
101:               /* The program counter is only 23 bits. */
102:               #define portUNUSED_PR_BITS	0x7f
103:               
104:               /* Records the nesting depth of calls to portENTER_CRITICAL(). */
105:               UBaseType_t uxCriticalNesting = 0xef;
106:               
107:               #if configKERNEL_INTERRUPT_PRIORITY != 1
108:               	#error If configKERNEL_INTERRUPT_PRIORITY is not 1 then the #32 in the following macros needs changing to equal the portINTERRUPT_BITS value, which is ( configKERNEL_INTERRUPT_PRIORITY << 5 )
109:               #endif
110:               
111:               #if defined( __PIC24E__ ) || defined ( __PIC24F__ ) || defined( __PIC24FK__ ) || defined( __PIC24H__ )
112:               
113:                   #ifdef __HAS_EDS__
114:               		#define portRESTORE_CONTEXT()																						\
115:               					asm volatile(	"MOV	_pxCurrentTCB, W0		\n"	/* Restore the stack pointer for the task. */		\
116:               							"MOV	[W0], W15				\n"																\
117:               							"POP	W0						\n"	/* Restore the critical nesting counter for the task. */	\
118:               							"MOV	W0, _uxCriticalNesting	\n"																\
119:               							"POP	DSWPAG					\n"																\
120:               							"POP    DSRPAG					\n"																\
121:               							"POP	CORCON					\n"																\
122:               							"POP	TBLPAG					\n"																\
123:               							"POP	RCOUNT					\n"	/* Restore the registers from the stack. */					\
124:               							"POP	W14						\n"																\
125:               							"POP.D	W12						\n"																\
126:               							"POP.D	W10						\n"																\
127:               							"POP.D	W8						\n"																\
128:               							"POP.D	W6						\n"																\
129:               							"POP.D	W4						\n"																\
130:               							"POP.D	W2						\n"																\
131:               							"POP.D	W0						\n"																\
132:               							"POP	SR						  " );
133:               	#else /* __HAS_EDS__ */
134:               		#define portRESTORE_CONTEXT()																						\
135:               			asm volatile(	"MOV	_pxCurrentTCB, W0		\n"	/* Restore the stack pointer for the task. */				\
136:               							"MOV	[W0], W15				\n"																\
137:               							"POP	W0						\n"	/* Restore the critical nesting counter for the task. */	\
138:               							"MOV	W0, _uxCriticalNesting	\n"																\
139:               							"POP	PSVPAG					\n"																\
140:               							"POP	CORCON					\n"																\
141:               							"POP	TBLPAG					\n"																\
142:               							"POP	RCOUNT					\n"	/* Restore the registers from the stack. */					\
143:               							"POP	W14						\n"																\
144:               							"POP.D	W12						\n"																\
145:               							"POP.D	W10						\n"																\
146:               							"POP.D	W8						\n"																\
147:               							"POP.D	W6						\n"																\
148:               							"POP.D	W4						\n"																\
149:               							"POP.D	W2						\n"																\
150:               							"POP.D	W0						\n"																\
151:               							"POP	SR						  " );
152:               		#endif /* __HAS_EDS__ */
153:               #endif /* MPLAB_PIC24_PORT */
154:               
155:               #if defined( __dsPIC30F__ ) || defined( __dsPIC33F__ )
156:               
157:               	#define portRESTORE_CONTEXT()																						\
158:               		asm volatile(	"MOV	_pxCurrentTCB, W0		\n"	/* Restore the stack pointer for the task. */				\
159:               						"MOV	[W0], W15				\n"																\
160:               						"POP	W0						\n"	/* Restore the critical nesting counter for the task. */	\
161:               						"MOV	W0, _uxCriticalNesting	\n"																\
162:               						"POP	PSVPAG					\n"																\
163:               						"POP	CORCON					\n"																\
164:               						"POP	DOENDH					\n"																\
165:               						"POP	DOENDL					\n"																\
166:               						"POP	DOSTARTH				\n"																\
167:               						"POP	DOSTARTL				\n"																\
168:               						"POP	DCOUNT					\n"																\
169:               						"POP	ACCBU					\n"																\
170:               						"POP	ACCBH					\n"																\
171:               						"POP	ACCBL					\n"																\
172:               						"POP	ACCAU					\n"																\
173:               						"POP	ACCAH					\n"																\
174:               						"POP	ACCAL					\n"																\
175:               						"POP	TBLPAG					\n"																\
176:               						"POP	RCOUNT					\n"	/* Restore the registers from the stack. */					\
177:               						"POP	W14						\n"																\
178:               						"POP.D	W12						\n"																\
179:               						"POP.D	W10						\n"																\
180:               						"POP.D	W8						\n"																\
181:               						"POP.D	W6						\n"																\
182:               						"POP.D	W4						\n"																\
183:               						"POP.D	W2						\n"																\
184:               						"POP.D	W0						\n"																\
185:               						"POP	SR						  " );
186:               
187:               #endif /* MPLAB_DSPIC_PORT */
188:               
189:               #ifndef portRESTORE_CONTEXT
190:               	#error Unrecognised device selected
191:               
192:               	/* Note:  dsPIC parts with EDS are not supported as there is no easy way to
193:               	recover the hardware stacked copies for DOCOUNT, DOHIGH, DOLOW. */
194:               #endif
195:               
196:               /*
197:                * Setup the timer used to generate the tick interrupt.
198:                */
199:               void vApplicationSetupTickTimerInterrupt( void );
200:               
201:               /*
202:                * See header file for description.
203:                */
204:               StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
205:               {
0047E0  FA002A     LNK #0x2A
0047E2  981720     MOV W0, [W14+36]
0047E4  981731     MOV W1, [W14+38]
0047E6  981742     MOV W2, [W14+40]
206:               uint16_t usCode;
207:               UBaseType_t i;
208:               
209:               const StackType_t xInitialStack[] =
0047E8  4700E4     ADD W14, #0x4, W1
0047EA  290962     MOV #0x9096, W2
0047EC  09000F     REPEAT #0xF
0047EE  7818B2     MOV [W2++], [W1++]
210:               {
211:               	0x1111,	/* W1 */
212:               	0x2222, /* W2 */
213:               	0x3333, /* W3 */
214:               	0x4444, /* W4 */
215:               	0x5555, /* W5 */
216:               	0x6666, /* W6 */
217:               	0x7777, /* W7 */
218:               	0x8888, /* W8 */
219:               	0x9999, /* W9 */
220:               	0xaaaa, /* W10 */
221:               	0xbbbb, /* W11 */
222:               	0xcccc, /* W12 */
223:               	0xdddd, /* W13 */
224:               	0xeeee, /* W14 */
225:               	0xcdce, /* RCOUNT */
226:               	0xabac, /* TBLPAG */
227:               
228:               	/* dsPIC specific registers. */
229:               	#ifdef MPLAB_DSPIC_PORT
230:               		0x0202, /* ACCAL */
231:               		0x0303, /* ACCAH */
232:               		0x0404, /* ACCAU */
233:               		0x0505, /* ACCBL */
234:               		0x0606, /* ACCBH */
235:               		0x0707, /* ACCBU */
236:               		0x0808, /* DCOUNT */
237:               		0x090a, /* DOSTARTL */
238:               		0x1010, /* DOSTARTH */
239:               		0x1110, /* DOENDL */
240:               		0x1212, /* DOENDH */
241:               	#endif
242:               };
243:               
244:               	/* Setup the stack as if a yield had occurred.
245:               
246:               	Save the low bytes of the program counter. */
247:               	usCode = ( uint16_t ) pxCode;
0047F0  9010BE     MOV [W14+38], W1
0047F2  980711     MOV W1, [W14+2]
248:               	*pxTopOfStack = ( StackType_t ) usCode;
0047F4  90102E     MOV [W14+36], W0
0047F6  90011E     MOV [W14+2], W2
0047F8  780802     MOV W2, [W0]
249:               	pxTopOfStack++;
0047FA  90102E     MOV [W14+36], W0
0047FC  E88000     INC2 W0, W0
0047FE  981720     MOV W0, [W14+36]
250:               
251:               	/* Save the high byte of the program counter.  This will always be zero
252:               	here as it is passed in a 16bit pointer.  If the address is greater than
253:               	16 bits then the pointer will point to a jump table. */
254:               	*pxTopOfStack = ( StackType_t ) 0;
004800  90102E     MOV [W14+36], W0
004802  EB0080     CLR W1
004804  780801     MOV W1, [W0]
255:               	pxTopOfStack++;
004806  90102E     MOV [W14+36], W0
004808  E88000     INC2 W0, W0
00480A  981720     MOV W0, [W14+36]
256:               
257:               	/* Status register with interrupts enabled. */
258:               	*pxTopOfStack = portINITIAL_SR;
00480C  90102E     MOV [W14+36], W0
00480E  EB0080     CLR W1
004810  780801     MOV W1, [W0]
259:               	pxTopOfStack++;
004812  90102E     MOV [W14+36], W0
004814  E88000     INC2 W0, W0
004816  981720     MOV W0, [W14+36]
260:               
261:               	/* Parameters are passed in W0. */
262:               	*pxTopOfStack = ( StackType_t ) pvParameters;
004818  9010CE     MOV [W14+40], W1
00481A  90102E     MOV [W14+36], W0
00481C  780801     MOV W1, [W0]
263:               	pxTopOfStack++;
00481E  90102E     MOV [W14+36], W0
004820  E88000     INC2 W0, W0
004822  981720     MOV W0, [W14+36]
264:               
265:               	for( i = 0; i < ( sizeof( xInitialStack ) / sizeof( StackType_t ) ); i++ )
004824  EB0000     CLR W0
004826  780F00     MOV W0, [W14]
004828  37000A     BRA .L2
00483C  E80F1E     INC [W14], [W14]
00483E  78001E     MOV [W14], W0
004840  500FEF     SUB W0, #0xF, [W15]
004842  36FFF3     BRA LEU, .L3
266:               	{
267:               		*pxTopOfStack = xInitialStack[ i ];
00482A  78001E     MOV [W14], W0
00482C  400000     ADD W0, W0, W0
00482E  470000     ADD W14, W0, W0
004830  9000A0     MOV [W0+4], W1
004832  90102E     MOV [W14+36], W0
004834  780801     MOV W1, [W0]
268:               		pxTopOfStack++;
004836  90102E     MOV [W14+36], W0
004838  E88000     INC2 W0, W0
00483A  981720     MOV W0, [W14+36]
269:               	}
270:               
271:               	*pxTopOfStack = CORCON;
004844  800221     MOV CORCON, W1
004846  90102E     MOV [W14+36], W0
004848  780801     MOV W1, [W0]
272:               	pxTopOfStack++;
00484A  90102E     MOV [W14+36], W0
00484C  E88000     INC2 W0, W0
00484E  981720     MOV W0, [W14+36]
273:               
274:               	#if defined(__HAS_EDS__)
275:               		*pxTopOfStack = DSRPAG;
004850  800191     MOV DSRPAG, W1
004852  90102E     MOV [W14+36], W0
004854  780801     MOV W1, [W0]
276:               		pxTopOfStack++;
004856  90102E     MOV [W14+36], W0
004858  E88000     INC2 W0, W0
00485A  981720     MOV W0, [W14+36]
277:               		*pxTopOfStack = DSWPAG;
00485C  8001A1     MOV DSWPAG, W1
00485E  90102E     MOV [W14+36], W0
004860  780801     MOV W1, [W0]
278:               		pxTopOfStack++;
004862  90102E     MOV [W14+36], W0
004864  E88000     INC2 W0, W0
004866  981720     MOV W0, [W14+36]
279:               	#else /* __HAS_EDS__ */
280:               		*pxTopOfStack = PSVPAG;
281:               		pxTopOfStack++;
282:               	#endif /* __HAS_EDS__ */
283:               
284:               	/* Finally the critical nesting depth. */
285:               	*pxTopOfStack = 0x00;
004868  90102E     MOV [W14+36], W0
00486A  EB0080     CLR W1
00486C  780801     MOV W1, [W0]
286:               	pxTopOfStack++;
00486E  90102E     MOV [W14+36], W0
004870  E88000     INC2 W0, W0
004872  981720     MOV W0, [W14+36]
287:               
288:               	return pxTopOfStack;
004874  90102E     MOV [W14+36], W0
289:               }
004876  FA8000     ULNK
004878  060000     RETURN
290:               /*-----------------------------------------------------------*/
291:               
292:               BaseType_t xPortStartScheduler( void )
293:               {
00487A  FA0000     LNK #0x0
294:               	/* Setup a timer for the tick ISR. */
295:               	vApplicationSetupTickTimerInterrupt();
00487C  0248B2     CALL vApplicationSetupTickTimerInterrupt
00487E  000000     NOP
296:               
297:               	/* Restore the context of the first task to run. */
298:               	portRESTORE_CONTEXT();
004880  804280     MOV pxCurrentTCB, W0
004882  780790     MOV [W0], W15
004884  78004F     MOV [--W15], W0
004886  884570     MOV W0, 0x8AE
004888  F90034     POP DSWPAG
00488A  F90032     POP DSRPAG
00488C  F90044     POP CORCON
00488E  F90054     POP TBLPAG
004890  F90036     POP RCOUNT
004892  78074F     MOV [--W15], W14
004894  BE064F     MOV.D [--W15], W12
004896  BE054F     MOV.D [--W15], W10
004898  BE044F     MOV.D [--W15], W8
00489A  BE034F     MOV.D [--W15], W6
00489C  BE024F     MOV.D [--W15], W4
00489E  BE014F     MOV.D [--W15], W2
0048A0  BE004F     MOV.D [--W15], W0
0048A2  F90042     POP SR
299:               
300:               	/* Simulate the end of the yield function. */
301:               	asm volatile ( "return" );
0048A4  060000     RETURN
302:               
303:               	/* Should not reach here. */
304:               	return pdTRUE;
0048A6  200010     MOV #0x1, W0
305:               }
0048A8  FA8000     ULNK
0048AA  060000     RETURN
306:               /*-----------------------------------------------------------*/
307:               
308:               void vPortEndScheduler( void )
309:               {
0048AC  FA0000     LNK #0x0
310:               	/* Not implemented in ports where there is nothing to return to.
311:               	Artificially force an assert. */
312:               	configASSERT( uxCriticalNesting == 1000UL );
313:               }
0048AE  FA8000     ULNK
0048B0  060000     RETURN
314:               /*-----------------------------------------------------------*/
315:               
316:               /*
317:                * Setup a timer for a regular tick.
318:                */
319:               __attribute__(( weak )) void vApplicationSetupTickTimerInterrupt( void )
320:               {
0048B2  FA0004     LNK #0x4
321:               const uint32_t ulCompareMatch = ( ( configCPU_CLOCK_HZ / portTIMER_PRESCALE ) / configTICK_RATE_HZ ) - 1;
0048B4  201F30     MOV #0x1F3, W0
0048B6  200001     MOV #0x0, W1
0048B8  BE8F00     MOV.D W0, [W14]
322:               
323:               	/* Prescale of 8. */
324:               	T1CON = 0;
0048BA  EF2104     CLR T1CON
325:               	TMR1 = 0;
0048BC  EF2100     CLR TMR1
326:               
327:               	PR1 = ( uint16_t ) ulCompareMatch;
0048BE  78001E     MOV [W14], W0
0048C0  880810     MOV W0, PR1
328:               
329:               	/* Setup timer 1 interrupt priority. */
330:               	IPC0bits.T1IP = configKERNEL_INTERRUPT_PRIORITY;
0048C2  800521     MOV IPC0, W1
0048C4  28FFF0     MOV #0x8FFF, W0
0048C6  608000     AND W1, W0, W0
0048C8  A0C000     BSET W0, #12
0048CA  880520     MOV W0, IPC0
331:               
332:               	/* Clear the interrupt as a starting condition. */
333:               	IFS0bits.T1IF = 0;
0048CC  A96084     BCLR IFS0, #3
334:               
335:               	/* Enable the interrupt. */
336:               	IEC0bits.T1IE = 1;
0048CE  A86094     BSET IEC0, #3
337:               
338:               	/* Setup the prescale value. */
339:               	T1CONbits.TCKPS0 = 1;
0048D0  A88104     BSET T1CON, #4
340:               	T1CONbits.TCKPS1 = 0;
0048D2  A9A104     BCLR T1CON, #5
341:               
342:               	/* Start the timer. */
343:               	T1CONbits.TON = 1;
0048D4  A8E105     BSET 0x105, #7
344:               }
0048D6  FA8000     ULNK
0048D8  060000     RETURN
345:               /*-----------------------------------------------------------*/
346:               
347:               void vPortEnterCritical( void )
348:               {
0048DA  FA0000     LNK #0x0
349:               	portDISABLE_INTERRUPTS();
0048DC  800211     MOV SR, W1
0048DE  2FF1F0     MOV #0xFF1F, W0
0048E0  608000     AND W1, W0, W0
0048E2  A05000     BSET W0, #5
0048E4  880210     MOV W0, SR
0048E6  000000     NOP
0048E8  000000     NOP
350:               	uxCriticalNesting++;
0048EA  804570     MOV 0x8AE, W0
0048EC  E80000     INC W0, W0
0048EE  884570     MOV W0, 0x8AE
351:               }
0048F0  FA8000     ULNK
0048F2  060000     RETURN
352:               /*-----------------------------------------------------------*/
353:               
354:               void vPortExitCritical( void )
355:               {
0048F4  FA0000     LNK #0x0
356:               	configASSERT( uxCriticalNesting );
357:               	uxCriticalNesting--;
0048F6  804570     MOV 0x8AE, W0
0048F8  E90000     DEC W0, W0
0048FA  884570     MOV W0, 0x8AE
358:               	if( uxCriticalNesting == 0 )
0048FC  804570     MOV 0x8AE, W0
0048FE  E00000     CP0 W0
004900  3A0005     BRA NZ, .L8
359:               	{
360:               		portENABLE_INTERRUPTS();
004902  800211     MOV SR, W1
004904  2FF1F0     MOV #0xFF1F, W0
004906  608000     AND W1, W0, W0
004908  880210     MOV W0, SR
00490A  000000     NOP
361:               	}
362:               }
00490C  FA8000     ULNK
00490E  060000     RETURN
363:               /*-----------------------------------------------------------*/
364:               
365:               void __attribute__((__interrupt__, auto_psv)) configTICK_INTERRUPT_HANDLER( void )
366:               {
000502  F80036     PUSH RCOUNT
000504  BE9F80     MOV.D W0, [W15++]
000506  BE9F82     MOV.D W2, [W15++]
000508  BE9F84     MOV.D W4, [W15++]
00050A  BE9F86     MOV.D W6, [W15++]
00050C  F80032     PUSH DSRPAG
00050E  F80034     PUSH DSWPAG
000510  200010     MOV #0x1, W0
000512  8801A0     MOV W0, DSWPAG
000514  202000     MOV #0x200, W0
000516  880190     MOV W0, DSRPAG
000518  FA0000     LNK #0x0
367:               	/* Clear the timer interrupt. */
368:               	IFS0bits.T1IF = 0;
00051A  A96084     BCLR IFS0, #3
369:               
370:               	if( xTaskIncrementTick() != pdFALSE )
00051C  021764     CALL xTaskIncrementTick
00051E  000000     NOP
000520  E00000     CP0 W0
000522  320003     BRA Z, .L10
371:               	{
372:               		portYIELD();
000524  0250DC     CALL .Letext0, .LFE1, _vPortYield
000526  000000     NOP
000528  000000     NOP
373:               	}
374:               }
00052A  FA8000     ULNK
00052C  F90034     POP DSWPAG
00052E  F90032     POP DSRPAG
000530  BE034F     MOV.D [--W15], W6
000532  BE024F     MOV.D [--W15], W4
000534  BE014F     MOV.D [--W15], W2
000536  BE004F     MOV.D [--W15], W0
000538  F90036     POP RCOUNT
00053A  064000     RETFIE
375:               
---  /home/zxc/Documents/WCGRTOS/Source/list.c  ---------------------------------------------------------
1:                 /*
2:                     FreeRTOS V9.0.0 - Copyright (C) 2016 Real Time Engineers Ltd.
3:                     All rights reserved
4:                 
5:                     VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
6:                 
7:                     This file is part of the FreeRTOS distribution.
8:                 
9:                     FreeRTOS is free software; you can redistribute it and/or modify it under
10:                    the terms of the GNU General Public License (version 2) as published by the
11:                    Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
12:                
13:                    ***************************************************************************
14:                    >>!   NOTE: The modification to the GPL is included to allow you to     !<<
15:                    >>!   distribute a combined work that includes FreeRTOS without being   !<<
16:                    >>!   obliged to provide the source code for proprietary components     !<<
17:                    >>!   outside of the FreeRTOS kernel.                                   !<<
18:                    ***************************************************************************
19:                
20:                    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
21:                    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
22:                    FOR A PARTICULAR PURPOSE.  Full license text is available on the following
23:                    link: http://www.freertos.org/a00114.html
24:                
25:                    ***************************************************************************
26:                     *                                                                       *
27:                     *    FreeRTOS provides completely free yet professionally developed,    *
28:                     *    robust, strictly quality controlled, supported, and cross          *
29:                     *    platform software that is more than just the market leader, it     *
30:                     *    is the industry's de facto standard.                               *
31:                     *                                                                       *
32:                     *    Help yourself get started quickly while simultaneously helping     *
33:                     *    to support the FreeRTOS project by purchasing a FreeRTOS           *
34:                     *    tutorial book, reference manual, or both:                          *
35:                     *    http://www.FreeRTOS.org/Documentation                              *
36:                     *                                                                       *
37:                    ***************************************************************************
38:                
39:                    http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
40:                    the FAQ page "My application does not run, what could be wrong?".  Have you
41:                    defined configASSERT()?
42:                
43:                    http://www.FreeRTOS.org/support - In return for receiving this top quality
44:                    embedded software for free we request you assist our global community by
45:                    participating in the support forum.
46:                
47:                    http://www.FreeRTOS.org/training - Investing in training allows your team to
48:                    be as productive as possible as early as possible.  Now you can receive
49:                    FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
50:                    Ltd, and the world's leading authority on the world's leading RTOS.
51:                
52:                    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
53:                    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
54:                    compatible FAT file system, and our tiny thread aware UDP/IP stack.
55:                
56:                    http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
57:                    Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
58:                
59:                    http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
60:                    Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
61:                    licenses offer ticketed support, indemnification and commercial middleware.
62:                
63:                    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
64:                    engineered and independently SIL3 certified version for use in safety and
65:                    mission critical applications that require provable dependability.
66:                
67:                    1 tab == 4 spaces!
68:                */
69:                
70:                
71:                #include <stdlib.h>
72:                #include "FreeRTOS.h"
73:                #include "list.h"
74:                
75:                /*-----------------------------------------------------------
76:                 * PUBLIC LIST API documented in list.h
77:                 *----------------------------------------------------------*/
78:                
79:                void vListInitialise( List_t * const pxList )
80:                {
004910  FA0002     LNK #0x2
004912  780F00     MOV W0, [W14]
81:                	/* The list structure contains a list item which is used to mark the
82:                	end of the list.  To initialise the list the list end is inserted
83:                	as the only list entry. */
84:                	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
004914  78009E     MOV [W14], W1
004916  408064     ADD W1, #0x4, W0
004918  780080     MOV W0, W1
00491A  78001E     MOV [W14], W0
00491C  980011     MOV W1, [W0+2]
85:                
86:                	/* The list end value is the highest possible value in the list to
87:                	ensure it remains at the end of the list. */
88:                	pxList->xListEnd.xItemValue = portMAX_DELAY;
00491E  78001E     MOV [W14], W0
004920  EB8080     SETM W1
004922  980021     MOV W1, [W0+4]
89:                
90:                	/* The list end next and previous pointers point to itself so we know
91:                	when the list is empty. */
92:                	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
004924  78009E     MOV [W14], W1
004926  408064     ADD W1, #0x4, W0
004928  780080     MOV W0, W1
00492A  78001E     MOV [W14], W0
00492C  980031     MOV W1, [W0+6]
93:                	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
00492E  78009E     MOV [W14], W1
004930  408064     ADD W1, #0x4, W0
004932  780080     MOV W0, W1
004934  78001E     MOV [W14], W0
004936  980041     MOV W1, [W0+8]
94:                
95:                	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
004938  78001E     MOV [W14], W0
00493A  EB0080     CLR W1
00493C  780801     MOV W1, [W0]
96:                
97:                	/* Write known values into the list if
98:                	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
99:                	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
100:               	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
101:               }
00493E  FA8000     ULNK
004940  060000     RETURN
102:               /*-----------------------------------------------------------*/
103:               
104:               void vListInitialiseItem( ListItem_t * const pxItem )
105:               {
004942  FA0002     LNK #0x2
004944  780F00     MOV W0, [W14]
106:               	/* Make sure the list item is not recorded as being on a list. */
107:               	pxItem->pvContainer = NULL;
004946  78001E     MOV [W14], W0
004948  EB0080     CLR W1
00494A  980041     MOV W1, [W0+8]
108:               
109:               	/* Write known values into the list item if
110:               	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
111:               	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
112:               	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
113:               }
00494C  FA8000     ULNK
00494E  060000     RETURN
114:               /*-----------------------------------------------------------*/
115:               
116:               void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
117:               {
004950  FA0006     LNK #0x6
004952  980710     MOV W0, [W14+2]
004954  980721     MOV W1, [W14+4]
118:               ListItem_t * const pxIndex = pxList->pxIndex;
004956  90001E     MOV [W14+2], W0
004958  900090     MOV [W0+2], W1
00495A  780F01     MOV W1, [W14]
119:               
120:               	/* Only effective when configASSERT() is also defined, these tests may catch
121:               	the list data structures being overwritten in memory.  They will not catch
122:               	data errors caused by incorrect configuration or use of FreeRTOS. */
123:               	listTEST_LIST_INTEGRITY( pxList );
124:               	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );
125:               
126:               	/* Insert a new list item into pxList, but rather than sort the list,
127:               	makes the new list item the last item to be removed by a call to
128:               	listGET_OWNER_OF_NEXT_ENTRY(). */
129:               	pxNewListItem->pxNext = pxIndex;
00495C  90002E     MOV [W14+4], W0
00495E  78009E     MOV [W14], W1
004960  980011     MOV W1, [W0+2]
130:               	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
004962  78001E     MOV [W14], W0
004964  9000A0     MOV [W0+4], W1
004966  90002E     MOV [W14+4], W0
004968  980021     MOV W1, [W0+4]
131:               
132:               	/* Only used during decision coverage testing. */
133:               	mtCOVERAGE_TEST_DELAY();
134:               
135:               	pxIndex->pxPrevious->pxNext = pxNewListItem;
00496A  78001E     MOV [W14], W0
00496C  900020     MOV [W0+4], W0
00496E  9000AE     MOV [W14+4], W1
004970  980011     MOV W1, [W0+2]
136:               	pxIndex->pxPrevious = pxNewListItem;
004972  78001E     MOV [W14], W0
004974  9000AE     MOV [W14+4], W1
004976  980021     MOV W1, [W0+4]
137:               
138:               	/* Remember which list the item is in. */
139:               	pxNewListItem->pvContainer = ( void * ) pxList;
004978  90002E     MOV [W14+4], W0
00497A  90009E     MOV [W14+2], W1
00497C  980041     MOV W1, [W0+8]
140:               
141:               	( pxList->uxNumberOfItems )++;
00497E  90001E     MOV [W14+2], W0
004980  780010     MOV [W0], W0
004982  E80080     INC W0, W1
004984  90001E     MOV [W14+2], W0
004986  780801     MOV W1, [W0]
142:               }
004988  FA8000     ULNK
00498A  060000     RETURN
143:               /*-----------------------------------------------------------*/
144:               
145:               void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
146:               {
00498C  FA0008     LNK #0x8
00498E  980720     MOV W0, [W14+4]
004990  980731     MOV W1, [W14+6]
147:               ListItem_t *pxIterator;
148:               const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
004992  90003E     MOV [W14+6], W0
004994  780090     MOV [W0], W1
004996  980711     MOV W1, [W14+2]
149:               
150:               	/* Only effective when configASSERT() is also defined, these tests may catch
151:               	the list data structures being overwritten in memory.  They will not catch
152:               	data errors caused by incorrect configuration or use of FreeRTOS. */
153:               	listTEST_LIST_INTEGRITY( pxList );
154:               	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );
155:               
156:               	/* Insert the new list item into the list, sorted in xItemValue order.
157:               
158:               	If the list already contains a list item with the same item value then the
159:               	new list item should be placed after it.  This ensures that TCB's which are
160:               	stored in ready lists (all of which have the same xItemValue value) get a
161:               	share of the CPU.  However, if the xItemValue is the same as the back marker
162:               	the iteration loop below will not end.  Therefore the value is checked
163:               	first, and the algorithm slightly modified if necessary. */
164:               	if( xValueOfInsertion == portMAX_DELAY )
004998  90001E     MOV [W14+2], W0
00499A  400FE1     ADD W0, #0x1, [W15]
00499C  3A0004     BRA NZ, .L5
165:               	{
166:               		pxIterator = pxList->xListEnd.pxPrevious;
00499E  90002E     MOV [W14+4], W0
0049A0  9000C0     MOV [W0+8], W1
0049A2  780F01     MOV W1, [W14]
0049A4  37000D     BRA .L6
167:               	}
168:               	else
169:               	{
170:               		/* *** NOTE ***********************************************************
171:               		If you find your application is crashing here then likely causes are
172:               		listed below.  In addition see http://www.freertos.org/FAQHelp.html for
173:               		more tips, and ensure configASSERT() is defined!
174:               		http://www.freertos.org/a00110.html#configASSERT
175:               
176:               			1) Stack overflow -
177:               			   see http://www.freertos.org/Stacks-and-stack-overflow-checking.html
178:               			2) Incorrect interrupt priority assignment, especially on Cortex-M
179:               			   parts where numerically high priority values denote low actual
180:               			   interrupt priorities, which can seem counter intuitive.  See
181:               			   http://www.freertos.org/RTOS-Cortex-M3-M4.html and the definition
182:               			   of configMAX_SYSCALL_INTERRUPT_PRIORITY on
183:               			   http://www.freertos.org/a00110.html
184:               			3) Calling an API function from within a critical section or when
185:               			   the scheduler is suspended, or calling an API function that does
186:               			   not end in "FromISR" from an interrupt.
187:               			4) Using a queue or semaphore before it has been initialised or
188:               			   before the scheduler has been started (are interrupts firing
189:               			   before vTaskStartScheduler() has been called?).
190:               		**********************************************************************/
191:               
192:               		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
0049A6  90002E     MOV [W14+4], W0
0049A8  400064     ADD W0, #0x4, W0
0049AA  780F00     MOV W0, [W14]
0049AC  370003     BRA .L7
0049AE  78001E     MOV [W14], W0
0049B0  900090     MOV [W0+2], W1
0049B2  780F01     MOV W1, [W14]
0049B4  78001E     MOV [W14], W0
0049B6  900010     MOV [W0+2], W0
0049B8  780090     MOV [W0], W1
0049BA  90001E     MOV [W14+2], W0
0049BC  508F80     SUB W1, W0, [W15]
0049BE  36FFF7     BRA LEU, .L8
193:               		{
194:               			/* There is nothing to do here, just iterating to the wanted
195:               			insertion position. */
196:               		}
197:               	}
198:               
199:               	pxNewListItem->pxNext = pxIterator->pxNext;
0049C0  78001E     MOV [W14], W0
0049C2  900090     MOV [W0+2], W1
0049C4  90003E     MOV [W14+6], W0
0049C6  980011     MOV W1, [W0+2]
200:               	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
0049C8  90003E     MOV [W14+6], W0
0049CA  900010     MOV [W0+2], W0
0049CC  9000BE     MOV [W14+6], W1
0049CE  980021     MOV W1, [W0+4]
201:               	pxNewListItem->pxPrevious = pxIterator;
0049D0  90003E     MOV [W14+6], W0
0049D2  78009E     MOV [W14], W1
0049D4  980021     MOV W1, [W0+4]
202:               	pxIterator->pxNext = pxNewListItem;
0049D6  78001E     MOV [W14], W0
0049D8  9000BE     MOV [W14+6], W1
0049DA  980011     MOV W1, [W0+2]
203:               
204:               	/* Remember which list the item is in.  This allows fast removal of the
205:               	item later. */
206:               	pxNewListItem->pvContainer = ( void * ) pxList;
0049DC  90003E     MOV [W14+6], W0
0049DE  9000AE     MOV [W14+4], W1
0049E0  980041     MOV W1, [W0+8]
207:               
208:               	( pxList->uxNumberOfItems )++;
0049E2  90002E     MOV [W14+4], W0
0049E4  780010     MOV [W0], W0
0049E6  E80080     INC W0, W1
0049E8  90002E     MOV [W14+4], W0
0049EA  780801     MOV W1, [W0]
209:               }
0049EC  FA8000     ULNK
0049EE  060000     RETURN
210:               /*-----------------------------------------------------------*/
211:               
212:               UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
213:               {
0049F0  FA0004     LNK #0x4
0049F2  980710     MOV W0, [W14+2]
214:               /* The list item knows which list it is in.  Obtain the list from the list
215:               item. */
216:               List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
0049F4  90001E     MOV [W14+2], W0
0049F6  900040     MOV [W0+8], W0
0049F8  780F00     MOV W0, [W14]
217:               
218:               	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
0049FA  90001E     MOV [W14+2], W0
0049FC  900010     MOV [W0+2], W0
0049FE  90009E     MOV [W14+2], W1
004A00  9000A1     MOV [W1+4], W1
004A02  980021     MOV W1, [W0+4]
219:               	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
004A04  90001E     MOV [W14+2], W0
004A06  900020     MOV [W0+4], W0
004A08  90009E     MOV [W14+2], W1
004A0A  900091     MOV [W1+2], W1
004A0C  980011     MOV W1, [W0+2]
220:               
221:               	/* Only used during decision coverage testing. */
222:               	mtCOVERAGE_TEST_DELAY();
223:               
224:               	/* Make sure the index is left pointing to a valid item. */
225:               	if( pxList->pxIndex == pxItemToRemove )
004A0E  78001E     MOV [W14], W0
004A10  900090     MOV [W0+2], W1
004A12  90001E     MOV [W14+2], W0
004A14  508F80     SUB W1, W0, [W15]
004A16  3A0004     BRA NZ, .L10
226:               	{
227:               		pxList->pxIndex = pxItemToRemove->pxPrevious;
004A18  90001E     MOV [W14+2], W0
004A1A  9000A0     MOV [W0+4], W1
004A1C  78001E     MOV [W14], W0
004A1E  980011     MOV W1, [W0+2]
228:               	}
229:               	else
230:               	{
231:               		mtCOVERAGE_TEST_MARKER();
232:               	}
233:               
234:               	pxItemToRemove->pvContainer = NULL;
004A20  90001E     MOV [W14+2], W0
004A22  EB0080     CLR W1
004A24  980041     MOV W1, [W0+8]
235:               	( pxList->uxNumberOfItems )--;
004A26  78001E     MOV [W14], W0
004A28  780010     MOV [W0], W0
004A2A  E90080     DEC W0, W1
004A2C  78001E     MOV [W14], W0
004A2E  780801     MOV W1, [W0]
236:               
237:               	return pxList->uxNumberOfItems;
004A30  78001E     MOV [W14], W0
004A32  780010     MOV [W0], W0
238:               }
004A34  FA8000     ULNK
004A36  060000     RETURN
239:               /*-----------------------------------------------------------*/
240:               
---  /home/zxc/Documents/WCGRTOS/Source/event_groups.c  -------------------------------------------------
1:                 /*
2:                     FreeRTOS V9.0.0 - Copyright (C) 2016 Real Time Engineers Ltd.
3:                     All rights reserved
4:                 
5:                     VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
6:                 
7:                     This file is part of the FreeRTOS distribution.
8:                 
9:                     FreeRTOS is free software; you can redistribute it and/or modify it under
10:                    the terms of the GNU General Public License (version 2) as published by the
11:                    Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
12:                
13:                    ***************************************************************************
14:                    >>!   NOTE: The modification to the GPL is included to allow you to     !<<
15:                    >>!   distribute a combined work that includes FreeRTOS without being   !<<
16:                    >>!   obliged to provide the source code for proprietary components     !<<
17:                    >>!   outside of the FreeRTOS kernel.                                   !<<
18:                    ***************************************************************************
19:                
20:                    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
21:                    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
22:                    FOR A PARTICULAR PURPOSE.  Full license text is available on the following
23:                    link: http://www.freertos.org/a00114.html
24:                
25:                    ***************************************************************************
26:                     *                                                                       *
27:                     *    FreeRTOS provides completely free yet professionally developed,    *
28:                     *    robust, strictly quality controlled, supported, and cross          *
29:                     *    platform software that is more than just the market leader, it     *
30:                     *    is the industry's de facto standard.                               *
31:                     *                                                                       *
32:                     *    Help yourself get started quickly while simultaneously helping     *
33:                     *    to support the FreeRTOS project by purchasing a FreeRTOS           *
34:                     *    tutorial book, reference manual, or both:                          *
35:                     *    http://www.FreeRTOS.org/Documentation                              *
36:                     *                                                                       *
37:                    ***************************************************************************
38:                
39:                    http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
40:                    the FAQ page "My application does not run, what could be wrong?".  Have you
41:                    defined configASSERT()?
42:                
43:                    http://www.FreeRTOS.org/support - In return for receiving this top quality
44:                    embedded software for free we request you assist our global community by
45:                    participating in the support forum.
46:                
47:                    http://www.FreeRTOS.org/training - Investing in training allows your team to
48:                    be as productive as possible as early as possible.  Now you can receive
49:                    FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
50:                    Ltd, and the world's leading authority on the world's leading RTOS.
51:                
52:                    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
53:                    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
54:                    compatible FAT file system, and our tiny thread aware UDP/IP stack.
55:                
56:                    http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
57:                    Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
58:                
59:                    http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
60:                    Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
61:                    licenses offer ticketed support, indemnification and commercial middleware.
62:                
63:                    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
64:                    engineered and independently SIL3 certified version for use in safety and
65:                    mission critical applications that require provable dependability.
66:                
67:                    1 tab == 4 spaces!
68:                */
69:                
70:                /* Standard includes. */
71:                #include <stdlib.h>
72:                
73:                /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
74:                all the API functions to use the MPU wrappers.  That should only be done when
75:                task.h is included from an application file. */
76:                #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
77:                
78:                /* FreeRTOS includes. */
79:                #include "FreeRTOS.h"
80:                #include "task.h"
81:                #include "timers.h"
82:                #include "event_groups.h"
83:                
84:                /* Lint e961 and e750 are suppressed as a MISRA exception justified because the
85:                MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined for the
86:                header files above, but not in this file, in order to generate the correct
87:                privileged Vs unprivileged linkage and placement. */
88:                #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750. */
89:                
90:                /* The following bit fields convey control information in a task's event list
91:                item value.  It is important they don't clash with the
92:                taskEVENT_LIST_ITEM_VALUE_IN_USE definition. */
93:                #if configUSE_16_BIT_TICKS == 1
94:                	#define eventCLEAR_EVENTS_ON_EXIT_BIT	0x0100U
95:                	#define eventUNBLOCKED_DUE_TO_BIT_SET	0x0200U
96:                	#define eventWAIT_FOR_ALL_BITS			0x0400U
97:                	#define eventEVENT_BITS_CONTROL_BYTES	0xff00U
98:                #else
99:                	#define eventCLEAR_EVENTS_ON_EXIT_BIT	0x01000000UL
100:               	#define eventUNBLOCKED_DUE_TO_BIT_SET	0x02000000UL
101:               	#define eventWAIT_FOR_ALL_BITS			0x04000000UL
102:               	#define eventEVENT_BITS_CONTROL_BYTES	0xff000000UL
103:               #endif
104:               
105:               typedef struct xEventGroupDefinition
106:               {
107:               	EventBits_t uxEventBits;
108:               	List_t xTasksWaitingForBits;		/*< List of tasks waiting for a bit to be set. */
109:               
110:               	#if( configUSE_TRACE_FACILITY == 1 )
111:               		UBaseType_t uxEventGroupNumber;
112:               	#endif
113:               
114:               	#if( ( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
115:               		uint8_t ucStaticallyAllocated; /*< Set to pdTRUE if the event group is statically allocated to ensure no attempt is made to free the memory. */
116:               	#endif
117:               } EventGroup_t;
118:               
119:               /*-----------------------------------------------------------*/
120:               
121:               /*
122:                * Test the bits set in uxCurrentEventBits to see if the wait condition is met.
123:                * The wait condition is defined by xWaitForAllBits.  If xWaitForAllBits is
124:                * pdTRUE then the wait condition is met if all the bits set in uxBitsToWaitFor
125:                * are also set in uxCurrentEventBits.  If xWaitForAllBits is pdFALSE then the
126:                * wait condition is met if any of the bits set in uxBitsToWait for are also set
127:                * in uxCurrentEventBits.
128:                */
129:               static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits ) PRIVILEGED_FUNCTION;
130:               
131:               /*-----------------------------------------------------------*/
132:               
133:               #if( configSUPPORT_STATIC_ALLOCATION == 1 )
134:               
135:               	EventGroupHandle_t xEventGroupCreateStatic( StaticEventGroup_t *pxEventGroupBuffer )
136:               	{
137:               	EventGroup_t *pxEventBits;
138:               
139:               		/* A StaticEventGroup_t object must be provided. */
140:               		configASSERT( pxEventGroupBuffer );
141:               
142:               		/* The user has provided a statically allocated event group - use it. */
143:               		pxEventBits = ( EventGroup_t * ) pxEventGroupBuffer; /*lint !e740 EventGroup_t and StaticEventGroup_t are guaranteed to have the same size and alignment requirement - checked by configASSERT(). */
144:               
145:               		if( pxEventBits != NULL )
146:               		{
147:               			pxEventBits->uxEventBits = 0;
148:               			vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
149:               
150:               			#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
151:               			{
152:               				/* Both static and dynamic allocation can be used, so note that
153:               				this event group was created statically in case the event group
154:               				is later deleted. */
155:               				pxEventBits->ucStaticallyAllocated = pdTRUE;
156:               			}
157:               			#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
158:               
159:               			traceEVENT_GROUP_CREATE( pxEventBits );
160:               		}
161:               		else
162:               		{
163:               			traceEVENT_GROUP_CREATE_FAILED();
164:               		}
165:               
166:               		return ( EventGroupHandle_t ) pxEventBits;
167:               	}
168:               
169:               #endif /* configSUPPORT_STATIC_ALLOCATION */
170:               /*-----------------------------------------------------------*/
171:               
172:               #if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
173:               
174:               	EventGroupHandle_t xEventGroupCreate( void )
175:               	{
0033E8  FA0002     LNK #0x2
176:               	EventGroup_t *pxEventBits;
177:               
178:               		/* Allocate the event group. */
179:               		pxEventBits = ( EventGroup_t * ) pvPortMalloc( sizeof( EventGroup_t ) );
0033EA  2000C0     MOV #0xC, W0
0033EC  023C80     CALL pvPortMalloc
0033EE  000000     NOP
0033F0  780F00     MOV W0, [W14]
180:               
181:               		if( pxEventBits != NULL )
0033F2  78001E     MOV [W14], W0
0033F4  E00000     CP0 W0
0033F6  320006     BRA Z, .L2
182:               		{
183:               			pxEventBits->uxEventBits = 0;
0033F8  78001E     MOV [W14], W0
0033FA  EB0080     CLR W1
0033FC  780801     MOV W1, [W0]
184:               			vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
0033FE  E8801E     INC2 [W14], W0
003400  024910     CALL vListInitialise
003402  000000     NOP
185:               
186:               			#if( configSUPPORT_STATIC_ALLOCATION == 1 )
187:               			{
188:               				/* Both static and dynamic allocation can be used, so note this
189:               				event group was allocated statically in case the event group is
190:               				later deleted. */
191:               				pxEventBits->ucStaticallyAllocated = pdFALSE;
192:               			}
193:               			#endif /* configSUPPORT_STATIC_ALLOCATION */
194:               
195:               			traceEVENT_GROUP_CREATE( pxEventBits );
196:               		}
197:               		else
198:               		{
199:               			traceEVENT_GROUP_CREATE_FAILED();
200:               		}
201:               
202:               		return ( EventGroupHandle_t ) pxEventBits;
003404  78001E     MOV [W14], W0
203:               	}
003406  FA8000     ULNK
003408  060000     RETURN
204:               
205:               #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
206:               /*-----------------------------------------------------------*/
207:               
208:               EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, const EventBits_t uxBitsToWaitFor, TickType_t xTicksToWait )
209:               {
00340A  FA0012     LNK #0x12
00340C  980750     MOV W0, [W14+10]
00340E  980761     MOV W1, [W14+12]
003410  980772     MOV W2, [W14+14]
003412  980F03     MOV W3, [W14+16]
210:               EventBits_t uxOriginalBitValue, uxReturn;
211:               EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
003414  9000DE     MOV [W14+10], W1
003416  980711     MOV W1, [W14+2]
212:               BaseType_t xAlreadyYielded;
213:               BaseType_t xTimeoutOccurred = pdFALSE;
003418  EB0000     CLR W0
00341A  980720     MOV W0, [W14+4]
214:               
215:               	configASSERT( ( uxBitsToWaitFor & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
216:               	configASSERT( uxBitsToWaitFor != 0 );
217:               	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
218:               	{
219:               		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
220:               	}
221:               	#endif
222:               
223:               	vTaskSuspendAll();
00341C  02165E     CALL vTaskSuspendAll
00341E  000000     NOP
224:               	{
225:               		uxOriginalBitValue = pxEventBits->uxEventBits;
003420  90001E     MOV [W14+2], W0
003422  780090     MOV [W0], W1
003424  980731     MOV W1, [W14+6]
226:               
227:               		( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
003426  9000EE     MOV [W14+12], W1
003428  90005E     MOV [W14+10], W0
00342A  0700E7     RCALL xEventGroupSetBits
228:               
229:               		if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
00342C  9000BE     MOV [W14+6], W1
00342E  90006E     MOV [W14+12], W0
003430  700081     IOR W0, W1, W1
003432  90007E     MOV [W14+14], W0
003434  608080     AND W1, W0, W1
003436  90007E     MOV [W14+14], W0
003438  508F80     SUB W1, W0, [W15]
00343A  3A000D     BRA NZ, .L4
230:               		{
231:               			/* All the rendezvous bits are now set - no need to block. */
232:               			uxReturn = ( uxOriginalBitValue | uxBitsToSet );
00343C  9000BE     MOV [W14+6], W1
00343E  90006E     MOV [W14+12], W0
003440  708F00     IOR W1, W0, [W14]
233:               
234:               			/* Rendezvous always clear the bits.  They will have been cleared
235:               			already unless this is the only task in the rendezvous. */
236:               			pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
003442  90001E     MOV [W14+2], W0
003444  780090     MOV [W0], W1
003446  90007E     MOV [W14+14], W0
003448  EA8000     COM W0, W0
00344A  608080     AND W1, W0, W1
00344C  90001E     MOV [W14+2], W0
00344E  780801     MOV W1, [W0]
237:               
238:               			xTicksToWait = 0;
003450  EB0000     CLR W0
003452  980F00     MOV W0, [W14+16]
003454  370010     BRA .L5
239:               		}
240:               		else
241:               		{
242:               			if( xTicksToWait != ( TickType_t ) 0 )
003456  90080E     MOV [W14+16], W0
003458  E00000     CP0 W0
00345A  32000B     BRA Z, .L6
243:               			{
244:               				traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor );
245:               
246:               				/* Store the bits that the calling task is waiting for in the
247:               				task's event list item so the kernel knows when a match is
248:               				found.  Then enter the blocked state. */
249:               				vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | eventCLEAR_EVENTS_ON_EXIT_BIT | eventWAIT_FOR_ALL_BITS ), xTicksToWait );
00345C  9000FE     MOV [W14+14], W1
00345E  205000     MOV #0x500, W0
003460  700081     IOR W0, W1, W1
003462  90001E     MOV [W14+2], W0
003464  E88000     INC2 W0, W0
003466  90090E     MOV [W14+16], W2
003468  0218F6     CALL vTaskPlaceOnUnorderedEventList
00346A  000000     NOP
250:               
251:               				/* This assignment is obsolete as uxReturn will get set after
252:               				the task unblocks, but some compilers mistakenly generate a
253:               				warning about uxReturn being returned without being set if the
254:               				assignment is omitted. */
255:               				uxReturn = 0;
00346C  EB0000     CLR W0
00346E  780F00     MOV W0, [W14]
003470  370002     BRA .L5
256:               			}
257:               			else
258:               			{
259:               				/* The rendezvous bits were not set, but no block time was
260:               				specified - just return the current event bit value. */
261:               				uxReturn = pxEventBits->uxEventBits;
003472  90001E     MOV [W14+2], W0
003474  780F10     MOV [W0], [W14]
262:               			}
263:               		}
264:               	}
265:               	xAlreadyYielded = xTaskResumeAll();
003476  02166A     CALL xTaskResumeAll
003478  000000     NOP
00347A  980740     MOV W0, [W14+8]
266:               
267:               	if( xTicksToWait != ( TickType_t ) 0 )
00347C  90080E     MOV [W14+16], W0
00347E  E00000     CP0 W0
003480  320023     BRA Z, .L7
268:               	{
269:               		if( xAlreadyYielded == pdFALSE )
003482  90004E     MOV [W14+8], W0
003484  E00000     CP0 W0
003486  3A0003     BRA NZ, .L8
270:               		{
271:               			portYIELD_WITHIN_API();
003488  0250DC     CALL .Letext0, .LFE1, _vPortYield
00348A  000000     NOP
00348C  000000     NOP
272:               		}
273:               		else
274:               		{
275:               			mtCOVERAGE_TEST_MARKER();
276:               		}
277:               
278:               		/* The task blocked to wait for its required bits to be set - at this
279:               		point either the required bits were set or the block time expired.  If
280:               		the required bits were set they will have been stored in the task's
281:               		event list item, and they should now be retrieved then cleared. */
282:               		uxReturn = uxTaskResetEventItemValue();
00348E  021B70     CALL uxTaskResetEventItemValue
003490  000000     NOP
003492  780F00     MOV W0, [W14]
283:               
284:               		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
003494  202000     MOV #0x200, W0
003496  60001E     AND W0, [W14], W0
003498  E00000     CP0 W0
00349A  3A0014     BRA NZ, .L9
285:               		{
286:               			/* The task timed out, just return the current event bit value. */
287:               			taskENTER_CRITICAL();
00349C  0248DA     CALL vPortEnterCritical
00349E  000000     NOP
288:               			{
289:               				uxReturn = pxEventBits->uxEventBits;
0034A0  90001E     MOV [W14+2], W0
0034A2  780F10     MOV [W0], [W14]
290:               
291:               				/* Although the task got here because it timed out before the
292:               				bits it was waiting for were set, it is possible that since it
293:               				unblocked another task has set the bits.  If this is the case
294:               				then it needs to clear the bits before exiting. */
295:               				if( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor )
0034A4  90007E     MOV [W14+14], W0
0034A6  60009E     AND W0, [W14], W1
0034A8  90007E     MOV [W14+14], W0
0034AA  508F80     SUB W1, W0, [W15]
0034AC  3A0007     BRA NZ, .L10
296:               				{
297:               					pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
0034AE  90001E     MOV [W14+2], W0
0034B0  780090     MOV [W0], W1
0034B2  90007E     MOV [W14+14], W0
0034B4  EA8000     COM W0, W0
0034B6  608080     AND W1, W0, W1
0034B8  90001E     MOV [W14+2], W0
0034BA  780801     MOV W1, [W0]
298:               				}
299:               				else
300:               				{
301:               					mtCOVERAGE_TEST_MARKER();
302:               				}
303:               			}
304:               			taskEXIT_CRITICAL();
0034BC  0248F4     CALL vPortExitCritical
0034BE  000000     NOP
305:               
306:               			xTimeoutOccurred = pdTRUE;
0034C0  200010     MOV #0x1, W0
0034C2  980720     MOV W0, [W14+4]
307:               		}
308:               		else
309:               		{
310:               			/* The task unblocked because the bits were set. */
311:               		}
312:               
313:               		/* Control bits might be set as the task had blocked should not be
314:               		returned. */
315:               		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
0034C4  200FF0     MOV #0xFF, W0
0034C6  600F1E     AND W0, [W14], [W14]
316:               	}
317:               
318:               	traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred );
319:               
320:               	return uxReturn;
0034C8  78001E     MOV [W14], W0
321:               }
0034CA  FA8000     ULNK
0034CC  060000     RETURN
322:               /*-----------------------------------------------------------*/
323:               
324:               EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait )
325:               {
0034CE  FA0018     LNK #0x18
0034D0  980770     MOV W0, [W14+14]
0034D2  980F01     MOV W1, [W14+16]
0034D4  980F12     MOV W2, [W14+18]
0034D6  980F23     MOV W3, [W14+20]
0034D8  980F34     MOV W4, [W14+22]
326:               EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
0034DA  9000FE     MOV [W14+14], W1
0034DC  980721     MOV W1, [W14+4]
327:               EventBits_t uxReturn, uxControlBits = 0;
0034DE  EB0000     CLR W0
0034E0  980710     MOV W0, [W14+2]
328:               BaseType_t xWaitConditionMet, xAlreadyYielded;
329:               BaseType_t xTimeoutOccurred = pdFALSE;
0034E2  EB0000     CLR W0
0034E4  980730     MOV W0, [W14+6]
330:               
331:               	/* Check the user is not attempting to wait on the bits used by the kernel
332:               	itself, and that at least one bit is being requested. */
333:               	configASSERT( xEventGroup );
334:               	configASSERT( ( uxBitsToWaitFor & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
335:               	configASSERT( uxBitsToWaitFor != 0 );
336:               	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
337:               	{
338:               		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
339:               	}
340:               	#endif
341:               
342:               	vTaskSuspendAll();
0034E6  02165E     CALL vTaskSuspendAll
0034E8  000000     NOP
343:               	{
344:               		const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
0034EA  90002E     MOV [W14+4], W0
0034EC  780090     MOV [W0], W1
0034EE  980741     MOV W1, [W14+8]
345:               
346:               		/* Check to see if the wait condition is already met or not. */
347:               		xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );
0034F0  90092E     MOV [W14+20], W2
0034F2  90088E     MOV [W14+16], W1
0034F4  90004E     MOV [W14+8], W0
0034F6  070116     RCALL _prvTestWaitCondition, .LFE8, .LFB9
0034F8  980750     MOV W0, [W14+10]
348:               
349:               		if( xWaitConditionMet != pdFALSE )
0034FA  90005E     MOV [W14+10], W0
0034FC  E00000     CP0 W0
0034FE  32000F     BRA Z, .L12
350:               		{
351:               			/* The wait condition has already been met so there is no need to
352:               			block. */
353:               			uxReturn = uxCurrentEventBits;
003500  9000CE     MOV [W14+8], W1
003502  780F01     MOV W1, [W14]
354:               			xTicksToWait = ( TickType_t ) 0;
003504  EB0000     CLR W0
003506  980F30     MOV W0, [W14+22]
355:               
356:               			/* Clear the wait bits if requested to do so. */
357:               			if( xClearOnExit != pdFALSE )
003508  90081E     MOV [W14+18], W0
00350A  E00000     CP0 W0
00350C  320024     BRA Z, .L13, .LBE2
358:               			{
359:               				pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
00350E  90002E     MOV [W14+4], W0
003510  780090     MOV [W0], W1
003512  90080E     MOV [W14+16], W0
003514  EA8000     COM W0, W0
003516  608080     AND W1, W0, W1
003518  90002E     MOV [W14+4], W0
00351A  780801     MOV W1, [W0]
00351C  37001C     BRA .L13, .LBE2
360:               			}
361:               			else
362:               			{
363:               				mtCOVERAGE_TEST_MARKER();
364:               			}
365:               		}
366:               		else if( xTicksToWait == ( TickType_t ) 0 )
00351E  90083E     MOV [W14+22], W0
003520  E00000     CP0 W0
003522  3A0003     BRA NZ, .L14
367:               		{
368:               			/* The wait condition has not been met, but no block time was
369:               			specified, so just return the current value. */
370:               			uxReturn = uxCurrentEventBits;
003524  9000CE     MOV [W14+8], W1
003526  780F01     MOV W1, [W14]
003528  370016     BRA .L13, .LBE2
371:               		}
372:               		else
373:               		{
374:               			/* The task is going to block to wait for its required bits to be
375:               			set.  uxControlBits are used to remember the specified behaviour of
376:               			this call to xEventGroupWaitBits() - for use when the event bits
377:               			unblock the task. */
378:               			if( xClearOnExit != pdFALSE )
00352A  90081E     MOV [W14+18], W0
00352C  E00000     CP0 W0
00352E  320003     BRA Z, .L15
379:               			{
380:               				uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
003530  90001E     MOV [W14+2], W0
003532  A08000     BSET W0, #8
003534  980710     MOV W0, [W14+2]
381:               			}
382:               			else
383:               			{
384:               				mtCOVERAGE_TEST_MARKER();
385:               			}
386:               
387:               			if( xWaitForAllBits != pdFALSE )
003536  90082E     MOV [W14+20], W0
003538  E00000     CP0 W0
00353A  320003     BRA Z, .L16
388:               			{
389:               				uxControlBits |= eventWAIT_FOR_ALL_BITS;
00353C  90001E     MOV [W14+2], W0
00353E  A0A000     BSET W0, #10
003540  980710     MOV W0, [W14+2]
390:               			}
391:               			else
392:               			{
393:               				mtCOVERAGE_TEST_MARKER();
394:               			}
395:               
396:               			/* Store the bits that the calling task is waiting for in the
397:               			task's event list item so the kernel knows when a match is
398:               			found.  Then enter the blocked state. */
399:               			vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
003542  90088E     MOV [W14+16], W1
003544  90001E     MOV [W14+2], W0
003546  700081     IOR W0, W1, W1
003548  90002E     MOV [W14+4], W0
00354A  E88000     INC2 W0, W0
00354C  90093E     MOV [W14+22], W2
00354E  0218F6     CALL vTaskPlaceOnUnorderedEventList
003550  000000     NOP
400:               
401:               			/* This is obsolete as it will get set after the task unblocks, but
402:               			some compilers mistakenly generate a warning about the variable
403:               			being returned without being set if it is not done. */
404:               			uxReturn = 0;
003552  EB0000     CLR W0
003554  780F00     MOV W0, [W14]
405:               
406:               			traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
407:               		}
408:               	}
409:               	xAlreadyYielded = xTaskResumeAll();
003556  02166A     CALL xTaskResumeAll
003558  000000     NOP
00355A  980760     MOV W0, [W14+12]
410:               
411:               	if( xTicksToWait != ( TickType_t ) 0 )
00355C  90083E     MOV [W14+22], W0
00355E  E00000     CP0 W0
003560  320027     BRA Z, .L17
412:               	{
413:               		if( xAlreadyYielded == pdFALSE )
003562  90006E     MOV [W14+12], W0
003564  E00000     CP0 W0
003566  3A0003     BRA NZ, .L18
414:               		{
415:               			portYIELD_WITHIN_API();
003568  0250DC     CALL .Letext0, .LFE1, _vPortYield
00356A  000000     NOP
00356C  000000     NOP
416:               		}
417:               		else
418:               		{
419:               			mtCOVERAGE_TEST_MARKER();
420:               		}
421:               
422:               		/* The task blocked to wait for its required bits to be set - at this
423:               		point either the required bits were set or the block time expired.  If
424:               		the required bits were set they will have been stored in the task's
425:               		event list item, and they should now be retrieved then cleared. */
426:               		uxReturn = uxTaskResetEventItemValue();
00356E  021B70     CALL uxTaskResetEventItemValue
003570  000000     NOP
003572  780F00     MOV W0, [W14]
427:               
428:               		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
003574  202000     MOV #0x200, W0
003576  60001E     AND W0, [W14], W0
003578  E00000     CP0 W0
00357A  3A0018     BRA NZ, .L19
429:               		{
430:               			taskENTER_CRITICAL();
00357C  0248DA     CALL vPortEnterCritical
00357E  000000     NOP
431:               			{
432:               				/* The task timed out, just return the current event bit value. */
433:               				uxReturn = pxEventBits->uxEventBits;
003580  90002E     MOV [W14+4], W0
003582  780F10     MOV [W0], [W14]
434:               
435:               				/* It is possible that the event bits were updated between this
436:               				task leaving the Blocked state and running again. */
437:               				if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
003584  90092E     MOV [W14+20], W2
003586  90088E     MOV [W14+16], W1
003588  78001E     MOV [W14], W0
00358A  0700CC     RCALL _prvTestWaitCondition, .LFE8, .LFB9
00358C  E00000     CP0 W0
00358E  32000A     BRA Z, .L20
438:               				{
439:               					if( xClearOnExit != pdFALSE )
003590  90081E     MOV [W14+18], W0
003592  E00000     CP0 W0
003594  320007     BRA Z, .L20
440:               					{
441:               						pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
003596  90002E     MOV [W14+4], W0
003598  780090     MOV [W0], W1
00359A  90080E     MOV [W14+16], W0
00359C  EA8000     COM W0, W0
00359E  608080     AND W1, W0, W1
0035A0  90002E     MOV [W14+4], W0
0035A2  780801     MOV W1, [W0]
442:               					}
443:               					else
444:               					{
445:               						mtCOVERAGE_TEST_MARKER();
446:               					}
447:               				}
448:               				else
449:               				{
450:               					mtCOVERAGE_TEST_MARKER();
451:               				}
452:               			}
453:               			taskEXIT_CRITICAL();
0035A4  0248F4     CALL vPortExitCritical
0035A6  000000     NOP
454:               
455:               			/* Prevent compiler warnings when trace macros are not used. */
456:               			xTimeoutOccurred = pdFALSE;
0035A8  EB0000     CLR W0
0035AA  980730     MOV W0, [W14+6]
457:               		}
458:               		else
459:               		{
460:               			/* The task unblocked because the bits were set. */
461:               		}
462:               
463:               		/* The task blocked so control bits may have been set. */
464:               		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
0035AC  200FF0     MOV #0xFF, W0
0035AE  600F1E     AND W0, [W14], [W14]
465:               	}
466:               	traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred );
467:               
468:               	return uxReturn;
0035B0  78001E     MOV [W14], W0
469:               }
0035B2  FA8000     ULNK
0035B4  060000     RETURN
470:               /*-----------------------------------------------------------*/
471:               
472:               EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear )
473:               {
0035B6  FA0008     LNK #0x8
0035B8  980720     MOV W0, [W14+4]
0035BA  980731     MOV W1, [W14+6]
474:               EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
0035BC  9000AE     MOV [W14+4], W1
0035BE  780F01     MOV W1, [W14]
475:               EventBits_t uxReturn;
476:               
477:               	/* Check the user is not attempting to clear the bits used by the kernel
478:               	itself. */
479:               	configASSERT( xEventGroup );
480:               	configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
481:               
482:               	taskENTER_CRITICAL();
0035C0  0248DA     CALL vPortEnterCritical
0035C2  000000     NOP
483:               	{
484:               		traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear );
485:               
486:               		/* The value returned is the event group value prior to the bits being
487:               		cleared. */
488:               		uxReturn = pxEventBits->uxEventBits;
0035C4  78001E     MOV [W14], W0
0035C6  780090     MOV [W0], W1
0035C8  980711     MOV W1, [W14+2]
489:               
490:               		/* Clear the bits. */
491:               		pxEventBits->uxEventBits &= ~uxBitsToClear;
0035CA  78001E     MOV [W14], W0
0035CC  780090     MOV [W0], W1
0035CE  90003E     MOV [W14+6], W0
0035D0  EA8000     COM W0, W0
0035D2  608080     AND W1, W0, W1
0035D4  78001E     MOV [W14], W0
0035D6  780801     MOV W1, [W0]
492:               	}
493:               	taskEXIT_CRITICAL();
0035D8  0248F4     CALL vPortExitCritical
0035DA  000000     NOP
494:               
495:               	return uxReturn;
0035DC  90001E     MOV [W14+2], W0
496:               }
0035DE  FA8000     ULNK
0035E0  060000     RETURN
497:               /*-----------------------------------------------------------*/
498:               
499:               #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( INCLUDE_xTimerPendFunctionCall == 1 ) && ( configUSE_TIMERS == 1 ) )
500:               
501:               	BaseType_t xEventGroupClearBitsFromISR( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear )
502:               	{
503:               		BaseType_t xReturn;
504:               
505:               		traceEVENT_GROUP_CLEAR_BITS_FROM_ISR( xEventGroup, uxBitsToClear );
506:               		xReturn = xTimerPendFunctionCallFromISR( vEventGroupClearBitsCallback, ( void * ) xEventGroup, ( uint32_t ) uxBitsToClear, NULL );
507:               
508:               		return xReturn;
509:               	}
510:               
511:               #endif
512:               /*-----------------------------------------------------------*/
513:               
514:               EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup )
515:               {
0035E2  FA0008     LNK #0x8
0035E4  980730     MOV W0, [W14+6]
516:               UBaseType_t uxSavedInterruptStatus;
517:               EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
0035E6  9000BE     MOV [W14+6], W1
0035E8  780F01     MOV W1, [W14]
518:               EventBits_t uxReturn;
519:               
520:               	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
0035EA  EB0000     CLR W0
0035EC  980710     MOV W0, [W14+2]
521:               	{
522:               		uxReturn = pxEventBits->uxEventBits;
0035EE  78001E     MOV [W14], W0
0035F0  780090     MOV [W0], W1
0035F2  980721     MOV W1, [W14+4]
523:               	}
524:               	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
525:               
526:               	return uxReturn;
0035F4  90002E     MOV [W14+4], W0
527:               }
0035F6  FA8000     ULNK
0035F8  060000     RETURN
528:               /*-----------------------------------------------------------*/
529:               
530:               EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
531:               {
0035FA  FA0016     LNK #0x16
0035FC  980F10     MOV W0, [W14+18]
0035FE  980F21     MOV W1, [W14+20]
532:               ListItem_t *pxListItem, *pxNext;
533:               ListItem_t const *pxListEnd;
534:               List_t *pxList;
535:               EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
003600  EB0000     CLR W0
003602  980710     MOV W0, [W14+2]
536:               EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
003604  90089E     MOV [W14+18], W1
003606  980731     MOV W1, [W14+6]
537:               BaseType_t xMatchFound = pdFALSE;
003608  EB0000     CLR W0
00360A  980720     MOV W0, [W14+4]
538:               
539:               	/* Check the user is not attempting to set the bits used by the kernel
540:               	itself. */
541:               	configASSERT( xEventGroup );
542:               	configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
543:               
544:               	pxList = &( pxEventBits->xTasksWaitingForBits );
00360C  90003E     MOV [W14+6], W0
00360E  E88000     INC2 W0, W0
003610  980740     MOV W0, [W14+8]
545:               	pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
003612  90004E     MOV [W14+8], W0
003614  400064     ADD W0, #0x4, W0
003616  980750     MOV W0, [W14+10]
546:               	vTaskSuspendAll();
003618  02165E     CALL vTaskSuspendAll
00361A  000000     NOP
547:               	{
548:               		traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );
549:               
550:               		pxListItem = listGET_HEAD_ENTRY( pxList );
00361C  90004E     MOV [W14+8], W0
00361E  9000B0     MOV [W0+6], W1
003620  780F01     MOV W1, [W14]
551:               
552:               		/* Set the bits. */
553:               		pxEventBits->uxEventBits |= uxBitsToSet;
003622  90003E     MOV [W14+6], W0
003624  780090     MOV [W0], W1
003626  90082E     MOV [W14+20], W0
003628  700081     IOR W0, W1, W1
00362A  90003E     MOV [W14+6], W0
00362C  780801     MOV W1, [W0]
554:               
555:               		/* See if the new bit value should unblock any tasks. */
556:               		while( pxListItem != pxListEnd )
00362E  37003C     BRA .L24
0036A8  90005E     MOV [W14+10], W0
0036AA  78009E     MOV [W14], W1
0036AC  508F80     SUB W1, W0, [W15]
0036AE  3AFFC0     BRA NZ, .L29
557:               		{
558:               			pxNext = listGET_NEXT( pxListItem );
003630  78001E     MOV [W14], W0
003632  900090     MOV [W0+2], W1
003634  980761     MOV W1, [W14+12]
559:               			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
003636  78001E     MOV [W14], W0
003638  780090     MOV [W0], W1
00363A  980771     MOV W1, [W14+14]
560:               			xMatchFound = pdFALSE;
00363C  EB0000     CLR W0
00363E  980720     MOV W0, [W14+4]
561:               
562:               			/* Split the bits waited for from the control bits. */
563:               			uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
003640  9000FE     MOV [W14+14], W1
003642  2FF000     MOV #0xFF00, W0
003644  608000     AND W1, W0, W0
003646  980F00     MOV W0, [W14+16]
564:               			uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
003648  9000FE     MOV [W14+14], W1
00364A  200FF0     MOV #0xFF, W0
00364C  608000     AND W1, W0, W0
00364E  980770     MOV W0, [W14+14]
565:               
566:               			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
003650  90088E     MOV [W14+16], W1
003652  204000     MOV #0x400, W0
003654  608000     AND W1, W0, W0
003656  E00000     CP0 W0
003658  3A0009     BRA NZ, .L25
567:               			{
568:               				/* Just looking for single bit being set. */
569:               				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
00365A  90003E     MOV [W14+6], W0
00365C  780090     MOV [W0], W1
00365E  90007E     MOV [W14+14], W0
003660  608000     AND W1, W0, W0
003662  E00000     CP0 W0
003664  32000C     BRA Z, .L26
570:               				{
571:               					xMatchFound = pdTRUE;
003666  200010     MOV #0x1, W0
003668  980720     MOV W0, [W14+4]
00366A  370009     BRA .L26
572:               				}
573:               				else
574:               				{
575:               					mtCOVERAGE_TEST_MARKER();
576:               				}
577:               			}
578:               			else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
00366C  90003E     MOV [W14+6], W0
00366E  780090     MOV [W0], W1
003670  90007E     MOV [W14+14], W0
003672  608080     AND W1, W0, W1
003674  90007E     MOV [W14+14], W0
003676  508F80     SUB W1, W0, [W15]
003678  3A0002     BRA NZ, .L26
579:               			{
580:               				/* All bits are set. */
581:               				xMatchFound = pdTRUE;
00367A  200010     MOV #0x1, W0
00367C  980720     MOV W0, [W14+4]
582:               			}
583:               			else
584:               			{
585:               				/* Need all bits to be set, but not all the bits were set. */
586:               			}
587:               
588:               			if( xMatchFound != pdFALSE )
00367E  90002E     MOV [W14+4], W0
003680  E00000     CP0 W0
003682  320010     BRA Z, .L27
589:               			{
590:               				/* The bits match.  Should the bits be cleared on exit? */
591:               				if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
003684  90088E     MOV [W14+16], W1
003686  201000     MOV #0x100, W0
003688  608000     AND W1, W0, W0
00368A  E00000     CP0 W0
00368C  320004     BRA Z, .L28
592:               				{
593:               					uxBitsToClear |= uxBitsWaitedFor;
00368E  90009E     MOV [W14+2], W1
003690  90007E     MOV [W14+14], W0
003692  700001     IOR W0, W1, W0
003694  980710     MOV W0, [W14+2]
594:               				}
595:               				else
596:               				{
597:               					mtCOVERAGE_TEST_MARKER();
598:               				}
599:               
600:               				/* Store the actual event flag value in the task's event list
601:               				item before removing the task from the event list.  The
602:               				eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
603:               				that is was unblocked due to its required bits matching, rather
604:               				than because it timed out. */
605:               				( void ) xTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
003696  90003E     MOV [W14+6], W0
003698  780010     MOV [W0], W0
00369A  A09000     BSET W0, #9
00369C  780080     MOV W0, W1
00369E  78001E     MOV [W14], W0
0036A0  021994     CALL xTaskRemoveFromUnorderedEventList
0036A2  000000     NOP
606:               			}
607:               
608:               			/* Move onto the next list item.  Note pxListItem->pxNext is not
609:               			used here as the list item may have been removed from the event list
610:               			and inserted into the ready/pending reading list. */
611:               			pxListItem = pxNext;
0036A4  9000EE     MOV [W14+12], W1
0036A6  780F01     MOV W1, [W14]
612:               		}
613:               
614:               		/* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
615:               		bit was set in the control word. */
616:               		pxEventBits->uxEventBits &= ~uxBitsToClear;
0036B0  90003E     MOV [W14+6], W0
0036B2  780090     MOV [W0], W1
0036B4  90001E     MOV [W14+2], W0
0036B6  EA8000     COM W0, W0
0036B8  608080     AND W1, W0, W1
0036BA  90003E     MOV [W14+6], W0
0036BC  780801     MOV W1, [W0]
617:               	}
618:               	( void ) xTaskResumeAll();
0036BE  02166A     CALL xTaskResumeAll
0036C0  000000     NOP
619:               
620:               	return pxEventBits->uxEventBits;
0036C2  90003E     MOV [W14+6], W0
0036C4  780010     MOV [W0], W0
621:               }
0036C6  FA8000     ULNK
0036C8  060000     RETURN
622:               /*-----------------------------------------------------------*/
623:               
624:               void vEventGroupDelete( EventGroupHandle_t xEventGroup )
625:               {
0036CA  FA0006     LNK #0x6
0036CC  980720     MOV W0, [W14+4]
626:               EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
0036CE  9000AE     MOV [W14+4], W1
0036D0  780F01     MOV W1, [W14]
627:               const List_t *pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits );
0036D2  E8801E     INC2 [W14], W0
0036D4  980710     MOV W0, [W14+2]
628:               
629:               	vTaskSuspendAll();
0036D6  02165E     CALL vTaskSuspendAll
0036D8  000000     NOP
630:               	{
631:               		traceEVENT_GROUP_DELETE( xEventGroup );
632:               
633:               		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
0036DA  370005     BRA .L31
0036E6  90001E     MOV [W14+2], W0
0036E8  780010     MOV [W0], W0
0036EA  E00000     CP0 W0
0036EC  3AFFF7     BRA NZ, .L32
634:               		{
635:               			/* Unblock the task, returning 0 as the event list is being deleted
636:               			and	cannot therefore have any bits set. */
637:               			configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
638:               			( void ) xTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
0036DC  90001E     MOV [W14+2], W0
0036DE  900030     MOV [W0+6], W0
0036E0  202001     MOV #0x200, W1
0036E2  021994     CALL xTaskRemoveFromUnorderedEventList
0036E4  000000     NOP
639:               		}
640:               
641:               		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
642:               		{
643:               			/* The event group can only have been allocated dynamically - free
644:               			it again. */
645:               			vPortFree( pxEventBits );
0036EE  78001E     MOV [W14], W0
0036F0  023D68     CALL vPortFree
0036F2  000000     NOP
646:               		}
647:               		#elif( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
648:               		{
649:               			/* The event group could have been allocated statically or
650:               			dynamically, so check before attempting to free the memory. */
651:               			if( pxEventBits->ucStaticallyAllocated == ( uint8_t ) pdFALSE )
652:               			{
653:               				vPortFree( pxEventBits );
654:               			}
655:               			else
656:               			{
657:               				mtCOVERAGE_TEST_MARKER();
658:               			}
659:               		}
660:               		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
661:               	}
662:               	( void ) xTaskResumeAll();
0036F4  02166A     CALL xTaskResumeAll
0036F6  000000     NOP
663:               }
0036F8  FA8000     ULNK
0036FA  060000     RETURN
664:               /*-----------------------------------------------------------*/
665:               
666:               /* For internal use only - execute a 'set bits' command that was pended from
667:               an interrupt. */
668:               void vEventGroupSetBitsCallback( void *pvEventGroup, const uint32_t ulBitsToSet )
669:               {
0036FC  FA0006     LNK #0x6
0036FE  780F00     MOV W0, [W14]
003700  980712     MOV W2, [W14+2]
003702  980723     MOV W3, [W14+4]
670:               	( void ) xEventGroupSetBits( pvEventGroup, ( EventBits_t ) ulBitsToSet );
003704  90001E     MOV [W14+2], W0
003706  780080     MOV W0, W1
003708  78001E     MOV [W14], W0
00370A  07FF77     RCALL xEventGroupSetBits
671:               }
00370C  FA8000     ULNK
00370E  060000     RETURN
672:               /*-----------------------------------------------------------*/
673:               
674:               /* For internal use only - execute a 'clear bits' command that was pended from
675:               an interrupt. */
676:               void vEventGroupClearBitsCallback( void *pvEventGroup, const uint32_t ulBitsToClear )
677:               {
003710  FA0006     LNK #0x6
003712  780F00     MOV W0, [W14]
003714  980712     MOV W2, [W14+2]
003716  980723     MOV W3, [W14+4]
678:               	( void ) xEventGroupClearBits( pvEventGroup, ( EventBits_t ) ulBitsToClear );
003718  90001E     MOV [W14+2], W0
00371A  780080     MOV W0, W1
00371C  78001E     MOV [W14], W0
00371E  07FF4B     RCALL xEventGroupClearBits
679:               }
003720  FA8000     ULNK
003722  060000     RETURN
680:               /*-----------------------------------------------------------*/
681:               
682:               static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits )
683:               {
003724  FA0008     LNK #0x8
003726  980710     MOV W0, [W14+2]
003728  980721     MOV W1, [W14+4]
00372A  980732     MOV W2, [W14+6]
684:               BaseType_t xWaitConditionMet = pdFALSE;
00372C  EB0000     CLR W0
00372E  780F00     MOV W0, [W14]
685:               
686:               	if( xWaitForAllBits == pdFALSE )
003730  90003E     MOV [W14+6], W0
003732  E00000     CP0 W0
003734  3A0008     BRA NZ, .L36
687:               	{
688:               		/* Task only has to wait for one bit within uxBitsToWaitFor to be
689:               		set.  Is one already set? */
690:               		if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
003736  90009E     MOV [W14+2], W1
003738  90002E     MOV [W14+4], W0
00373A  608000     AND W1, W0, W0
00373C  E00000     CP0 W0
00373E  32000B     BRA Z, .L37
691:               		{
692:               			xWaitConditionMet = pdTRUE;
003740  200010     MOV #0x1, W0
003742  780F00     MOV W0, [W14]
003744  370008     BRA .L37
693:               		}
694:               		else
695:               		{
696:               			mtCOVERAGE_TEST_MARKER();
697:               		}
698:               	}
699:               	else
700:               	{
701:               		/* Task has to wait for all the bits in uxBitsToWaitFor to be set.
702:               		Are they set already? */
703:               		if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
003746  90009E     MOV [W14+2], W1
003748  90002E     MOV [W14+4], W0
00374A  608080     AND W1, W0, W1
00374C  90002E     MOV [W14+4], W0
00374E  508F80     SUB W1, W0, [W15]
003750  3A0002     BRA NZ, .L37
704:               		{
705:               			xWaitConditionMet = pdTRUE;
003752  200010     MOV #0x1, W0
003754  780F00     MOV W0, [W14]
706:               		}
707:               		else
708:               		{
709:               			mtCOVERAGE_TEST_MARKER();
710:               		}
711:               	}
712:               
713:               	return xWaitConditionMet;
003756  78001E     MOV [W14], W0
714:               }
003758  FA8000     ULNK
00375A  060000     RETURN
715:               /*-----------------------------------------------------------*/
716:               
717:               #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( INCLUDE_xTimerPendFunctionCall == 1 ) && ( configUSE_TIMERS == 1 ) )
718:               
719:               	BaseType_t xEventGroupSetBitsFromISR( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, BaseType_t *pxHigherPriorityTaskWoken )
720:               	{
721:               	BaseType_t xReturn;
722:               
723:               		traceEVENT_GROUP_SET_BITS_FROM_ISR( xEventGroup, uxBitsToSet );
724:               		xReturn = xTimerPendFunctionCallFromISR( vEventGroupSetBitsCallback, ( void * ) xEventGroup, ( uint32_t ) uxBitsToSet, pxHigherPriorityTaskWoken );
725:               
726:               		return xReturn;
727:               	}
728:               
729:               #endif
730:               /*-----------------------------------------------------------*/
731:               
732:               #if (configUSE_TRACE_FACILITY == 1)
733:               
734:               	UBaseType_t uxEventGroupGetNumber( void* xEventGroup )
735:               	{
736:               	UBaseType_t xReturn;
737:               	EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
738:               
739:               		if( xEventGroup == NULL )
740:               		{
741:               			xReturn = 0;
742:               		}
743:               		else
744:               		{
745:               			xReturn = pxEventBits->uxEventGroupNumber;
746:               		}
747:               
748:               		return xReturn;
749:               	}
750:               
751:               #endif
752:               
---  /home/zxc/Documents/WCGRTOS/Demo/PIC24_MPLAB/main.c  -----------------------------------------------
1:                 /*
2:                     FreeRTOS V9.0.0 - Copyright (C) 2016 Real Time Engineers Ltd.
3:                     All rights reserved
4:                 
5:                     VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
6:                 
7:                     This file is part of the FreeRTOS distribution.
8:                 
9:                     FreeRTOS is free software; you can redistribute it and/or modify it under
10:                    the terms of the GNU General Public License (version 2) as published by the
11:                    Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
12:                
13:                 ***************************************************************************
14:                    >>!   NOTE: The modification to the GPL is included to allow you to     !<<
15:                    >>!   distribute a combined work that includes FreeRTOS without being   !<<
16:                    >>!   obliged to provide the source code for proprietary components     !<<
17:                    >>!   outside of the FreeRTOS kernel.                                   !<<
18:                 ***************************************************************************
19:                
20:                    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
21:                    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
22:                    FOR A PARTICULAR PURPOSE.  Full license text is available on the following
23:                    link: http://www.freertos.org/a00114.html
24:                
25:                 ***************************************************************************
26:                 *                                                                       *
27:                 *    FreeRTOS provides completely free yet professionally developed,    *
28:                 *    robust, strictly quality controlled, supported, and cross          *
29:                 *    platform software that is more than just the market leader, it     *
30:                 *    is the industry's de facto standard.                               *
31:                 *                                                                       *
32:                 *    Help yourself get started quickly while simultaneously helping     *
33:                 *    to support the FreeRTOS project by purchasing a FreeRTOS           *
34:                 *    tutorial book, reference manual, or both:                          *
35:                 *    http://www.FreeRTOS.org/Documentation                              *
36:                 *                                                                       *
37:                 ***************************************************************************
38:                
39:                    http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
40:                    the FAQ page "My application does not run, what could be wrong?".  Have you
41:                    defined configASSERT()?
42:                
43:                    http://www.FreeRTOS.org/support - In return for receiving this top quality
44:                    embedded software for free we request you assist our global community by
45:                    participating in the support forum.
46:                
47:                    http://www.FreeRTOS.org/training - Investing in training allows your team to
48:                    be as productive as possible as early as possible.  Now you can receive
49:                    FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
50:                    Ltd, and the world's leading authority on the world's leading RTOS.
51:                
52:                    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
53:                    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
54:                    compatible FAT file system, and our tiny thread aware UDP/IP stack.
55:                
56:                    http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
57:                    Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
58:                
59:                    http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
60:                    Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
61:                    licenses offer ticketed support, indemnification and commercial middleware.
62:                
63:                    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
64:                    engineered and independently SIL3 certified version for use in safety and
65:                    mission critical applications that require provable dependability.
66:                
67:                    1 tab == 4 spaces!
68:                 */
69:                // ****************************************************************************
70:                /*
71:                 * Creates all the demo application tasks, then starts the scheduler.  The WEB
72:                 * documentation provides more details of the standard demo application tasks.
73:                 * In addition to the standard demo tasks, the following tasks and tests are
74:                 * defined and/or created within this file:
75:                 *
76:                 * "Fast Interrupt Test" - A high frequency periodic interrupt is generated
77:                 * using a free running timer to demonstrate the use of the 
78:                 * configKERNEL_INTERRUPT_PRIORITY configuration constant.  The interrupt 
79:                 * service routine measures the number of processor clocks that occur between
80:                 * each interrupt - and in so doing measures the jitter in the interrupt 
81:                 * timing.  The maximum measured jitter time is latched in the usMaxJitter 
82:                 * variable, and displayed on the LCD by the 'Check' as described below.  
83:                 * The fast interrupt is configured and handled in the timer_test.c source 
84:                 * file.
85:                 *
86:                 * "LCD" task - the LCD task is a 'gatekeeper' task.  It is the only task that
87:                 * is permitted to access the LCD directly.  Other tasks wishing to write a
88:                 * message to the LCD send the message on a queue to the LCD task instead of 
89:                 * accessing the LCD themselves.  The LCD task just blocks on the queue waiting 
90:                 * for messages - waking and displaying the messages as they arrive.  The LCD
91:                 * task is defined in lcd.c.  
92:                 * 
93:                 * "Check" task -  This only executes every three seconds but has the highest 
94:                 * priority so is guaranteed to get processor time.  Its main function is to 
95:                 * check that all the standard demo tasks are still operational.  Should any
96:                 * unexpected behaviour within a demo task be discovered the 'check' task will
97:                 * write "FAIL #n" to the LCD (via the LCD task).  If all the demo tasks are 
98:                 * executing with their expected behaviour then the check task writes the max
99:                 * jitter time to the LCD (again via the LCD task), as described above.
100:                */
101:               
102:               /* Standard includes. */
103:               #include <stdio.h>
104:               
105:               /* Scheduler includes. */
106:               #include "FreeRTOS.h"
107:               #include "task.h"
108:               #include "queue.h"
109:               #include "croutine.h"
110:               #include "semphr.h"
111:               #include "event_groups.h"
112:               
113:               /* Demo application includes. */
114:               #include "Config_Bit.h"
115:               #include "BlockQ.h"
116:               #include "crflash.h"
117:               #include "blocktim.h"
118:               #include "integer.h"
119:               #include "comtest2.h"
120:               #include "partest.h"
121:               #include "LCD.h"
122:               #include "timertest.h"
123:               #include "WCGDeBug.h"
124:               #include "PCF8583.h"
125:               #include "CAT24C512.h"
126:               #include "UART1.h"
127:               #include "UART2.h"
128:               #include "TR04.h"
129:               #include "LED.h"
130:               #include "KEY.h"
131:               #include "Common.h"
132:               #include "CheckData.h"
133:               
134:               /* Demo task priorities. */
135:               #define mainBLOCK_Q_PRIORITY				( tskIDLE_PRIORITY + 2 )
136:               #define mainCHECK_TASK_PRIORITY				( tskIDLE_PRIORITY + 3 )
137:               #define mainCOM_TEST_PRIORITY				( 2 )
138:               
139:               /* The check task may require a bit more stack as it calls sprintf(). */
140:               #define mainCHECK_TAKS_STACK_SIZE			( configMINIMAL_STACK_SIZE * 2 )
141:               
142:               /* The execution period of the check task. */
143:               #define mainCHECK_TASK_PERIOD				( ( TickType_t ) 3000 / portTICK_PERIOD_MS )
144:               
145:               /* The number of flash co-routines to create. */
146:               //#define mainNUM_FLASH_COROUTINES			( 5 )
147:               
148:               /* Baud rate used by the comtest tasks. */
149:               #define mainCOM_TEST_BAUD_RATE				( 19200 )
150:               
151:               /* The LED used by the comtest tasks.  mainCOM_TEST_LED + 1 is also used.
152:               See the comtest.c file for more information. */
153:               #define mainCOM_TEST_LED					( 6 )
154:               
155:               /* The frequency at which the "fast interrupt test" interrupt will occur. */
156:               #define mainTEST_INTERRUPT_FREQUENCY		( 20000 )
157:               
158:               /* The number of processor clocks we expect to occur between each "fast
159:               interrupt test" interrupt. */
160:               #define mainEXPECTED_CLOCKS_BETWEEN_INTERRUPTS ( configCPU_CLOCK_HZ / mainTEST_INTERRUPT_FREQUENCY )
161:               
162:               /* The number of nano seconds between each processor clock. */
163:               #define mainNS_PER_CLOCK ( ( unsigned short ) ( ( 1.0 / ( double ) configCPU_CLOCK_HZ ) * 1000000000.0 ) )
164:               
165:               /* Dimension the buffer used to hold the value of the maximum jitter time when
166:               it is converted to a string. */
167:               #define mainMAX_STRING_LENGTH				( 20 )
168:               
169:               /*-----------------------------------------------------------*/
170:               
171:               /*
172:                * The check task as described at the top of this file.
173:                */
174:               //static void vCheckTask(void *pvParameters);
175:               
176:               /*
177:                * Setup the processor ready for the demo.
178:                */
179:               //static void prvSetupHardware(void);
180:               
181:               /* Prototypes for the standard FreeRTOS callback/hook functions implemented
182:               within this file. */
183:               void vApplicationStackOverflowHook(TaskHandle_t pxTask, char *pcTaskName);
184:               
185:               /*-----------------------------------------------------------*/
186:               
187:               /* The queue used to send messages to the LCD task. */
188:               //static QueueHandle_t xLCDQueue;
189:               
190:               /*-----------------------------------------------------------*/
191:               void task_start(void *parameter);
192:               //void vLEDShark(void *pvParameters);
193:               //void LED456(void *pvParameters);
194:               
195:               UBaseType_t start_PRIORITY = 4;
196:               UBaseType_t vLEDShark_PRIORITY = 3;
197:               //UBaseType_t LED456_PRIORITY = 3;
198:               //uint16_t configMINIMAL_STACK_SIZE = 128;
199:               //uint16_t configMINIMAL_STACK_SIZE 128;
200:               //uint16_t configMINIMAL_STACK_SIZE 128;
201:               /*Create EventGroup*/
202:               EventGroupHandle_t xEventGroupWCGFlag;
203:               #define Bit0GetPressureByTime      (1<<0)
204:               #define Bit4GetPressByUser         (1<<4)
205:               SemaphoreHandle_t xSemBinGetPress;
206:               
207:               BaseType_t CAT24_PC = 0;
208:               
209:               xQueueHandle xQueueUart1Pressure;
210:               
211:               SemaphoreHandle_t xSemBinKey;
212:               SemaphoreHandle_t xSemBinSendByGPRS;
213:               SemaphoreHandle_t xSemBinGPRSIsLink;
214:               
215:               /*
216:                * Create the demo tasks then start the scheduler.
217:                */
218:               int main(void) {//2LED
004116  FA0000     LNK #0x0
219:                   /* Configure any hardware required for this demo. */
220:                   //    prvSetupHardware();
221:               
222:                   /* Create the standard demo tasks. */
223:                   //    vStartBlockingQueueTasks(mainBLOCK_Q_PRIORITY);
224:                   //    vStartIntegerMathTasks(tskIDLE_PRIORITY);
225:                   //    vStartFlashCoRoutines(mainNUM_FLASH_COROUTINES);
226:                   //    vAltStartComTestTasks(mainCOM_TEST_PRIORITY, mainCOM_TEST_BAUD_RATE, mainCOM_TEST_LED);
227:                   //    vCreateBlockTimeTasks();
228:               
229:                   /* Create the test tasks defined within this file. */
230:                   //    xTaskCreate(vCheckTask, "Check", mainCHECK_TAKS_STACK_SIZE, NULL, mainCHECK_TASK_PRIORITY, NULL);
231:               #if (ENABLE_DEBUG==1)   
232:                   vDebugTaskHook();
233:               #endif
234:                   /* Start the task that will control the LCD.  This returns the handle
235:                   to the queue used to write text out to the task. */
236:                   //	xLCDQueue = xStartLCDTask();
237:                   xTaskCreate(task_start, "start_task", configMINIMAL_STACK_SIZE, NULL, start_PRIORITY, NULL); /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
004118  804540     MOV 0x8A8, W0
00411A  EB0280     CLR W5
00411C  780200     MOV W0, W4
00411E  EB0180     CLR W3
004120  200732     MOV #0x73, W2
004122  290481     MOV #0x9048, W1
004124  241780     MOV #0x4178, W0
004126  0210E8     CALL xTaskCreate
004128  000000     NOP
238:                   /* Start the high frequency interrupt test. */
239:                   //    vSetupTimerTest(mainTEST_INTERRUPT_FREQUENCY);
240:               
241:                   /* Finally start the scheduler. */
242:                   vTaskStartScheduler();
00412A  02160C     CALL vTaskStartScheduler
00412C  000000     NOP
243:               
244:                   /* Will only reach here if there is insufficient heap available to start
245:                   the scheduler. */
246:                   return 0;
00412E  EB0000     CLR W0
247:               }
004130  FA8000     ULNK
004132  060000     RETURN
248:               
249:               /*-----------------------------------------------------------*/
250:               
251:               //static void prvSetupHardware(void) {
252:               //    vParTestInitialise();
253:               //}
254:               
255:               /*-----------------------------------------------------------*/
256:               
257:               //static void vCheckTask(void *pvParameters) {
258:               //    /* Used to wake the task at the correct frequency. */
259:               //    TickType_t xLastExecutionTime;
260:               //
261:               //    /* The maximum jitter time measured by the fast interrupt test. */
262:               //    extern unsigned short usMaxJitter;
263:               //
264:               //    /* Buffer into which the maximum jitter time is written as a string. */
265:               //    static char cStringBuffer[ mainMAX_STRING_LENGTH ];
266:               //
267:               //    /* The message that is sent on the queue to the LCD task.  The first
268:               //    parameter is the minimum time (in ticks) that the message should be
269:               //    left on the LCD without being overwritten.  The second parameter is a pointer
270:               //    to the message to display itself. */
271:               //    xLCDMessage xMessage = {0, cStringBuffer};
272:               //
273:               //    /* Set to pdTRUE should an error be detected in any of the standard demo tasks. */
274:               //    unsigned short usErrorDetected = pdFALSE;
275:               //
276:               //    /* Remove compiler warnings. */
277:               //    (void) pvParameters;
278:               //
279:               //    /* Initialise xLastExecutionTime so the first call to vTaskDelayUntil()
280:               //    works correctly. */
281:               //    xLastExecutionTime = xTaskGetTickCount();
282:               //
283:               //    for (;;) {
284:               //        /* Wait until it is time for the next cycle. */
285:               //        vTaskDelayUntil(&xLastExecutionTime, mainCHECK_TASK_PERIOD);
286:               //
287:               //        /* Has an error been found in any of the standard demo tasks? */
288:               //
289:               //        if (xAreIntegerMathsTaskStillRunning() != pdTRUE) {
290:               //            usErrorDetected = pdTRUE;
291:               //            sprintf(cStringBuffer, "FAIL #1");
292:               //        }
293:               //
294:               //        if (xAreComTestTasksStillRunning() != pdTRUE) {
295:               //            usErrorDetected = pdTRUE;
296:               //            sprintf(cStringBuffer, "FAIL #2");
297:               //        }
298:               //
299:               //        if (xAreBlockTimeTestTasksStillRunning() != pdTRUE) {
300:               //            usErrorDetected = pdTRUE;
301:               //            sprintf(cStringBuffer, "FAIL #3");
302:               //        }
303:               //
304:               //        if (xAreBlockingQueuesStillRunning() != pdTRUE) {
305:               //            usErrorDetected = pdTRUE;
306:               //            sprintf(cStringBuffer, "FAIL #4");
307:               //        }
308:               //
309:               //        if (usErrorDetected == pdFALSE) {
310:               //            /* No errors have been discovered, so display the maximum jitter
311:               //            timer discovered by the "fast interrupt test". */
312:               //            sprintf(cStringBuffer, "%dns max jitter", (short) (usMaxJitter - mainEXPECTED_CLOCKS_BETWEEN_INTERRUPTS) * mainNS_PER_CLOCK);
313:               //        }
314:               //
315:               //        /* Send the message to the LCD gatekeeper for display. */
316:               //        xQueueSend(xLCDQueue, &xMessage, portMAX_DELAY);
317:               //    }
318:               //}
319:               
320:               /*-----------------------------------------------------------*/
321:               
322:               void vApplicationIdleHook(void) {
004134  FA0000     LNK #0x0
323:                   /* Schedule the co-routines from within the idle task hook. */
324:                   //    vCoRoutineSchedule();
325:               }
004136  FA8000     ULNK
004138  060000     RETURN
326:               
327:               /*-----------------------------------------------------------*/
328:               
329:               void vApplicationStackOverflowHook(TaskHandle_t pxTask, char *pcTaskName) {
00413A  FA0004     LNK #0x4
00413C  780F00     MOV W0, [W14]
00413E  980711     MOV W1, [W14+2]
330:                   (void) pcTaskName;
331:                   (void) pxTask;
332:               
333:                   /* Run time stack overflow checking is performed if
334:                   configCHECK_FOR_STACK_OVERFLOW is defined to 1 or 2.  This hook
335:                   function is called if a stack overflow is detected. */
336:                   taskDISABLE_INTERRUPTS();
004140  800211     MOV SR, W1
004142  2FF1F0     MOV #0xFF1F, W0
004144  608000     AND W1, W0, W0
004146  A05000     BSET W0, #5
004148  880210     MOV W0, SR
00414A  000000     NOP
00414C  000000     NOP
337:                   for (;;);
00414E  37FFFF     BRA .L4
338:               }
339:               
340:               void vLEDShark1(void *pvParameters) {
004150  FA0002     LNK #0x2
004152  780F00     MOV W0, [W14]
341:                   pvParameters = pvParameters;
342:                   vLEDInit();
004154  024E66     CALL vLEDInit
004156  000000     NOP
343:               
344:                   for (;;) {
345:                       _LATE7 ^= 1; //green led
004158  801720     MOV LATE, W0
00415A  DE0047     LSR W0, #7, W0
00415C  604061     AND.B W0, #0x1, W0
00415E  A20400     BTG.B W0, #0
004160  604061     AND.B W0, #0x1, W0
004162  FB8000     ZE W0, W0
004164  600061     AND W0, #0x1, W0
004166  DD0047     SL W0, #7, W0
004168  801721     MOV LATE, W1
00416A  A17001     BCLR W1, #7
00416C  700001     IOR W0, W1, W0
00416E  881720     MOV W0, LATE
346:                       vTaskDelay(500);
004170  201F40     MOV #0x1F4, W0
004172  021398     CALL vTaskDelay
004174  000000     NOP
347:                   }
004176  37FFF0     BRA .L6
348:               }
349:               
350:               //void LED456(void *pvParameters) {
351:               //    pvParameters = pvParameters;
352:               //    vLEDInit();
353:               //    for (;;) {
354:               //        vLEDShark(LEDGreen, 1000, 300, 4);
355:               //    }
356:               //}
357:               extern void vTaskKey(void *parameter);
358:               extern void vTaskGetPressure(void* parameter);
359:               
360:               void task_start(void *parameter) {
004178  FA0002     LNK #0x2
00417A  780F00     MOV W0, [W14]
361:                   vLCDInit();
00417C  0226F6     CALL vLCDInit
00417E  000000     NOP
362:                   xTaskCreate(vTaskGetPressure, "vTaskGetPressure", mainCHECK_TAKS_STACK_SIZE, NULL, mainCHECK_TASK_PRIORITY, NULL);
004180  EB0280     CLR W5
004182  200034     MOV #0x3, W4
004184  EB0180     CLR W3
004186  200E62     MOV #0xE6, W2
004188  290531     MOV #0x9053, W1
00418A  241AA0     MOV #0x41AA, W0
00418C  0210E8     CALL xTaskCreate
00418E  000000     NOP
363:                   xTaskCreate(vTaskKey, "led456", mainCHECK_TAKS_STACK_SIZE, NULL, mainCHECK_TASK_PRIORITY - 1, NULL);
004190  EB0280     CLR W5
004192  200024     MOV #0x2, W4
004194  EB0180     CLR W3
004196  200E62     MOV #0xE6, W2
004198  290641     MOV #0x9064, W1
00419A  242B60     MOV #0x42B6, W0
00419C  0210E8     CALL xTaskCreate
00419E  000000     NOP
364:                   /*Get EEPROM Write Point Count*/
365:                   //    xCAT24ReadPointCount(CAT24_PC);
366:                   vTaskDelete(NULL);
0041A0  EB0000     CLR W0
0041A2  0212A8     CALL vTaskDelete
0041A4  000000     NOP
367:               }
0041A6  FA8000     ULNK
0041A8  060000     RETURN
368:               
369:               void vTaskGetPressure(void* parameter) {
0041AA  FA0012     LNK #0x12
0041AC  781F88     MOV W8, [W15++]
0041AE  980F00     MOV W0, [W14+16]
370:                   unsigned char ucGetData[9];
371:                   unsigned char ucGetOffset;
372:                   unsigned char ucCount = 0;
0041B0  EB4000     CLR.B W0
0041B2  784F00     MOV.B W0, [W14]
373:                   float fPress;
374:                   /*use UART1 and RS485_CON(PEc6),initialization UART2*/
375:                   vUART1Init();
0041B4  02430E     CALL vUART1Init
0041B6  000000     NOP
376:                   /*create uart1 receive buffer notify*/
377:                   xQueueUart1Pressure = xQueueCreate(1, UART1_BUFFER_LENGTH);
0041B8  EB4100     CLR.B W2
0041BA  200101     MOV #0x10, W1
0041BC  200010     MOV #0x1, W0
0041BE  02207C     CALL xQueueGenericCreate
0041C0  000000     NOP
0041C2  884420     MOV W0, xQueueUart1Pressure
378:                   /*create semaphorebinary*/
379:                   //    vSemaphoreCreateBinary(xSemBinGetPress);
380:                   /*create flag event*/
381:                   xEventGroupWCGFlag = xEventGroupCreate();
0041C4  0233E8     CALL xEventGroupCreate
0041C6  000000     NOP
0041C8  8843F0     MOV W0, xEventGroupWCGFlag
0041CA  370001     BRA .L12
382:                   for (;;) {
383:                       /* it's time to get pressure or user need get pressure,then wake up WCG,and send xGetPressSem*/
384:                       /*wait for uart1 receive data*/
385:                       if (xQueueReceive(xQueueUart1Pressure, ucUart1Buffer, portMAX_DELAY) != pdFALSE) {
0041CE  804420     MOV xQueueUart1Pressure, W0
0041D0  EB0180     CLR W3
0041D2  EB8100     SETM W2
0041D4  21D9E1     MOV #0x1D9E, W1
0041D6  0222D4     CALL xQueueGenericReceive
0041D8  000000     NOP
0041DA  E00000     CP0 W0
0041DC  32FFF7     BRA Z, .L13
386:                           /*xEventGropWCGFlag bit0|bit4 is One,every 30ms*/
387:                           /*delay for get last byte*/
388:                           vTaskDelay(1);
0041DE  200010     MOV #0x1, W0
0041E0  021398     CALL vTaskDelay
0041E2  000000     NOP
389:                           vUARTRxGet4Byte();
0041E4  0244B8     CALL vUARTRxGet4Byte
0041E6  000000     NOP
390:                           while (bUART1BufferRead(ucGetData + ucCount++));
0041E8  000000     NOP
0041EA  FB801E     ZE [W14], W0
0041EC  E8808E     INC2 W14, W1
0041EE  408000     ADD W1, W0, W0
0041F0  E84F1E     INC.B [W14], [W14]
0041F2  02445E     CALL bUART1BufferRead
0041F4  000000     NOP
0041F6  E00400     CP0.B W0
0041F8  3AFFF8     BRA NZ, .L10
391:                           ucGetOffset = Str_Find_Head(ucGetData, TR04, 9, 2);
0041FA  E8800E     INC2 W14, W0
0041FC  B3C023     MOV.B #0x2, W3
0041FE  B3C092     MOV.B #0x9, W2
004200  290401     MOV #0x9040, W1
004202  022F62     CALL Str_Find_Head
004204  000000     NOP
004206  984710     MOV.B W0, [W14+1]
392:                           if (ucGetOffset && bCRC16IsRight1(ucGetData + ucGetOffset - 1, 7)) {
004208  90401E     MOV.B [W14+1], W0
00420A  E00400     CP0.B W0
00420C  320034     BRA Z, .L11
00420E  90401E     MOV.B [W14+1], W0
004210  FB8000     ZE W0, W0
004212  400067     ADD W0, #0x7, W0
004214  E8808E     INC2 W14, W1
004216  408000     ADD W1, W0, W0
004218  784010     MOV.B [W0], W0
00421A  FB8000     ZE W0, W0
00421C  DD00C8     SL W0, #8, W1
00421E  90401E     MOV.B [W14+1], W0
004220  FB8000     ZE W0, W0
004222  400066     ADD W0, #0x6, W0
004224  E8810E     INC2 W14, W2
004226  410000     ADD W2, W0, W0
004228  784010     MOV.B [W0], W0
00422A  FB8000     ZE W0, W0
00422C  408400     ADD W1, W0, W8
00422E  90401E     MOV.B [W14+1], W0
004230  FB8000     ZE W0, W0
004232  E90000     DEC W0, W0
004234  E8808E     INC2 W14, W1
004236  408000     ADD W1, W0, W0
004238  B3C071     MOV.B #0x7, W1
00423A  024F0E     CALL usCRC16Check
00423C  000000     NOP
00423E  540F80     SUB W8, W0, [W15]
004240  3A001A     BRA NZ, .L11
393:                               CharToFloat(&fPress, ucGetData + ucGetOffset + 2);
004242  90401E     MOV.B [W14+1], W0
004244  FB8000     ZE W0, W0
004246  E88000     INC2 W0, W0
004248  E8808E     INC2 W14, W1
00424A  408080     ADD W1, W0, W1
00424C  47006C     ADD W14, #0xC, W0
00424E  022C06     CALL CharToFloat
004250  000000     NOP
394:                               vLCDShowNums((unsigned int) (fPress * 100), false);
004252  90006E     MOV [W14+12], W0
004254  9000FE     MOV [W14+14], W1
004256  200002     MOV #0x0, W2
004258  242C83     MOV #0x42C8, W3
00425A  020786     CALL ___mulsf3
00425C  000000     NOP
00425E  0206A0     CALL ___fixunssfsi
004260  000000     NOP
004262  780000     MOV W0, W0
004264  EB0080     CLR W1
004266  EB4100     CLR.B W2
004268  022AA4     CALL vLCDShowNums
00426A  000000     NOP
395:                               vLCDShowDigitalPoint(2);
00426C  B3C020     MOV.B #0x2, W0
00426E  022A5E     CALL vLCDShowDigitalPoint
004270  000000     NOP
396:                               Nop();
004272  000000     NOP
397:                           } else {
398:                               /*Error Code*/
399:                               Nop();
004276  000000     NOP
400:                           }
401:                       }
402:                   }
0041CC  000000     NOP
004274  37FFAC     BRA .L12
004278  37FFAA     BRA .L12
403:               }
404:               
405:               void vTaskSendByGPRS(void*parameter) {
00427A  FA0002     LNK #0x2
00427C  780F00     MOV W0, [W14]
406:                   //    vGPRSInit();
407:                   xSemBinSendByGPRS = xSemaphoreCreateBinary();
00427E  B3C032     MOV.B #0x3, W2
004280  EB0080     CLR W1
004282  200010     MOV #0x1, W0
004284  02207C     CALL xQueueGenericCreate
004286  000000     NOP
004288  884440     MOV W0, xSemBinSendByGPRS
00428A  370001     BRA .L17
408:                   for (;;) {
409:                       if (xSemaphoreTake(xSemBinSendByGPRS, portMAX_DELAY) == pdTRUE) {
00428E  804440     MOV xSemBinSendByGPRS, W0
004290  EB0180     CLR W3
004292  EB8100     SETM W2
004294  EB0080     CLR W1
004296  0222D4     CALL xQueueGenericReceive
004298  000000     NOP
00429A  500FE1     SUB W0, #0x1, [W15]
00429C  3AFFF7     BRA NZ, .L18
410:                           //            GPRSEnable = 1;
411:                           if (xSemaphoreTake(xSemBinGPRSIsLink, pdMS_TO_TICKS(50000)) == pdTRUE) {
00429E  804450     MOV xSemBinGPRSIsLink, W0
0042A0  EB0180     CLR W3
0042A2  2003D2     MOV #0x3D, W2
0042A4  EB0080     CLR W1
0042A6  0222D4     CALL xQueueGenericReceive
0042A8  000000     NOP
0042AA  500FE1     SUB W0, #0x1, [W15]
0042AC  3A0002     BRA NZ, .L16
412:                               //                vGPRSSendData();
413:                               //                vTaskDelay(3000);
414:                               //                vGPRSReceiveData();
415:                               //                vWCGHandleOnliveData();
416:                               Nop();
0042AE  000000     NOP
417:                           } else {
418:                               //                FailGPRSConnectCount++;
419:                               //ERRORSend();
420:                               Nop();
0042B2  000000     NOP
421:                           }
422:                           //            GPRSEnable = 0;
423:                       }
424:                   }
00428C  000000     NOP
0042B0  37FFEE     BRA .L17
0042B4  37FFEC     BRA .L17
425:               }
426:               
427:               void vTaskKey(void *parameter) {
0042B6  FA0002     LNK #0x2
0042B8  780F00     MOV W0, [W14]
428:                   unsigned char ucKeyState;
429:                   /*create semaphore*/
430:                   xSemBinKey = xSemaphoreCreateBinary();
0042BA  B3C032     MOV.B #0x3, W2
0042BC  EB0080     CLR W1
0042BE  200010     MOV #0x1, W0
0042C0  02207C     CALL xQueueGenericCreate
0042C2  000000     NOP
0042C4  884430     MOV W0, xSemBinKey
431:                   /*Init key*/
432:                   vKeyInit();
0042C6  024528     CALL vKeyInit
0042C8  000000     NOP
433:                   vLEDInit();
0042CA  024E66     CALL vLEDInit
0042CC  000000     NOP
0042CE  370001     BRA .L21
434:                   for (;;) {
435:                       if (xSemaphoreTake(xSemBinKey, portMAX_DELAY) == pdTRUE) {
0042D2  804430     MOV xSemBinKey, W0
0042D4  EB0180     CLR W3
0042D6  EB8100     SETM W2
0042D8  EB0080     CLR W1
0042DA  0222D4     CALL xQueueGenericReceive
0042DC  000000     NOP
0042DE  500FE1     SUB W0, #0x1, [W15]
0042E0  3AFFF7     BRA NZ, .L22
436:                           //            vKeyScan(&ucKeyState);
437:                           //            vTaskDelay(10);
438:                           //            vKeyUserFunction(ucKeyState);
439:                           vUART1Send((unsigned char*) TR04, sizeof (TR04));
0042E2  B3C081     MOV.B #0x8, W1
0042E4  290400     MOV #0x9040, W0
0042E6  0243B2     CALL vUART1Send
0042E8  000000     NOP
440:                           vLEDShark(LEDGreen, 300, 100, 3);
0042EA  B3C033     MOV.B #0x3, W3
0042EC  200642     MOV #0x64, W2
0042EE  2012C1     MOV #0x12C, W1
0042F0  B3C010     MOV.B #0x1, W0
0042F2  024ECE     CALL vLEDShark
0042F4  000000     NOP
441:                       }
442:                   }
0042D0  000000     NOP
0042F6  37FFED     BRA .L21
443:               }
444:               
445:               void vTaskShowLCD(void *parameter) {
0042F8  FA0002     LNK #0x2
0042FA  780F00     MOV W0, [W14]
446:                   vLCDInit();
0042FC  0226F6     CALL vLCDInit
0042FE  000000     NOP
447:               
448:                   for (;;) {
449:               
450:                   }
004300  37FFFF     BRA .L24
451:               }
452:               
453:               void vTaskCalaClockTime(void *parameter) {
004302  FA0002     LNK #0x2
004304  780F00     MOV W0, [W14]
454:                   for (;;) {
455:                   }
004306  37FFFF     BRA .L26
456:               }
457:               
458:               void vTaskStorageSample(void *parameter) {
004308  FA0002     LNK #0x2
00430A  780F00     MOV W0, [W14]
459:                   for (;;) {
460:                       /*packet data in eeprom*/
461:                       //            xCAT24WriteBytes(CAT24_PC, Data, length);
462:                       //            CAT24_PC += length;            
463:                       //            xCAT24WritePointCount(CAT24_PC );
464:                   }
00430C  37FFFF     BRA .L28
465:               }
466:               
467:               
468:               
---  /home/zxc/Documents/WCGRTOS/Demo/PIC24_MPLAB/WCGDebug.c  -------------------------------------------
1:                 /*
2:                  * File:   WCGDebug.c
3:                  * Author: root
4:                  *
5:                  * Created on January 11, 2019, 10:14 AM
6:                  */
7:                 #include "Debug.h"
8:                 #include "FreeRTOS.h"
9:                 #include "task.h"
10:                #include "WCGDeBug.h"
11:                #include <xc.h>
12:                
13:                /*set all control debug*/
14:                #if (ENABLE_DEBUG == 1)
15:                
16:                /*debug LCD*/
17:                #if (DebugLCD == 1)
18:                #include "LCD.h"
19:                
20:                void vTaskTestLCD(void*parameter) {
21:                    uint8_t ucCnt, ucCnt1;
22:                    /*Initialization LCD*/
23:                    vLCDInit();
24:                    /*use rs485*/
25:                    _LATE6 = 1;
26:                
27:                    for (;;) {
28:                #if (TestSpecialSign == 1)
29:                        /*print information*/
30:                        vDeBugPrintInformation("test special sign");
31:                        /*clear screen*/
32:                        vLCDClearScreen();
33:                        /*delay*/
34:                        vTaskDelay(1000);
35:                        /*show external power*/
36:                        vLCDShowPoint(ePower, SEGSHOW);
37:                        /*show error*/
38:                        vLCDShowPoint(eError, SEGSHOW);
39:                        /*show forword*/
40:                        vLCDShowPoint(eForword, SEGSHOW);
41:                        /*show backword*/
42:                        vLCDShowPoint(eBackword, SEGSHOW);
43:                        /*show kPa*/
44:                        vLCDShowPoint(eKPa, SEGSHOW);
45:                        /*show m3*/
46:                        vLCDShowPoint(em3, SEGSHOW);
47:                        /*show per hour*/
48:                        vLCDShowPoint(ePerh, SEGSHOW);
49:                        /*show temperature unit*/
50:                        vLCDShowPoint(eCC, SEGSHOW);
51:                        /*show battery power*/
52:                        for (ucCnt = 0; ucCnt < 4; ucCnt++)
53:                            vLCDShowBattery(ucCnt);
54:                        /*show GPRS signal*/
55:                        for (ucCnt = 0; ucCnt < 5; ucCnt++)
56:                            vLCDShowGPRSSign(ucCnt);
57:                        /*endif (TestSpecialSign == 1)*/
58:                #endif
59:                #if (TestNum == 1)
60:                        /*show digital point*/
61:                        for (ucCnt = 0; ucCnt < 5; ucCnt++)
62:                            vLCDShowDigitalPoint(ucCnt);
63:                        /*show one position nums*/
64:                        for (ucCnt1 = 0; ucCnt1 < 7; ucCnt1++) {
65:                            for (ucCnt = 0; ucCnt < 10; ucCnt++) {
66:                                vLCDShowNum(ucCnt, ucCnt1);
67:                                vTaskDelay(200);
68:                            }
69:                        }
70:                        /*shou all zero*/
71:                        vLCDShowNums(0L, FristZeroShow);
72:                        vTaskDelay(1000);
73:                        /*show one zero*/
74:                        vLCDShowNums(0L, FristZeroHide);
75:                        vTaskDelay(1000);
76:                        /*show 1234567*/
77:                        vLCDShowNums(1234567L, FristZeroShow);
78:                        vTaskDelay(1000);
79:                        /*show 123*/
80:                        vLCDShowNums(123L, FristZeroHide);
81:                        vTaskDelay(1000);
82:                        /*override test*/
83:                        vLCDShowNums(10000000L, FristZeroShow);
84:                        vTaskDelay(1000);
85:                        /*show  111111*/
86:                        vLCDShowNums(1111111L, FristZeroShow);
87:                        vTaskDelay(1000);
88:                        /*endif(TestNum == 1)*/
89:                #endif
90:                    }
91:                }
92:                /*endif (DebugLCD==1)*/
93:                #endif
94:                
95:                #if  (DebugPCF8583 == 1)
96:                #include "PCF8583.h"
97:                #include "FreeRTOS.h"
98:                #include "semphr.h"
99:                
100:               SemaphoreHandle_t xSemBinaryAlarm;
101:               
102:               void vTaskTestPCF(void*parameter) {
103:                   /*Initialization PCF8583*/
104:                   vPCF8583Init();
105:                   /*use rs485*/
106:                   _LATE6 = 1;
107:                   struct tm sReadTime;
108:                   time_t tReadTimestamp;
109:                   time_t tSetAlarmTimestamp;
110:               
111:                   /*set clock time*/
112:                   vPCF8583SetTimeByTimestamp((time_t*) & tNowTimestamp);
113:                   /*set alrarm ttime*/
114:                   tSetAlarmTimestamp = tNowTimestamp + 10;
115:                   vPCF8583SetAlarmTimeByTimestamp(&tSetAlarmTimestamp);
116:                   /*create semaphorebinary*/
117:                   xSemBinaryAlarm = xSemaphoreCreateBinary();
118:                   for (;;) {
119:               #if (TestReadTime == 1)
120:                       /**test  read time**/
121:                       sReadTime = sPCF8583ReadTime();
122:                       vDeBugPrintStringAndNums("year is ", sReadTime.tm_year);
123:                       vDeBugPrintStringAndNums("month is ", sReadTime.tm_mon);
124:                       vDeBugPrintStringAndNums("mday is ", sReadTime.tm_mday);
125:                       vDeBugPrintStringAndNums("hour is ", sReadTime.tm_hour);
126:                       vDeBugPrintStringAndNums("minute is ", sReadTime.tm_min);
127:                       vDeBugPrintStringAndNums("second is ", sReadTime.tm_sec);
128:                       vTaskDelay(1000);
129:                       /*endif (TestReadTime == 1)*/
130:               #endif
131:               #if (TestReadTimestamp == 1)
132:                       /*test write and read time by timestamp*/
133:                       vDeBugPrintInformation("test PCF8583  read time (timestame)\r\n");
134:                       tReadTimestamp = tPCF8583ReadTime();
135:                       vDeBugPrintStringAndNums("\r\ntimestamp high is ", (unsigned int) (tReadTimestamp >> 16));
136:                       vDeBugPrintStringAndNums("\r\ntimestamp low is ", (unsigned int) tReadTimestamp);
137:                       vDeBugPrintInformation("\r\n");
138:                       vTaskDelay(1000);
139:                       /*endif(TestReadTimestamp == 1)*/
140:               #endif
141:               #if (TestAlarm == 1)
142:                       /*test set alarm by set time*/
143:                       vDeBugPrintInformation("test PCF8583  Alarm time \r\n");
144:                       if (xSemaphoreTake(xSemBinaryAlarm, 0)) {
145:                           /*clear alarm flag*/
146:                           vPCF8583WriteRegister(PCF_CON_STA, PCF_START_VALUE);
147:                           /*calculate new alarm time*/
148:                           tSetAlarmTimestamp += 10;
149:                           vPCF8583SetAlarmTimeByTimestamp(&tSetAlarmTimestamp);
150:                           vDeBugPrintStringAndNums("tSetAlarmTimestamp is ", (unsigned int) tSetAlarmTimestamp);
151:                           vDeBugPrintStringAndNums("tNowTimestamp is ", (unsigned int) tNowTimestamp);
152:                           vTaskDelay(1000);
153:                       }
154:                       /*endif (TestAlarm == 1)*/
155:               #endif
156:               #if (TestWriteReadRegister == 1)
157:                       /**test write read register**/
158:                       vDeBugPrintStringAndNums("PCF_CON_STA is ", HCD(ucPCF8583ReadRegister(PCF_CON_STA)));
159:                       vDeBugPrintStringAndNums("PCF_CON_ALARM is ", HCD(ucPCF8583ReadRegister(PCF_CON_ALARM)));
160:                       vDeBugPrintStringAndNums("PCF_A_SEC_100 is ", HCD(ucPCF8583ReadRegister(PCF_A_SEC_100)));
161:                       vDeBugPrintStringAndNums("PCF_A_SEC is ", HCD(ucPCF8583ReadRegister(PCF_A_SEC)));
162:                       vDeBugPrintStringAndNums("PCF_A_MIN is ", HCD(ucPCF8583ReadRegister(PCF_A_MIN)));
163:                       vDeBugPrintStringAndNums("PCF_A_HOUR is ", HCD(ucPCF8583ReadRegister(PCF_A_HOUR)));
164:                       vDeBugPrintStringAndNums("PCF_A_DAY is ", HCD(ucPCF8583ReadRegister(PCF_A_DAY)));
165:                       vDeBugPrintStringAndNums("PCF_A_MONTH is ", HCD(ucPCF8583ReadRegister(PCF_A_MONTH)));
166:                       vDeBugPrintStringAndNums("PCF_T_SEC_100 is ", HCD(ucPCF8583ReadRegister(PCF_T_SEC_100)));
167:                       vDeBugPrintStringAndNums("PCF_T_SEC is ", HCD(ucPCF8583ReadRegister(PCF_T_SEC)));
168:                       vDeBugPrintStringAndNums("PCF_T_MIN is ", HCD(ucPCF8583ReadRegister(PCF_T_MIN)));
169:                       vDeBugPrintStringAndNums("PCF_T_HOUR is ", HCD(ucPCF8583ReadRegister(PCF_T_HOUR)&0x3F));
170:                       vDeBugPrintStringAndNums("PCF_T_DAY is ", HCD(ucPCF8583ReadRegister(PCF_T_DAY)&0x3F));
171:                       vDeBugPrintStringAndNums("PCF_T_MONTH is ", HCD(ucPCF8583ReadRegister(PCF_T_MONTH)&0x3F));
172:                       vTaskDelay(1000);
173:                       /*endif (TestWriteReadRegister == 1)*/
174:               #endif
175:                   }
176:               }
177:               /*end (DebugPCF8583 == 1)*/
178:               #endif 
179:               
180:               #if (DebugCAT24C512 == 1)
181:               #include "CAT24C512.h"
182:               #include <string.h>
183:               
184:               /*define test cat24C512 function*/
185:               void vTaskTestCAT(void* parameter) {
186:                   unsigned char ucWriteArray[10], ucReadArray[10];
187:                   unsigned char ucCnt;
188:               
189:                   _LATE6 = 1;
190:                   memset(ucReadArray, 10, 0);
191:                   memcpy(ucWriteArray, "1234567890", 10);
192:                   /*initialize CAT24C512,maybe initialize I2C_S*/
193:                   vCAT24Init();
194:               
195:                   for (;;) {
196:               #if  (TestReadByte == 1)
197:                       /*write 1 byte*/
198:                       xCAT24WriteByte(0x0000, ucWriteArray[0]);
199:                       vDeBugPrintStringAndNums("test write byte is ", ucWriteArray[0]);
200:                       vTaskDelay(1000);
201:                       /*read 1 byte*/
202:                       ucReadArray[0] = 0xaa;
203:                       xCAT24ReadByte(0x0000, ucReadArray[0]);
204:                       vDeBugPrintStringAndNums("test read byte is ", ucReadArray[0]);
205:                       /*delay*/
206:                       vTaskDelay(1000);
207:                       /*endif(TestReadByte == 1)*/
208:               #endif
209:               #if (TestReadBytes == 1)
210:                       /*write bytes*/
211:                       vDeBugPrintInformation("test Init readarry :");
212:                       xCAT24WriteBytes(0x000A, ucWriteArray, sizeof (ucWriteArray));
213:                       /*print array of read*/
214:                       memset(ucReadArray, 0xa, sizeof (ucReadArray));
215:                       for (ucCnt = 0; ucCnt<sizeof (ucReadArray); ucCnt++) {
216:                           vDeBugPrintStringAndNums("\t\t", ucReadArray[ucCnt]);
217:                       }
218:                       vTaskDelay(1000);
219:                       /*read bytes*/
220:                       vDeBugPrintInformation("test read bytes :");
221:                       xCAT24ReadBytes(0x000A, ucReadArray, sizeof (ucReadArray));
222:                       /*print array of read*/
223:                       for (ucCnt = 0; ucCnt<sizeof (ucReadArray); ucCnt++) {
224:                           vDeBugPrintStringAndNums("\t\t", ucReadArray[ucCnt]);
225:                       }
226:                       vTaskDelay(1000);
227:                       /*endif (TestReadBytes == 1)*/
228:               #endif  
229:                   }
230:               }
231:               /*endif (DebugCAT24C512==1)*/
232:               #endif 
233:               /*endif ENABLE_DEBUG==1*/
234:               #endif 
235:               
236:               
237:               
238:               
239:               #define tskDebugPCFStack  256
240:               #define tskDebugPCFPriority 4 
241:               
242:               void vDebugTaskHook(void) {
005158  FA0000     LNK #0x0
243:               #if (DebugLCD == 1)
244:                   /*Create Test LCD task*/
245:                   xTaskCreate(vTaskTestLCD, "debug LCD", tskDebugPCFStack, NULL, tskDebugPCFPriority, NULL);
246:                   /*endif (DebugLCD==1)*/
247:               #endif 
248:               #if (DebugPCF8583 == 1)
249:                   /*Create Test PCF8583 task*/
250:                   xTaskCreate(vTaskTestPCF, "debug PCF", tskDebugPCFStack, NULL, tskDebugPCFPriority, NULL);
251:                   /*endif (DebugPCF8583==1)*/
252:               #endif
253:               #if (DebugCAT24C512 == 1)
254:                   /*Create Test CAT24C512 task*/
255:                   xTaskCreate(vTaskTestCAT, "debug CAT", tskDebugPCFStack, NULL, tskDebugPCFPriority, NULL);
256:                   /*endif (DebugCAT24C512 == 1)*/
257:               #endif
258:               }
00515A  FA8000     ULNK
00515C  060000     RETURN
259:               
260:               
---  /home/zxc/Documents/WCGRTOS/Demo/Common/Minimal/integer.c  -----------------------------------------
1:                 /*
2:                     FreeRTOS V9.0.0 - Copyright (C) 2016 Real Time Engineers Ltd.
3:                     All rights reserved
4:                 
5:                     VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
6:                 
7:                     This file is part of the FreeRTOS distribution.
8:                 
9:                     FreeRTOS is free software; you can redistribute it and/or modify it under
10:                    the terms of the GNU General Public License (version 2) as published by the
11:                    Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
12:                
13:                    ***************************************************************************
14:                    >>!   NOTE: The modification to the GPL is included to allow you to     !<<
15:                    >>!   distribute a combined work that includes FreeRTOS without being   !<<
16:                    >>!   obliged to provide the source code for proprietary components     !<<
17:                    >>!   outside of the FreeRTOS kernel.                                   !<<
18:                    ***************************************************************************
19:                
20:                    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
21:                    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
22:                    FOR A PARTICULAR PURPOSE.  Full license text is available on the following
23:                    link: http://www.freertos.org/a00114.html
24:                
25:                    ***************************************************************************
26:                     *                                                                       *
27:                     *    FreeRTOS provides completely free yet professionally developed,    *
28:                     *    robust, strictly quality controlled, supported, and cross          *
29:                     *    platform software that is more than just the market leader, it     *
30:                     *    is the industry's de facto standard.                               *
31:                     *                                                                       *
32:                     *    Help yourself get started quickly while simultaneously helping     *
33:                     *    to support the FreeRTOS project by purchasing a FreeRTOS           *
34:                     *    tutorial book, reference manual, or both:                          *
35:                     *    http://www.FreeRTOS.org/Documentation                              *
36:                     *                                                                       *
37:                    ***************************************************************************
38:                
39:                    http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
40:                    the FAQ page "My application does not run, what could be wrong?".  Have you
41:                    defined configASSERT()?
42:                
43:                    http://www.FreeRTOS.org/support - In return for receiving this top quality
44:                    embedded software for free we request you assist our global community by
45:                    participating in the support forum.
46:                
47:                    http://www.FreeRTOS.org/training - Investing in training allows your team to
48:                    be as productive as possible as early as possible.  Now you can receive
49:                    FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
50:                    Ltd, and the world's leading authority on the world's leading RTOS.
51:                
52:                    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
53:                    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
54:                    compatible FAT file system, and our tiny thread aware UDP/IP stack.
55:                
56:                    http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
57:                    Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
58:                
59:                    http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
60:                    Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
61:                    licenses offer ticketed support, indemnification and commercial middleware.
62:                
63:                    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
64:                    engineered and independently SIL3 certified version for use in safety and
65:                    mission critical applications that require provable dependability.
66:                
67:                    1 tab == 4 spaces!
68:                */
69:                
70:                /*
71:                 * Creates one or more tasks that repeatedly perform a set of integer
72:                 * calculations.  The result of each run-time calculation is compared to the 
73:                 * known expected result - with a mismatch being indicative of an error in the
74:                 * context switch mechanism.
75:                 */
76:                
77:                #include <stdlib.h>
78:                
79:                /* Scheduler include files. */
80:                #include "FreeRTOS.h"
81:                #include "task.h"
82:                
83:                /* Demo program include files. */
84:                #include "integer.h"
85:                
86:                /* The constants used in the calculation. */
87:                #define intgCONST1				( ( long ) 123 )
88:                #define intgCONST2				( ( long ) 234567 )
89:                #define intgCONST3				( ( long ) -3 )
90:                #define intgCONST4				( ( long ) 7 )
91:                #define intgEXPECTED_ANSWER		( ( ( intgCONST1 + intgCONST2 ) * intgCONST3 ) / intgCONST4 )
92:                
93:                #define intgSTACK_SIZE			configMINIMAL_STACK_SIZE
94:                
95:                /* As this is the minimal version, we will only create one task. */
96:                #define intgNUMBER_OF_TASKS		( 1 )
97:                
98:                /* The task function.  Repeatedly performs a 32 bit calculation, checking the
99:                result against the expected result.  If the result is incorrect then the
100:               context switch must have caused some corruption. */
101:               static portTASK_FUNCTION_PROTO( vCompeteingIntMathTask, pvParameters );
102:               
103:               /* Variables that are set to true within the calculation task to indicate
104:               that the task is still executing.  The check task sets the variable back to
105:               false, flagging an error if the variable is still false the next time it
106:               is called. */
107:               static volatile BaseType_t xTaskCheck[ intgNUMBER_OF_TASKS ] = { ( BaseType_t ) pdFALSE };
108:               
109:               /*-----------------------------------------------------------*/
110:               
111:               void vStartIntegerMathTasks( UBaseType_t uxPriority )
112:               {
004B2A  FA0004     LNK #0x4
004B2C  980710     MOV W0, [W14+2]
113:               short sTask;
114:               
115:               	for( sTask = 0; sTask < intgNUMBER_OF_TASKS; sTask++ )
004B2E  EB0000     CLR W0
004B30  780F00     MOV W0, [W14]
004B32  37000E     BRA .L2
004B4E  E80F1E     INC [W14], [W14]
004B50  78001E     MOV [W14], W0
004B52  E00000     CP0 W0
004B54  34FFEF     BRA LE, .L3
116:               	{
117:               		xTaskCreate( vCompeteingIntMathTask, "IntMath", intgSTACK_SIZE, ( void * ) &( xTaskCheck[ sTask ] ), uxPriority, ( TaskHandle_t * ) NULL );
004B34  78001E     MOV [W14], W0
004B36  400000     ADD W0, W0, W0
004B38  780080     MOV W0, W1
004B3A  208B00     MOV #0x8B0, W0
004B3C  408000     ADD W1, W0, W0
004B3E  EB0280     CLR W5
004B40  90021E     MOV [W14+2], W4
004B42  780180     MOV W0, W3
004B44  200732     MOV #0x73, W2
004B46  290DE1     MOV #0x90DE, W1
004B48  24B5A0     MOV #0x4B5A, W0
004B4A  0210E8     CALL xTaskCreate
004B4C  000000     NOP
118:               	}
119:               }
004B56  FA8000     ULNK
004B58  060000     RETURN
120:               /*-----------------------------------------------------------*/
121:               
122:               static portTASK_FUNCTION( vCompeteingIntMathTask, pvParameters )
123:               {
004B5A  FA000A     LNK #0xA
004B5C  980740     MOV W0, [W14+8]
124:               /* These variables are all effectively set to constants so they are volatile to
125:               ensure the compiler does not just get rid of them. */
126:               volatile long lValue;
127:               short sError = pdFALSE;
004B5E  EB0000     CLR W0
004B60  780F00     MOV W0, [W14]
128:               volatile BaseType_t *pxTaskHasExecuted;
129:               
130:               	/* Set a pointer to the variable we are going to set to true each
131:               	iteration.  This is also a good test of the parameter passing mechanism
132:               	within each port. */
133:               	pxTaskHasExecuted = ( volatile BaseType_t * ) pvParameters;
004B62  9000CE     MOV [W14+8], W1
004B64  980711     MOV W1, [W14+2]
004B66  370001     BRA .L7
134:               
135:               	/* Keep performing a calculation and checking the result against a constant. */
136:               	for( ;; )
137:               	{
138:               		/* Perform the calculation.  This will store partial value in
139:               		registers, resulting in a good test of the context switch mechanism. */
140:               		lValue = intgCONST1;
004B6A  2007B0     MOV #0x7B, W0
004B6C  200001     MOV #0x0, W1
004B6E  980720     MOV W0, [W14+4]
004B70  980731     MOV W1, [W14+6]
141:               		lValue += intgCONST2;
004B72  90012E     MOV [W14+4], W2
004B74  9001BE     MOV [W14+6], W3
004B76  294470     MOV #0x9447, W0
004B78  200031     MOV #0x3, W1
004B7A  400002     ADD W0, W2, W0
004B7C  488083     ADDC W1, W3, W1
004B7E  980720     MOV W0, [W14+4]
004B80  980731     MOV W1, [W14+6]
142:               
143:               		/* Yield in case cooperative scheduling is being used. */
144:               		#if configUSE_PREEMPTION == 0
145:               		{
146:               			taskYIELD();
147:               		}
148:               		#endif
149:               
150:               		/* Finish off the calculation. */
151:               		lValue *= intgCONST3;
004B82  90002E     MOV [W14+4], W0
004B84  9000BE     MOV [W14+6], W1
004B86  2FFFD2     MOV #0xFFFD, W2
004B88  B98902     MUL.SS W1, W2, W2
004B8A  780102     MOV W2, W2
004B8C  EB8180     SETM W3
004B8E  B98203     MUL.SS W0, W3, W4
004B90  780184     MOV W4, W3
004B92  410103     ADD W2, W3, W2
004B94  2FFFD3     MOV #0xFFFD, W3
004B96  B80003     MUL.UU W0, W3, W0
004B98  410101     ADD W2, W1, W2
004B9A  780082     MOV W2, W1
004B9C  980720     MOV W0, [W14+4]
004B9E  980731     MOV W1, [W14+6]
152:               		lValue /= intgCONST4;
004BA0  90002E     MOV [W14+4], W0
004BA2  9000BE     MOV [W14+6], W1
004BA4  200072     MOV #0x7, W2
004BA6  200003     MOV #0x0, W3
004BA8  020682     CALL ___divsi3
004BAA  000000     NOP
004BAC  980720     MOV W0, [W14+4]
004BAE  980731     MOV W1, [W14+6]
153:               
154:               		/* If the calculation is found to be incorrect we stop setting the 
155:               		TaskHasExecuted variable so the check task can see an error has 
156:               		occurred. */
157:               		if( lValue != intgEXPECTED_ANSWER ) /*lint !e774 volatile used to prevent this being optimised out. */
004BB0  90012E     MOV [W14+4], W2
004BB2  9001BE     MOV [W14+6], W3
004BB4  2771B0     MOV #0x771B, W0
004BB6  2FFFE1     MOV #0xFFFE, W1
004BB8  510F80     SUB W2, W0, [W15]
004BBA  598F81     SUBB W3, W1, [W15]
004BBC  320002     BRA Z, .L5
158:               		{
159:               			sError = pdTRUE;
004BBE  200010     MOV #0x1, W0
004BC0  780F00     MOV W0, [W14]
160:               		}
161:               
162:               		if( sError == pdFALSE )
004BC2  78001E     MOV [W14], W0
004BC4  E00000     CP0 W0
004BC6  3AFFD0     BRA NZ, .L8
163:               		{
164:               			/* We have not encountered any errors, so set the flag that show
165:               			we are still executing.  This will be periodically cleared by
166:               			the check task. */
167:               			portENTER_CRITICAL();
004BC8  0248DA     CALL vPortEnterCritical
004BCA  000000     NOP
168:               				*pxTaskHasExecuted = pdTRUE;
004BCC  90001E     MOV [W14+2], W0
004BCE  200011     MOV #0x1, W1
004BD0  780801     MOV W1, [W0]
169:               			portEXIT_CRITICAL();
004BD2  0248F4     CALL vPortExitCritical
004BD4  000000     NOP
170:               		}
171:               
172:               		/* Yield in case cooperative scheduling is being used. */
173:               		#if configUSE_PREEMPTION == 0
174:               		{
175:               			taskYIELD();
176:               		}
177:               		#endif
178:               	}
004B68  000000     NOP
004BD6  37FFC9     BRA .L7
179:               }
180:               /*-----------------------------------------------------------*/
181:               
182:               /* This is called to check that all the created tasks are still running. */
183:               BaseType_t xAreIntegerMathsTaskStillRunning( void )
184:               {
004BD8  FA0004     LNK #0x4
185:               BaseType_t xReturn = pdTRUE;
004BDA  200010     MOV #0x1, W0
004BDC  780F00     MOV W0, [W14]
186:               short sTask;
187:               
188:               	/* Check the maths tasks are still running by ensuring their check variables 
189:               	are still being set to true. */
190:               	for( sTask = 0; sTask < intgNUMBER_OF_TASKS; sTask++ )
004BDE  EB0000     CLR W0
004BE0  980710     MOV W0, [W14+2]
004BE2  370012     BRA .L10
004C02  90001E     MOV [W14+2], W0
004C04  E80000     INC W0, W0
004C06  980710     MOV W0, [W14+2]
004C08  90001E     MOV [W14+2], W0
004C0A  E00000     CP0 W0
004C0C  34FFEB     BRA LE, .L12
191:               	{
192:               		if( xTaskCheck[ sTask ] == pdFALSE )
004BE4  90001E     MOV [W14+2], W0
004BE6  400080     ADD W0, W0, W1
004BE8  208B00     MOV #0x8B0, W0
004BEA  408000     ADD W1, W0, W0
004BEC  780010     MOV [W0], W0
004BEE  E00000     CP0 W0
004BF0  3A0002     BRA NZ, .L11
193:               		{
194:               			/* The check has not incremented so an error exists. */
195:               			xReturn = pdFALSE;
004BF2  EB0000     CLR W0
004BF4  780F00     MOV W0, [W14]
196:               		}
197:               
198:               		/* Reset the check variable so we can tell if it has been set by
199:               		the next time around. */
200:               		xTaskCheck[ sTask ] = pdFALSE;
004BF6  90001E     MOV [W14+2], W0
004BF8  400080     ADD W0, W0, W1
004BFA  208B00     MOV #0x8B0, W0
004BFC  408000     ADD W1, W0, W0
004BFE  EB0080     CLR W1
004C00  780801     MOV W1, [W0]
201:               	}
202:               
203:               	return xReturn;
004C0E  78001E     MOV [W14], W0
204:               }
004C10  FA8000     ULNK
004C12  060000     RETURN
205:               
---  /home/zxc/Documents/WCGRTOS/Demo/Common/Minimal/blocktim.c  ----------------------------------------
1:                 /*
2:                     FreeRTOS V9.0.0 - Copyright (C) 2016 Real Time Engineers Ltd.
3:                     All rights reserved
4:                 
5:                     VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
6:                 
7:                     This file is part of the FreeRTOS distribution.
8:                 
9:                     FreeRTOS is free software; you can redistribute it and/or modify it under
10:                    the terms of the GNU General Public License (version 2) as published by the
11:                    Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
12:                
13:                    ***************************************************************************
14:                    >>!   NOTE: The modification to the GPL is included to allow you to     !<<
15:                    >>!   distribute a combined work that includes FreeRTOS without being   !<<
16:                    >>!   obliged to provide the source code for proprietary components     !<<
17:                    >>!   outside of the FreeRTOS kernel.                                   !<<
18:                    ***************************************************************************
19:                
20:                    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
21:                    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
22:                    FOR A PARTICULAR PURPOSE.  Full license text is available on the following
23:                    link: http://www.freertos.org/a00114.html
24:                
25:                    ***************************************************************************
26:                     *                                                                       *
27:                     *    FreeRTOS provides completely free yet professionally developed,    *
28:                     *    robust, strictly quality controlled, supported, and cross          *
29:                     *    platform software that is more than just the market leader, it     *
30:                     *    is the industry's de facto standard.                               *
31:                     *                                                                       *
32:                     *    Help yourself get started quickly while simultaneously helping     *
33:                     *    to support the FreeRTOS project by purchasing a FreeRTOS           *
34:                     *    tutorial book, reference manual, or both:                          *
35:                     *    http://www.FreeRTOS.org/Documentation                              *
36:                     *                                                                       *
37:                    ***************************************************************************
38:                
39:                    http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
40:                    the FAQ page "My application does not run, what could be wrong?".  Have you
41:                    defined configASSERT()?
42:                
43:                    http://www.FreeRTOS.org/support - In return for receiving this top quality
44:                    embedded software for free we request you assist our global community by
45:                    participating in the support forum.
46:                
47:                    http://www.FreeRTOS.org/training - Investing in training allows your team to
48:                    be as productive as possible as early as possible.  Now you can receive
49:                    FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
50:                    Ltd, and the world's leading authority on the world's leading RTOS.
51:                
52:                    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
53:                    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
54:                    compatible FAT file system, and our tiny thread aware UDP/IP stack.
55:                
56:                    http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
57:                    Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
58:                
59:                    http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
60:                    Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
61:                    licenses offer ticketed support, indemnification and commercial middleware.
62:                
63:                    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
64:                    engineered and independently SIL3 certified version for use in safety and
65:                    mission critical applications that require provable dependability.
66:                
67:                    1 tab == 4 spaces!
68:                */
69:                
70:                /*
71:                 * This file contains some test scenarios that ensure tasks do not exit queue
72:                 * send or receive functions prematurely.  A description of the tests is
73:                 * included within the code.
74:                 */
75:                
76:                /* Kernel includes. */
77:                #include "FreeRTOS.h"
78:                #include "task.h"
79:                #include "queue.h"
80:                
81:                /* Demo includes. */
82:                #include "blocktim.h"
83:                
84:                /* Task priorities.  Allow these to be overridden. */
85:                #ifndef bktPRIMARY_PRIORITY
86:                	#define bktPRIMARY_PRIORITY		( configMAX_PRIORITIES - 3 )
87:                #endif
88:                
89:                #ifndef bktSECONDARY_PRIORITY
90:                	#define bktSECONDARY_PRIORITY	( configMAX_PRIORITIES - 4 )
91:                #endif
92:                
93:                /* Task behaviour. */
94:                #define bktQUEUE_LENGTH				( 5 )
95:                #define bktSHORT_WAIT				pdMS_TO_TICKS( ( TickType_t ) 20 )
96:                #define bktPRIMARY_BLOCK_TIME		( 10 )
97:                #define bktALLOWABLE_MARGIN			( 15 )
98:                #define bktTIME_TO_BLOCK			( 175 )
99:                #define bktDONT_BLOCK				( ( TickType_t ) 0 )
100:               #define bktRUN_INDICATOR			( ( UBaseType_t ) 0x55 )
101:               
102:               /* In case the demo does not have software timers enabled, as this file uses
103:               the configTIMER_TASK_PRIORITY setting. */
104:               #ifndef configTIMER_TASK_PRIORITY
105:               	#define configTIMER_TASK_PRIORITY ( configMAX_PRIORITIES - 1 )
106:               #endif
107:               
108:               /*-----------------------------------------------------------*/
109:               
110:               /*
111:                * The two test tasks.  Their behaviour is commented within the functions.
112:                */
113:               static void vPrimaryBlockTimeTestTask( void *pvParameters );
114:               static void vSecondaryBlockTimeTestTask( void *pvParameters );
115:               
116:               /*
117:                * Very basic tests to verify the block times are as expected.
118:                */
119:               static void prvBasicDelayTests( void );
120:               
121:               /*-----------------------------------------------------------*/
122:               
123:               /* The queue on which the tasks block. */
124:               static QueueHandle_t xTestQueue;
125:               
126:               /* Handle to the secondary task is required by the primary task for calls
127:               to vTaskSuspend/Resume(). */
128:               static TaskHandle_t xSecondary;
129:               
130:               /* Used to ensure that tasks are still executing without error. */
131:               static volatile BaseType_t xPrimaryCycles = 0, xSecondaryCycles = 0;
132:               static volatile BaseType_t xErrorOccurred = pdFALSE;
133:               
134:               /* Provides a simple mechanism for the primary task to know when the
135:               secondary task has executed. */
136:               static volatile UBaseType_t xRunIndicator;
137:               
138:               /*-----------------------------------------------------------*/
139:               
140:               void vCreateBlockTimeTasks( void )
141:               {
003014  FA0000     LNK #0x0
142:               	/* Create the queue on which the two tasks block. */
143:               	xTestQueue = xQueueCreate( bktQUEUE_LENGTH, sizeof( BaseType_t ) );
003016  EB4100     CLR.B W2
003018  200021     MOV #0x2, W1
00301A  200050     MOV #0x5, W0
00301C  02207C     CALL xQueueGenericCreate
00301E  000000     NOP
003020  884370     MOV W0, xTestQueue
144:               
145:               	if( xTestQueue != NULL )
003022  804370     MOV xTestQueue, W0
003024  E00000     CP0 W0
003026  320010     BRA Z, .L1
146:               	{
147:               		/* vQueueAddToRegistry() adds the queue to the queue registry, if one
148:               		is in use.  The queue registry is provided as a means for kernel aware
149:               		debuggers to locate queues and has no purpose if a kernel aware
150:               		debugger is not being used.  The call to vQueueAddToRegistry() will be
151:               		removed by the pre-processor if configQUEUE_REGISTRY_SIZE is not
152:               		defined or is defined to be less than 1. */
153:               		vQueueAddToRegistry( xTestQueue, "Block_Time_Queue" );
154:               
155:               		/* Create the two test tasks. */
156:               		xTaskCreate( vPrimaryBlockTimeTestTask, "BTest1", configMINIMAL_STACK_SIZE, NULL, bktPRIMARY_PRIORITY, NULL );
003028  EB0280     CLR W5
00302A  200014     MOV #0x1, W4
00302C  EB0180     CLR W3
00302E  200732     MOV #0x73, W2
003030  290D01     MOV #0x90D0, W1
003032  2304C0     MOV #0x304C, W0
003034  0210E8     CALL xTaskCreate
003036  000000     NOP
157:               		xTaskCreate( vSecondaryBlockTimeTestTask, "BTest2", configMINIMAL_STACK_SIZE, NULL, bktSECONDARY_PRIORITY, &xSecondary );
003038  208705     MOV #0x870, W5
00303A  EB0200     CLR W4
00303C  EB0180     CLR W3
00303E  200732     MOV #0x73, W2
003040  290D71     MOV #0x90D7, W1
003042  232820     MOV #0x3282, W0
003044  0210E8     CALL xTaskCreate
003046  000000     NOP
158:               	}
159:               }
003048  FA8000     ULNK
00304A  060000     RETURN
160:               /*-----------------------------------------------------------*/
161:               
162:               static void vPrimaryBlockTimeTestTask( void *pvParameters )
163:               {
00304C  FA000C     LNK #0xC
164:               BaseType_t xItem, xData;
165:               TickType_t xTimeWhenBlocking;
166:               TickType_t xTimeToBlock, xBlockedTime;
167:               
168:               	( void ) pvParameters;
169:               
170:               	for( ;; )
171:               	{
172:               		/*********************************************************************
173:               		Test 0
174:               
175:               		Basic vTaskDelay() and vTaskDelayUntil() tests. */
176:               		prvBasicDelayTests();
00304E  980750     MOV W0, [W14+10]
003050  070168     RCALL _prvBasicDelayTests, .LFE2, .LFB3
177:               
178:               
179:               		/*********************************************************************
180:               		Test 1
181:               
182:               		Simple block time wakeup test on queue receives. */
183:               		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
003052  EB0000     CLR W0
003054  980730     MOV W0, [W14+6]
003056  370025     BRA .L4
00309C  90003E     MOV [W14+6], W0
00309E  E80000     INC W0, W0
0030A0  980730     MOV W0, [W14+6]
0030A2  90003E     MOV [W14+6], W0
0030A4  500FE4     SUB W0, #0x4, [W15]
0030A6  34FFD8     BRA LE, .L8
184:               		{
185:               			/* The queue is empty. Attempt to read from the queue using a block
186:               			time.  When we wake, ensure the delta in time is as expected. */
187:               			xTimeToBlock = ( TickType_t ) ( bktPRIMARY_BLOCK_TIME << xItem );
003058  90003E     MOV [W14+6], W0
00305A  2000A1     MOV #0xA, W1
00305C  DD0800     SL W1, W0, W0
00305E  780F00     MOV W0, [W14]
188:               
189:               			xTimeWhenBlocking = xTaskGetTickCount();
003060  02171E     CALL xTaskGetTickCount
003062  000000     NOP
003064  980710     MOV W0, [W14+2]
190:               
191:               			/* We should unblock after xTimeToBlock having not received
192:               			anything on the queue. */
193:               			if( xQueueReceive( xTestQueue, &xData, xTimeToBlock ) != errQUEUE_EMPTY )
003066  804370     MOV xTestQueue, W0
003068  4700E8     ADD W14, #0x8, W1
00306A  EB0180     CLR W3
00306C  78011E     MOV [W14], W2
00306E  0222D4     CALL xQueueGenericReceive
003070  000000     NOP
003072  E00000     CP0 W0
003074  320002     BRA Z, .L5
194:               			{
195:               				xErrorOccurred = pdTRUE;
003076  200010     MOV #0x1, W0
003078  8843B0     MOV W0, xErrorOccurred
196:               			}
197:               
198:               			/* How long were we blocked for? */
199:               			xBlockedTime = xTaskGetTickCount() - xTimeWhenBlocking;
00307A  02171E     CALL xTaskGetTickCount
00307C  000000     NOP
00307E  90009E     MOV [W14+2], W1
003080  500001     SUB W0, W1, W0
003082  980720     MOV W0, [W14+4]
200:               
201:               			if( xBlockedTime < xTimeToBlock )
003084  90002E     MOV [W14+4], W0
003086  500F9E     SUB W0, [W14], [W15]
003088  310002     BRA C, .L6
202:               			{
203:               				/* Should not have blocked for less than we requested. */
204:               				xErrorOccurred = pdTRUE;
00308A  200010     MOV #0x1, W0
00308C  8843B0     MOV W0, xErrorOccurred
205:               			}
206:               
207:               			if( xBlockedTime > ( xTimeToBlock + bktALLOWABLE_MARGIN ) )
00308E  78011E     MOV [W14], W2
003090  4100EF     ADD W2, #0xF, W1
003092  90002E     MOV [W14+4], W0
003094  508F80     SUB W1, W0, [W15]
003096  310002     BRA C, .L7
208:               			{
209:               				/* Should not have blocked for longer than we requested,
210:               				although we would not necessarily run as soon as we were
211:               				unblocked so a margin is allowed. */
212:               				xErrorOccurred = pdTRUE;
003098  200010     MOV #0x1, W0
00309A  8843B0     MOV W0, xErrorOccurred
213:               			}
214:               		}
215:               
216:               		/*********************************************************************
217:               		Test 2
218:               
219:               		Simple block time wakeup test on queue sends.
220:               
221:               		First fill the queue.  It should be empty so all sends should pass. */
222:               		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
0030A8  EB0000     CLR W0
0030AA  980730     MOV W0, [W14+6]
0030AC  37000D     BRA .L9
0030C2  90003E     MOV [W14+6], W0
0030C4  E80000     INC W0, W0
0030C6  980730     MOV W0, [W14+6]
0030C8  90003E     MOV [W14+6], W0
0030CA  500FE4     SUB W0, #0x4, [W15]
0030CC  34FFF0     BRA LE, .L11
223:               		{
224:               			if( xQueueSend( xTestQueue, &xItem, bktDONT_BLOCK ) != pdPASS )
0030AE  804370     MOV xTestQueue, W0
0030B0  4700E6     ADD W14, #0x6, W1
0030B2  EB0180     CLR W3
0030B4  EB0100     CLR W2
0030B6  0220F8     CALL xQueueGenericSend
0030B8  000000     NOP
0030BA  500FE1     SUB W0, #0x1, [W15]
0030BC  320002     BRA Z, .L10
225:               			{
226:               				xErrorOccurred = pdTRUE;
0030BE  200010     MOV #0x1, W0
0030C0  8843B0     MOV W0, xErrorOccurred
227:               			}
228:               
229:               			#if configUSE_PREEMPTION == 0
230:               				taskYIELD();
231:               			#endif
232:               		}
233:               
234:               		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
0030CE  EB0000     CLR W0
0030D0  980730     MOV W0, [W14+6]
0030D2  370025     BRA .L12
003118  90003E     MOV [W14+6], W0
00311A  E80000     INC W0, W0
00311C  980730     MOV W0, [W14+6]
00311E  90003E     MOV [W14+6], W0
003120  500FE4     SUB W0, #0x4, [W15]
003122  34FFD8     BRA LE, .L16
235:               		{
236:               			/* The queue is full. Attempt to write to the queue using a block
237:               			time.  When we wake, ensure the delta in time is as expected. */
238:               			xTimeToBlock = ( TickType_t ) ( bktPRIMARY_BLOCK_TIME << xItem );
0030D4  90003E     MOV [W14+6], W0
0030D6  2000A1     MOV #0xA, W1
0030D8  DD0800     SL W1, W0, W0
0030DA  780F00     MOV W0, [W14]
239:               
240:               			xTimeWhenBlocking = xTaskGetTickCount();
0030DC  02171E     CALL xTaskGetTickCount
0030DE  000000     NOP
0030E0  980710     MOV W0, [W14+2]
241:               
242:               			/* We should unblock after xTimeToBlock having not received
243:               			anything on the queue. */
244:               			if( xQueueSend( xTestQueue, &xItem, xTimeToBlock ) != errQUEUE_FULL )
0030E2  804370     MOV xTestQueue, W0
0030E4  4700E6     ADD W14, #0x6, W1
0030E6  EB0180     CLR W3
0030E8  78011E     MOV [W14], W2
0030EA  0220F8     CALL xQueueGenericSend
0030EC  000000     NOP
0030EE  E00000     CP0 W0
0030F0  320002     BRA Z, .L13
245:               			{
246:               				xErrorOccurred = pdTRUE;
0030F2  200010     MOV #0x1, W0
0030F4  8843B0     MOV W0, xErrorOccurred
247:               			}
248:               
249:               			/* How long were we blocked for? */
250:               			xBlockedTime = xTaskGetTickCount() - xTimeWhenBlocking;
0030F6  02171E     CALL xTaskGetTickCount
0030F8  000000     NOP
0030FA  90009E     MOV [W14+2], W1
0030FC  500001     SUB W0, W1, W0
0030FE  980720     MOV W0, [W14+4]
251:               
252:               			if( xBlockedTime < xTimeToBlock )
003100  90002E     MOV [W14+4], W0
003102  500F9E     SUB W0, [W14], [W15]
003104  310002     BRA C, .L14
253:               			{
254:               				/* Should not have blocked for less than we requested. */
255:               				xErrorOccurred = pdTRUE;
003106  200010     MOV #0x1, W0
003108  8843B0     MOV W0, xErrorOccurred
256:               			}
257:               
258:               			if( xBlockedTime > ( xTimeToBlock + bktALLOWABLE_MARGIN ) )
00310A  78011E     MOV [W14], W2
00310C  4100EF     ADD W2, #0xF, W1
00310E  90002E     MOV [W14+4], W0
003110  508F80     SUB W1, W0, [W15]
003112  310002     BRA C, .L15
259:               			{
260:               				/* Should not have blocked for longer than we requested,
261:               				although we would not necessarily run as soon as we were
262:               				unblocked so a margin is allowed. */
263:               				xErrorOccurred = pdTRUE;
003114  200010     MOV #0x1, W0
003116  8843B0     MOV W0, xErrorOccurred
264:               			}
265:               		}
266:               
267:               		/*********************************************************************
268:               		Test 3
269:               
270:               		Wake the other task, it will block attempting to post to the queue.
271:               		When we read from the queue the other task will wake, but before it
272:               		can run we will post to the queue again.  When the other task runs it
273:               		will find the queue still full, even though it was woken.  It should
274:               		recognise that its block time has not expired and return to block for
275:               		the remains of its block time.
276:               
277:               		Wake the other task so it blocks attempting to post to the already
278:               		full queue. */
279:               		xRunIndicator = 0;
003124  EF2878     CLR xRunIndicator
280:               		vTaskResume( xSecondary );
003126  804380     MOV xSecondary, W0
003128  021536     CALL vTaskResume
00312A  000000     NOP
281:               
282:               		/* We need to wait a little to ensure the other task executes. */
283:               		while( xRunIndicator != bktRUN_INDICATOR )
00312C  370003     BRA .L17
003134  8043C1     MOV xRunIndicator, W1
003136  200550     MOV #0x55, W0
003138  508F80     SUB W1, W0, [W15]
00313A  3AFFF9     BRA NZ, .L18
284:               		{
285:               			/* The other task has not yet executed. */
286:               			vTaskDelay( bktSHORT_WAIT );
00312E  200140     MOV #0x14, W0
003130  021398     CALL vTaskDelay
003132  000000     NOP
287:               		}
288:               		/* Make sure the other task is blocked on the queue. */
289:               		vTaskDelay( bktSHORT_WAIT );
00313C  200140     MOV #0x14, W0
00313E  021398     CALL vTaskDelay
003140  000000     NOP
290:               		xRunIndicator = 0;
003142  EF2878     CLR xRunIndicator
291:               
292:               		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
003144  EB0000     CLR W0
003146  980730     MOV W0, [W14+6]
003148  37002B     BRA .L19
00319A  90003E     MOV [W14+6], W0
00319C  E80000     INC W0, W0
00319E  980730     MOV W0, [W14+6]
0031A0  90003E     MOV [W14+6], W0
0031A2  500FE4     SUB W0, #0x4, [W15]
0031A4  34FFD2     BRA LE, .L24
293:               		{
294:               			/* Now when we make space on the queue the other task should wake
295:               			but not execute as this task has higher priority. */
296:               			if( xQueueReceive( xTestQueue, &xData, bktDONT_BLOCK ) != pdPASS )
00314A  804370     MOV xTestQueue, W0
00314C  4700E8     ADD W14, #0x8, W1
00314E  EB0180     CLR W3
003150  EB0100     CLR W2
003152  0222D4     CALL xQueueGenericReceive
003154  000000     NOP
003156  500FE1     SUB W0, #0x1, [W15]
003158  320002     BRA Z, .L20
297:               			{
298:               				xErrorOccurred = pdTRUE;
00315A  200010     MOV #0x1, W0
00315C  8843B0     MOV W0, xErrorOccurred
299:               			}
300:               
301:               			/* Now fill the queue again before the other task gets a chance to
302:               			execute.  If the other task had executed we would find the queue
303:               			full ourselves, and the other task have set xRunIndicator. */
304:               			if( xQueueSend( xTestQueue, &xItem, bktDONT_BLOCK ) != pdPASS )
00315E  804370     MOV xTestQueue, W0
003160  4700E6     ADD W14, #0x6, W1
003162  EB0180     CLR W3
003164  EB0100     CLR W2
003166  0220F8     CALL xQueueGenericSend
003168  000000     NOP
00316A  500FE1     SUB W0, #0x1, [W15]
00316C  320002     BRA Z, .L21
305:               			{
306:               				xErrorOccurred = pdTRUE;
00316E  200010     MOV #0x1, W0
003170  8843B0     MOV W0, xErrorOccurred
307:               			}
308:               
309:               			if( xRunIndicator == bktRUN_INDICATOR )
003172  8043C1     MOV xRunIndicator, W1
003174  200550     MOV #0x55, W0
003176  508F80     SUB W1, W0, [W15]
003178  3A0002     BRA NZ, .L22
310:               			{
311:               				/* The other task should not have executed. */
312:               				xErrorOccurred = pdTRUE;
00317A  200010     MOV #0x1, W0
00317C  8843B0     MOV W0, xErrorOccurred
313:               			}
314:               
315:               			/* Raise the priority of the other task so it executes and blocks
316:               			on the queue again. */
317:               			vTaskPrioritySet( xSecondary, bktPRIMARY_PRIORITY + 2 );
00317E  804380     MOV xSecondary, W0
003180  200031     MOV #0x3, W1
003182  0213C2     CALL vTaskPrioritySet
003184  000000     NOP
318:               
319:               			/* The other task should now have re-blocked without exiting the
320:               			queue function. */
321:               			if( xRunIndicator == bktRUN_INDICATOR )
003186  8043C1     MOV xRunIndicator, W1
003188  200550     MOV #0x55, W0
00318A  508F80     SUB W1, W0, [W15]
00318C  3A0002     BRA NZ, .L23
322:               			{
323:               				/* The other task should not have executed outside of the
324:               				queue function. */
325:               				xErrorOccurred = pdTRUE;
00318E  200010     MOV #0x1, W0
003190  8843B0     MOV W0, xErrorOccurred
326:               			}
327:               
328:               			/* Set the priority back down. */
329:               			vTaskPrioritySet( xSecondary, bktSECONDARY_PRIORITY );
003192  804380     MOV xSecondary, W0
003194  EB0080     CLR W1
003196  0213C2     CALL vTaskPrioritySet
003198  000000     NOP
330:               		}
331:               
332:               		/* Let the other task timeout.  When it unblockes it will check that it
333:               		unblocked at the correct time, then suspend itself. */
334:               		while( xRunIndicator != bktRUN_INDICATOR )
0031A6  370003     BRA .L25
0031AE  8043C1     MOV xRunIndicator, W1
0031B0  200550     MOV #0x55, W0
0031B2  508F80     SUB W1, W0, [W15]
0031B4  3AFFF9     BRA NZ, .L26
335:               		{
336:               			vTaskDelay( bktSHORT_WAIT );
0031A8  200140     MOV #0x14, W0
0031AA  021398     CALL vTaskDelay
0031AC  000000     NOP
337:               		}
338:               		vTaskDelay( bktSHORT_WAIT );
0031B6  200140     MOV #0x14, W0
0031B8  021398     CALL vTaskDelay
0031BA  000000     NOP
339:               		xRunIndicator = 0;
0031BC  EF2878     CLR xRunIndicator
340:               
341:               
342:               		/*********************************************************************
343:               		Test 4
344:               
345:               		As per test 3 - but with the send and receive the other way around.
346:               		The other task blocks attempting to read from the queue.
347:               
348:               		Empty the queue.  We should find that it is full. */
349:               		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
0031BE  EB0000     CLR W0
0031C0  980730     MOV W0, [W14+6]
0031C2  37000D     BRA .L27
0031D8  90003E     MOV [W14+6], W0
0031DA  E80000     INC W0, W0
0031DC  980730     MOV W0, [W14+6]
0031DE  90003E     MOV [W14+6], W0
0031E0  500FE4     SUB W0, #0x4, [W15]
0031E2  34FFF0     BRA LE, .L29
350:               		{
351:               			if( xQueueReceive( xTestQueue, &xData, bktDONT_BLOCK ) != pdPASS )
0031C4  804370     MOV xTestQueue, W0
0031C6  4700E8     ADD W14, #0x8, W1
0031C8  EB0180     CLR W3
0031CA  EB0100     CLR W2
0031CC  0222D4     CALL xQueueGenericReceive
0031CE  000000     NOP
0031D0  500FE1     SUB W0, #0x1, [W15]
0031D2  320002     BRA Z, .L28
352:               			{
353:               				xErrorOccurred = pdTRUE;
0031D4  200010     MOV #0x1, W0
0031D6  8843B0     MOV W0, xErrorOccurred
354:               			}
355:               		}
356:               
357:               		/* Wake the other task so it blocks attempting to read from  the
358:               		already	empty queue. */
359:               		vTaskResume( xSecondary );
0031E4  804380     MOV xSecondary, W0
0031E6  021536     CALL vTaskResume
0031E8  000000     NOP
360:               
361:               		/* We need to wait a little to ensure the other task executes. */
362:               		while( xRunIndicator != bktRUN_INDICATOR )
0031EA  370003     BRA .L30
0031F2  8043C1     MOV xRunIndicator, W1
0031F4  200550     MOV #0x55, W0
0031F6  508F80     SUB W1, W0, [W15]
0031F8  3AFFF9     BRA NZ, .L31
363:               		{
364:               			vTaskDelay( bktSHORT_WAIT );
0031EC  200140     MOV #0x14, W0
0031EE  021398     CALL vTaskDelay
0031F0  000000     NOP
365:               		}
366:               		vTaskDelay( bktSHORT_WAIT );
0031FA  200140     MOV #0x14, W0
0031FC  021398     CALL vTaskDelay
0031FE  000000     NOP
367:               		xRunIndicator = 0;
003200  EF2878     CLR xRunIndicator
368:               
369:               		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
003202  EB0000     CLR W0
003204  980730     MOV W0, [W14+6]
003206  37002B     BRA .L32
003258  90003E     MOV [W14+6], W0
00325A  E80000     INC W0, W0
00325C  980730     MOV W0, [W14+6]
00325E  90003E     MOV [W14+6], W0
003260  500FE4     SUB W0, #0x4, [W15]
003262  34FFD2     BRA LE, .L37
370:               		{
371:               			/* Now when we place an item on the queue the other task should
372:               			wake but not execute as this task has higher priority. */
373:               			if( xQueueSend( xTestQueue, &xItem, bktDONT_BLOCK ) != pdPASS )
003208  804370     MOV xTestQueue, W0
00320A  4700E6     ADD W14, #0x6, W1
00320C  EB0180     CLR W3
00320E  EB0100     CLR W2
003210  0220F8     CALL xQueueGenericSend
003212  000000     NOP
003214  500FE1     SUB W0, #0x1, [W15]
003216  320002     BRA Z, .L33
374:               			{
375:               				xErrorOccurred = pdTRUE;
003218  200010     MOV #0x1, W0
00321A  8843B0     MOV W0, xErrorOccurred
376:               			}
377:               
378:               			/* Now empty the queue again before the other task gets a chance to
379:               			execute.  If the other task had executed we would find the queue
380:               			empty ourselves, and the other task would be suspended. */
381:               			if( xQueueReceive( xTestQueue, &xData, bktDONT_BLOCK ) != pdPASS )
00321C  804370     MOV xTestQueue, W0
00321E  4700E8     ADD W14, #0x8, W1
003220  EB0180     CLR W3
003222  EB0100     CLR W2
003224  0222D4     CALL xQueueGenericReceive
003226  000000     NOP
003228  500FE1     SUB W0, #0x1, [W15]
00322A  320002     BRA Z, .L34
382:               			{
383:               				xErrorOccurred = pdTRUE;
00322C  200010     MOV #0x1, W0
00322E  8843B0     MOV W0, xErrorOccurred
384:               			}
385:               
386:               			if( xRunIndicator == bktRUN_INDICATOR )
003230  8043C1     MOV xRunIndicator, W1
003232  200550     MOV #0x55, W0
003234  508F80     SUB W1, W0, [W15]
003236  3A0002     BRA NZ, .L35
387:               			{
388:               				/* The other task should not have executed. */
389:               				xErrorOccurred = pdTRUE;
003238  200010     MOV #0x1, W0
00323A  8843B0     MOV W0, xErrorOccurred
390:               			}
391:               
392:               			/* Raise the priority of the other task so it executes and blocks
393:               			on the queue again. */
394:               			vTaskPrioritySet( xSecondary, bktPRIMARY_PRIORITY + 2 );
00323C  804380     MOV xSecondary, W0
00323E  200031     MOV #0x3, W1
003240  0213C2     CALL vTaskPrioritySet
003242  000000     NOP
395:               
396:               			/* The other task should now have re-blocked without exiting the
397:               			queue function. */
398:               			if( xRunIndicator == bktRUN_INDICATOR )
003244  8043C1     MOV xRunIndicator, W1
003246  200550     MOV #0x55, W0
003248  508F80     SUB W1, W0, [W15]
00324A  3A0002     BRA NZ, .L36
399:               			{
400:               				/* The other task should not have executed outside of the
401:               				queue function. */
402:               				xErrorOccurred = pdTRUE;
00324C  200010     MOV #0x1, W0
00324E  8843B0     MOV W0, xErrorOccurred
403:               			}
404:               			vTaskPrioritySet( xSecondary, bktSECONDARY_PRIORITY );
003250  804380     MOV xSecondary, W0
003252  EB0080     CLR W1
003254  0213C2     CALL vTaskPrioritySet
003256  000000     NOP
405:               		}
406:               
407:               		/* Let the other task timeout.  When it unblockes it will check that it
408:               		unblocked at the correct time, then suspend itself. */
409:               		while( xRunIndicator != bktRUN_INDICATOR )
003264  370003     BRA .L38
00326C  8043C1     MOV xRunIndicator, W1
00326E  200550     MOV #0x55, W0
003270  508F80     SUB W1, W0, [W15]
003272  3AFFF9     BRA NZ, .L39
410:               		{
411:               			vTaskDelay( bktSHORT_WAIT );
003266  200140     MOV #0x14, W0
003268  021398     CALL vTaskDelay
00326A  000000     NOP
412:               		}
413:               		vTaskDelay( bktSHORT_WAIT );
003274  200140     MOV #0x14, W0
003276  021398     CALL vTaskDelay
003278  000000     NOP
414:               
415:               		xPrimaryCycles++;
00327A  804390     MOV xPrimaryCycles, W0
00327C  E80000     INC W0, W0
00327E  884390     MOV W0, xPrimaryCycles
416:               	}
003280  37FEE7     BRA .L40
417:               }
418:               /*-----------------------------------------------------------*/
419:               
420:               static void vSecondaryBlockTimeTestTask( void *pvParameters )
421:               {
003282  FA0008     LNK #0x8
003284  980730     MOV W0, [W14+6]
422:               TickType_t xTimeWhenBlocking, xBlockedTime;
423:               BaseType_t xData;
424:               
425:               	( void ) pvParameters;
426:               
427:               	for( ;; )
428:               	{
429:               		/*********************************************************************
430:               		Test 0, 1 and 2
431:               
432:               		This task does not participate in these tests. */
433:               		vTaskSuspend( NULL );
003286  EB0000     CLR W0
003288  021492     CALL vTaskSuspend
00328A  000000     NOP
434:               
435:               		/*********************************************************************
436:               		Test 3
437:               
438:               		The first thing we do is attempt to read from the queue.  It should be
439:               		full so we block.  Note the time before we block so we can check the
440:               		wake time is as per that expected. */
441:               		xTimeWhenBlocking = xTaskGetTickCount();
00328C  02171E     CALL xTaskGetTickCount
00328E  000000     NOP
003290  780F00     MOV W0, [W14]
442:               
443:               		/* We should unblock after bktTIME_TO_BLOCK having not sent anything to
444:               		the queue. */
445:               		xData = 0;
003292  EB0000     CLR W0
003294  980720     MOV W0, [W14+4]
446:               		xRunIndicator = bktRUN_INDICATOR;
003296  200550     MOV #0x55, W0
003298  8843C0     MOV W0, xRunIndicator
447:               		if( xQueueSend( xTestQueue, &xData, bktTIME_TO_BLOCK ) != errQUEUE_FULL )
00329A  804370     MOV xTestQueue, W0
00329C  4700E4     ADD W14, #0x4, W1
00329E  EB0180     CLR W3
0032A0  200AF2     MOV #0xAF, W2
0032A2  0220F8     CALL xQueueGenericSend
0032A4  000000     NOP
0032A6  E00000     CP0 W0
0032A8  320002     BRA Z, .L42
448:               		{
449:               			xErrorOccurred = pdTRUE;
0032AA  200010     MOV #0x1, W0
0032AC  8843B0     MOV W0, xErrorOccurred
450:               		}
451:               
452:               		/* How long were we inside the send function? */
453:               		xBlockedTime = xTaskGetTickCount() - xTimeWhenBlocking;
0032AE  02171E     CALL xTaskGetTickCount
0032B0  000000     NOP
0032B2  50001E     SUB W0, [W14], W0
0032B4  980710     MOV W0, [W14+2]
454:               
455:               		/* We should not have blocked for less time than bktTIME_TO_BLOCK. */
456:               		if( xBlockedTime < bktTIME_TO_BLOCK )
0032B6  90009E     MOV [W14+2], W1
0032B8  200AE0     MOV #0xAE, W0
0032BA  508F80     SUB W1, W0, [W15]
0032BC  3E0002     BRA GTU, .L43
457:               		{
458:               			xErrorOccurred = pdTRUE;
0032BE  200010     MOV #0x1, W0
0032C0  8843B0     MOV W0, xErrorOccurred
459:               		}
460:               
461:               		/* We should of not blocked for much longer than bktALLOWABLE_MARGIN
462:               		either.  A margin is permitted as we would not necessarily run as
463:               		soon as we unblocked. */
464:               		if( xBlockedTime > ( bktTIME_TO_BLOCK + bktALLOWABLE_MARGIN ) )
0032C2  90009E     MOV [W14+2], W1
0032C4  200BE0     MOV #0xBE, W0
0032C6  508F80     SUB W1, W0, [W15]
0032C8  360002     BRA LEU, .L44
465:               		{
466:               			xErrorOccurred = pdTRUE;
0032CA  200010     MOV #0x1, W0
0032CC  8843B0     MOV W0, xErrorOccurred
467:               		}
468:               
469:               		/* Suspend ready for test 3. */
470:               		xRunIndicator = bktRUN_INDICATOR;
0032CE  200550     MOV #0x55, W0
0032D0  8843C0     MOV W0, xRunIndicator
471:               		vTaskSuspend( NULL );
0032D2  EB0000     CLR W0
0032D4  021492     CALL vTaskSuspend
0032D6  000000     NOP
472:               
473:               		/*********************************************************************
474:                       Test 4
475:               
476:               		As per test three, but with the send and receive reversed. */
477:               		xTimeWhenBlocking = xTaskGetTickCount();
0032D8  02171E     CALL xTaskGetTickCount
0032DA  000000     NOP
0032DC  780F00     MOV W0, [W14]
478:               
479:               		/* We should unblock after bktTIME_TO_BLOCK having not received
480:               		anything on the queue. */
481:               		xRunIndicator = bktRUN_INDICATOR;
0032DE  200550     MOV #0x55, W0
0032E0  8843C0     MOV W0, xRunIndicator
482:               		if( xQueueReceive( xTestQueue, &xData, bktTIME_TO_BLOCK ) != errQUEUE_EMPTY )
0032E2  804370     MOV xTestQueue, W0
0032E4  4700E4     ADD W14, #0x4, W1
0032E6  EB0180     CLR W3
0032E8  200AF2     MOV #0xAF, W2
0032EA  0222D4     CALL xQueueGenericReceive
0032EC  000000     NOP
0032EE  E00000     CP0 W0
0032F0  320002     BRA Z, .L45
483:               		{
484:               			xErrorOccurred = pdTRUE;
0032F2  200010     MOV #0x1, W0
0032F4  8843B0     MOV W0, xErrorOccurred
485:               		}
486:               
487:               		xBlockedTime = xTaskGetTickCount() - xTimeWhenBlocking;
0032F6  02171E     CALL xTaskGetTickCount
0032F8  000000     NOP
0032FA  50001E     SUB W0, [W14], W0
0032FC  980710     MOV W0, [W14+2]
488:               
489:               		/* We should not have blocked for less time than bktTIME_TO_BLOCK. */
490:               		if( xBlockedTime < bktTIME_TO_BLOCK )
0032FE  90009E     MOV [W14+2], W1
003300  200AE0     MOV #0xAE, W0
003302  508F80     SUB W1, W0, [W15]
003304  3E0002     BRA GTU, .L46
491:               		{
492:               			xErrorOccurred = pdTRUE;
003306  200010     MOV #0x1, W0
003308  8843B0     MOV W0, xErrorOccurred
493:               		}
494:               
495:               		/* We should of not blocked for much longer than bktALLOWABLE_MARGIN
496:               		either.  A margin is permitted as we would not necessarily run as soon
497:               		as we unblocked. */
498:               		if( xBlockedTime > ( bktTIME_TO_BLOCK + bktALLOWABLE_MARGIN ) )
00330A  90009E     MOV [W14+2], W1
00330C  200BE0     MOV #0xBE, W0
00330E  508F80     SUB W1, W0, [W15]
003310  360002     BRA LEU, .L47
499:               		{
500:               			xErrorOccurred = pdTRUE;
003312  200010     MOV #0x1, W0
003314  8843B0     MOV W0, xErrorOccurred
501:               		}
502:               
503:               		xRunIndicator = bktRUN_INDICATOR;
003316  200550     MOV #0x55, W0
003318  8843C0     MOV W0, xRunIndicator
504:               
505:               		xSecondaryCycles++;
00331A  8043A0     MOV xSecondaryCycles, W0
00331C  E80000     INC W0, W0
00331E  8843A0     MOV W0, xSecondaryCycles
506:               	}
003320  37FFB2     BRA .L48
507:               }
508:               /*-----------------------------------------------------------*/
509:               
510:               static void prvBasicDelayTests( void )
511:               {
003322  FA0010     LNK #0x10
512:               TickType_t xPreTime, xPostTime, x, xLastUnblockTime, xExpectedUnblockTime;
513:               const TickType_t xPeriod = 75, xCycles = 5, xAllowableMargin = ( bktALLOWABLE_MARGIN >> 1 );
003324  2004B0     MOV #0x4B, W0
003326  980710     MOV W0, [W14+2]
003328  200050     MOV #0x5, W0
00332A  980720     MOV W0, [W14+4]
00332C  200070     MOV #0x7, W0
00332E  980730     MOV W0, [W14+6]
514:               
515:               	/* Temporarily increase priority so the timing is more accurate, but not so
516:               	high as to disrupt the timer tests. */
517:               	vTaskPrioritySet( NULL, configTIMER_TASK_PRIORITY - 1 );
003330  200021     MOV #0x2, W1
003332  EB0000     CLR W0
003334  0213C2     CALL vTaskPrioritySet
003336  000000     NOP
518:               
519:               	/* Crude check to too that vTaskDelay() blocks for the expected period. */
520:               	xPreTime = xTaskGetTickCount();
003338  02171E     CALL xTaskGetTickCount
00333A  000000     NOP
00333C  980740     MOV W0, [W14+8]
521:               	vTaskDelay( bktTIME_TO_BLOCK );
00333E  200AF0     MOV #0xAF, W0
003340  021398     CALL vTaskDelay
003342  000000     NOP
522:               	xPostTime = xTaskGetTickCount();
003344  02171E     CALL xTaskGetTickCount
003346  000000     NOP
003348  980750     MOV W0, [W14+10]
523:               
524:               	/* The priority is higher, so the allowable margin is halved when compared
525:               	to the other tests in this file. */
526:               	if( ( xPostTime - xPreTime ) > ( bktTIME_TO_BLOCK + xAllowableMargin ) )
00334A  9000DE     MOV [W14+10], W1
00334C  90004E     MOV [W14+8], W0
00334E  508080     SUB W1, W0, W1
003350  90003E     MOV [W14+6], W0
003352  B00AF0     ADD #0xAF, W0
003354  508F80     SUB W1, W0, [W15]
003356  360002     BRA LEU, .L50
527:               	{
528:               		xErrorOccurred = pdTRUE;
003358  200010     MOV #0x1, W0
00335A  8843B0     MOV W0, xErrorOccurred
529:               	}
530:               
531:               	/* Now crude tests to check the vTaskDelayUntil() functionality. */
532:               	xPostTime = xTaskGetTickCount();
00335C  02171E     CALL xTaskGetTickCount
00335E  000000     NOP
003360  980750     MOV W0, [W14+10]
533:               	xLastUnblockTime = xPostTime;
003362  9000DE     MOV [W14+10], W1
003364  980771     MOV W1, [W14+14]
534:               
535:               	for( x = 0; x < xCycles; x++ )
003366  EB0000     CLR W0
003368  780F00     MOV W0, [W14]
00336A  370019     BRA .L51
00339C  E80F1E     INC [W14], [W14]
00339E  90002E     MOV [W14+4], W0
0033A0  78009E     MOV [W14], W1
0033A2  508F80     SUB W1, W0, [W15]
0033A4  39FFE3     BRA NC, .L53
536:               	{
537:               		/* Calculate the next expected unblock time from the time taken before
538:               		this loop was entered. */
539:               		xExpectedUnblockTime = xPostTime + ( x * xPeriod );
00336C  78009E     MOV [W14], W1
00336E  90001E     MOV [W14+2], W0
003370  B98800     MUL.SS W1, W0, W0
003372  780080     MOV W0, W1
003374  90005E     MOV [W14+10], W0
003376  408000     ADD W1, W0, W0
003378  980760     MOV W0, [W14+12]
540:               
541:               		vTaskDelayUntil( &xLastUnblockTime, xPeriod );
00337A  47006E     ADD W14, #0xE, W0
00337C  90009E     MOV [W14+2], W1
00337E  02131C     CALL vTaskDelayUntil
003380  000000     NOP
542:               
543:               		if( ( xTaskGetTickCount() - xExpectedUnblockTime ) > ( bktTIME_TO_BLOCK + xAllowableMargin ) )
003382  02171E     CALL xTaskGetTickCount
003384  000000     NOP
003386  9000EE     MOV [W14+12], W1
003388  500081     SUB W0, W1, W1
00338A  90003E     MOV [W14+6], W0
00338C  B00AF0     ADD #0xAF, W0
00338E  508F80     SUB W1, W0, [W15]
003390  360002     BRA LEU, .L52
544:               		{
545:               			xErrorOccurred = pdTRUE;
003392  200010     MOV #0x1, W0
003394  8843B0     MOV W0, xErrorOccurred
546:               		}
547:               
548:               		xPrimaryCycles++;
003396  804390     MOV xPrimaryCycles, W0
003398  E80000     INC W0, W0
00339A  884390     MOV W0, xPrimaryCycles
549:               	}
550:               
551:               	/* Reset to the original task priority ready for the other tests. */
552:               	vTaskPrioritySet( NULL, bktPRIMARY_PRIORITY );
0033A6  200011     MOV #0x1, W1
0033A8  EB0000     CLR W0
0033AA  0213C2     CALL vTaskPrioritySet
0033AC  000000     NOP
553:               }
0033AE  FA8000     ULNK
0033B0  060000     RETURN
554:               /*-----------------------------------------------------------*/
555:               
556:               BaseType_t xAreBlockTimeTestTasksStillRunning( void )
557:               {
0033B2  FA0002     LNK #0x2
558:               static BaseType_t xLastPrimaryCycleCount = 0, xLastSecondaryCycleCount = 0;
559:               BaseType_t xReturn = pdPASS;
0033B4  200010     MOV #0x1, W0
0033B6  780F00     MOV W0, [W14]
560:               
561:               	/* Have both tasks performed at least one cycle since this function was
562:               	last called? */
563:               	if( xPrimaryCycles == xLastPrimaryCycleCount )
0033B8  804391     MOV xPrimaryCycles, W1
0033BA  8043D0     MOV xLastPrimaryCycleCount, W0
0033BC  508F80     SUB W1, W0, [W15]
0033BE  3A0002     BRA NZ, .L55
564:               	{
565:               		xReturn = pdFAIL;
0033C0  EB0000     CLR W0
0033C2  780F00     MOV W0, [W14]
566:               	}
567:               
568:               	if( xSecondaryCycles == xLastSecondaryCycleCount )
0033C4  8043A1     MOV xSecondaryCycles, W1
0033C6  8043E0     MOV xLastSecondaryCycleCount, W0
0033C8  508F80     SUB W1, W0, [W15]
0033CA  3A0002     BRA NZ, .L56
569:               	{
570:               		xReturn = pdFAIL;
0033CC  EB0000     CLR W0
0033CE  780F00     MOV W0, [W14]
571:               	}
572:               
573:               	if( xErrorOccurred == pdTRUE )
0033D0  8043B0     MOV xErrorOccurred, W0
0033D2  500FE1     SUB W0, #0x1, [W15]
0033D4  3A0002     BRA NZ, .L57
574:               	{
575:               		xReturn = pdFAIL;
0033D6  EB0000     CLR W0
0033D8  780F00     MOV W0, [W14]
576:               	}
577:               
578:               	xLastSecondaryCycleCount = xSecondaryCycles;
0033DA  8043A0     MOV xSecondaryCycles, W0
0033DC  8843E0     MOV W0, xLastSecondaryCycleCount
579:               	xLastPrimaryCycleCount = xPrimaryCycles;
0033DE  804390     MOV xPrimaryCycles, W0
0033E0  8843D0     MOV W0, xLastPrimaryCycleCount
580:               
581:               	return xReturn;
0033E2  78001E     MOV [W14], W0
582:               }
0033E4  FA8000     ULNK
0033E6  060000     RETURN
---  /home/zxc/Documents/WCGRTOS/Demo/Common/Minimal/BlockQ.c  ------------------------------------------
1:                 /*
2:                     FreeRTOS V9.0.0 - Copyright (C) 2016 Real Time Engineers Ltd.
3:                     All rights reserved
4:                 
5:                     VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
6:                 
7:                     This file is part of the FreeRTOS distribution.
8:                 
9:                     FreeRTOS is free software; you can redistribute it and/or modify it under
10:                    the terms of the GNU General Public License (version 2) as published by the
11:                    Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
12:                
13:                    ***************************************************************************
14:                    >>!   NOTE: The modification to the GPL is included to allow you to     !<<
15:                    >>!   distribute a combined work that includes FreeRTOS without being   !<<
16:                    >>!   obliged to provide the source code for proprietary components     !<<
17:                    >>!   outside of the FreeRTOS kernel.                                   !<<
18:                    ***************************************************************************
19:                
20:                    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
21:                    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
22:                    FOR A PARTICULAR PURPOSE.  Full license text is available on the following
23:                    link: http://www.freertos.org/a00114.html
24:                
25:                    ***************************************************************************
26:                     *                                                                       *
27:                     *    FreeRTOS provides completely free yet professionally developed,    *
28:                     *    robust, strictly quality controlled, supported, and cross          *
29:                     *    platform software that is more than just the market leader, it     *
30:                     *    is the industry's de facto standard.                               *
31:                     *                                                                       *
32:                     *    Help yourself get started quickly while simultaneously helping     *
33:                     *    to support the FreeRTOS project by purchasing a FreeRTOS           *
34:                     *    tutorial book, reference manual, or both:                          *
35:                     *    http://www.FreeRTOS.org/Documentation                              *
36:                     *                                                                       *
37:                    ***************************************************************************
38:                
39:                    http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
40:                    the FAQ page "My application does not run, what could be wrong?".  Have you
41:                    defined configASSERT()?
42:                
43:                    http://www.FreeRTOS.org/support - In return for receiving this top quality
44:                    embedded software for free we request you assist our global community by
45:                    participating in the support forum.
46:                
47:                    http://www.FreeRTOS.org/training - Investing in training allows your team to
48:                    be as productive as possible as early as possible.  Now you can receive
49:                    FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
50:                    Ltd, and the world's leading authority on the world's leading RTOS.
51:                
52:                    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
53:                    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
54:                    compatible FAT file system, and our tiny thread aware UDP/IP stack.
55:                
56:                    http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
57:                    Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
58:                
59:                    http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
60:                    Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
61:                    licenses offer ticketed support, indemnification and commercial middleware.
62:                
63:                    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
64:                    engineered and independently SIL3 certified version for use in safety and
65:                    mission critical applications that require provable dependability.
66:                
67:                    1 tab == 4 spaces!
68:                */
69:                
70:                /*
71:                 * Creates six tasks that operate on three queues as follows:
72:                 *
73:                 * The first two tasks send and receive an incrementing number to/from a queue.
74:                 * One task acts as a producer and the other as the consumer.  The consumer is a
75:                 * higher priority than the producer and is set to block on queue reads.  The queue
76:                 * only has space for one item - as soon as the producer posts a message on the
77:                 * queue the consumer will unblock, pre-empt the producer, and remove the item.
78:                 *
79:                 * The second two tasks work the other way around.  Again the queue used only has
80:                 * enough space for one item.  This time the consumer has a lower priority than the
81:                 * producer.  The producer will try to post on the queue blocking when the queue is
82:                 * full.  When the consumer wakes it will remove the item from the queue, causing
83:                 * the producer to unblock, pre-empt the consumer, and immediately re-fill the
84:                 * queue.
85:                 *
86:                 * The last two tasks use the same queue producer and consumer functions.  This time the queue has
87:                 * enough space for lots of items and the tasks operate at the same priority.  The
88:                 * producer will execute, placing items into the queue.  The consumer will start
89:                 * executing when either the queue becomes full (causing the producer to block) or
90:                 * a context switch occurs (tasks of the same priority will time slice).
91:                 *
92:                 */
93:                
94:                #include <stdlib.h>
95:                
96:                /* Scheduler include files. */
97:                #include "FreeRTOS.h"
98:                #include "task.h"
99:                #include "queue.h"
100:               
101:               /* Demo program include files. */
102:               #include "BlockQ.h"
103:               
104:               #define blckqSTACK_SIZE		configMINIMAL_STACK_SIZE
105:               #define blckqNUM_TASK_SETS	( 3 )
106:               
107:               #if( configSUPPORT_DYNAMIC_ALLOCATION == 0 )
108:               	#error This example cannot be used if dynamic allocation is not allowed.
109:               #endif
110:               
111:               /* Structure used to pass parameters to the blocking queue tasks. */
112:               typedef struct BLOCKING_QUEUE_PARAMETERS
113:               {
114:               	QueueHandle_t xQueue;					/*< The queue to be used by the task. */
115:               	TickType_t xBlockTime;				/*< The block time to use on queue reads/writes. */
116:               	volatile short *psCheckVariable;	/*< Incremented on each successful cycle to check the task is still running. */
117:               } xBlockingQueueParameters;
118:               
119:               /* Task function that creates an incrementing number and posts it on a queue. */
120:               static portTASK_FUNCTION_PROTO( vBlockingQueueProducer, pvParameters );
121:               
122:               /* Task function that removes the incrementing number from a queue and checks that
123:               it is the expected number. */
124:               static portTASK_FUNCTION_PROTO( vBlockingQueueConsumer, pvParameters );
125:               
126:               /* Variables which are incremented each time an item is removed from a queue, and
127:               found to be the expected value.
128:               These are used to check that the tasks are still running. */
129:               static volatile short sBlockingConsumerCount[ blckqNUM_TASK_SETS ] = { ( uint16_t ) 0, ( uint16_t ) 0, ( uint16_t ) 0 };
130:               
131:               /* Variable which are incremented each time an item is posted on a queue.   These
132:               are used to check that the tasks are still running. */
133:               static volatile short sBlockingProducerCount[ blckqNUM_TASK_SETS ] = { ( uint16_t ) 0, ( uint16_t ) 0, ( uint16_t ) 0 };
134:               
135:               /*-----------------------------------------------------------*/
136:               
137:               void vStartBlockingQueueTasks( UBaseType_t uxPriority )
138:               {
003ED8  FA0016     LNK #0x16
003EDA  980F20     MOV W0, [W14+20]
139:               xBlockingQueueParameters *pxQueueParameters1, *pxQueueParameters2;
140:               xBlockingQueueParameters *pxQueueParameters3, *pxQueueParameters4;
141:               xBlockingQueueParameters *pxQueueParameters5, *pxQueueParameters6;
142:               const UBaseType_t uxQueueSize1 = 1, uxQueueSize5 = 5;
003EDC  200010     MOV #0x1, W0
003EDE  780F00     MOV W0, [W14]
003EE0  200050     MOV #0x5, W0
003EE2  980710     MOV W0, [W14+2]
143:               const TickType_t xBlockTime = pdMS_TO_TICKS( ( TickType_t ) 1000 );
003EE4  200100     MOV #0x10, W0
003EE6  980720     MOV W0, [W14+4]
144:               const TickType_t xDontBlock = ( TickType_t ) 0;
003EE8  EB0000     CLR W0
003EEA  980730     MOV W0, [W14+6]
145:               
146:               	/* Create the first two tasks as described at the top of the file. */
147:               
148:               	/* First create the structure used to pass parameters to the consumer tasks. */
149:               	pxQueueParameters1 = ( xBlockingQueueParameters * ) pvPortMalloc( sizeof( xBlockingQueueParameters ) );
003EEC  200060     MOV #0x6, W0
003EEE  023C80     CALL pvPortMalloc
003EF0  000000     NOP
003EF2  980740     MOV W0, [W14+8]
150:               
151:               	/* Create the queue used by the first two tasks to pass the incrementing number.
152:               	Pass a pointer to the queue in the parameter structure. */
153:               	pxQueueParameters1->xQueue = xQueueCreate( uxQueueSize1, ( UBaseType_t ) sizeof( uint16_t ) );
003EF4  EB4100     CLR.B W2
003EF6  200021     MOV #0x2, W1
003EF8  78001E     MOV [W14], W0
003EFA  02207C     CALL xQueueGenericCreate
003EFC  000000     NOP
003EFE  9000CE     MOV [W14+8], W1
003F00  780880     MOV W0, [W1]
154:               
155:               	/* The consumer is created first so gets a block time as described above. */
156:               	pxQueueParameters1->xBlockTime = xBlockTime;
003F02  90004E     MOV [W14+8], W0
003F04  9000AE     MOV [W14+4], W1
003F06  980011     MOV W1, [W0+2]
157:               
158:               	/* Pass in the variable that this task is going to increment so we can check it
159:               	is still running. */
160:               	pxQueueParameters1->psCheckVariable = &( sBlockingConsumerCount[ 0 ] );
003F08  90004E     MOV [W14+8], W0
003F0A  21D721     MOV #0x1D72, W1
003F0C  980021     MOV W1, [W0+4]
161:               
162:               	/* Create the structure used to pass parameters to the producer task. */
163:               	pxQueueParameters2 = ( xBlockingQueueParameters * ) pvPortMalloc( sizeof( xBlockingQueueParameters ) );
003F0E  200060     MOV #0x6, W0
003F10  023C80     CALL pvPortMalloc
003F12  000000     NOP
003F14  980750     MOV W0, [W14+10]
164:               
165:               	/* Pass the queue to this task also, using the parameter structure. */
166:               	pxQueueParameters2->xQueue = pxQueueParameters1->xQueue;
003F16  90004E     MOV [W14+8], W0
003F18  780090     MOV [W0], W1
003F1A  90005E     MOV [W14+10], W0
003F1C  780801     MOV W1, [W0]
167:               
168:               	/* The producer is not going to block - as soon as it posts the consumer will
169:               	wake and remove the item so the producer should always have room to post. */
170:               	pxQueueParameters2->xBlockTime = xDontBlock;
003F1E  90005E     MOV [W14+10], W0
003F20  9000BE     MOV [W14+6], W1
003F22  980011     MOV W1, [W0+2]
171:               
172:               	/* Pass in the variable that this task is going to increment so we can check
173:               	it is still running. */
174:               	pxQueueParameters2->psCheckVariable = &( sBlockingProducerCount[ 0 ] );
003F24  90005E     MOV [W14+10], W0
003F26  21D781     MOV #0x1D78, W1
003F28  980021     MOV W1, [W0+4]
175:               
176:               
177:               	/* Note the producer has a lower priority than the consumer when the tasks are
178:               	spawned. */
179:               	xTaskCreate( vBlockingQueueConsumer, "QConsB1", blckqSTACK_SIZE, ( void * ) pxQueueParameters1, uxPriority, NULL );
003F2A  EB0280     CLR W5
003F2C  900A2E     MOV [W14+20], W4
003F2E  9001CE     MOV [W14+8], W3
003F30  200732     MOV #0x73, W2
003F32  290101     MOV #0x9010, W1
003F34  2404C0     MOV #0x404C, W0
003F36  0210E8     CALL xTaskCreate
003F38  000000     NOP
180:               	xTaskCreate( vBlockingQueueProducer, "QProdB2", blckqSTACK_SIZE, ( void * ) pxQueueParameters2, tskIDLE_PRIORITY, NULL );
003F3A  EB0280     CLR W5
003F3C  EB0200     CLR W4
003F3E  9001DE     MOV [W14+10], W3
003F40  200732     MOV #0x73, W2
003F42  290181     MOV #0x9018, W1
003F44  2400A0     MOV #0x400A, W0
003F46  0210E8     CALL xTaskCreate
003F48  000000     NOP
181:               
182:               
183:               
184:               	/* Create the second two tasks as described at the top of the file.   This uses
185:               	the same mechanism but reverses the task priorities. */
186:               
187:               	pxQueueParameters3 = ( xBlockingQueueParameters * ) pvPortMalloc( sizeof( xBlockingQueueParameters ) );
003F4A  200060     MOV #0x6, W0
003F4C  023C80     CALL pvPortMalloc
003F4E  000000     NOP
003F50  980760     MOV W0, [W14+12]
188:               	pxQueueParameters3->xQueue = xQueueCreate( uxQueueSize1, ( UBaseType_t ) sizeof( uint16_t ) );
003F52  EB4100     CLR.B W2
003F54  200021     MOV #0x2, W1
003F56  78001E     MOV [W14], W0
003F58  02207C     CALL xQueueGenericCreate
003F5A  000000     NOP
003F5C  9000EE     MOV [W14+12], W1
003F5E  780880     MOV W0, [W1]
189:               	pxQueueParameters3->xBlockTime = xDontBlock;
003F60  90006E     MOV [W14+12], W0
003F62  9000BE     MOV [W14+6], W1
003F64  980011     MOV W1, [W0+2]
190:               	pxQueueParameters3->psCheckVariable = &( sBlockingProducerCount[ 1 ] );
003F66  90006E     MOV [W14+12], W0
003F68  21D7A1     MOV #0x1D7A, W1
003F6A  980021     MOV W1, [W0+4]
191:               
192:               	pxQueueParameters4 = ( xBlockingQueueParameters * ) pvPortMalloc( sizeof( xBlockingQueueParameters ) );
003F6C  200060     MOV #0x6, W0
003F6E  023C80     CALL pvPortMalloc
003F70  000000     NOP
003F72  980770     MOV W0, [W14+14]
193:               	pxQueueParameters4->xQueue = pxQueueParameters3->xQueue;
003F74  90006E     MOV [W14+12], W0
003F76  780090     MOV [W0], W1
003F78  90007E     MOV [W14+14], W0
003F7A  780801     MOV W1, [W0]
194:               	pxQueueParameters4->xBlockTime = xBlockTime;
003F7C  90007E     MOV [W14+14], W0
003F7E  9000AE     MOV [W14+4], W1
003F80  980011     MOV W1, [W0+2]
195:               	pxQueueParameters4->psCheckVariable = &( sBlockingConsumerCount[ 1 ] );
003F82  90007E     MOV [W14+14], W0
003F84  21D741     MOV #0x1D74, W1
003F86  980021     MOV W1, [W0+4]
196:               
197:               	xTaskCreate( vBlockingQueueConsumer, "QConsB3", blckqSTACK_SIZE, ( void * ) pxQueueParameters3, tskIDLE_PRIORITY, NULL );
003F88  EB0280     CLR W5
003F8A  EB0200     CLR W4
003F8C  9001EE     MOV [W14+12], W3
003F8E  200732     MOV #0x73, W2
003F90  290201     MOV #0x9020, W1
003F92  2404C0     MOV #0x404C, W0
003F94  0210E8     CALL xTaskCreate
003F96  000000     NOP
198:               	xTaskCreate( vBlockingQueueProducer, "QProdB4", blckqSTACK_SIZE, ( void * ) pxQueueParameters4, uxPriority, NULL );
003F98  EB0280     CLR W5
003F9A  900A2E     MOV [W14+20], W4
003F9C  9001FE     MOV [W14+14], W3
003F9E  200732     MOV #0x73, W2
003FA0  290281     MOV #0x9028, W1
003FA2  2400A0     MOV #0x400A, W0
003FA4  0210E8     CALL xTaskCreate
003FA6  000000     NOP
199:               
200:               
201:               
202:               	/* Create the last two tasks as described above.  The mechanism is again just
203:               	the same.  This time both parameter structures are given a block time. */
204:               	pxQueueParameters5 = ( xBlockingQueueParameters * ) pvPortMalloc( sizeof( xBlockingQueueParameters ) );
003FA8  200060     MOV #0x6, W0
003FAA  023C80     CALL pvPortMalloc
003FAC  000000     NOP
003FAE  980F00     MOV W0, [W14+16]
205:               	pxQueueParameters5->xQueue = xQueueCreate( uxQueueSize5, ( UBaseType_t ) sizeof( uint16_t ) );
003FB0  EB4100     CLR.B W2
003FB2  200021     MOV #0x2, W1
003FB4  90001E     MOV [W14+2], W0
003FB6  02207C     CALL xQueueGenericCreate
003FB8  000000     NOP
003FBA  90088E     MOV [W14+16], W1
003FBC  780880     MOV W0, [W1]
206:               	pxQueueParameters5->xBlockTime = xBlockTime;
003FBE  90080E     MOV [W14+16], W0
003FC0  9000AE     MOV [W14+4], W1
003FC2  980011     MOV W1, [W0+2]
207:               	pxQueueParameters5->psCheckVariable = &( sBlockingProducerCount[ 2 ] );
003FC4  90080E     MOV [W14+16], W0
003FC6  21D7C1     MOV #0x1D7C, W1
003FC8  980021     MOV W1, [W0+4]
208:               
209:               	pxQueueParameters6 = ( xBlockingQueueParameters * ) pvPortMalloc( sizeof( xBlockingQueueParameters ) );
003FCA  200060     MOV #0x6, W0
003FCC  023C80     CALL pvPortMalloc
003FCE  000000     NOP
003FD0  980F10     MOV W0, [W14+18]
210:               	pxQueueParameters6->xQueue = pxQueueParameters5->xQueue;
003FD2  90080E     MOV [W14+16], W0
003FD4  780090     MOV [W0], W1
003FD6  90081E     MOV [W14+18], W0
003FD8  780801     MOV W1, [W0]
211:               	pxQueueParameters6->xBlockTime = xBlockTime;
003FDA  90081E     MOV [W14+18], W0
003FDC  9000AE     MOV [W14+4], W1
003FDE  980011     MOV W1, [W0+2]
212:               	pxQueueParameters6->psCheckVariable = &( sBlockingConsumerCount[ 2 ] );
003FE0  90081E     MOV [W14+18], W0
003FE2  21D761     MOV #0x1D76, W1
003FE4  980021     MOV W1, [W0+4]
213:               
214:               	xTaskCreate( vBlockingQueueProducer, "QProdB5", blckqSTACK_SIZE, ( void * ) pxQueueParameters5, tskIDLE_PRIORITY, NULL );
003FE6  EB0280     CLR W5
003FE8  EB0200     CLR W4
003FEA  90098E     MOV [W14+16], W3
003FEC  200732     MOV #0x73, W2
003FEE  290301     MOV #0x9030, W1
003FF0  2400A0     MOV #0x400A, W0
003FF2  0210E8     CALL xTaskCreate
003FF4  000000     NOP
215:               	xTaskCreate( vBlockingQueueConsumer, "QConsB6", blckqSTACK_SIZE, ( void * ) pxQueueParameters6, tskIDLE_PRIORITY, NULL );
003FF6  EB0280     CLR W5
003FF8  EB0200     CLR W4
003FFA  90099E     MOV [W14+18], W3
003FFC  200732     MOV #0x73, W2
003FFE  290381     MOV #0x9038, W1
004000  2404C0     MOV #0x404C, W0
004002  0210E8     CALL xTaskCreate
004004  000000     NOP
216:               }
004006  FA8000     ULNK
004008  060000     RETURN
217:               /*-----------------------------------------------------------*/
218:               
219:               static portTASK_FUNCTION( vBlockingQueueProducer, pvParameters )
220:               {
00400A  FA0008     LNK #0x8
00400C  980730     MOV W0, [W14+6]
221:               uint16_t usValue = 0;
00400E  EB0000     CLR W0
004010  980720     MOV W0, [W14+4]
222:               xBlockingQueueParameters *pxQueueParameters;
223:               short sErrorEverOccurred = pdFALSE;
004012  EB0000     CLR W0
004014  780F00     MOV W0, [W14]
224:               
225:               	pxQueueParameters = ( xBlockingQueueParameters * ) pvParameters;
004016  9000BE     MOV [W14+6], W1
004018  980711     MOV W1, [W14+2]
226:               
227:               	for( ;; )
228:               	{
229:               		if( xQueueSend( pxQueueParameters->xQueue, ( void * ) &usValue, pxQueueParameters->xBlockTime ) != pdPASS )
00401A  90001E     MOV [W14+2], W0
00401C  900110     MOV [W0+2], W2
00401E  90001E     MOV [W14+2], W0
004020  780010     MOV [W0], W0
004022  4700E4     ADD W14, #0x4, W1
004024  EB0180     CLR W3
004026  0220F8     CALL xQueueGenericSend
004028  000000     NOP
00402A  500FE1     SUB W0, #0x1, [W15]
00402C  320003     BRA Z, .L3
230:               		{
231:               			sErrorEverOccurred = pdTRUE;
00402E  200010     MOV #0x1, W0
004030  780F00     MOV W0, [W14]
232:               		}
233:               		else
234:               		{
235:               			/* We have successfully posted a message, so increment the variable
236:               			used to check we are still running. */
237:               			if( sErrorEverOccurred == pdFALSE )
004034  78001E     MOV [W14], W0
004036  E00000     CP0 W0
004038  3A0005     BRA NZ, .L5
238:               			{
239:               				( *pxQueueParameters->psCheckVariable )++;
00403A  90001E     MOV [W14+2], W0
00403C  900020     MOV [W0+4], W0
00403E  780090     MOV [W0], W1
004040  E80081     INC W1, W1
004042  780801     MOV W1, [W0]
240:               			}
241:               
242:               			/* Increment the variable we are going to post next time round.  The
243:               			consumer will expect the numbers to	follow in numerical order. */
244:               			++usValue;
004044  90002E     MOV [W14+4], W0
004046  E80000     INC W0, W0
004048  980720     MOV W0, [W14+4]
245:               
246:               			#if configUSE_PREEMPTION == 0
247:               				taskYIELD();
248:               			#endif
249:               		}
250:               	}
004032  37FFF3     BRA .L6
00404A  37FFE7     BRA .L6
251:               }
252:               /*-----------------------------------------------------------*/
253:               
254:               static portTASK_FUNCTION( vBlockingQueueConsumer, pvParameters )
255:               {
00404C  FA000A     LNK #0xA
00404E  980740     MOV W0, [W14+8]
256:               uint16_t usData, usExpectedValue = 0;
004050  EB0000     CLR W0
004052  780F00     MOV W0, [W14]
257:               xBlockingQueueParameters *pxQueueParameters;
258:               short sErrorEverOccurred = pdFALSE;
004054  EB0000     CLR W0
004056  980710     MOV W0, [W14+2]
259:               
260:               	pxQueueParameters = ( xBlockingQueueParameters * ) pvParameters;
004058  9000CE     MOV [W14+8], W1
00405A  980721     MOV W1, [W14+4]
00405C  370001     BRA .L11
261:               
262:               	for( ;; )
263:               	{
264:               		if( xQueueReceive( pxQueueParameters->xQueue, &usData, pxQueueParameters->xBlockTime ) == pdPASS )
004060  90002E     MOV [W14+4], W0
004062  900110     MOV [W0+2], W2
004064  90002E     MOV [W14+4], W0
004066  780010     MOV [W0], W0
004068  4700E6     ADD W14, #0x6, W1
00406A  EB0180     CLR W3
00406C  0222D4     CALL xQueueGenericReceive
00406E  000000     NOP
004070  500FE1     SUB W0, #0x1, [W15]
004072  3AFFF5     BRA NZ, .L12
265:               		{
266:               			if( usData != usExpectedValue )
004074  90003E     MOV [W14+6], W0
004076  500F9E     SUB W0, [W14], [W15]
004078  320005     BRA Z, .L9
267:               			{
268:               				/* Catch-up. */
269:               				usExpectedValue = usData;
00407A  9000BE     MOV [W14+6], W1
00407C  780F01     MOV W1, [W14]
270:               
271:               				sErrorEverOccurred = pdTRUE;
00407E  200010     MOV #0x1, W0
004080  980710     MOV W0, [W14+2]
272:               			}
273:               			else
274:               			{
275:               				/* We have successfully received a message, so increment the
276:               				variable used to check we are still running. */
277:               				if( sErrorEverOccurred == pdFALSE )
004084  90001E     MOV [W14+2], W0
004086  E00000     CP0 W0
004088  3A0005     BRA NZ, .L10
278:               				{
279:               					( *pxQueueParameters->psCheckVariable )++;
00408A  90002E     MOV [W14+4], W0
00408C  900020     MOV [W0+4], W0
00408E  780090     MOV [W0], W1
004090  E80081     INC W1, W1
004092  780801     MOV W1, [W0]
280:               				}
281:               
282:               				/* Increment the value we expect to remove from the queue next time
283:               				round. */
284:               				++usExpectedValue;
004094  E80F1E     INC [W14], [W14]
285:               			}
286:               
287:               			#if configUSE_PREEMPTION == 0
288:               			{
289:               				if( pxQueueParameters->xBlockTime == 0 )
290:               				{
291:               					taskYIELD();
292:               				}
293:               			}
294:               			#endif
295:               		}
296:               	}
00405E  000000     NOP
004082  37FFEE     BRA .L11
004096  37FFE4     BRA .L11
297:               }
298:               /*-----------------------------------------------------------*/
299:               
300:               /* This is called to check that all the created tasks are still running. */
301:               BaseType_t xAreBlockingQueuesStillRunning( void )
302:               {
004098  FA0004     LNK #0x4
303:               static short sLastBlockingConsumerCount[ blckqNUM_TASK_SETS ] = { ( uint16_t ) 0, ( uint16_t ) 0, ( uint16_t ) 0 };
304:               static short sLastBlockingProducerCount[ blckqNUM_TASK_SETS ] = { ( uint16_t ) 0, ( uint16_t ) 0, ( uint16_t ) 0 };
305:               BaseType_t xReturn = pdPASS, xTasks;
00409A  200010     MOV #0x1, W0
00409C  780F00     MOV W0, [W14]
306:               
307:               	/* Not too worried about mutual exclusion on these variables as they are 16
308:               	bits and we are only reading them. We also only care to see if they have
309:               	changed or not.
310:               
311:               	Loop through each check variable to and return pdFALSE if any are found not
312:               	to have changed since the last call. */
313:               
314:               	for( xTasks = 0; xTasks < blckqNUM_TASK_SETS; xTasks++ )
00409E  EB0000     CLR W0
0040A0  980710     MOV W0, [W14+2]
0040A2  370033     BRA .L14
004104  90001E     MOV [W14+2], W0
004106  E80000     INC W0, W0
004108  980710     MOV W0, [W14+2]
00410A  90001E     MOV [W14+2], W0
00410C  500FE2     SUB W0, #0x2, [W15]
00410E  34FFCA     BRA LE, .L17
315:               	{
316:               		if( sBlockingConsumerCount[ xTasks ] == sLastBlockingConsumerCount[ xTasks ]  )
0040A4  90001E     MOV [W14+2], W0
0040A6  400080     ADD W0, W0, W1
0040A8  21D720     MOV #0x1D72, W0
0040AA  408000     ADD W1, W0, W0
0040AC  780090     MOV [W0], W1
0040AE  90001E     MOV [W14+2], W0
0040B0  400100     ADD W0, W0, W2
0040B2  21D7E0     MOV #0x1D7E, W0
0040B4  410000     ADD W2, W0, W0
0040B6  780010     MOV [W0], W0
0040B8  508F80     SUB W1, W0, [W15]
0040BA  3A0002     BRA NZ, .L15
317:               		{
318:               			xReturn = pdFALSE;
0040BC  EB0000     CLR W0
0040BE  780F00     MOV W0, [W14]
319:               		}
320:               		sLastBlockingConsumerCount[ xTasks ] = sBlockingConsumerCount[ xTasks ];
0040C0  90001E     MOV [W14+2], W0
0040C2  400080     ADD W0, W0, W1
0040C4  21D720     MOV #0x1D72, W0
0040C6  408000     ADD W1, W0, W0
0040C8  780090     MOV [W0], W1
0040CA  90001E     MOV [W14+2], W0
0040CC  400100     ADD W0, W0, W2
0040CE  21D7E0     MOV #0x1D7E, W0
0040D0  410000     ADD W2, W0, W0
0040D2  780801     MOV W1, [W0]
321:               
322:               
323:               		if( sBlockingProducerCount[ xTasks ] == sLastBlockingProducerCount[ xTasks ]  )
0040D4  90001E     MOV [W14+2], W0
0040D6  400080     ADD W0, W0, W1
0040D8  21D780     MOV #0x1D78, W0
0040DA  408000     ADD W1, W0, W0
0040DC  780090     MOV [W0], W1
0040DE  90001E     MOV [W14+2], W0
0040E0  400100     ADD W0, W0, W2
0040E2  21D840     MOV #0x1D84, W0
0040E4  410000     ADD W2, W0, W0
0040E6  780010     MOV [W0], W0
0040E8  508F80     SUB W1, W0, [W15]
0040EA  3A0002     BRA NZ, .L16
324:               		{
325:               			xReturn = pdFALSE;
0040EC  EB0000     CLR W0
0040EE  780F00     MOV W0, [W14]
326:               		}
327:               		sLastBlockingProducerCount[ xTasks ] = sBlockingProducerCount[ xTasks ];
0040F0  90001E     MOV [W14+2], W0
0040F2  400080     ADD W0, W0, W1
0040F4  21D780     MOV #0x1D78, W0
0040F6  408000     ADD W1, W0, W0
0040F8  780090     MOV [W0], W1
0040FA  90001E     MOV [W14+2], W0
0040FC  400100     ADD W0, W0, W2
0040FE  21D840     MOV #0x1D84, W0
004100  410000     ADD W2, W0, W0
004102  780801     MOV W1, [W0]
328:               	}
329:               
330:               	return xReturn;
004110  78001E     MOV [W14], W0
331:               }
004112  FA8000     ULNK
004114  060000     RETURN
332:               
---  /home/zxc/Documents/WCGRTOS/Demo/BSP/timertest.c  --------------------------------------------------
1:                 /*
2:                     FreeRTOS V9.0.0 - Copyright (C) 2016 Real Time Engineers Ltd.
3:                     All rights reserved
4:                 
5:                     VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
6:                 
7:                     This file is part of the FreeRTOS distribution.
8:                 
9:                     FreeRTOS is free software; you can redistribute it and/or modify it under
10:                    the terms of the GNU General Public License (version 2) as published by the
11:                    Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
12:                
13:                    ***************************************************************************
14:                    >>!   NOTE: The modification to the GPL is included to allow you to     !<<
15:                    >>!   distribute a combined work that includes FreeRTOS without being   !<<
16:                    >>!   obliged to provide the source code for proprietary components     !<<
17:                    >>!   outside of the FreeRTOS kernel.                                   !<<
18:                    ***************************************************************************
19:                
20:                    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
21:                    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
22:                    FOR A PARTICULAR PURPOSE.  Full license text is available on the following
23:                    link: http://www.freertos.org/a00114.html
24:                
25:                    ***************************************************************************
26:                     *                                                                       *
27:                     *    FreeRTOS provides completely free yet professionally developed,    *
28:                     *    robust, strictly quality controlled, supported, and cross          *
29:                     *    platform software that is more than just the market leader, it     *
30:                     *    is the industry's de facto standard.                               *
31:                     *                                                                       *
32:                     *    Help yourself get started quickly while simultaneously helping     *
33:                     *    to support the FreeRTOS project by purchasing a FreeRTOS           *
34:                     *    tutorial book, reference manual, or both:                          *
35:                     *    http://www.FreeRTOS.org/Documentation                              *
36:                     *                                                                       *
37:                    ***************************************************************************
38:                
39:                    http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
40:                    the FAQ page "My application does not run, what could be wrong?".  Have you
41:                    defined configASSERT()?
42:                
43:                    http://www.FreeRTOS.org/support - In return for receiving this top quality
44:                    embedded software for free we request you assist our global community by
45:                    participating in the support forum.
46:                
47:                    http://www.FreeRTOS.org/training - Investing in training allows your team to
48:                    be as productive as possible as early as possible.  Now you can receive
49:                    FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
50:                    Ltd, and the world's leading authority on the world's leading RTOS.
51:                
52:                    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
53:                    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
54:                    compatible FAT file system, and our tiny thread aware UDP/IP stack.
55:                
56:                    http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
57:                    Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
58:                
59:                    http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
60:                    Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
61:                    licenses offer ticketed support, indemnification and commercial middleware.
62:                
63:                    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
64:                    engineered and independently SIL3 certified version for use in safety and
65:                    mission critical applications that require provable dependability.
66:                
67:                    1 tab == 4 spaces!
68:                */
69:                
70:                /* High speed timer test as described in main.c. */
71:                
72:                
73:                /* Scheduler includes. */
74:                #include "FreeRTOS.h"
75:                
76:                /* Demo includes. */
77:                #include "partest.h"
78:                
79:                /* The number of interrupts to pass before we start looking at the jitter. */
80:                #define timerSETTLE_TIME			5
81:                
82:                /* The maximum value the 16bit timer can contain. */
83:                #define timerMAX_COUNT				0xffff
84:                
85:                /*-----------------------------------------------------------*/
86:                
87:                /*
88:                 * Measure the time between this interrupt and the previous interrupt to 
89:                 * calculate the timing jitter.  Remember the maximum value the jitter has
90:                 * ever been calculated to be.
91:                 */
92:                static void prvCalculateAndStoreJitter( void );
93:                
94:                /*-----------------------------------------------------------*/
95:                
96:                /* The maximum time (in processor clocks) between two consecutive timer
97:                interrupts so far. */
98:                unsigned short usMaxJitter = 0;
99:                
100:               /*-----------------------------------------------------------*/
101:               
102:               void vSetupTimerTest( unsigned short usFrequencyHz )
103:               {
00501E  FA0002     LNK #0x2
005020  780F00     MOV W0, [W14]
104:               	/* T2 is used to generate interrupts.  T4 is used to provide an accurate
105:               	time measurement. */
106:               	T2CON = 0;
005022  EF2110     CLR T2CON
107:               	T3CON = 0;
005024  EF2112     CLR T3CON
108:               	TMR2 = 0;
005026  EF2106     CLR TMR2
109:               	TMR3 = 0;
005028  EF210A     CLR TMR3
110:               
111:               	/* Timer 2 is going to interrupt at usFrequencyHz Hz. */
112:               	PR2 = ( unsigned short ) ( configCPU_CLOCK_HZ / ( unsigned long ) usFrequencyHz );
00502A  78001E     MOV [W14], W0
00502C  EB0080     CLR W1
00502E  BE0100     MOV.D W0, W2
005030  209000     MOV #0x900, W0
005032  2003D1     MOV #0x3D, W1
005034  0209B4     CALL ___udivsi3
005036  000000     NOP
005038  780000     MOV W0, W0
00503A  880860     MOV W0, PR2
113:               
114:               	/* Timer 4 is going to free run from minimum to maximum value. */
115:               	PR3 = ( unsigned short ) timerMAX_COUNT;
00503C  EB8000     SETM W0
00503E  880870     MOV W0, PR3
116:               
117:               	/* Setup timer 2 interrupt priority to be above the kernel priority so 
118:               	the timer jitter is not effected by the kernel activity. */
119:               	IPC1bits.T2IP = configKERNEL_INTERRUPT_PRIORITY + 1;
005040  800531     MOV IPC1, W1
005042  28FFF0     MOV #0x8FFF, W0
005044  608000     AND W1, W0, W0
005046  A0D000     BSET W0, #13
005048  880530     MOV W0, IPC1
120:               
121:               	/* Clear the interrupt as a starting condition. */
122:               	IFS0bits.T2IF = 0;
00504A  A9E084     BCLR IFS0, #7
123:               
124:               	/* Enable the interrupt. */
125:               	IEC0bits.T2IE = 1;
00504C  A8E094     BSET IEC0, #7
126:               
127:               	/* Start both timers. */
128:               	T2CONbits.TON = 1;
00504E  A8E111     BSET 0x111, #7
129:               	T3CONbits.TON = 1;
005050  A8E113     BSET 0x113, #7
130:               }
005052  FA8000     ULNK
005054  060000     RETURN
131:               /*-----------------------------------------------------------*/
132:               
133:               static void prvCalculateAndStoreJitter( void )
134:               {
005056  FA0004     LNK #0x4
135:               static unsigned short usLastCount = 0, usSettleCount = 0;
136:               unsigned short usThisCount, usDifference;
137:               
138:               	/* Capture the timer value as we enter the interrupt. */
139:               	usThisCount = TMR3;
005058  800851     MOV TMR3, W1
00505A  780F01     MOV W1, [W14]
140:               
141:               	if( usSettleCount >= timerSETTLE_TIME )
00505C  804500     MOV usSettleCount, W0
00505E  500FE4     SUB W0, #0x4, [W15]
005060  36000A     BRA LEU, .L3
142:               	{
143:               		/* What is the difference between the timer value in this interrupt
144:               		and the value from the last interrupt. */
145:               		usDifference = usThisCount - usLastCount;
005062  804510     MOV usLastCount, W0
005064  10001E     SUBR W0, [W14], W0
005066  980710     MOV W0, [W14+2]
146:               
147:               		/* Store the difference in the timer values if it is larger than the
148:               		currently stored largest value.  The difference over and above the 
149:               		expected difference will give the 'jitter' in the processing of these
150:               		interrupts. */
151:               		if( usDifference > usMaxJitter )
005068  8044F0     MOV usMaxJitter, W0
00506A  90009E     MOV [W14+2], W1
00506C  508F80     SUB W1, W0, [W15]
00506E  360006     BRA LEU, .L4
152:               		{
153:               			usMaxJitter = usDifference;
005070  90009E     MOV [W14+2], W1
005072  8844F1     MOV W1, usMaxJitter
005074  370003     BRA .L4
154:               		}
155:               	}
156:               	else
157:               	{
158:               		/* Don't bother storing any values for the first couple of 
159:               		interrupts. */
160:               		usSettleCount++;
005076  804500     MOV usSettleCount, W0
005078  E80000     INC W0, W0
00507A  884500     MOV W0, usSettleCount
161:               	}
162:               
163:               	/* Remember what the timer value was this time through, so we can calculate
164:               	the difference the next time through. */
165:               	usLastCount = usThisCount;
00507C  78009E     MOV [W14], W1
00507E  884511     MOV W1, usLastCount
166:               }
005080  FA8000     ULNK
005082  060000     RETURN
167:               /*-----------------------------------------------------------*/
168:               
169:               void __attribute__((__interrupt__, auto_psv)) _T2Interrupt( void )
170:               {
000448  F80036     PUSH RCOUNT
00044A  BE9F80     MOV.D W0, [W15++]
00044C  BE9F82     MOV.D W2, [W15++]
00044E  BE9F84     MOV.D W4, [W15++]
000450  BE9F86     MOV.D W6, [W15++]
000452  F80032     PUSH DSRPAG
000454  F80034     PUSH DSWPAG
000456  200010     MOV #0x1, W0
000458  8801A0     MOV W0, DSWPAG
00045A  202000     MOV #0x200, W0
00045C  880190     MOV W0, DSRPAG
00045E  FA0000     LNK #0x0
171:               	/* Work out the time between this and the previous interrupt. */
172:               	prvCalculateAndStoreJitter();
000460  025056     CALL _prvCalculateAndStoreJitter, .LFE0, .LFB1
000462  000000     NOP
173:               
174:               	/* Clear the timer interrupt. */
175:               	IFS0bits.T2IF = 0;
000464  A9E084     BCLR IFS0, #7
176:               }
000466  FA8000     ULNK
000468  F90034     POP DSWPAG
00046A  F90032     POP DSRPAG
00046C  BE034F     MOV.D [--W15], W6
00046E  BE024F     MOV.D [--W15], W4
000470  BE014F     MOV.D [--W15], W2
000472  BE004F     MOV.D [--W15], W0
000474  F90036     POP RCOUNT
000476  064000     RETFIE
177:               
178:               
---  /home/zxc/Documents/WCGRTOS/Demo/BSP/UART3.c  ------------------------------------------------------
1:                 //#include "includes.h"
2:                 #include "UART3.h"
3:                 #include <xc.h>
4:                 
5:                 void UART3_Init(void) {
004CE0  FA0000     LNK #0x0
6:                     TRISGbits.TRISG8 = 1; //
004CE2  A802F1     BSET 0x2F1, #0
7:                     TRISGbits.TRISG7 = 0; //
004CE4  A9E2F0     BCLR TRISG, #7
8:                     ANSGbits.ANSG7 = 0; //
004CE6  A9E4EC     BCLR ANSG, #7
9:                     ANSGbits.ANSG8 = 0;
004CE8  A904ED     BCLR 0x4ED, #0
10:                    ODCGbits.ODG8 = 1; //
004CEA  A802F7     BSET 0x2F7, #0
11:                    //    TRISDbits.TRISD3 = 1; //
12:                    //    TRISDbits.TRISD2 = 0; //
13:                
14:                    U3MODEbits.BRGH = 0; //1:16
004CEC  A96250     BCLR U3MODE, #3
15:                    U3BRG = 0x19; //19200 103; //16000000/9600/16-1
004CEE  200190     MOV #0x19, W0
004CF0  8812C0     MOV W0, U3BRG
16:                    U3MODEbits.PDSEL = 00; //
004CF2  801281     MOV U3MODE, W1
004CF4  2FFF90     MOV #0xFFF9, W0
004CF6  608000     AND W1, W0, W0
004CF8  881280     MOV W0, U3MODE
17:                    U3MODEbits.STSEL = 0; //1
004CFA  A90250     BCLR U3MODE, #0
18:                
19:                    U3MODEbits.UARTEN = 1; //
004CFC  A8E251     BSET 0x251, #7
20:                
21:                    U3STAbits.URXISEL = 3; // 4  1
004CFE  801291     MOV U3STA, W1
004D00  200C00     MOV #0xC0, W0
004D02  700001     IOR W0, W1, W0
004D04  881290     MOV W0, U3STA
22:                    IFS5bits.U3RXIF = 0; //  
004D06  A9408E     BCLR IFS5, #2
23:                    IPC20bits.U3RXIP = 6;
004D08  800661     MOV IPC20, W1
004D0A  2F8FF0     MOV #0xF8FF, W0
004D0C  608080     AND W1, W0, W1
004D0E  206000     MOV #0x600, W0
004D10  700001     IOR W0, W1, W0
004D12  880660     MOV W0, IPC20
24:                    IEC5bits.U3RXIE = 1; //
004D14  A8409E     BSET IEC5, #2
25:                    IFS5bits.U3ERIF = 0;
004D16  A9208E     BCLR IFS5, #1
26:                    IPC20bits.U3ERIP = 7;
004D18  800661     MOV IPC20, W1
004D1A  200700     MOV #0x70, W0
004D1C  700001     IOR W0, W1, W0
004D1E  880660     MOV W0, IPC20
27:                    IEC5bits.U3ERIE = 1;
004D20  A8209E     BSET IEC5, #1
28:                    U3STAbits.UTXEN = 1; //  
004D22  A84253     BSET 0x253, #2
29:                }
004D24  FA8000     ULNK
004D26  060000     RETURN
30:                
31:                void UART3_Open(void) {
004D28  FA0000     LNK #0x0
32:                    U3MODEbits.UARTEN = 1; //
004D2A  A8E251     BSET 0x251, #7
33:                    U3STAbits.UTXEN = 1; //  
004D2C  A84253     BSET 0x253, #2
34:                    // IEC1bits.U3TXIE=1;
35:                    IEC5bits.U3RXIE = 1;
004D2E  A8409E     BSET IEC5, #2
36:                }
004D30  FA8000     ULNK
004D32  060000     RETURN
37:                
38:                void UART3_Close(void) {
004D34  FA0000     LNK #0x0
39:                    // IEC1bits.U3TXIE=0;
40:                    IEC5bits.U3RXIE = 0;
004D36  A9409E     BCLR IEC5, #2
41:                    U3STAbits.UTXEN = 1; //  
004D38  A84253     BSET 0x253, #2
42:                    U3MODEbits.UARTEN = 0; //    
004D3A  A9E251     BCLR 0x251, #7
43:                }
004D3C  FA8000     ULNK
004D3E  060000     RETURN
44:                
45:                void UART3_SendChar(uint8_t ch) {
004D40  FA0002     LNK #0x2
004D42  784F00     MOV.B W0, [W14]
46:                    U3TXREG = ch;
004D44  FB801E     ZE [W14], W0
004D46  8812A0     MOV W0, U3TXREG
47:                    while (!U3STAbits.TRMT);
004D48  000000     NOP
004D4A  801291     MOV U3STA, W1
004D4C  201000     MOV #0x100, W0
004D4E  608000     AND W1, W0, W0
004D50  E00000     CP0 W0
004D52  32FFFB     BRA Z, .L5
48:                }
004D54  FA8000     ULNK
004D56  060000     RETURN
49:                
50:                uint8_t UART3_SendString(const uint8_t *str, const uint8_t len) {
004D58  FA0006     LNK #0x6
004D5A  980710     MOV W0, [W14+2]
004D5C  984741     MOV.B W1, [W14+4]
51:                    uint8_t bytes = 0;
004D5E  EB4000     CLR.B W0
004D60  784F00     MOV.B W0, [W14]
52:                    for (bytes = 0; bytes < len; bytes++) {//(bytes++ < len) {
004D62  EB4000     CLR.B W0
004D64  784F00     MOV.B W0, [W14]
004D66  370006     BRA .L7
004D72  E84F1E     INC.B [W14], [W14]
004D74  90404E     MOV.B [W14+4], W0
004D76  78409E     MOV.B [W14], W1
004D78  50CF80     SUB.B W1, W0, [W15]
004D7A  39FFF6     BRA NC, .L8
53:                        UART3_SendChar(*(str + bytes));
004D68  FB801E     ZE [W14], W0
004D6A  90009E     MOV [W14+2], W1
004D6C  408000     ADD W1, W0, W0
004D6E  784010     MOV.B [W0], W0
004D70  07FFE7     RCALL UART3_SendChar
54:                        //        bytes++;
55:                    }
56:                    return bytes;
004D7C  78401E     MOV.B [W14], W0
57:                }
004D7E  FA8000     ULNK
004D80  060000     RETURN
58:                
59:                bool UART3_ReceiveChar(uint8_t * ch) {
004D82  FA0002     LNK #0x2
004D84  780F00     MOV W0, [W14]
60:                    if (U3STAbits.URXDA) {
004D86  801290     MOV U3STA, W0
004D88  600061     AND W0, #0x1, W0
004D8A  E00000     CP0 W0
004D8C  320006     BRA Z, .L10
61:                        *ch = U3RXREG;
004D8E  8012B0     MOV U3RXREG, W0
004D90  784080     MOV.B W0, W1
004D92  78001E     MOV [W14], W0
004D94  784801     MOV.B W1, [W0]
62:                        return true;
004D96  B3C010     MOV.B #0x1, W0
004D98  370001     BRA .L11
63:                    } else
64:                        return false;
004D9A  EB4000     CLR.B W0
65:                }
004D9C  FA8000     ULNK
004D9E  060000     RETURN
66:                
67:                void U3Rx4Byte(void) {//4
004DA0  FA0000     LNK #0x0
68:                //    uint8_t cnt;
69:                //    for (cnt = 0; cnt < 4; cnt++)//
70:                //        if (U3STAbits.URXDA) //
71:                //            BufferWrite_UART3();
72:                }
004DA2  FA8000     ULNK
004DA4  060000     RETURN
73:                
74:                
75:                
---  /home/zxc/Documents/WCGRTOS/Demo/BSP/UART2.c  ------------------------------------------------------
1:                 #include "UART2.h"
2:                 
3:                 
4:                 
5:                 void UART2_Init(void) {
004A38  FA0000     LNK #0x0
6:                     //
7:                     TRISDbits.TRISD2 = 1; //
004A3A  A842D8     BSET TRISD, #2
8:                     TRISDbits.TRISD3 = 0; //
004A3C  A962D8     BCLR TRISD, #3
9:                     //    TRISDbits.TRISD3 = 1; //
10:                    //    TRISDbits.TRISD2 = 0; //
11:                
12:                    U2MODEbits.BRGH = 1; //1:16  U2MODEbits.BRGH
004A3E  A86230     BSET U2MODE, #3
13:                    U2BRG = 12; //1000000/19200/4-1
004A40  2000C0     MOV #0xC, W0
004A42  8811C0     MOV W0, U2BRG
14:                    U2MODEbits.PDSEL = 00; //
004A44  801181     MOV U2MODE, W1
004A46  2FFF90     MOV #0xFFF9, W0
004A48  608000     AND W1, W0, W0
004A4A  881180     MOV W0, U2MODE
15:                    U2MODEbits.STSEL = 0; //1
004A4C  A90230     BCLR U2MODE, #0
16:                
17:                    U2MODEbits.UARTEN = 1; //
004A4E  A8E231     BSET 0x231, #7
18:                
19:                    U2STAbits.UTXEN = 1; //  
004A50  A84233     BSET 0x233, #2
20:                    U2STAbits.URXISEL = 3; // 4  1
004A52  801191     MOV U2STA, W1
004A54  200C00     MOV #0xC0, W0
004A56  700001     IOR W0, W1, W0
004A58  881190     MOV W0, U2STA
21:                    IPC7bits.U2RXIP = 7;
004A5A  800591     MOV IPC7, W1
004A5C  207000     MOV #0x700, W0
004A5E  700001     IOR W0, W1, W0
004A60  880590     MOV W0, IPC7
22:                    //    IFS0bits.U2RXIF = 0; //
23:                    //    IEC0bits.U2RXIE = 1; //
24:                    IPC16bits.U2ERIP = 6;
004A62  800621     MOV IPC16, W1
004A64  2F8FF0     MOV #0xF8FF, W0
004A66  608080     AND W1, W0, W1
004A68  206000     MOV #0x600, W0
004A6A  700001     IOR W0, W1, W0
004A6C  880620     MOV W0, IPC16
25:                    IEC1bits.U2RXIE = 1; //
004A6E  A8C097     BSET 0x97, #6
26:                    IFS1bits.U2RXIF = 0; //
004A70  A9C087     BCLR 0x87, #6
27:                    IEC4bits.U2ERIE = 1;
004A72  A8409C     BSET IEC4, #2
28:                    IFS4bits.U2ERIF = 0;
004A74  A9408C     BCLR IFS4, #2
29:                }
004A76  FA8000     ULNK
004A78  060000     RETURN
30:                
31:                void UART2_Open(void) {
004A7A  FA0000     LNK #0x0
32:                    U2MODEbits.UARTEN = 1; //
004A7C  A8E231     BSET 0x231, #7
33:                    U2STAbits.UTXEN = 1; //  
004A7E  A84233     BSET 0x233, #2
34:                    // IEC1bits.U2TXIE=1;
35:                    IEC1bits.U2RXIE = 1;
004A80  A8C097     BSET 0x97, #6
36:                }
004A82  FA8000     ULNK
004A84  060000     RETURN
37:                
38:                void UART2_Close(void) {
004A86  FA0000     LNK #0x0
39:                    // IEC1bits.U2TXIE=0;
40:                    IEC1bits.U2RXIE = 0;
004A88  A9C097     BCLR 0x97, #6
41:                    U2STAbits.UTXEN = 0; //  
004A8A  A94233     BCLR 0x233, #2
42:                    U2MODEbits.UARTEN = 0; //    
004A8C  A9E231     BCLR 0x231, #7
43:                }
004A8E  FA8000     ULNK
004A90  060000     RETURN
44:                
45:                void UART2_SendChar(uint8_t ch) {
004A92  FA0002     LNK #0x2
004A94  784F00     MOV.B W0, [W14]
46:                    U2TXREG = ch;
004A96  FB801E     ZE [W14], W0
004A98  8811A0     MOV W0, U2TXREG
47:                    while (!U2STAbits.TRMT);
004A9A  000000     NOP
004A9C  801191     MOV U2STA, W1
004A9E  201000     MOV #0x100, W0
004AA0  608000     AND W1, W0, W0
004AA2  E00000     CP0 W0
004AA4  32FFFB     BRA Z, .L5
48:                }
004AA6  FA8000     ULNK
004AA8  060000     RETURN
49:                
50:                uint8_t UART2_SendString(const uint8_t *str) {
004AAA  FA0004     LNK #0x4
004AAC  980710     MOV W0, [W14+2]
51:                    uint8_t bytes = 0;
004AAE  EB4000     CLR.B W0
004AB0  784F00     MOV.B W0, [W14]
52:                    while (*(str + bytes) != '\0') {
004AB2  370006     BRA .L7
004AC0  FB801E     ZE [W14], W0
004AC2  90009E     MOV [W14+2], W1
004AC4  408000     ADD W1, W0, W0
004AC6  784010     MOV.B [W0], W0
004AC8  E00400     CP0.B W0
004ACA  3AFFF4     BRA NZ, .L8
53:                        UART2_SendChar(*(str + bytes));
004AB4  FB801E     ZE [W14], W0
004AB6  90009E     MOV [W14+2], W1
004AB8  408000     ADD W1, W0, W0
004ABA  784010     MOV.B [W0], W0
004ABC  07FFEA     RCALL UART2_SendChar
54:                        bytes++;
004ABE  E84F1E     INC.B [W14], [W14]
55:                    }
56:                    return bytes;
004ACC  78401E     MOV.B [W14], W0
57:                }
004ACE  FA8000     ULNK
004AD0  060000     RETURN
58:                
59:                uint8_t UART2_SendString2(const uint8_t *str, uint8_t len) {
004AD2  FA0006     LNK #0x6
004AD4  980710     MOV W0, [W14+2]
004AD6  984741     MOV.B W1, [W14+4]
60:                    uint8_t bytes = 0;
004AD8  EB4000     CLR.B W0
004ADA  784F00     MOV.B W0, [W14]
61:                    while (bytes < len) {
004ADC  37000D     BRA .L10
004AF8  90404E     MOV.B [W14+4], W0
004AFA  78409E     MOV.B [W14], W1
004AFC  50CF80     SUB.B W1, W0, [W15]
004AFE  39FFEF     BRA NC, .L12
62:                        U2TXREG = (*(str + bytes));
004ADE  FB801E     ZE [W14], W0
004AE0  90009E     MOV [W14+2], W1
004AE2  408000     ADD W1, W0, W0
004AE4  784010     MOV.B [W0], W0
004AE6  FB8000     ZE W0, W0
004AE8  8811A0     MOV W0, U2TXREG
63:                        while (!U2STAbits.TRMT);
004AEA  000000     NOP
004AEC  801191     MOV U2STA, W1
004AEE  201000     MOV #0x100, W0
004AF0  608000     AND W1, W0, W0
004AF2  E00000     CP0 W0
004AF4  32FFFB     BRA Z, .L11
64:                        bytes++;
004AF6  E84F1E     INC.B [W14], [W14]
65:                    }
66:                    return bytes;
004B00  78401E     MOV.B [W14], W0
67:                }
004B02  FA8000     ULNK
004B04  060000     RETURN
68:                
69:                bool UART2_ReceiveChar(uint8_t * ch) {
004B06  FA0002     LNK #0x2
004B08  780F00     MOV W0, [W14]
70:                    if (U2STAbits.URXDA) {
004B0A  801190     MOV U2STA, W0
004B0C  600061     AND W0, #0x1, W0
004B0E  E00000     CP0 W0
004B10  320006     BRA Z, .L14
71:                        *ch = U2RXREG;
004B12  8011B0     MOV U2RXREG, W0
004B14  784080     MOV.B W0, W1
004B16  78001E     MOV [W14], W0
004B18  784801     MOV.B W1, [W0]
72:                        return true;
004B1A  B3C010     MOV.B #0x1, W0
004B1C  370001     BRA .L15
73:                    } else
74:                        return false;
004B1E  EB4000     CLR.B W0
75:                }
004B20  FA8000     ULNK
004B22  060000     RETURN
76:                
77:                void U2Rx4Byte(void) {//4
004B24  FA0000     LNK #0x0
78:                //    uint8_t cnt;
79:                //    for (cnt = 0; cnt < 4; cnt++)//
80:                //        if (U2STAbits.URXDA) //
81:                //            BufferWrite_UART2();
82:                }
004B26  FA8000     ULNK
004B28  060000     RETURN
83:                
84:                
85:                
86:                
87:                
---  /home/zxc/Documents/WCGRTOS/Demo/BSP/UART1.c  ------------------------------------------------------
1:                 #include <stdio.h>
2:                 
3:                 #include "UART1.h"
4:                 
5:                 
6:                 #if (UseFreeRTOSInUART1==1)
7:                 
8:                 #include "FreeRTOS.h"
9:                 #include "queue.h"
10:                #include "projdefs.h"
11:                #include "LED.h"
12:                
13:                extern xQueueHandle xQueueUart1Pressure;
14:                #endif
15:                
16:                #if (USE_BUFFER_UART1 == 1)
17:                /*define buffer*/
18:                uint8_t ucUart1Buffer[UART1_BUFFER_LENGTH];
19:                /*define writepointer*/
20:                static uint8_t ucUart1BufferWptr = 0;
21:                /*define readpointer*/
22:                static uint8_t ucUart1BufferRptr = 0;
23:                #endif
24:                
25:                /*************************************
26:                Function: vUART1Init
27:                Description: 485
28:                Input:  
29:                Output: 
30:                 *************************************/
31:                void vUART1Init(void) {
00430E  FA0000     LNK #0x0
32:                    /* 485_CON*/
33:                    UART1_TX_TRIS = 0;
004310  A922C9     BCLR 0x2C9, #1
34:                    /**/
35:                    UART1_RX_TRIS = 1;
004312  A802C9     BSET 0x2C9, #0
36:                    /**/
37:                    RS485_CON1_TRIS = 0;
004314  A942C9     BCLR 0x2C9, #2
38:                    /**/
39:                    UART1_TX_ANS = 0;
004316  A924E3     BCLR 0x4E3, #1
40:                    /**/
41:                    UART1_RX_ANS = 0;
004318  A904E3     BCLR 0x4E3, #0
42:                    /**/
43:                    RS485_CON1_ANS = 1;
00431A  A844E3     BSET 0x4E3, #2
44:                    /*unlock PPS*/
45:                    __builtin_write_OSCCONL(OSCCON & 0xbf);
00431C  803A11     MOV OSCCON, W1
00431E  200BF0     MOV #0xBF, W0
004320  608100     AND W1, W0, W2
004322  200460     MOV #0x46, W0
004324  200571     MOV #0x57, W1
004326  207423     MOV #0x742, W3
004328  784980     MOV.B W0, [W3]
00432A  784981     MOV.B W1, [W3]
00432C  784982     MOV.B W2, [W3]
46:                    /* RB9->UART1:U1TX*/
47:                    RPOR4bits.RP9R = 0x03;
00432E  803641     MOV RPOR4, W1
004330  2C0FF0     MOV #0xC0FF, W0
004332  608080     AND W1, W0, W1
004334  203000     MOV #0x300, W0
004336  700001     IOR W0, W1, W0
004338  883640     MOV W0, RPOR4
48:                    /* RB8->UART1:U1RX*/
49:                    RPINR18bits.U1RXR = 0x08;
00433A  803521     MOV RPINR18, W1
00433C  2FFC00     MOV #0xFFC0, W0
00433E  608000     AND W1, W0, W0
004340  A03000     BSET W0, #3
004342  883520     MOV W0, RPINR18
50:                    /*Lock PPS*/
51:                    __builtin_write_OSCCONL(OSCCON | 0x40);
004344  803A10     MOV OSCCON, W0
004346  780100     MOV W0, W2
004348  A06002     BSET W2, #6
00434A  200460     MOV #0x46, W0
00434C  200571     MOV #0x57, W1
00434E  207423     MOV #0x742, W3
004350  784980     MOV.B W0, [W3]
004352  784981     MOV.B W1, [W3]
004354  784982     MOV.B W2, [W3]
52:                    /**/
53:                    U1MODEbits.UARTEN = 1;
004356  A8E221     BSET 0x221, #7
54:                    /*high baud rate*/
55:                    U1MODEbits.BRGH = 1;
004358  A86220     BSET U1MODE, #3
56:                    /*set baud rate 1000000/9600/4-1,last value equal 0x0019*/
57:                    U1BRG = WCG_CLOCK_HZ / UART1_BAUD_RATE / 4 - 1;
00435A  200670     MOV #0x67, W0
00435C  881140     MOV W0, U1BRG
58:                    /**/
59:                    U1MODEbits.PDSEL = 00;
00435E  801101     MOV U1MODE, W1
004360  2FFF90     MOV #0xFFF9, W0
004362  608000     AND W1, W0, W0
004364  881100     MOV W0, U1MODE
60:                    /*1*/
61:                    U1MODEbits.STSEL = 0;
004366  A90220     BCLR U1MODE, #0
62:                    /**/
63:                    U1MODEbits.USIDL = 0;
004368  A9A221     BCLR 0x221, #5
64:                    /**/
65:                    U1MODEbits.WAKE = 1;
00436A  A8E220     BSET U1MODE, #7
66:                    /*  */
67:                    U1STAbits.UTXEN = 0;
00436C  A94223     BCLR 0x223, #2
68:                    /*4 1*/
69:                    U1STAbits.URXISEL = 3;
00436E  801111     MOV U1STA, W1
004370  200C00     MOV #0xC0, W0
004372  700001     IOR W0, W1, W0
004374  881110     MOV W0, U1STA
70:                    /* send buffer set zero*/
71:                    U1TXREG = 0;
004376  EF2224     CLR U1TXREG
72:                    /*receive buffer set zero*/
73:                    U1RXREG = 0;
004378  EF2226     CLR U1RXREG
74:                    /*set receive interrupt priority is seven*/
75:                    IPC2bits.U1RXIP = 7;
00437A  800541     MOV IPC2, W1
00437C  270000     MOV #0x7000, W0
00437E  700001     IOR W0, W1, W0
004380  880540     MOV W0, IPC2
76:                    /**/
77:                    IFS0bits.U1RXIF = 0;
004382  A96085     BCLR 0x85, #3
78:                    /**/
79:                    IEC0bits.U1RXIE = 1;
004384  A86095     BSET 0x95, #3
80:                    /*set send interrupt priority is six*/
81:                    IPC16bits.U1ERIP = 6;
004386  800621     MOV IPC16, W1
004388  2FF8F0     MOV #0xFF8F, W0
00438A  608080     AND W1, W0, W1
00438C  200600     MOV #0x60, W0
00438E  700001     IOR W0, W1, W0
004390  880620     MOV W0, IPC16
82:                    /**/
83:                    IFS4bits.U1ERIF = 0;
004392  A9208C     BCLR IFS4, #1
84:                    /**/
85:                    IEC4bits.U1ERIE = 1;
004394  A8209C     BSET IEC4, #1
86:                    /*  */
87:                    U1STAbits.UTXEN = 1;
004396  A84223     BSET 0x223, #2
88:                }
004398  FA8000     ULNK
00439A  060000     RETURN
89:                #if (USE_RS485_ON_UART1 == 1)
90:                
91:                /*************************************
92:                Function: vSetRS485CON
93:                Description: set Rs485CON status,1:send mode;0:receive mode
94:                Input:  
95:                Output: 1:
96:                 *************************************/
97:                static void vSetRS485CON(bool bSta) {
00439C  FA0002     LNK #0x2
00439E  784F00     MOV.B W0, [W14]
98:                    /*maybe need delay*/
99:                    /*set 1:send;set 0:receive */
100:                   RS485_CON1 = bSta;
0043A0  FB801E     ZE [W14], W0
0043A2  600061     AND W0, #0x1, W0
0043A4  DD004A     SL W0, #10, W0
0043A6  801661     MOV LATB, W1
0043A8  A1A001     BCLR W1, #10
0043AA  700001     IOR W0, W1, W0
0043AC  881660     MOV W0, LATB
101:                   /*maybe need delay*/
102:               }
0043AE  FA8000     ULNK
0043B0  060000     RETURN
103:               #endif
104:               
105:               /*************************************
106:               Function: vUART1Send
107:               Description: send length of bytes data
108:               Input: ucData,ucBytes
109:               Output: 
110:                *************************************/
111:               void vUART1Send(void* ucData, uint8_t ucBytes) {
0043B2  FA0008     LNK #0x8
0043B4  980720     MOV W0, [W14+4]
0043B6  984761     MOV.B W1, [W14+6]
112:                   uint8_t ucCount = 0;
0043B8  EB4000     CLR.B W0
0043BA  784F00     MOV.B W0, [W14]
113:                   char * pcChar = (char*) ucData;
0043BC  9000AE     MOV [W14+4], W1
0043BE  980711     MOV W1, [W14+2]
114:                   /*use 485 need set mode*/
115:               #if (USE_RS485_ON_UART1 == 1)
116:                   vSetRS485CON(RS485_SEND_MODE);
0043C0  B3C010     MOV.B #0x1, W0
0043C2  07FFEC     RCALL _vSetRS485CON, .LFE0, .LFB1
117:               #endif
118:                   /*send data*/
119:                   while (ucCount < ucBytes) {
0043C4  37000D     BRA .L4
0043E0  90406E     MOV.B [W14+6], W0
0043E2  78409E     MOV.B [W14], W1
0043E4  50CF80     SUB.B W1, W0, [W15]
0043E6  39FFEF     BRA NC, .L6
120:                       U1TXREG = *(pcChar + ucCount);
0043C6  FB801E     ZE [W14], W0
0043C8  90009E     MOV [W14+2], W1
0043CA  408000     ADD W1, W0, W0
0043CC  784010     MOV.B [W0], W0
0043CE  FB0000     SE W0, W0
0043D0  881120     MOV W0, U1TXREG
121:                       while (!U1STAbits.TRMT);
0043D2  000000     NOP
0043D4  801111     MOV U1STA, W1
0043D6  201000     MOV #0x100, W0
0043D8  608000     AND W1, W0, W0
0043DA  E00000     CP0 W0
0043DC  32FFFB     BRA Z, .L5
122:                       ucCount++;
0043DE  E84F1E     INC.B [W14], [W14]
123:                   }
124:                   /*use 485 need set mode*/
125:               #if (USE_RS485_ON_UART1 == 1)
126:                   vSetRS485CON(RS485_RECEIVE_MODE);
0043E8  EB4000     CLR.B W0
0043EA  07FFD8     RCALL _vSetRS485CON, .LFE0, .LFB1
127:               #endif
128:               }
0043EC  FA8000     ULNK
0043EE  060000     RETURN
129:               
130:               /*************************************
131:               Function: vUART1SendString
132:               Description: 485
133:               Input: string address
134:               Output: 
135:                *************************************/
136:               void vUART1SendString(void* dat) {
0043F0  FA0006     LNK #0x6
0043F2  980720     MOV W0, [W14+4]
137:                   uint8_t ucBytes = 0;
0043F4  EB4000     CLR.B W0
0043F6  784F00     MOV.B W0, [W14]
138:               
139:                   char * pcChar = (char*) dat;
0043F8  9000AE     MOV [W14+4], W1
0043FA  980711     MOV W1, [W14+2]
140:                   /*get strings length*/
141:                   ucBytes = strlen(pcChar);
0043FC  90001E     MOV [W14+2], W0
0043FE  020FDA     CALL _strlen
004400  000000     NOP
004402  784F00     MOV.B W0, [W14]
142:                   /*send string*/
143:                   vUART1Send(pcChar, ucBytes);
004404  78409E     MOV.B [W14], W1
004406  90001E     MOV [W14+2], W0
004408  07FFD4     RCALL vUART1Send
144:               }
00440A  FA8000     ULNK
00440C  060000     RETURN
145:               
146:               /*************************************
147:               Function: bUART1Receive 
148:               Description: 43
149:               Input: get char address
150:               Output: bool true:get;false:not get
151:                *************************************/
152:               bool bUART1Receive(int8_t *pcChar) {
00440E  FA0002     LNK #0x2
004410  780F00     MOV W0, [W14]
153:                   /*received 3 byte,don't have interrupt*/
154:                   if (U1STAbits.URXDA) {
004412  801110     MOV U1STA, W0
004414  600061     AND W0, #0x1, W0
004416  E00000     CP0 W0
004418  320006     BRA Z, .L9
155:                       *pcChar = U1RXREG;
00441A  801130     MOV U1RXREG, W0
00441C  784080     MOV.B W0, W1
00441E  78001E     MOV [W14], W0
004420  784801     MOV.B W1, [W0]
156:                       return true;
004422  B3C010     MOV.B #0x1, W0
004424  370001     BRA .L10
157:                   }
158:                   return false;
004426  EB4000     CLR.B W0
159:               }
004428  FA8000     ULNK
00442A  060000     RETURN
160:               
161:               /*************************************
162:               Function: vUART1BufferWrite 
163:               Description: 
164:               Input: void 
165:               Output: 
166:                *************************************/
167:               void vUART1BufferWrite(void) {
00442C  FA0002     LNK #0x2
168:                   uint8_t tmp;
169:                   /* */
170:                   if (ucUart1BufferWptr == (ucUart1BufferRptr - 1)) {
00442E  BFC8AC     MOV.B ucUart1BufferWptr, WREG
004430  FB8080     ZE W0, W1
004432  BFC8AD     MOV.B ucUart1BufferRptr, WREG
004434  FB8000     ZE W0, W0
004436  E90000     DEC W0, W0
004438  508F80     SUB W1, W0, [W15]
00443A  3A0003     BRA NZ, .L12
171:                       tmp = U1RXREG; //
00443C  801130     MOV U1RXREG, W0
00443E  784F00     MOV.B W0, [W14]
172:                       return;
004440  37000C     BRA .L11
173:                   }
174:                   ucUart1Buffer[ucUart1BufferWptr] = U1RXREG;
004442  BFC8AC     MOV.B ucUart1BufferWptr, WREG
004444  FB8000     ZE W0, W0
004446  801131     MOV U1RXREG, W1
004448  784101     MOV.B W1, W2
00444A  21D9E1     MOV #0x1D9E, W1
00444C  787082     MOV.B W2, [W1+W0]
175:                   ucUart1BufferWptr++;
00444E  BFC8AC     MOV.B ucUart1BufferWptr, WREG
004450  E84000     INC.B W0, W0
004452  B7E8AC     MOV.B WREG, ucUart1BufferWptr
176:                   ucUart1BufferWptr %= UART1_BUFFER_LENGTH;
004454  BFC8AC     MOV.B ucUart1BufferWptr, WREG
004456  60406F     AND.B W0, #0xF, W0
004458  B7E8AC     MOV.B WREG, ucUart1BufferWptr
177:               }
00445A  FA8000     ULNK
00445C  060000     RETURN
178:               
179:               /*************************************
180:               Function:  bUART1BufferRead
181:               Description: 
182:               Input:  
183:               Output: 10
184:                *************************************/
185:               bool bUART1BufferRead(uint8_t *pucData) {
00445E  FA0002     LNK #0x2
004460  780F00     MOV W0, [W14]
186:                   if (ucUart1BufferRptr == ucUart1BufferWptr) {
004462  208AD1     MOV #0x8AD, W1
004464  784091     MOV.B [W1], W1
004466  BFC8AC     MOV.B ucUart1BufferWptr, WREG
004468  50CF80     SUB.B W1, W0, [W15]
00446A  3A0007     BRA NZ, .L15
187:                       /*FIFO*/
188:                       if (U1STAbits.OERR)
00446C  801110     MOV U1STA, W0
00446E  600062     AND W0, #0x2, W0
004470  E00000     CP0 W0
004472  320001     BRA Z, .L16
189:                           U1STAbits.OERR = 0;
004474  A92222     BCLR U1STA, #1
190:                       return 0;
004476  EB4000     CLR.B W0
004478  37000D     BRA .L17
191:                   }
192:                   *pucData = ucUart1Buffer[ucUart1BufferRptr];
00447A  BFC8AD     MOV.B ucUart1BufferRptr, WREG
00447C  FB8000     ZE W0, W0
00447E  21D9E1     MOV #0x1D9E, W1
004480  7840E1     MOV.B [W1+W0], W1
004482  78001E     MOV [W14], W0
004484  784801     MOV.B W1, [W0]
193:                   ucUart1BufferRptr++;
004486  BFC8AD     MOV.B ucUart1BufferRptr, WREG
004488  E84000     INC.B W0, W0
00448A  B7E8AD     MOV.B WREG, ucUart1BufferRptr
194:                   ucUart1BufferRptr %= UART1_BUFFER_LENGTH;
00448C  BFC8AD     MOV.B ucUart1BufferRptr, WREG
00448E  60406F     AND.B W0, #0xF, W0
004490  B7E8AD     MOV.B WREG, ucUart1BufferRptr
195:                   return 1;
004492  B3C010     MOV.B #0x1, W0
196:               }
004494  FA8000     ULNK
004496  060000     RETURN
197:               
198:               /*************************************
199:               Function: usUART1GetBufferSize 
200:               Description: uart1 vaild buffer size
201:               Input: void
202:               Output: length
203:                *************************************/
204:               unsigned int usUART1GetBufferSize(void) {
004498  FA0000     LNK #0x0
205:                   if (ucUart1BufferWptr < ucUart1BufferRptr)
00449A  208AC1     MOV #0x8AC, W1
00449C  784091     MOV.B [W1], W1
00449E  BFC8AD     MOV.B ucUart1BufferRptr, WREG
0044A0  50CF80     SUB.B W1, W0, [W15]
0044A2  310003     BRA C, .L19
206:                       ucUart1BufferWptr += UART1_BUFFER_LENGTH;
0044A4  BFC8AC     MOV.B ucUart1BufferWptr, WREG
0044A6  404070     ADD.B W0, #0x10, W0
0044A8  B7E8AC     MOV.B WREG, ucUart1BufferWptr
207:                   return ucUart1BufferWptr - ucUart1BufferRptr;
0044AA  BFC8AC     MOV.B ucUart1BufferWptr, WREG
0044AC  FB8080     ZE W0, W1
0044AE  BFC8AD     MOV.B ucUart1BufferRptr, WREG
0044B0  FB8000     ZE W0, W0
0044B2  508000     SUB W1, W0, W0
208:               }
0044B4  FA8000     ULNK
0044B6  060000     RETURN
209:               
210:               /*************************************
211:               Function: vUARTRxGetLast3Byte 
212:               Description: uart1 get data (no interrupt)
213:               Input: void
214:               Output: void
215:                *************************************/
216:               void vUARTRxGet4Byte(void) {
0044B8  FA0002     LNK #0x2
217:                   unsigned char ucCount;
218:                   for (ucCount = 0; ucCount < 4; ucCount++) {
0044BA  EB4000     CLR.B W0
0044BC  784F00     MOV.B W0, [W14]
0044BE  370006     BRA .L21
0044CA  E84F1E     INC.B [W14], [W14]
0044CC  78401E     MOV.B [W14], W0
0044CE  504FE3     SUB.B W0, #0x3, [W15]
0044D0  36FFF7     BRA LEU, .L23
219:                       /**/
220:                       if (U1STAbits.URXDA)
0044C0  801110     MOV U1STA, W0
0044C2  600061     AND W0, #0x1, W0
0044C4  E00000     CP0 W0
221:                           vUART1BufferWrite();
0044C6  320001     BRA Z, .L22
0044C8  07FFB1     RCALL vUART1BufferWrite
222:                   }
223:               }
0044D2  FA8000     ULNK
0044D4  060000     RETURN
224:               
225:               /*************************************
226:               Function: _U1RXInterrupt 
227:               Description: uart1 receive interrupt
228:               Input: void
229:               Output: void
230:                *************************************/
231:               void __attribute__((interrupt, no_auto_psv)) _U1RXInterrupt(void) {
000494  F80036     PUSH RCOUNT
000496  BE9F80     MOV.D W0, [W15++]
000498  BE9F82     MOV.D W2, [W15++]
00049A  BE9F84     MOV.D W4, [W15++]
00049C  BE9F86     MOV.D W6, [W15++]
00049E  FA0002     LNK #0x2
232:               #if (UseFreeRTOSInUART1 == 1)
233:                   BaseType_t xHigherPriorityTaskWoken;
234:               #endif
235:                   vUARTRxGet4Byte();
0004A0  0244B8     CALL vUARTRxGet4Byte
0004A2  000000     NOP
236:               #if (UseFreeRTOSInUART1 == 1)
237:                   if (usUART1GetBufferSize() >= 8) {
0004A4  024498     CALL usUART1GetBufferSize
0004A6  000000     NOP
0004A8  500FE7     SUB W0, #0x7, [W15]
0004AA  36000C     BRA LEU, .L25
238:                       xQueueSendFromISR(xQueueUart1Pressure, ucUart1Buffer, &xHigherPriorityTaskWoken);
0004AC  804420     MOV xQueueUart1Pressure, W0
0004AE  EB0180     CLR W3
0004B0  78010E     MOV W14, W2
0004B2  21D9E1     MOV #0x1D9E, W1
0004B4  0221F2     CALL xQueueGenericSendFromISR
0004B6  000000     NOP
239:                       if (xHigherPriorityTaskWoken)
0004B8  78001E     MOV [W14], W0
0004BA  E00000     CP0 W0
0004BC  320003     BRA Z, .L25
240:                           portYIELD();
0004BE  0250DC     CALL .Letext0, .LFE1, _vPortYield
0004C0  000000     NOP
0004C2  000000     NOP
241:                   }
242:               
243:               #endif
244:                   LEDGreenON;
0004C4  A8A2E4     BSET LATE, #5
245:                   _U1RXIF = 0;
0004C6  A96085     BCLR 0x85, #3
246:               }
0004C8  FA8000     ULNK
0004CA  BE034F     MOV.D [--W15], W6
0004CC  BE024F     MOV.D [--W15], W4
0004CE  BE014F     MOV.D [--W15], W2
0004D0  BE004F     MOV.D [--W15], W0
0004D2  F90036     POP RCOUNT
0004D4  064000     RETFIE
247:               
248:               /*************************************
249:               Function: UART1
250:               Description: 
251:               Input:  
252:               Output: 
253:                *************************************/
254:               void __attribute__((interrupt, no_auto_psv)) _U1ErrInterrupt(void) {
0004D6  781F80     MOV W0, [W15++]
0004D8  FA0000     LNK #0x0
255:                   LEDRedON;
0004DA  A8E2E4     BSET LATE, #7
256:                   if (U1STAbits.OERR)
0004DC  801110     MOV U1STA, W0
0004DE  600062     AND W0, #0x2, W0
0004E0  E00000     CP0 W0
0004E2  320001     BRA Z, .L27
257:                       U1STAbits.OERR = 0;
0004E4  A92222     BCLR U1STA, #1
258:                   if (U1STAbits.FERR) {//mark
0004E6  801110     MOV U1STA, W0
0004E8  600064     AND W0, #0x4, W0
0004EA  E00000     CP0 W0
0004EC  320001     BRA Z, .L28
259:                       //        U1RXREG = U1RXREG;
260:                       U1STAbits.FERR = 0;
0004EE  A94222     BCLR U1STA, #2
261:                   }
262:                   if (U1STAbits.PERR)
0004F0  801110     MOV U1STA, W0
0004F2  600068     AND W0, #0x8, W0
0004F4  E00000     CP0 W0
0004F6  320001     BRA Z, .L29
263:                       U1STAbits.PERR = 0;
0004F8  A96222     BCLR U1STA, #3
264:                   IFS4bits.U1ERIF = 0;
0004FA  A9208C     BCLR IFS4, #1
265:               
266:               }
0004FC  FA8000     ULNK
0004FE  78004F     MOV [--W15], W0
000500  064000     RETFIE
267:               
---  /home/zxc/Documents/WCGRTOS/Demo/BSP/TIM.c  --------------------------------------------------------
1:                 #include <TIM.h>
2:                 //LCD
3:                 
4:                 volatile uint8_t gT3flag;
5:                 volatile uint8_t gT3Cnt;
6:                 //
7:                 
8:                 void TMR1_Initialize(void) {
004C14  FA0000     LNK #0x0
9:                     //TSIDL disabled; TGATE disabled; TCS External; TSYNC disabled; TCKPS 1:1; TECS SOSC; TON enabled; 
10:                    T1CON = 0x0002;
004C16  200020     MOV #0x2, W0
004C18  880820     MOV W0, T1CON
11:                    //TMR1 0; 
12:                    TMR1 = 0x0000;
004C1A  EF2100     CLR TMR1
13:                    //PR1 20; 
14:                    PR1 = 0x8000; //1s// 0xF230; //2s 
004C1C  280000     MOV #0x8000, W0
004C1E  880810     MOV W0, PR1
15:                    T1CONbits.TON = 1;
004C20  A8E105     BSET 0x105, #7
16:                    IPC0bits.T1IP = 5;
004C22  800521     MOV IPC0, W1
004C24  28FFF0     MOV #0x8FFF, W0
004C26  608080     AND W1, W0, W1
004C28  250000     MOV #0x5000, W0
004C2A  700001     IOR W0, W1, W0
004C2C  880520     MOV W0, IPC0
17:                    IFS0bits.T1IF = 0;
004C2E  A96084     BCLR IFS0, #3
18:                    IEC0bits.T1IE = 1;
004C30  A86094     BSET IEC0, #3
19:                }
004C32  FA8000     ULNK
004C34  060000     RETURN
20:                //
21:                
22:                void TMR2_Initialize(void) {
004C36  FA0000     LNK #0x0
23:                    //TSIDL disabled; TGATE disabled; TCS FOSC/2; TCKPS 1:256; T32 disabled; TON enabled; 
24:                    T2CON = 0x8030;
004C38  280300     MOV #0x8030, W0
004C3A  880880     MOV W0, T2CON
25:                    //TMR2 0; 
26:                    TMR2 = 0x0000;
004C3C  EF2106     CLR TMR2
27:                    //Period Value = 10.000 ms; PR2 20000; 
28:                    PR2 = 0xffff; //0x4E20;
004C3E  EB8000     SETM W0
004C40  880860     MOV W0, PR2
29:                    IPC1bits.T2IP = 3;
004C42  800531     MOV IPC1, W1
004C44  28FFF0     MOV #0x8FFF, W0
004C46  608080     AND W1, W0, W1
004C48  230000     MOV #0x3000, W0
004C4A  700001     IOR W0, W1, W0
004C4C  880530     MOV W0, IPC1
30:                    T2CONbits.TON = 0;
004C4E  A9E111     BCLR 0x111, #7
31:                    IFS0bits.T2IF = 0;
004C50  A9E084     BCLR IFS0, #7
32:                }
004C52  FA8000     ULNK
004C54  060000     RETURN
33:                //AT
34:                
35:                void TMR3_Initialize(void) {
004C56  FA0000     LNK #0x0
36:                    //TSIDL disabled; TGATE disabled; TCS FOSC/2; TCKPS 1:256; T32 disabled; TON enabled; 
37:                    T3CON = 0x0030;
004C58  200300     MOV #0x30, W0
004C5A  880890     MOV W0, T3CON
38:                    //TMR2 0; 
39:                    TMR3 = 0x0000;
004C5C  EF210A     CLR TMR3
40:                    //Period  1M
41:                    PR3 = 391; //100ms
004C5E  201870     MOV #0x187, W0
004C60  880870     MOV W0, PR3
42:                    IPC2bits.T3IP = 1;
004C62  800541     MOV IPC2, W1
004C64  2FFF80     MOV #0xFFF8, W0
004C66  608000     AND W1, W0, W0
004C68  A00000     BSET W0, #0
004C6A  880540     MOV W0, IPC2
43:                    T3CONbits.TON = 0;
004C6C  A9E113     BCLR 0x113, #7
44:                    IFS0bits.T3IF = 0;
004C6E  A90085     BCLR 0x85, #0
45:                }
004C70  FA8000     ULNK
004C72  060000     RETURN
46:                //PC
47:                
48:                void TMR4_Initialize(void) {
004C74  FA0000     LNK #0x0
49:                    //TSIDL disabled; TGATE disabled; TCS External; TSYNC disabled; TCKPS 1:1; TECS SOSC; TON enabled; 
50:                    T4CON = 0x0030;
004C76  200300     MOV #0x30, W0
004C78  8808F0     MOV W0, T4CON
51:                    //TMR1 0; 
52:                    TMR4 = 0x0000;
004C7A  EF2114     CLR TMR4
53:                    //PR1 20; 
54:                    PR4 = 3915; //1s// 0xF230; //2s 1/1000000*256
004C7C  20F4B0     MOV #0xF4B, W0
004C7E  8808D0     MOV W0, PR4
55:                    T4CONbits.TON = 0;
004C80  A9E11F     BCLR 0x11F, #7
56:                    _T4IP = 2;
004C82  800581     MOV IPC6, W1
004C84  28FFF0     MOV #0x8FFF, W0
004C86  608000     AND W1, W0, W0
004C88  A0D000     BSET W0, #13
004C8A  880580     MOV W0, IPC6
57:                    _T4IF = 0;
004C8C  A96087     BCLR 0x87, #3
58:                    _T4IE = 1;
004C8E  A86097     BSET 0x97, #3
59:                }
004C90  FA8000     ULNK
004C92  060000     RETURN
60:                
61:                void StartTMR2(void) {
004C94  FA0000     LNK #0x0
62:                    IEC0bits.T2IE = 1;
004C96  A8E094     BSET IEC0, #7
63:                    T2CONbits.TON = 1;
004C98  A8E111     BSET 0x111, #7
64:                }
004C9A  FA8000     ULNK
004C9C  060000     RETURN
65:                
66:                void StopTMR2(void) {
004C9E  FA0000     LNK #0x0
67:                    IEC0bits.T2IE = 0;
004CA0  A9E094     BCLR IEC0, #7
68:                    T2CONbits.TON = 0;
004CA2  A9E111     BCLR 0x111, #7
69:                }
004CA4  FA8000     ULNK
004CA6  060000     RETURN
70:                
71:                void StartTMR3(const uint8_t cnt) {
004CA8  FA0002     LNK #0x2
004CAA  784F00     MOV.B W0, [W14]
72:                    TMR3 = 0x0000;
004CAC  EF210A     CLR TMR3
73:                    gT3Cnt = cnt;
004CAE  78411E     MOV.B [W14], W2
004CB0  208291     MOV #0x829, W1
004CB2  784882     MOV.B W2, [W1]
74:                    //Period Value = 10.000 ms; PR2 20000; 4M
75:                    //    if (ms100 >= 10240)
76:                    //        PR3 = 65535;
77:                    //    else
78:                    //    PR3 = ms100 / 6.4; //0x4E20; 1/4000000*256   15625
79:                    IEC0bits.T3IE = 1;
004CB4  A80095     BSET 0x95, #0
80:                    T3CONbits.TON = 1;
004CB6  A8E113     BSET 0x113, #7
81:                }
004CB8  FA8000     ULNK
004CBA  060000     RETURN
82:                
83:                void StopTMR3(void) {
004CBC  FA0000     LNK #0x0
84:                    IEC0bits.T3IE = 0;
004CBE  A90095     BCLR 0x95, #0
85:                    T3CONbits.TON = 0;
004CC0  A9E113     BCLR 0x113, #7
86:                    TMR3 = 0x0000;
004CC2  EF210A     CLR TMR3
87:                    //Period Value = 10.000 ms; PR2 20000; 4M
88:                    //    PR2 = 0xffff; //0x4E20;
89:                }
004CC4  FA8000     ULNK
004CC6  060000     RETURN
90:                
91:                void StartTMR4(void) {
004CC8  FA0000     LNK #0x0
92:                    TMR4 = 0x0000;
004CCA  EF2114     CLR TMR4
93:                    _T4IE = 1;
004CCC  A86097     BSET 0x97, #3
94:                    T4CONbits.TON = 1;
004CCE  A8E11F     BSET 0x11F, #7
95:                }
004CD0  FA8000     ULNK
004CD2  060000     RETURN
96:                
97:                void StopTMR4(void) {
004CD4  FA0000     LNK #0x0
98:                    _T4IE = 0;
004CD6  A96097     BCLR 0x97, #3
99:                    T4CONbits.TON = 0;
004CD8  A9E11F     BCLR 0x11F, #7
100:                   TMR3 = 0x0000;
004CDA  EF210A     CLR TMR3
101:               }
004CDC  FA8000     ULNK
004CDE  060000     RETURN
102:               
103:               
---  /home/zxc/Documents/WCGRTOS/Demo/BSP/LCD.c  --------------------------------------------------------
1:                 #include "LCD.h"
2:                 #include "WCGDeBug.h"
3:                 #include "Common.h"
4:                 #ifdef DebugLCD
5:                 #include "Debug.h"
6:                 #endif
7:                 
8:                 /*one num={"0123456789abcdef"};-:a |:b */
9:                 const uint8_t Data_Code[16] = {
10:                    0x3f, 0x06, 0x5b, 0x4f, 0x66, 0x6d, 0x7d, 0x07, 0x7f, 0x6f, 0x77, 0x7c, 0x39, 0x5e, 0x79, 0x71
11:                };
12:                const uint8_t LCD_Num12_Code[7] = {
13:                    eN1A, eN1B, eN1C, eN1D, eN1E, eN1F, eN1G
14:                };
15:                const uint8_t LCD_Num34567_Code[7] = {
16:                    eN3A, eN3B, eN3C, eN3D, eN3E, eN3F, eN3G
17:                };
18:                /**/
19:                const uint8_t LCD_NUM_OFFSET[7] = {0, 2, 0, 2, 4, 6, 8};
20:                
21:                /*****************************************************************************/
22:                
23:                /*************************************
24:                 * Function: vLCDInit
25:                 * Description: LCD initialization
26:                 * Input: pvString,ucBytes
27:                 * Output: void
28:                 * notice: void
29:                 *************************************/
30:                void vLCDInit(void) {
0026F6  FA0000     LNK #0x0
31:                    /*SEG0-15*/
32:                    LCDSE0 = 0xFFFF;
0026F8  EB8000     SETM W0
0026FA  882C40     MOV W0, LCDSE0
33:                    /*SEG16-17*/
34:                    LCDSE1 = 0x0003;
0026FC  200030     MOV #0x3, W0
0026FE  882C50     MOV W0, LCDSE1
35:                    LCDDATA0 = LCDDATA1 = LCDDATA4 = LCDDATA5 = 0;
002700  EF259A     CLR LCDDATA5
002702  802CD0     MOV LCDDATA5, W0
002704  882CC0     MOV W0, LCDDATA4
002706  802CC0     MOV LCDDATA4, W0
002708  882C90     MOV W0, LCDDATA1
00270A  802C90     MOV LCDDATA1, W0
00270C  882C80     MOV W0, LCDDATA0
36:                    LCDDATA8 = LCDDATA9 = LCDDATA16 = LCDDATA17 = 0;
00270E  EF25B2     CLR LCDDATA17
002710  802D90     MOV LCDDATA17, W0
002712  882D80     MOV W0, LCDDATA16
002714  802D80     MOV LCDDATA16, W0
002716  882D10     MOV W0, LCDDATA9
002718  802D10     MOV LCDDATA9, W0
00271A  882D00     MOV W0, LCDDATA8
37:                    LCDREG = 0x0004;
00271C  200040     MOV #0x4, W0
00271E  882C00     MOV W0, LCDREG
38:                    //	LCDREF=0x07F0;  //external
39:                    /*internal regsistor ladder*/
40:                    LCDREF = 0x805F;
002720  2805F0     MOV #0x805F, W0
002722  882C10     MOV W0, LCDREF
41:                    LCDPS = 0x0002;
002724  200020     MOV #0x2, W0
002726  882C30     MOV W0, LCDPS
42:                    LCDREFbits.LCDCST = 0;
002728  802C11     MOV LCDREF, W1
00272A  2C7FF0     MOV #0xC7FF, W0
00272C  608000     AND W1, W0, W0
00272E  882C10     MOV W0, LCDREF
43:                    /*use four common pin*/
44:                    LCDCON = 0x800B;
002730  2800B0     MOV #0x800B, W0
002732  882C20     MOV W0, LCDCON
45:                }
002734  FA8000     ULNK
002736  060000     RETURN
46:                
47:                /*************************************
48:                 * Function: vLCDShowPoint
49:                 * Description: usSeg,bOperation;
50:                 * Input: usSeg,ucBytes
51:                 * Output: void
52:                 * notice: ep:vLCDShowPoint(ePower) LCDDATA
53:                 *************************************/
54:                
55:                void vLCDShowPoint(uint16_t usSeg, bool bOperation) {
002738  FA0006     LNK #0x6
00273A  980710     MOV W0, [W14+2]
00273C  984741     MOV.B W1, [W14+4]
56:                    uint8_t ucCom;
57:                    uint8_t ucSeg;
58:                    /*overflow 18*4=72*/
59:                    if (usSeg > 71) {
00273E  90009E     MOV [W14+2], W1
002740  200470     MOV #0x47, W0
002742  508F80     SUB W1, W0, [W15]
002744  360002     BRA LEU, .L3
60:                        usSeg = 71;
002746  200470     MOV #0x47, W0
002748  980710     MOV W0, [W14+2]
61:                    }
62:                
63:                    ucCom = (((usSeg & 0x00FF) / LCDSEGSIZE) << 2); //
00274A  90009E     MOV [W14+2], W1
00274C  200FF0     MOV #0xFF, W0
00274E  608080     AND W1, W0, W1
002750  2E38F0     MOV #0xE38F, W0
002752  B80800     MUL.UU W1, W0, W0
002754  DE0844     LSR W1, #4, W0
002756  784080     MOV.B W0, W1
002758  200020     MOV #0x2, W0
00275A  DD0800     SL W1, W0, W0
00275C  784F00     MOV.B W0, [W14]
64:                    ucSeg = usSeg % LCDSEGSIZE; //
00275E  90011E     MOV [W14+2], W2
002760  2E38F0     MOV #0xE38F, W0
002762  B81000     MUL.UU W2, W0, W0
002764  DE0844     LSR W1, #4, W0
002766  B90072     MUL.SU W0, #18, W0
002768  780000     MOV W0, W0
00276A  510000     SUB W2, W0, W0
00276C  984710     MOV.B W0, [W14+1]
65:                
66:                    /**/
67:                    if (ucSeg > 15) {
00276E  90401E     MOV.B [W14+1], W0
002770  504FEF     SUB.B W0, #0xF, [W15]
002772  360004     BRA LEU, .L4
68:                        ucCom += 1;
002774  E84F1E     INC.B [W14], [W14]
69:                        ucSeg -= 16;
002776  90401E     MOV.B [W14+1], W0
002778  504070     SUB.B W0, #0x10, W0
00277A  984710     MOV.B W0, [W14+1]
70:                    }
71:                    switch (ucCom) {
00277C  FB801E     ZE [W14], W0
00277E  DE80CF     ASR W0, #15, W1
002780  200112     MOV #0x11, W2
002782  200003     MOV #0x0, W3
002784  500F82     SUB W0, W2, [W15]
002786  588F83     SUBB W1, W3, [W15]
002788  3E00E5     BRA GTU, .L2
00278A  016000     BRA W0
00278C  370011     BRA .L6
00278E  370025     BRA .L7
002790  3700E1     BRA .L2
002792  3700E0     BRA .L2
002794  370037     BRA .L8
002796  37004B     BRA .L9
002798  3700DD     BRA .L2
00279A  3700DC     BRA .L2
00279C  37005D     BRA .L10
00279E  370071     BRA .L11
0027A0  3700D9     BRA .L2
0027A2  3700D8     BRA .L2
0027A4  370083     BRA .L12
0027A6  370097     BRA .L13
0027A8  3700D5     BRA .L2
0027AA  3700D4     BRA .L2
0027AC  3700A9     BRA .L14
0027AE  3700BD     BRA .L15
72:                        case 0:
73:                            LCD_Set(0, ucSeg, bOperation);
0027B0  90404E     MOV.B [W14+4], W0
0027B2  E00400     CP0.B W0
0027B4  320008     BRA Z, .L17
0027B6  90401E     MOV.B [W14+1], W0
0027B8  FB8000     ZE W0, W0
0027BA  200011     MOV #0x1, W1
0027BC  DD0800     SL W1, W0, W0
0027BE  780080     MOV W0, W1
0027C0  802C80     MOV LCDDATA0, W0
0027C2  700001     IOR W0, W1, W0
0027C4  370008     BRA .L18
0027C6  90401E     MOV.B [W14+1], W0
0027C8  FB8000     ZE W0, W0
0027CA  200011     MOV #0x1, W1
0027CC  DD0800     SL W1, W0, W0
0027CE  EA8000     COM W0, W0
0027D0  780080     MOV W0, W1
0027D2  802C80     MOV LCDDATA0, W0
0027D4  608000     AND W1, W0, W0
0027D6  882C80     MOV W0, LCDDATA0
74:                            break;
0027D8  3700BD     BRA .L2
75:                        case 1:
76:                            LCD_Set(1, ucSeg, bOperation);
0027DA  90404E     MOV.B [W14+4], W0
0027DC  E00400     CP0.B W0
0027DE  320008     BRA Z, .L19
0027E0  90401E     MOV.B [W14+1], W0
0027E2  FB8000     ZE W0, W0
0027E4  200011     MOV #0x1, W1
0027E6  DD0800     SL W1, W0, W0
0027E8  780080     MOV W0, W1
0027EA  802C90     MOV LCDDATA1, W0
0027EC  700001     IOR W0, W1, W0
0027EE  370008     BRA .L20
0027F0  90401E     MOV.B [W14+1], W0
0027F2  FB8000     ZE W0, W0
0027F4  200011     MOV #0x1, W1
0027F6  DD0800     SL W1, W0, W0
0027F8  EA8000     COM W0, W0
0027FA  780080     MOV W0, W1
0027FC  802C90     MOV LCDDATA1, W0
0027FE  608000     AND W1, W0, W0
002800  882C90     MOV W0, LCDDATA1
77:                            break;
002802  3700A8     BRA .L2
78:                        case 4:
79:                            LCD_Set(4, ucSeg, bOperation);
002804  90404E     MOV.B [W14+4], W0
002806  E00400     CP0.B W0
002808  320008     BRA Z, .L21
00280A  90401E     MOV.B [W14+1], W0
00280C  FB8000     ZE W0, W0
00280E  200011     MOV #0x1, W1
002810  DD0800     SL W1, W0, W0
002812  780080     MOV W0, W1
002814  802CC0     MOV LCDDATA4, W0
002816  700001     IOR W0, W1, W0
002818  370008     BRA .L22
00281A  90401E     MOV.B [W14+1], W0
00281C  FB8000     ZE W0, W0
00281E  200011     MOV #0x1, W1
002820  DD0800     SL W1, W0, W0
002822  EA8000     COM W0, W0
002824  780080     MOV W0, W1
002826  802CC0     MOV LCDDATA4, W0
002828  608000     AND W1, W0, W0
00282A  882CC0     MOV W0, LCDDATA4
80:                            break;
00282C  370093     BRA .L2
81:                        case 5:
82:                            LCD_Set(5, ucSeg, bOperation);
00282E  90404E     MOV.B [W14+4], W0
002830  E00400     CP0.B W0
002832  320008     BRA Z, .L23
002834  90401E     MOV.B [W14+1], W0
002836  FB8000     ZE W0, W0
002838  200011     MOV #0x1, W1
00283A  DD0800     SL W1, W0, W0
00283C  780080     MOV W0, W1
00283E  802CD0     MOV LCDDATA5, W0
002840  700001     IOR W0, W1, W0
002842  370008     BRA .L24
002844  90401E     MOV.B [W14+1], W0
002846  FB8000     ZE W0, W0
002848  200011     MOV #0x1, W1
00284A  DD0800     SL W1, W0, W0
00284C  EA8000     COM W0, W0
00284E  780080     MOV W0, W1
002850  802CD0     MOV LCDDATA5, W0
002852  608000     AND W1, W0, W0
002854  882CD0     MOV W0, LCDDATA5
83:                            break;
002856  37007E     BRA .L2
84:                        case 8:
85:                            LCD_Set(8, ucSeg, bOperation);
002858  90404E     MOV.B [W14+4], W0
00285A  E00400     CP0.B W0
00285C  320008     BRA Z, .L25
00285E  90401E     MOV.B [W14+1], W0
002860  FB8000     ZE W0, W0
002862  200011     MOV #0x1, W1
002864  DD0800     SL W1, W0, W0
002866  780080     MOV W0, W1
002868  802D00     MOV LCDDATA8, W0
00286A  700001     IOR W0, W1, W0
00286C  370008     BRA .L26
00286E  90401E     MOV.B [W14+1], W0
002870  FB8000     ZE W0, W0
002872  200011     MOV #0x1, W1
002874  DD0800     SL W1, W0, W0
002876  EA8000     COM W0, W0
002878  780080     MOV W0, W1
00287A  802D00     MOV LCDDATA8, W0
00287C  608000     AND W1, W0, W0
00287E  882D00     MOV W0, LCDDATA8
86:                            break;
002880  370069     BRA .L2
87:                        case 9:
88:                            LCD_Set(9, ucSeg, bOperation);
002882  90404E     MOV.B [W14+4], W0
002884  E00400     CP0.B W0
002886  320008     BRA Z, .L27
002888  90401E     MOV.B [W14+1], W0
00288A  FB8000     ZE W0, W0
00288C  200011     MOV #0x1, W1
00288E  DD0800     SL W1, W0, W0
002890  780080     MOV W0, W1
002892  802D10     MOV LCDDATA9, W0
002894  700001     IOR W0, W1, W0
002896  370008     BRA .L28
002898  90401E     MOV.B [W14+1], W0
00289A  FB8000     ZE W0, W0
00289C  200011     MOV #0x1, W1
00289E  DD0800     SL W1, W0, W0
0028A0  EA8000     COM W0, W0
0028A2  780080     MOV W0, W1
0028A4  802D10     MOV LCDDATA9, W0
0028A6  608000     AND W1, W0, W0
0028A8  882D10     MOV W0, LCDDATA9
89:                            break;
0028AA  370054     BRA .L2
90:                        case 12:
91:                            LCD_Set(12, ucSeg, bOperation);
0028AC  90404E     MOV.B [W14+4], W0
0028AE  E00400     CP0.B W0
0028B0  320008     BRA Z, .L29
0028B2  90401E     MOV.B [W14+1], W0
0028B4  FB8000     ZE W0, W0
0028B6  200011     MOV #0x1, W1
0028B8  DD0800     SL W1, W0, W0
0028BA  780080     MOV W0, W1
0028BC  802D40     MOV LCDDATA12, W0
0028BE  700001     IOR W0, W1, W0
0028C0  370008     BRA .L30
0028C2  90401E     MOV.B [W14+1], W0
0028C4  FB8000     ZE W0, W0
0028C6  200011     MOV #0x1, W1
0028C8  DD0800     SL W1, W0, W0
0028CA  EA8000     COM W0, W0
0028CC  780080     MOV W0, W1
0028CE  802D40     MOV LCDDATA12, W0
0028D0  608000     AND W1, W0, W0
0028D2  882D40     MOV W0, LCDDATA12
92:                            break;
0028D4  37003F     BRA .L2
93:                        case 13:
94:                            LCD_Set(13, ucSeg, bOperation);
0028D6  90404E     MOV.B [W14+4], W0
0028D8  E00400     CP0.B W0
0028DA  320008     BRA Z, .L31
0028DC  90401E     MOV.B [W14+1], W0
0028DE  FB8000     ZE W0, W0
0028E0  200011     MOV #0x1, W1
0028E2  DD0800     SL W1, W0, W0
0028E4  780080     MOV W0, W1
0028E6  802D50     MOV LCDDATA13, W0
0028E8  700001     IOR W0, W1, W0
0028EA  370008     BRA .L32
0028EC  90401E     MOV.B [W14+1], W0
0028EE  FB8000     ZE W0, W0
0028F0  200011     MOV #0x1, W1
0028F2  DD0800     SL W1, W0, W0
0028F4  EA8000     COM W0, W0
0028F6  780080     MOV W0, W1
0028F8  802D50     MOV LCDDATA13, W0
0028FA  608000     AND W1, W0, W0
0028FC  882D50     MOV W0, LCDDATA13
95:                            break;
0028FE  37002A     BRA .L2
96:                        case 16:
97:                            LCD_Set(16, ucSeg, bOperation);
002900  90404E     MOV.B [W14+4], W0
002902  E00400     CP0.B W0
002904  320008     BRA Z, .L33
002906  90401E     MOV.B [W14+1], W0
002908  FB8000     ZE W0, W0
00290A  200011     MOV #0x1, W1
00290C  DD0800     SL W1, W0, W0
00290E  780080     MOV W0, W1
002910  802D80     MOV LCDDATA16, W0
002912  700001     IOR W0, W1, W0
002914  370008     BRA .L34
002916  90401E     MOV.B [W14+1], W0
002918  FB8000     ZE W0, W0
00291A  200011     MOV #0x1, W1
00291C  DD0800     SL W1, W0, W0
00291E  EA8000     COM W0, W0
002920  780080     MOV W0, W1
002922  802D80     MOV LCDDATA16, W0
002924  608000     AND W1, W0, W0
002926  882D80     MOV W0, LCDDATA16
98:                            break;
002928  370015     BRA .L2
99:                        case 17:
100:                           LCD_Set(17, ucSeg, bOperation);
00292A  90404E     MOV.B [W14+4], W0
00292C  E00400     CP0.B W0
00292E  320008     BRA Z, .L35
002930  90401E     MOV.B [W14+1], W0
002932  FB8000     ZE W0, W0
002934  200011     MOV #0x1, W1
002936  DD0800     SL W1, W0, W0
002938  780080     MOV W0, W1
00293A  802D90     MOV LCDDATA17, W0
00293C  700001     IOR W0, W1, W0
00293E  370008     BRA .L36
002940  90401E     MOV.B [W14+1], W0
002942  FB8000     ZE W0, W0
002944  200011     MOV #0x1, W1
002946  DD0800     SL W1, W0, W0
002948  EA8000     COM W0, W0
00294A  780080     MOV W0, W1
00294C  802D90     MOV LCDDATA17, W0
00294E  608000     AND W1, W0, W0
002950  882D90     MOV W0, LCDDATA17
101:                           break;
002952  000000     NOP
102:                   }
103:               }
002954  FA8000     ULNK
002956  060000     RETURN
104:               
105:               /*************************************
106:                * Function: vLCDShowNum
107:                * Description: LCD show one Num 
108:                * Input: ucNum,ucPosition
109:                * Output: void
110:                * notice: parameter ucNum:0-9
111:                *         parameter ucPosition:0-6
112:                *************************************/
113:               
114:               void vLCDShowNum(uint8_t ucNum, uint8_t ucPosition) {
002958  FA0004     LNK #0x4
00295A  984720     MOV.B W0, [W14+2]
00295C  984731     MOV.B W1, [W14+3]
115:                   uint8_t ucCnt;
116:                   bool bShowOrHide = SEGSHOW;
00295E  B3C010     MOV.B #0x1, W0
002960  984710     MOV.B W0, [W14+1]
117:               
118:                   if (ucNum > 9)
002962  90402E     MOV.B [W14+2], W0
002964  504FE9     SUB.B W0, #0x9, [W15]
002966  360002     BRA LEU, .L38
119:                       ucNum = 9;
002968  B3C090     MOV.B #0x9, W0
00296A  984720     MOV.B W0, [W14+2]
120:                   if (ucPosition > 6)
00296C  90403E     MOV.B [W14+3], W0
00296E  504FE6     SUB.B W0, #0x6, [W15]
002970  360002     BRA LEU, .L39
121:                       ucPosition = 6;
002972  B3C060     MOV.B #0x6, W0
002974  984730     MOV.B W0, [W14+3]
122:               
123:                   /*shou Num in Seg,*/
124:                   for (ucCnt = 0; ucCnt < 7; ucCnt++) {
002976  EB4000     CLR.B W0
002978  784F00     MOV.B W0, [W14]
00297A  37002B     BRA .L40
0029D0  E84F1E     INC.B [W14], [W14]
0029D2  78401E     MOV.B [W14], W0
0029D4  504FE6     SUB.B W0, #0x6, [W15]
0029D6  36FFD2     BRA LEU, .L43
125:                       bShowOrHide = (Data_Code[ucNum] &(1 << ucCnt)); //OxFF,0xff
00297C  90402E     MOV.B [W14+2], W0
00297E  FB8000     ZE W0, W0
002980  2906C1     MOV #0x906C, W1
002982  784061     MOV.B [W1+W0], W0
002984  FB8080     ZE W0, W1
002986  FB801E     ZE [W14], W0
002988  200012     MOV #0x1, W2
00298A  DD1000     SL W2, W0, W0
00298C  608000     AND W1, W0, W0
00298E  A7F000     BTSC W0, #15
002990  EA0000     NEG W0, W0
002992  EA0000     NEG W0, W0
002994  DE004F     LSR W0, #15, W0
002996  984710     MOV.B W0, [W14+1]
126:                       if (ucPosition > 1)
002998  90403E     MOV.B [W14+3], W0
00299A  504FE1     SUB.B W0, #0x1, [W15]
00299C  36000D     BRA LEU, .L41
127:                           vLCDShowPoint(LCD_Num34567_Code[ucCnt] - LCD_NUM_OFFSET[ucPosition], bShowOrHide);
00299E  FB801E     ZE [W14], W0
0029A0  290831     MOV #0x9083, W1
0029A2  784061     MOV.B [W1+W0], W0
0029A4  FB8080     ZE W0, W1
0029A6  90403E     MOV.B [W14+3], W0
0029A8  FB8000     ZE W0, W0
0029AA  2908A2     MOV #0x908A, W2
0029AC  784062     MOV.B [W2+W0], W0
0029AE  FB8000     ZE W0, W0
0029B0  508000     SUB W1, W0, W0
0029B2  90409E     MOV.B [W14+1], W1
0029B4  07FEC1     RCALL vLCDShowPoint
0029B6  37000C     BRA .L42
128:                       else
129:                           vLCDShowPoint(LCD_Num12_Code[ucCnt] + LCD_NUM_OFFSET[ucPosition], bShowOrHide);
0029B8  FB801E     ZE [W14], W0
0029BA  2907C1     MOV #0x907C, W1
0029BC  784061     MOV.B [W1+W0], W0
0029BE  FB8080     ZE W0, W1
0029C0  90403E     MOV.B [W14+3], W0
0029C2  FB8000     ZE W0, W0
0029C4  2908A2     MOV #0x908A, W2
0029C6  784062     MOV.B [W2+W0], W0
0029C8  FB8000     ZE W0, W0
0029CA  408000     ADD W1, W0, W0
0029CC  90409E     MOV.B [W14+1], W1
0029CE  07FEB4     RCALL vLCDShowPoint
130:                   }
131:               }
0029D8  FA8000     ULNK
0029DA  060000     RETURN
132:               
133:               /*************************************
134:                * Function: vLCDShowBattery
135:                * Description:LCD show Battery Segmnet pin
136:                * Input: ucBatterySign
137:                * Output: void
138:                * notice: parameter:ucBatterySign
139:                *         0:ucBatterySign Frame
140:                *         1:one ucBatterySign
141:                *          ...
142:                *         3:Full ucBatterySign
143:                *************************************/
144:               
145:               void vLCDShowBattery(uint8_t ucBatterySign) {
0029DC  FA0006     LNK #0x6
0029DE  984740     MOV.B W0, [W14+4]
146:                   unsigned char ucCnt;
147:                   unsigned char ucNowSign;
148:                   bool bNowState;
149:               
150:                   if (ucBatterySign > 3)
0029E0  90404E     MOV.B [W14+4], W0
0029E2  504FE3     SUB.B W0, #0x3, [W15]
0029E4  360002     BRA LEU, .L45
151:                       ucBatterySign = 3;
0029E6  B3C030     MOV.B #0x3, W0
0029E8  984740     MOV.B W0, [W14+4]
152:                   vLCDShowPoint(eBattery0, SEGSHOW);
0029EA  B3C011     MOV.B #0x1, W1
0029EC  2003B0     MOV #0x3B, W0
0029EE  07FEA4     RCALL vLCDShowPoint
153:                   ucNowSign = eBattery1;
0029F0  B3C290     MOV.B #0x29, W0
0029F2  984710     MOV.B W0, [W14+1]
154:                   for (ucCnt = 0; ucCnt < 4; ucCnt++) {
0029F4  EB4000     CLR.B W0
0029F6  784F00     MOV.B W0, [W14]
0029F8  37000E     BRA .L46
002A14  E84F1E     INC.B [W14], [W14]
002A16  78401E     MOV.B [W14], W0
002A18  504FE3     SUB.B W0, #0x3, [W15]
002A1A  36FFEF     BRA LEU, .L48
155:                       bNowState = (ucBatterySign > ucCnt) ? SEGSHOW : SEGHIDE;
0029FA  B3C010     MOV.B #0x1, W0
0029FC  9040CE     MOV.B [W14+4], W1
0029FE  50CF9E     SUB.B W1, [W14], [W15]
002A00  3E0001     BRA GTU, .L47
002A02  EB4000     CLR.B W0
002A04  984720     MOV.B W0, [W14+2]
156:                       vLCDShowPoint(ucNowSign, bNowState);
002A06  90401E     MOV.B [W14+1], W0
002A08  FB8000     ZE W0, W0
002A0A  9040AE     MOV.B [W14+2], W1
002A0C  07FE95     RCALL vLCDShowPoint
157:                       ucNowSign -= LCDSEGSIZE;
002A0E  90401E     MOV.B [W14+1], W0
002A10  504072     SUB.B W0, #0x12, W0
002A12  984710     MOV.B W0, [W14+1]
158:                   }
159:               }
002A1C  FA8000     ULNK
002A1E  060000     RETURN
160:               
161:               /*************************************
162:                * Function: vLCDShowGPRSSign
163:                * Description: LCD show GPRS sign
164:                * Input: ucGPRSSign
165:                * Output: void
166:                * notice:  parameter:ucGPRSSign
167:                *          0:none GPRSSign
168:                *          1:one GPRSSign
169:                *          ...
170:                *          3:Full GPRSSign
171:                *************************************/
172:               
173:               void vLCDShowGPRSSign(uint8_t ucGPRSSign) {
002A20  FA0006     LNK #0x6
002A22  984740     MOV.B W0, [W14+4]
174:                   unsigned char ucCnt;
175:                   unsigned char ucNowSign;
176:                   bool bNowState;
177:               
178:                   if (ucGPRSSign > 4)
002A24  90404E     MOV.B [W14+4], W0
002A26  504FE4     SUB.B W0, #0x4, [W15]
002A28  360002     BRA LEU, .L50
179:                       ucGPRSSign = 4;
002A2A  B3C040     MOV.B #0x4, W0
002A2C  984740     MOV.B W0, [W14+4]
180:                   ucNowSign = eSign0;
002A2E  B3C3C0     MOV.B #0x3C, W0
002A30  984710     MOV.B W0, [W14+1]
181:                   for (ucCnt = 0; ucCnt < 4; ucCnt++) {
002A32  EB4000     CLR.B W0
002A34  784F00     MOV.B W0, [W14]
002A36  37000E     BRA .L51
002A52  E84F1E     INC.B [W14], [W14]
002A54  78401E     MOV.B [W14], W0
002A56  504FE3     SUB.B W0, #0x3, [W15]
002A58  36FFEF     BRA LEU, .L53
182:                       bNowState = (ucGPRSSign > ucCnt) ? SEGSHOW : SEGHIDE;
002A38  B3C010     MOV.B #0x1, W0
002A3A  9040CE     MOV.B [W14+4], W1
002A3C  50CF9E     SUB.B W1, [W14], [W15]
002A3E  3E0001     BRA GTU, .L52
002A40  EB4000     CLR.B W0
002A42  984720     MOV.B W0, [W14+2]
183:                       vLCDShowPoint(ucNowSign, bNowState);
002A44  90401E     MOV.B [W14+1], W0
002A46  FB8000     ZE W0, W0
002A48  9040AE     MOV.B [W14+2], W1
002A4A  07FE76     RCALL vLCDShowPoint
184:                       ucNowSign -= LCDSEGSIZE;
002A4C  90401E     MOV.B [W14+1], W0
002A4E  504072     SUB.B W0, #0x12, W0
002A50  984710     MOV.B W0, [W14+1]
185:                   }
186:               }
002A5A  FA8000     ULNK
002A5C  060000     RETURN
187:               
188:               /*************************************
189:                * Function: vLCDShowDigitalPoint
190:                * Description: 
191:                * Input: ucPosition
192:                * Output: void
193:                * notice:  parameter:ucPosition
194:                *          0:12345
195:                *          1:1234.5
196:                *            ...
197:                *          4:12.3424
198:                *************************************/
199:               void vLCDShowDigitalPoint(uint8_t ucPosition) {
002A5E  FA000A     LNK #0xA
002A60  984F00     MOV.B W0, [W14+8]
200:                   unsigned char ucCnt;
201:                   unsigned char ucNowPosition;
202:                   unsigned char ucDigitalPoint[4] = {eP1, eP2, eP3, eP4};
002A62  4700E3     ADD W14, #0x3, W1
002A64  290912     MOV #0x9091, W2
002A66  090003     REPEAT #0x3
002A68  7858B2     MOV.B [W2++], [W1++]
203:                   bool bNowState;
204:               
205:                   if (ucPosition > 4)
002A6A  90480E     MOV.B [W14+8], W0
002A6C  504FE4     SUB.B W0, #0x4, [W15]
002A6E  360002     BRA LEU, .L55
206:                       ucPosition = 0;
002A70  EB4000     CLR.B W0
002A72  984F00     MOV.B W0, [W14+8]
207:                   for (ucCnt = 1; ucCnt < 5; ucCnt++) {
002A74  B3C010     MOV.B #0x1, W0
002A76  784F00     MOV.B W0, [W14]
002A78  370010     BRA .L56
002A98  E84F1E     INC.B [W14], [W14]
002A9A  78401E     MOV.B [W14], W0
002A9C  504FE4     SUB.B W0, #0x4, [W15]
002A9E  36FFED     BRA LEU, .L57
208:                       ucNowPosition = ucDigitalPoint[ucCnt - 1];
002A7A  FB801E     ZE [W14], W0
002A7C  E90000     DEC W0, W0
002A7E  470000     ADD W14, W0, W0
002A80  9040B0     MOV.B [W0+3], W1
002A82  984711     MOV.B W1, [W14+1]
209:                       bNowState = (ucPosition == ucCnt) ? SEGSHOW : SEGHIDE;
002A84  90480E     MOV.B [W14+8], W0
002A86  68401E     XOR.B W0, [W14], W0
002A88  FB8000     ZE W0, W0
002A8A  E90000     DEC W0, W0
002A8C  DE004F     LSR W0, #15, W0
002A8E  984720     MOV.B W0, [W14+2]
210:                       vLCDShowPoint(ucNowPosition, bNowState);
002A90  90401E     MOV.B [W14+1], W0
002A92  FB8000     ZE W0, W0
002A94  9040AE     MOV.B [W14+2], W1
002A96  07FE50     RCALL vLCDShowPoint
211:                   }
212:               }
002AA0  FA8000     ULNK
002AA2  060000     RETURN
213:               
214:               /*************************************
215:                * Function: vLCDShowNums
216:                * Description: LCD Show Nums,like 123412
217:                * Input: ulNums,bFirstZeroshow
218:                * Output: void
219:                * notice: 
220:                *************************************/
221:               
222:               void vLCDShowNums(uint32_t ulNums, bool bFirstZeroshow) {
002AA4  FA000A     LNK #0xA
002AA6  BE9F88     MOV.D W8, [W15++]
002AA8  980720     MOV W0, [W14+4]
002AAA  980731     MOV W1, [W14+6]
002AAC  984F02     MOV.B W2, [W14+8]
223:                   char cCnt; //
224:                   uint8_t ucNumTmep;
225:                   bool bIsFindHead = false;
002AAE  EB4000     CLR.B W0
226:               
227:                   vLCDClearNums();
002AB0  984710     MOV.B W0, [W14+1]
002AB2  070047     RCALL vLCDClearNums
228:                   /*if ulNums equal zero , LCD show "0"*/
229:                   if (ulNums > 9999999L)
002AB4  90012E     MOV [W14+4], W2
002AB6  9001BE     MOV [W14+6], W3
002AB8  2967F0     MOV #0x967F, W0
002ABA  200981     MOV #0x98, W1
002ABC  510F80     SUB W2, W0, [W15]
002ABE  598F81     SUBB W3, W1, [W15]
002AC0  360004     BRA LEU, .L59
230:                       ulNums = 9999999L;
002AC2  2967F0     MOV #0x967F, W0
002AC4  200981     MOV #0x98, W1
002AC6  980720     MOV W0, [W14+4]
002AC8  980731     MOV W1, [W14+6]
231:                   /**/
232:                   for (cCnt = 6; cCnt >= 0; cCnt--) {
002ACA  B3C060     MOV.B #0x6, W0
002ACC  784F00     MOV.B W0, [W14]
002ACE  370033     BRA .L60
002B34  E94F1E     DEC.B [W14], [W14]
002B36  78401E     MOV.B [W14], W0
002B38  E00400     CP0.B W0
002B3A  3DFFCA     BRA GE, .L64
233:                       ucNumTmep = (unsigned char) ((unsigned long) (ulNums / pow(10, cCnt)) % 10);
002AD0  90002E     MOV [W14+4], W0
002AD2  9000BE     MOV [W14+6], W1
002AD4  0206DC     CALL ___floatunsisf
002AD6  000000     NOP
002AD8  BE0400     MOV.D W0, W8
002ADA  FB001E     SE [W14], W0
002ADC  DE80CF     ASR W0, #15, W1
002ADE  0206D6     CALL ___floatsisf
002AE0  000000     NOP
002AE2  BE0100     MOV.D W0, W2
002AE4  200000     MOV #0x0, W0
002AE6  241201     MOV #0x4120, W1
002AE8  0207EE     CALL _powf
002AEA  000000     NOP
002AEC  BE0100     MOV.D W0, W2
002AEE  BE0008     MOV.D W8, W0
002AF0  0205FE     CALL ___divsf3
002AF2  000000     NOP
002AF4  0206A0     CALL ___fixunssfsi
002AF6  000000     NOP
002AF8  2000A2     MOV #0xA, W2
002AFA  200003     MOV #0x0, W3
002AFC  0209D4     CALL ___umodsi3
002AFE  000000     NOP
002B00  984720     MOV.B W0, [W14+2]
234:                       /*find first*/
235:                       if (ucNumTmep&&!bIsFindHead) {
002B02  90402E     MOV.B [W14+2], W0
002B04  E00400     CP0.B W0
002B06  320006     BRA Z, .L61
002B08  90401E     MOV.B [W14+1], W0
002B0A  A20400     BTG.B W0, #0
002B0C  E00400     CP0.B W0
002B0E  320002     BRA Z, .L61
236:                           bIsFindHead = true;
002B10  B3C010     MOV.B #0x1, W0
002B12  984710     MOV.B W0, [W14+1]
237:                       }
238:                       /*all show|| first not zero num finded || only zero*/
239:                       if (bFirstZeroshow || bIsFindHead || ((!cCnt)&&(!ucNumTmep))) {
002B14  90480E     MOV.B [W14+8], W0
002B16  E00400     CP0.B W0
002B18  3A0009     BRA NZ, .L62
002B1A  90401E     MOV.B [W14+1], W0
002B1C  E00400     CP0.B W0
002B1E  3A0006     BRA NZ, .L62
002B20  78401E     MOV.B [W14], W0
002B22  E00400     CP0.B W0
002B24  3A0007     BRA NZ, .L63
002B26  90402E     MOV.B [W14+2], W0
002B28  E00400     CP0.B W0
002B2A  3A0004     BRA NZ, .L63
240:                           vLCDShowNum(ucNumTmep, cCnt);
002B2C  78401E     MOV.B [W14], W0
002B2E  784080     MOV.B W0, W1
002B30  90402E     MOV.B [W14+2], W0
002B32  07FF12     RCALL vLCDShowNum
241:                       }
242:                   }
243:               }
002B3C  BE044F     MOV.D [--W15], W8
002B3E  FA8000     ULNK
002B40  060000     RETURN
244:               
245:               /*************************************
246:                * Function: vLCDClearNums
247:                * Description: LCD Clear Nums,vLCDShowNums(1234567L, FristZeroShow);
248:                * Input: void
249:                * Output: void
250:                * notice: number last bit must add L
251:                *************************************/
252:               
253:               void vLCDClearNums(void) {
002B42  FA0004     LNK #0x4
254:                   unsigned char x, y;
255:                   unsigned char ucOffset;
256:               
257:                   /**/
258:                   for (y = 0; y < 7; y++) {
002B44  EB4000     CLR.B W0
002B46  984710     MOV.B W0, [W14+1]
002B48  370023     BRA .L66
002B8A  90401E     MOV.B [W14+1], W0
002B8C  E84000     INC.B W0, W0
002B8E  984710     MOV.B W0, [W14+1]
002B90  90401E     MOV.B [W14+1], W0
002B92  504FE6     SUB.B W0, #0x6, [W15]
002B94  36FFDA     BRA LEU, .L71
259:                       for (x = 0; x < 7; x++) {
002B4A  EB4000     CLR.B W0
002B4C  784F00     MOV.B W0, [W14]
002B4E  37001A     BRA .L67
002B82  E84F1E     INC.B [W14], [W14]
002B84  78401E     MOV.B [W14], W0
002B86  504FE6     SUB.B W0, #0x6, [W15]
002B88  36FFE3     BRA LEU, .L70
260:                           ucOffset = (y < 2) ? (LCD_Num12_Code[x] + LCD_NUM_OFFSET[y]) : (LCD_Num34567_Code[x] - LCD_NUM_OFFSET[y]);
002B50  90401E     MOV.B [W14+1], W0
002B52  504FE1     SUB.B W0, #0x1, [W15]
002B54  3E0009     BRA GTU, .L68
002B56  FB801E     ZE [W14], W0
002B58  2907C1     MOV #0x907C, W1
002B5A  7840E1     MOV.B [W1+W0], W1
002B5C  90401E     MOV.B [W14+1], W0
002B5E  FB8000     ZE W0, W0
002B60  2908A2     MOV #0x908A, W2
002B62  784062     MOV.B [W2+W0], W0
002B64  40C000     ADD.B W1, W0, W0
002B66  370008     BRA .L69
002B68  FB801E     ZE [W14], W0
002B6A  290831     MOV #0x9083, W1
002B6C  7840E1     MOV.B [W1+W0], W1
002B6E  90401E     MOV.B [W14+1], W0
002B70  FB8000     ZE W0, W0
002B72  2908A2     MOV #0x908A, W2
002B74  784062     MOV.B [W2+W0], W0
002B76  50C000     SUB.B W1, W0, W0
002B78  984720     MOV.B W0, [W14+2]
261:                           vLCDShowPoint(ucOffset, SEGHIDE);
002B7A  90402E     MOV.B [W14+2], W0
002B7C  FB8000     ZE W0, W0
002B7E  EB4080     CLR.B W1
002B80  07FDDB     RCALL vLCDShowPoint
262:                       }
263:                   }
264:                   /*clear digital piont*/
265:                   vLCDShowDigitalPoint(0);
002B96  EB4000     CLR.B W0
002B98  07FF62     RCALL vLCDShowDigitalPoint
266:               }
002B9A  FA8000     ULNK
002B9C  060000     RETURN
267:               
268:               /*************************************
269:                * Function: vLCDClearScreen
270:                * Description: LCD clear Screen
271:                * Input: void
272:                * Output: void
273:                * notice: 
274:                *************************************/
275:               
276:               void vLCDClearScreen(void) {
002B9E  FA0004     LNK #0x4
277:                   uint16_t lcd_x = 0, lcd_y = 0;
002BA0  EB0000     CLR W0
002BA2  780F00     MOV W0, [W14]
002BA4  EB0000     CLR W0
002BA6  980710     MOV W0, [W14+2]
278:                   for (lcd_y = 0; lcd_y < 4; lcd_y++)
002BA8  EB0000     CLR W0
002BAA  980710     MOV W0, [W14+2]
002BAC  370010     BRA .L73
002BC8  90001E     MOV [W14+2], W0
002BCA  E80000     INC W0, W0
002BCC  980710     MOV W0, [W14+2]
002BCE  90001E     MOV [W14+2], W0
002BD0  500FE3     SUB W0, #0x3, [W15]
002BD2  36FFED     BRA LEU, .L76
279:                       for (lcd_x = 0; lcd_x < LCDSEGSIZE; lcd_x++)
002BAE  EB0000     CLR W0
002BB0  780F00     MOV W0, [W14]
002BB2  370007     BRA .L74
002BC0  E80F1E     INC [W14], [W14]
002BC2  78001E     MOV [W14], W0
002BC4  500FF1     SUB W0, #0x11, [W15]
002BC6  36FFF6     BRA LEU, .L75
280:                           vLCDShowPoint(lcd_x + lcd_y * LCDSEGSIZE, SEGHIDE);
002BB4  90001E     MOV [W14+2], W0
002BB6  B90072     MUL.SU W0, #18, W0
002BB8  780000     MOV W0, W0
002BBA  40001E     ADD W0, [W14], W0
002BBC  EB4080     CLR.B W1
002BBE  07FDBC     RCALL vLCDShowPoint
281:               }
002BD4  FA8000     ULNK
002BD6  060000     RETURN
282:               
---  /home/zxc/Documents/WCGRTOS/Demo/BSP/INT.c  --------------------------------------------------------
1:                 #include "INT.h"
2:                 #include "WCGDeBug.h"
3:                 #include <xc.h>
4:                 
5:                 #if   (DebugPCF8583 == 1)
6:                 #include "FreeRTOS.h"
7:                 #include "semphr.h"
8:                 #include "Debug.h"
9:                 /*endif (DebugPCF8583 == 1)*/
10:                #endif
11:                
12:                void INT0_Init(void) {
005130  FA0000     LNK #0x0
13:                    TRISFbits.TRISF6 = 1; //
005132  A8C2E8     BSET TRISF, #6
14:                    INTCON2bits.INT0EP = 1; //  1 =   0 = 
005134  A80082     BSET INTCON2, #0
15:                    IPC0bits.INT0IP = 7; //2
005136  800520     MOV IPC0, W0
005138  B30070     IOR #0x7, W0
00513A  880520     MOV W0, IPC0
16:                    IFS0bits.INT0IF = 0; //
00513C  A90084     BCLR IFS0, #0
17:                    IEC0bits.INT0IE = 1; //
00513E  A80094     BSET IEC0, #0
18:                }
005140  FA8000     ULNK
005142  060000     RETURN
19:                
20:                void INT0_Open(void) {
005144  FA0000     LNK #0x0
21:                    IFS0bits.INT0IF = 0; //
005146  A90084     BCLR IFS0, #0
22:                    IEC0bits.INT0IE = 1;
005148  A80094     BSET IEC0, #0
23:                }
00514A  FA8000     ULNK
00514C  060000     RETURN
24:                
25:                void INT0_Close(void) {
00514E  FA0000     LNK #0x0
26:                    IFS0bits.INT0IF = 0; //
005150  A90084     BCLR IFS0, #0
27:                    IEC0bits.INT0IE = 0;
005152  A90094     BCLR IEC0, #0
28:                }
005154  FA8000     ULNK
005156  060000     RETURN
29:                extern void vDeBugPrintInformation(void* strings);
30:                /*debug PCF8583*/
31:                #if (DebugPCF8583 == 1)
32:                extern SemaphoreHandle_t xSemBinaryAlarm;
33:                /*endif (DebugPCF8583 == 1)*/
34:                #endif
35:                
36:                void __attribute__((__interrupt__, auto_psv))_INT0Interrupt(void) {
000478  F80032     PUSH DSRPAG
00047A  F80034     PUSH DSWPAG
00047C  781F88     MOV W8, [W15++]
00047E  200018     MOV #0x1, W8
000480  8801A8     MOV W8, DSWPAG
000482  202008     MOV #0x200, W8
000484  880198     MOV W8, DSRPAG
000486  78044F     MOV [--W15], W8
000488  FA0000     LNK #0x0
37:                #if  (DebugPCF8583 == 1)
38:                    vDeBugPrintInformation("****************************\r\n");
39:                    vDeBugPrintInformation("enter int0\r\n");
40:                    vDeBugPrintInformation("****************************\r\n");
41:                    xSemaphoreGiveFromISR(xSemBinaryAlarm, NULL);
42:                    /*endif (DebugPCF8583 == 1)*/
43:                #endif
44:                    IFS0bits.INT0IF = 0;
00048A  A90084     BCLR IFS0, #0
45:                }
00048C  FA8000     ULNK
00048E  F90034     POP DSWPAG
000490  F90032     POP DSRPAG
000492  064000     RETFIE
---  /home/zxc/Documents/WCGRTOS/Demo/BSP/I2C_S.c  ------------------------------------------------------
1:                 #include "I2C_S.h"
2:                 #ifdef UseRTOS
3:                 #include "FreeRTOS.h"
4:                 #include "task.h"
5:                 #endif
6:                 
7:                 /*************************************
8:                 Function: vI2CDelay
9:                 Description: 
10:                Input: void
11:                Output: void
12:                 *************************************/
13:                static void vI2CDelay(void) {
003A14  FA0002     LNK #0x2
14:                    unsigned int usCnt;
15:                    /*Select delay time by system clock*/
16:                #if (SystemClock==4000000L)    //100Khz Fsck=100khz  
17:                    for (usCnt = 0; usCnt < 20; usCnt++)
003A16  EB0000     CLR W0
003A18  780F00     MOV W0, [W14]
003A1A  370002     BRA .L2
003A1E  E80F1E     INC [W14], [W14]
003A20  78001E     MOV [W14], W0
003A22  500FF3     SUB W0, #0x13, [W15]
003A24  36FFFB     BRA LEU, .L3
18:                        SystemNop();
003A1C  000000     NOP
19:                #else 
20:                #error "please add delay in other clock"    
21:                #endif
22:                }
003A26  FA8000     ULNK
003A28  060000     RETURN
23:                
24:                /*************************************
25:                Function: I2C_Init 
26:                Description: I2CIO
27:                Input: void
28:                Output: void
29:                 *************************************/
30:                void vI2CInit(void) {
003A2A  FA0000     LNK #0x0
31:                    /*SCL*/
32:                    I2C_SCL_DIR = 0;
003A2C  A942F0     BCLR TRISG, #2
33:                    /*SDA*/
34:                    I2C_SDA_DIR = 0;
003A2E  A962F0     BCLR TRISG, #3
35:                    /*SCL*/
36:                    I2C_SCL = 1;
003A30  A842F4     BSET LATG, #2
37:                    /*SDA*/
38:                    I2C_SDA = 1;
39:                    /*delay*/
40:                    vI2CDelay();
003A32  A862F4     BSET LATG, #3
003A34  07FFEF     RCALL .Letext0, .LFE8, _vI2CDelay, .Ltext0, .LFB0
41:                }
003A36  FA8000     ULNK
003A38  060000     RETURN
42:                
43:                /*************************************
44:                Function: I2C_Start 
45:                Description: I2C
46:                Input: void 
47:                Output: void
48:                 *************************************/
49:                void vI2CStart(void) {
003A3A  FA0000     LNK #0x0
50:                    /**/
51:                    I2C_SDA = 1;
52:                    /*delay*/
53:                    vI2CDelay();
003A3C  A862F4     BSET LATG, #3
003A3E  07FFEA     RCALL .Letext0, .LFE8, _vI2CDelay, .Ltext0, .LFB0
54:                    /**/
55:                    I2C_SCL = 1;
56:                    /*delay*/
57:                    vI2CDelay();
003A40  A842F4     BSET LATG, #2
003A42  07FFE8     RCALL .Letext0, .LFE8, _vI2CDelay, .Ltext0, .LFB0
58:                    /**/
59:                    I2C_SDA = 0;
60:                    /*delay,ICus*/
61:                    vI2CDelay();
003A44  A962F4     BCLR LATG, #3
003A46  07FFE6     RCALL .Letext0, .LFE8, _vI2CDelay, .Ltext0, .LFB0
62:                    /**/
63:                    I2C_SCL = 0;
64:                    /*delay*/
65:                    vI2CDelay();
003A48  A942F4     BCLR LATG, #2
003A4A  07FFE4     RCALL .Letext0, .LFE8, _vI2CDelay, .Ltext0, .LFB0
66:                }
003A4C  FA8000     ULNK
003A4E  060000     RETURN
67:                
68:                /*************************************
69:                Function: I2C_Stop 
70:                Description: I2C
71:                Input: void
72:                Output: void
73:                 *************************************/
74:                void vI2CStop(void) {
003A50  FA0000     LNK #0x0
75:                    /**/
76:                    I2C_SDA = 0;
77:                    /*delay*/
78:                    vI2CDelay();
003A52  A962F4     BCLR LATG, #3
003A54  07FFDF     RCALL .Letext0, .LFE8, _vI2CDelay, .Ltext0, .LFB0
79:                    /**/
80:                    I2C_SCL = 1;
81:                    /*delayICus*/
82:                    vI2CDelay();
003A56  A842F4     BSET LATG, #2
003A58  07FFDD     RCALL .Letext0, .LFE8, _vI2CDelay, .Ltext0, .LFB0
83:                    /**/
84:                    I2C_SDA = 1;
85:                    /*delay*/
86:                    vI2CDelay();
003A5A  A862F4     BSET LATG, #3
003A5C  07FFDB     RCALL .Letext0, .LFE8, _vI2CDelay, .Ltext0, .LFB0
87:                }
003A5E  FA8000     ULNK
003A60  060000     RETURN
88:                
89:                /*************************************
90:                Function: I2C_WriteICAdd 
91:                Description: I2CIC
92:                Input: ICaddopreation
93:                Output: 
94:                 *************************************/
95:                void vI2CWriteByte(unsigned char ucData) {
003A62  FA0004     LNK #0x4
003A64  984720     MOV.B W0, [W14+2]
96:                    /**/
97:                    unsigned char ucTmp;
98:                    char cCnt;
99:                    /**/
100:                   ucTmp = ucData;
003A66  9040AE     MOV.B [W14+2], W1
003A68  984711     MOV.B W1, [W14+1]
101:                   /*(bit)*/
102:                   for (cCnt = 7; cCnt >= 0; cCnt--) {
003A6A  B3C070     MOV.B #0x7, W0
003A6C  784F00     MOV.B W0, [W14]
003A6E  37001C     BRA .L8
003AA6  E94F1E     DEC.B [W14], [W14]
003AA8  78401E     MOV.B [W14], W0
003AAA  E00400     CP0.B W0
003AAC  3DFFE1     BRA GE, .L10
103:                       /*SDASCLSCL*/
104:                       I2C_SDA = ((ucTmp >> cCnt) & 0x01) ? 1 : 0;
003A70  90401E     MOV.B [W14+1], W0
003A72  FB8080     ZE W0, W1
003A74  FB001E     SE [W14], W0
003A76  DE8800     ASR W1, W0, W0
003A78  784000     MOV.B W0, W0
003A7A  604061     AND.B W0, #0x1, W0
003A7C  604061     AND.B W0, #0x1, W0
003A7E  604061     AND.B W0, #0x1, W0
003A80  FB8000     ZE W0, W0
003A82  600061     AND W0, #0x1, W0
003A84  DD0043     SL W0, #3, W0
003A86  8017A1     MOV LATG, W1
003A88  A13001     BCLR W1, #3
003A8A  700001     IOR W0, W1, W0
105:                       /*delay*/
106:                       vI2CDelay();
003A8C  8817A0     MOV W0, LATG
003A8E  07FFC2     RCALL .Letext0, .LFE8, _vI2CDelay, .Ltext0, .LFB0
107:                       /*give I2C bus*/
108:                       I2C_SCL = 1;
109:                       /*delay*/
110:                       vI2CDelay();
003A90  A842F4     BSET LATG, #2
003A92  07FFC0     RCALL .Letext0, .LFE8, _vI2CDelay, .Ltext0, .LFB0
111:                       /*take I2C bus*/
112:                       I2C_SCL = 0;
003A94  A942F4     BCLR LATG, #2
113:                       /*1SDA=0,I2C*/
114:                       if (!cCnt && I2C_SDA)
003A96  78401E     MOV.B [W14], W0
003A98  E00400     CP0.B W0
003A9A  3A0005     BRA NZ, .L9
003A9C  8017A0     MOV LATG, W0
003A9E  600068     AND W0, #0x8, W0
003AA0  E00000     CP0 W0
003AA2  320001     BRA Z, .L9
115:                           I2C_SDA = 0;
003AA4  A962F4     BCLR LATG, #3
116:                   }
117:               }
003AAE  FA8000     ULNK
003AB0  060000     RETURN
118:               
119:               ///*************************************
120:               //Function: I2C_WriteDatas 
121:               //Description: Write data to I2C device
122:               //Input: data 
123:               //Output: is finish complete 
124:               // *************************************/
125:               //bool bI2CWriteBytes(unsigned char *pucData, unsigned char ucDatasBytes) {
126:               //    unsigned char* pucTmp = pucData; //
127:               //    char cCnt;
128:               //
129:               //    /*repeat write data */
130:               //    for (cCnt = 0; cCnt < ucDatasBytes; cCnt++) {
131:               //        vI2CWriteByte(*(pucTmp + cCnt));
132:               //        if (!bI2CGetACK()) {
133:               //            return false;
134:               //        }
135:               //    }
136:               //    return true;
137:               //}
138:               
139:               /*************************************
140:               Function: I2C_ReadData 
141:               Description:read data from I2C device 
142:               Input: void 
143:               Output: data
144:                *************************************/
145:               unsigned char ucI2CReadByte(void) {
003AB2  FA0002     LNK #0x2
146:                   /**/
147:                   unsigned char ucTmp = 0;
003AB4  EB4000     CLR.B W0
003AB6  784F00     MOV.B W0, [W14]
148:                   char cCnt;
149:               
150:                   /**/
151:                   I2C_SDA_DIR = 1;
003AB8  A862F0     BSET TRISG, #3
152:                   /*I2C*/
153:                   for (cCnt = 7; cCnt >= 0; cCnt--) {
003ABA  B3C070     MOV.B #0x7, W0
003ABC  984710     MOV.B W0, [W14+1]
003ABE  370013     BRA .L12
003AE0  90401E     MOV.B [W14+1], W0
003AE2  E94000     DEC.B W0, W0
003AE4  984710     MOV.B W0, [W14+1]
003AE6  90401E     MOV.B [W14+1], W0
003AE8  E00400     CP0.B W0
003AEA  3DFFEA     BRA GE, .L13
154:                       /**/
155:                       I2C_SCL = 1;
156:                       /*delay*/
157:                       vI2CDelay();
003AC0  A842F4     BSET LATG, #2
003AC2  07FFA8     RCALL .Letext0, .LFE8, _vI2CDelay, .Ltext0, .LFB0
158:                       /**/
159:                       ucTmp |= I2C_R_SDA << cCnt;
003AC4  801790     MOV PORTG, W0
003AC6  DE0043     LSR W0, #3, W0
003AC8  604061     AND.B W0, #0x1, W0
003ACA  FB8080     ZE W0, W1
003ACC  90401E     MOV.B [W14+1], W0
003ACE  FB0000     SE W0, W0
003AD0  DD0800     SL W1, W0, W0
003AD2  784080     MOV.B W0, W1
003AD4  78401E     MOV.B [W14], W0
003AD6  70C000     IOR.B W1, W0, W0
160:                       /*delay*/
161:                       vI2CDelay();
003AD8  784F00     MOV.B W0, [W14]
003ADA  07FF9C     RCALL .Letext0, .LFE8, _vI2CDelay, .Ltext0, .LFB0
162:                       /**/
163:                       I2C_SCL = 0;
164:                       /*delay*/
165:                       vI2CDelay();
003ADC  A942F4     BCLR LATG, #2
003ADE  07FF9A     RCALL .Letext0, .LFE8, _vI2CDelay, .Ltext0, .LFB0
166:                   }
167:                   /**/
168:                   I2C_SDA_DIR = 0;
003AEC  A962F0     BCLR TRISG, #3
169:                   /**/
170:                   return ucTmp;
003AEE  78401E     MOV.B [W14], W0
171:               }
003AF0  FA8000     ULNK
003AF2  060000     RETURN
172:               
173:               /*************************************
174:               Function: I2C_ACK 
175:               Description: Master Get ACK state 
176:               Input: void 
177:               Output: isAck
178:                *************************************/
179:               bool bI2CGetACK(void) {
003AF4  FA0002     LNK #0x2
180:                   /*I2C*/
181:                   bool ucI2CSDASTA;
182:               
183:                   /**/
184:                   I2C_SDA_DIR = 1;
185:                   vI2CDelay();
003AF6  A862F0     BSET TRISG, #3
003AF8  07FF8D     RCALL .Letext0, .LFE8, _vI2CDelay, .Ltext0, .LFB0
186:                   /**/
187:                   I2C_SCL = 1;
188:                   vI2CDelay();
003AFA  A842F4     BSET LATG, #2
003AFC  07FF8B     RCALL .Letext0, .LFE8, _vI2CDelay, .Ltext0, .LFB0
189:                   /*ACK*/
190:                   ucI2CSDASTA = (I2C_R_SDA) ? I2C_MASTER_MISS_ACK : I2C_MASTER_GET_ACK;
003AFE  801790     MOV PORTG, W0
003B00  600068     AND W0, #0x8, W0
003B02  A7F000     BTSC W0, #15
003B04  EA0000     NEG W0, W0
003B06  E90000     DEC W0, W0
003B08  DE004F     LSR W0, #15, W0
191:                   vI2CDelay();
003B0A  784F00     MOV.B W0, [W14]
003B0C  07FF83     RCALL .Letext0, .LFE8, _vI2CDelay, .Ltext0, .LFB0
192:                   /**/
193:                   I2C_SCL = 0;
194:                   vI2CDelay();
003B0E  A942F4     BCLR LATG, #2
003B10  07FF81     RCALL .Letext0, .LFE8, _vI2CDelay, .Ltext0, .LFB0
195:                   /**/
196:                   I2C_SDA_DIR = 0;
003B12  A962F0     BCLR TRISG, #3
197:                   //    I2C_SDA = 1; //
198:                   /*ACK*/
199:                   return ucI2CSDASTA;
003B14  78401E     MOV.B [W14], W0
200:               }
003B16  FA8000     ULNK
003B18  060000     RETURN
201:               
202:               /*************************************
203:               Function: I2C_NACK 
204:               Description: master send NoAck
205:               Input: void
206:               Output: void
207:                *************************************/
208:               void vI2CSetNACK(bool bACK) {
003B1A  FA0002     LNK #0x2
003B1C  784F00     MOV.B W0, [W14]
209:                   /**/
210:                   I2C_SDA = bACK;
003B1E  FB801E     ZE [W14], W0
003B20  600061     AND W0, #0x1, W0
003B22  DD0043     SL W0, #3, W0
003B24  8017A1     MOV LATG, W1
003B26  A13001     BCLR W1, #3
003B28  700001     IOR W0, W1, W0
211:                   vI2CDelay();
003B2A  8817A0     MOV W0, LATG
003B2C  07FF73     RCALL .Letext0, .LFE8, _vI2CDelay, .Ltext0, .LFB0
212:                   /**/
213:                   I2C_SCL = 1;
214:                   vI2CDelay();
003B2E  A842F4     BSET LATG, #2
003B30  07FF71     RCALL .Letext0, .LFE8, _vI2CDelay, .Ltext0, .LFB0
215:                   /**/
216:                   I2C_SCL = 0;
217:                   vI2CDelay();
003B32  A942F4     BCLR LATG, #2
003B34  07FF6F     RCALL .Letext0, .LFE8, _vI2CDelay, .Ltext0, .LFB0
218:                   /**/
219:                   I2C_SDA = 0;
220:                   vI2CDelay();
003B36  A962F4     BCLR LATG, #3
003B38  07FF6D     RCALL .Letext0, .LFE8, _vI2CDelay, .Ltext0, .LFB0
221:               }
003B3A  FA8000     ULNK
003B3C  060000     RETURN
222:               
223:               /*************************************
224:               Function: bI2CWriteSlave 
225:               Description: continue write data 
226:               Input: sI2CDevice
227:               Output: void
228:                *************************************/
229:               bool bI2CWriteSlave(sI2CDeviceAttribute *sI2CDevice) {
003B3E  FA0004     LNK #0x4
003B40  980710     MOV W0, [W14+2]
230:                   /*if use rtos,disable tick interrupt*/
231:               #ifdef UseRTOS
232:                   taskDISABLE_INTERRUPTS();
003B42  800211     MOV SR, W1
003B44  2FF1F0     MOV #0xFF1F, W0
003B46  608000     AND W1, W0, W0
003B48  A05000     BSET W0, #5
003B4A  880210     MOV W0, SR
003B4C  000000     NOP
003B4E  000000     NOP
233:               #endif
234:                   bool bIsWriteComplete = true;
003B50  B3C010     MOV.B #0x1, W0
235:                   unsigned char ucCnt;
236:                   /*Start I2C communication*/
237:                   vI2CStart();
003B52  784F00     MOV.B W0, [W14]
003B54  07FF72     RCALL vI2CStart
238:                   /*Select PCF and  ready to write */
239:                   vI2CWriteByte(sI2CDevice->ucSlaveAddress & I2C_WRITE);
003B56  90001E     MOV [W14+2], W0
003B58  784010     MOV.B [W0], W0
003B5A  A10400     BCLR.B W0, #0
240:                   if (bI2CGetACK()) {
003B5C  07FF82     RCALL vI2CWriteByte
003B5E  07FFCA     RCALL bI2CGetACK
003B60  E00400     CP0.B W0
003B62  32002E     BRA Z, .L17
241:                       if (sI2CDevice->bIs16BitDevice) {
003B64  90001E     MOV [W14+2], W0
003B66  904040     MOV.B [W0+4], W0
003B68  E00400     CP0.B W0
003B6A  32000A     BRA Z, .L18
242:                           /*write 16bit register address 0x00*/
243:                           vI2CWriteByte((unsigned char) ((sI2CDevice->usRegisterAddress && 0x00ff) >> 8));
003B6C  EB4000     CLR.B W0
244:                           if (bI2CGetACK()) {
003B6E  07FF79     RCALL vI2CWriteByte
003B70  07FFC1     RCALL bI2CGetACK
003B72  E00400     CP0.B W0
003B74  320009     BRA Z, .L19
245:                               vI2CWriteByte((unsigned char) (sI2CDevice->usRegisterAddress & 0x00ff));
003B76  90001E     MOV [W14+2], W0
003B78  900010     MOV [W0+2], W0
003B7A  784000     MOV.B W0, W0
003B7C  07FF72     RCALL vI2CWriteByte
003B7E  370004     BRA .L19
246:                           }
247:                       } else {
248:                           /*write 8bit register address 0x00*/
249:                           vI2CWriteByte((unsigned char) (sI2CDevice->usRegisterAddress & 0x00FF));
003B80  90001E     MOV [W14+2], W0
003B82  900010     MOV [W0+2], W0
003B84  784000     MOV.B W0, W0
250:                       }
251:                       if (bI2CGetACK()) {
003B86  07FF6D     RCALL vI2CWriteByte
003B88  07FFB5     RCALL bI2CGetACK
003B8A  E00400     CP0.B W0
003B8C  320019     BRA Z, .L17
252:                           /*write data in register ,all write 15 bytes,repeat write data */
253:                           for (ucCnt = 0; ucCnt < sI2CDevice->ucNeedDataBytes; ucCnt++) {
003B8E  EB4000     CLR.B W0
003B90  984710     MOV.B W0, [W14+1]
003B92  370011     BRA .L20
003BB0  90401E     MOV.B [W14+1], W0
003BB2  E84000     INC.B W0, W0
003BB4  984710     MOV.B W0, [W14+1]
003BB6  90001E     MOV [W14+2], W0
003BB8  904880     MOV.B [W0+8], W1
003BBA  90401E     MOV.B [W14+1], W0
003BBC  50CF80     SUB.B W1, W0, [W15]
254:                               vI2CWriteByte(*(sI2CDevice->pucNeedData + ucCnt));
003B94  90001E     MOV [W14+2], W0
003B96  9000B0     MOV [W0+6], W1
003B98  90401E     MOV.B [W14+1], W0
003B9A  FB8000     ZE W0, W0
003B9C  408000     ADD W1, W0, W0
003B9E  784010     MOV.B [W0], W0
255:                               if (!bI2CGetACK()) {
003BA0  07FF60     RCALL vI2CWriteByte
003BA2  07FFA8     RCALL bI2CGetACK
003BA4  A20400     BTG.B W0, #0
003BA6  E00400     CP0.B W0
003BA8  320003     BRA Z, .L21
256:                                   bIsWriteComplete = false; //                error(0);//notice error:0
003BAA  EB4000     CLR.B W0
003BAC  784F00     MOV.B W0, [W14]
257:                                   break;
003BAE  370008     BRA .L17
258:                               }
259:                           }
260:                       }
261:                   }
262:                   /*I2C Protocal stop commuication*/
263:                   vI2CStop();
003BBE  3EFFEA     BRA GTU, .L22
003BC0  07FF47     RCALL vI2CStop
264:               #ifdef UseRTOS
265:                   taskENABLE_INTERRUPTS();
003BC2  800211     MOV SR, W1
003BC4  2FF1F0     MOV #0xFF1F, W0
003BC6  608000     AND W1, W0, W0
003BC8  880210     MOV W0, SR
003BCA  000000     NOP
266:               #endif
267:                   return bIsWriteComplete;
003BCC  78401E     MOV.B [W14], W0
268:               }
003BCE  FA8000     ULNK
003BD0  060000     RETURN
269:               
270:               /*************************************
271:               Function: bI2CReadSlave 
272:               Description: master read data
273:               Input: sI2CDevice
274:               Output: void
275:                *************************************/
276:               bool bI2CReadSlave(sI2CDeviceAttribute *sI2CDevice) {
003BD2  FA0004     LNK #0x4
003BD4  781F88     MOV W8, [W15++]
003BD6  980710     MOV W0, [W14+2]
277:                   unsigned char ucCnt;
278:                   bool bIsReadComplete = false;
003BD8  EB4000     CLR.B W0
003BDA  984710     MOV.B W0, [W14+1]
279:               
280:               #ifdef UseRTOS
281:                   taskDISABLE_INTERRUPTS();
003BDC  800211     MOV SR, W1
003BDE  2FF1F0     MOV #0xFF1F, W0
003BE0  608000     AND W1, W0, W0
003BE2  A05000     BSET W0, #5
003BE4  880210     MOV W0, SR
003BE6  000000     NOP
282:               #endif
283:                   /*I2C protocal is started communication*/
284:                   vI2CStart();
003BE8  000000     NOP
003BEA  07FF27     RCALL vI2CStart
285:                   /*send salve address and write operation*/
286:                   vI2CWriteByte(sI2CDevice->ucSlaveAddress & I2C_WRITE);
003BEC  90001E     MOV [W14+2], W0
003BEE  784010     MOV.B [W0], W0
003BF0  A10400     BCLR.B W0, #0
287:                   /*get ack*/
288:                   if (bI2CGetACK()) {
003BF2  07FF37     RCALL vI2CWriteByte
003BF4  07FF7F     RCALL bI2CGetACK
003BF6  E00400     CP0.B W0
003BF8  320039     BRA Z, .L24
289:                       /*send salve register address,*/
290:                       if (sI2CDevice->bIs16BitDevice) {
003BFA  90001E     MOV [W14+2], W0
003BFC  904040     MOV.B [W0+4], W0
003BFE  E00400     CP0.B W0
003C00  32000A     BRA Z, .L25
291:                           /*write 16bit register address 0x00*/
292:                           vI2CWriteByte((unsigned char) ((sI2CDevice->usRegisterAddress && 0x00ff) >> 8));
003C02  EB4000     CLR.B W0
293:                           if (bI2CGetACK()) {
003C04  07FF2E     RCALL vI2CWriteByte
003C06  07FF76     RCALL bI2CGetACK
003C08  E00400     CP0.B W0
003C0A  320009     BRA Z, .L26
294:                               vI2CWriteByte((unsigned char) (sI2CDevice->usRegisterAddress & 0x00ff));
003C0C  90001E     MOV [W14+2], W0
003C0E  900010     MOV [W0+2], W0
003C10  784000     MOV.B W0, W0
003C12  07FF27     RCALL vI2CWriteByte
003C14  370004     BRA .L26
295:                           }
296:                       } else {
297:                           /*write 8bit register address 0x00*/
298:                           vI2CWriteByte((unsigned char) (sI2CDevice->usRegisterAddress & 0x00FF));
003C16  90001E     MOV [W14+2], W0
003C18  900010     MOV [W0+2], W0
003C1A  784000     MOV.B W0, W0
299:                       }
300:                       //        vI2CWriteByte(sI2CDevice->usRegisterAddress); //PCF_CON_STA + 2);
301:                       /*get ack*/
302:                       if (bI2CGetACK()) {
003C1C  07FF22     RCALL vI2CWriteByte
003C1E  07FF6A     RCALL bI2CGetACK
003C20  E00400     CP0.B W0
303:                           /*I2C Restart*/
304:                           vI2CStart();
003C22  320024     BRA Z, .L24
003C24  07FF0A     RCALL vI2CStart
305:                           /*send read handle*/
306:                           vI2CWriteByte(sI2CDevice->ucSlaveAddress | I2C_READ);
003C26  90001E     MOV [W14+2], W0
003C28  784010     MOV.B [W0], W0
003C2A  A00400     BSET.B W0, #0
307:                           /*get ack*/
308:                           if (bI2CGetACK()) {
003C2C  07FF1A     RCALL vI2CWriteByte
003C2E  07FF62     RCALL bI2CGetACK
003C30  E00400     CP0.B W0
003C32  32001C     BRA Z, .L24
309:                               /*repeat read data*/
310:                               for (ucCnt = 0; ucCnt < sI2CDevice->ucNeedDataBytes; ucCnt++) {
003C34  EB4000     CLR.B W0
003C36  784F00     MOV.B W0, [W14]
003C38  370015     BRA .L27
003C62  E84F1E     INC.B [W14], [W14]
003C64  90001E     MOV [W14+2], W0
003C66  904800     MOV.B [W0+8], W0
003C68  504F9E     SUB.B W0, [W14], [W15]
311:                                   /*Read byte*/
312:                                   *(sI2CDevice->pucNeedData + ucCnt) = ucI2CReadByte();
003C3A  90001E     MOV [W14+2], W0
003C3C  9000B0     MOV [W0+6], W1
003C3E  FB801E     ZE [W14], W0
003C40  408400     ADD W1, W0, W8
003C42  07FF37     RCALL ucI2CReadByte
003C44  784C00     MOV.B W0, [W8]
313:                                   /*if count is last byte, set nack;else set ack*/
314:                                   if (ucCnt == sI2CDevice->ucNeedDataBytes - 1) {
003C46  FB809E     ZE [W14], W1
003C48  90001E     MOV [W14+2], W0
003C4A  904800     MOV.B [W0+8], W0
003C4C  FB8000     ZE W0, W0
003C4E  E90000     DEC W0, W0
003C50  508F80     SUB W1, W0, [W15]
003C52  3A0005     BRA NZ, .L28
315:                                       vI2CSetNACK(I2C_MASTER_SEND_NACK);
003C54  B3C010     MOV.B #0x1, W0
003C56  07FF61     RCALL vI2CSetNACK
316:                                       bIsReadComplete = true;
003C58  B3C010     MOV.B #0x1, W0
003C5A  984710     MOV.B W0, [W14+1]
003C5C  370002     BRA .L29
317:                                   } else {
318:                                       vI2CSetNACK(I2C_MASTER_SEND_ACK);
003C5E  EB4000     CLR.B W0
003C60  07FF5C     RCALL vI2CSetNACK
319:                                   }
320:                               }
321:                           }
322:               
323:                       }
324:                   }
325:                   /*I2x protocal is stopped communication */
326:                   vI2CStop();
003C6A  3EFFE7     BRA GTU, .L30
003C6C  07FEF1     RCALL vI2CStop
327:               #ifdef UseRTOS
328:                   taskENABLE_INTERRUPTS();
003C6E  800211     MOV SR, W1
003C70  2FF1F0     MOV #0xFF1F, W0
003C72  608000     AND W1, W0, W0
003C74  880210     MOV W0, SR
003C76  000000     NOP
329:               #endif
330:                   return bIsReadComplete;
003C78  90401E     MOV.B [W14+1], W0
331:               }
003C7A  78044F     MOV [--W15], W8
003C7C  FA8000     ULNK
003C7E  060000     RETURN
332:               
---  /home/zxc/Documents/WCGRTOS/Demo/BSP/Debug.c  ------------------------------------------------------
1:                 #include "Debug.h"
2:                 
3:                 /*************************************
4:                  * Function: vDeBugPrintString
5:                  * Description: print char by setting bytes
6:                  * Input: pvString,ucBytes
7:                  * Output: void
8:                  * notice: can print 0x00
9:                  *************************************/
10:                void vDeBugPrintString(void *pvStrings, uint8_t ucBytes) {
004FA0  FA0004     LNK #0x4
004FA2  780F00     MOV W0, [W14]
004FA4  984721     MOV.B W1, [W14+2]
11:                    vDebugSendString((uint8_t*) pvStrings, ucBytes);
004FA6  78001E     MOV [W14], W0
004FA8  9040AE     MOV.B [W14+2], W1
004FAA  024D58     CALL UART3_SendString
004FAC  000000     NOP
12:                }
004FAE  FA8000     ULNK
004FB0  060000     RETURN
13:                
14:                /*************************************
15:                 * Function: vDeBugPrintInformation
16:                 * Description: print string 
17:                 * Input: pvString
18:                 * Output: void
19:                 * notice: print stop by 0x00
20:                 *************************************/
21:                void vDeBugPrintInformation(void *pvStrings) {
004FB2  FA0004     LNK #0x4
004FB4  980710     MOV W0, [W14+2]
22:                    uint8_t* pucFirstChar;
23:                
24:                    pucFirstChar = (uint8_t*) pvStrings;
004FB6  90009E     MOV [W14+2], W1
004FB8  780F01     MOV W1, [W14]
25:                    while (*pucFirstChar != '\0') {
004FBA  370005     BRA .L3
004FC6  78001E     MOV [W14], W0
004FC8  784010     MOV.B [W0], W0
004FCA  E00400     CP0.B W0
004FCC  3AFFF7     BRA NZ, .L4
26:                        vDebugSendChar(*pucFirstChar);
004FBC  78001E     MOV [W14], W0
004FBE  784010     MOV.B [W0], W0
004FC0  024D40     CALL UART3_SendChar
004FC2  000000     NOP
27:                        pucFirstChar += 1;
004FC4  E80F1E     INC [W14], [W14]
28:                    }
29:                    vDebugSendChar('\n');
004FCE  B3C0A0     MOV.B #0xA, W0
004FD0  024D40     CALL UART3_SendChar
004FD2  000000     NOP
30:                }
004FD4  FA8000     ULNK
004FD6  060000     RETURN
31:                
32:                /*************************************
33:                 * Function: vDeBugPrintStringAndNums
34:                 * Description: print String and nums
35:                 * Input: pvStrings,usNums
36:                 * Output: void
37:                 * notice: print String stop by 0x00,usNums range from 0 to 65536
38:                 *************************************/
39:                
40:                void vDeBugPrintStringAndNums(void *pvStrings, uint16_t usNums) {
004FD8  FA000E     LNK #0xE
004FDA  980750     MOV W0, [W14+10]
004FDC  980761     MOV W1, [W14+12]
41:                    uint8_t ucNumsString[6] = {0, 0, 0, 0, 0, 0}, ucNumsStringLength = 0;
004FDE  4700E3     ADD W14, #0x3, W1
004FE0  090005     REPEAT #0x5
004FE2  EB5880     CLR.B [W1++]
004FE4  EB4000     CLR.B W0
004FE6  984720     MOV.B W0, [W14+2]
42:                    uint8_t* pucFirstChar;
43:                
44:                    pucFirstChar = (uint8_t*) pvStrings;
004FE8  9000DE     MOV [W14+10], W1
004FEA  780F01     MOV W1, [W14]
45:                    while (*pucFirstChar != '\0') {
004FEC  370005     BRA .L6
004FF8  78001E     MOV [W14], W0
004FFA  784010     MOV.B [W0], W0
004FFC  E00400     CP0.B W0
004FFE  3AFFF7     BRA NZ, .L7
46:                        vDebugSendChar(*pucFirstChar);
004FEE  78001E     MOV [W14], W0
004FF0  784010     MOV.B [W0], W0
004FF2  024D40     CALL UART3_SendChar
004FF4  000000     NOP
47:                        pucFirstChar += 1;
004FF6  E80F1E     INC [W14], [W14]
48:                    }
49:                    ucNumsStringLength = my_itoa(usNums, ucNumsString);
005000  470063     ADD W14, #0x3, W0
005002  780080     MOV W0, W1
005004  90006E     MOV [W14+12], W0
005006  022ECE     CALL my_itoa
005008  000000     NOP
00500A  984720     MOV.B W0, [W14+2]
50:                    vDebugSendString(ucNumsString, ucNumsStringLength);
00500C  470063     ADD W14, #0x3, W0
00500E  9040AE     MOV.B [W14+2], W1
005010  024D58     CALL UART3_SendString
005012  000000     NOP
51:                    vDebugSendChar('\n');
005014  B3C0A0     MOV.B #0xA, W0
005016  024D40     CALL UART3_SendChar
005018  000000     NOP
52:                }
00501A  FA8000     ULNK
00501C  060000     RETURN
53:                
54:                
55:                
---  /home/zxc/Documents/WCGRTOS/Demo/App/serial/serial.c  ----------------------------------------------
1:                 /*
2:                     FreeRTOS V9.0.0 - Copyright (C) 2016 Real Time Engineers Ltd.
3:                     All rights reserved
4:                 
5:                     VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
6:                 
7:                     This file is part of the FreeRTOS distribution.
8:                 
9:                     FreeRTOS is free software; you can redistribute it and/or modify it under
10:                    the terms of the GNU General Public License (version 2) as published by the
11:                    Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
12:                
13:                 ***************************************************************************
14:                    >>!   NOTE: The modification to the GPL is included to allow you to     !<<
15:                    >>!   distribute a combined work that includes FreeRTOS without being   !<<
16:                    >>!   obliged to provide the source code for proprietary components     !<<
17:                    >>!   outside of the FreeRTOS kernel.                                   !<<
18:                 ***************************************************************************
19:                
20:                    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
21:                    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
22:                    FOR A PARTICULAR PURPOSE.  Full license text is available on the following
23:                    link: http://www.freertos.org/a00114.html
24:                
25:                 ***************************************************************************
26:                 *                                                                       *
27:                 *    FreeRTOS provides completely free yet professionally developed,    *
28:                 *    robust, strictly quality controlled, supported, and cross          *
29:                 *    platform software that is more than just the market leader, it     *
30:                 *    is the industry's de facto standard.                               *
31:                 *                                                                       *
32:                 *    Help yourself get started quickly while simultaneously helping     *
33:                 *    to support the FreeRTOS project by purchasing a FreeRTOS           *
34:                 *    tutorial book, reference manual, or both:                          *
35:                 *    http://www.FreeRTOS.org/Documentation                              *
36:                 *                                                                       *
37:                 ***************************************************************************
38:                
39:                    http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
40:                    the FAQ page "My application does not run, what could be wrong?".  Have you
41:                    defined configASSERT()?
42:                
43:                    http://www.FreeRTOS.org/support - In return for receiving this top quality
44:                    embedded software for free we request you assist our global community by
45:                    participating in the support forum.
46:                
47:                    http://www.FreeRTOS.org/training - Investing in training allows your team to
48:                    be as productive as possible as early as possible.  Now you can receive
49:                    FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
50:                    Ltd, and the world's leading authority on the world's leading RTOS.
51:                
52:                    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
53:                    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
54:                    compatible FAT file system, and our tiny thread aware UDP/IP stack.
55:                
56:                    http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
57:                    Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
58:                
59:                    http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
60:                    Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
61:                    licenses offer ticketed support, indemnification and commercial middleware.
62:                
63:                    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
64:                    engineered and independently SIL3 certified version for use in safety and
65:                    mission critical applications that require provable dependability.
66:                
67:                    1 tab == 4 spaces!
68:                 */
69:                
70:                
71:                /* BASIC INTERRUPT DRIVEN SERIAL PORT DRIVER. 
72:                
73:                NOTE:  This driver is primarily to test the scheduler functionality.  It does
74:                not effectively use the buffers or DMA and is therefore not intended to be
75:                an example of an efficient driver. */
76:                
77:                /* Standard include file. */
78:                #include <stdlib.h>
79:                #include <stdbool.h>
80:                
81:                /* Scheduler include files. */
82:                #include "FreeRTOS.h"
83:                #include "queue.h"
84:                #include "task.h"
85:                
86:                /* Demo app include files. */
87:                #include "serial.h"
88:                
89:                /* Hardware setup. */
90:                #define serOUTPUT						0
91:                #define serINPUT						1
92:                #define serLOW_SPEED					0
93:                #define serONE_STOP_BIT					0
94:                #define serEIGHT_DATA_BITS_NO_PARITY	0
95:                #define serNORMAL_IDLE_STATE			0
96:                #define serAUTO_BAUD_OFF				0
97:                #define serLOOPBACK_OFF					0
98:                #define serWAKE_UP_DISABLE				0
99:                #define serNO_HARDWARE_FLOW_CONTROL		0
100:               #define serSTANDARD_IO					0
101:               #define serNO_IRDA						0
102:               #define serCONTINUE_IN_IDLE_MODE		0
103:               #define serUART_ENABLED					1
104:               #define serINTERRUPT_ON_SINGLE_CHAR		0
105:               #define serTX_ENABLE					1
106:               #define serINTERRUPT_ENABLE				1
107:               #define serINTERRUPT_DISABLE			0
108:               #define serCLEAR_FLAG					0
109:               #define serSET_FLAG						1
110:               
111:               
112:               /* The queues used to communicate between tasks and ISR's. */
113:               static QueueHandle_t xRxedChars;
114:               static QueueHandle_t xCharsForTx;
115:               
116:               static portBASE_TYPE xTxHasEnded;
117:               
118:               /*-----------------------------------------------------------*/
119:               
120:               xComPortHandle xSerialPortInitMinimal(unsigned long ulWantedBaud, unsigned portBASE_TYPE uxQueueLength) {
004678  FA0008     LNK #0x8
00467A  980710     MOV W0, [W14+2]
00467C  980721     MOV W1, [W14+4]
00467E  980732     MOV W2, [W14+6]
121:                   char cChar;
122:                   //
123:                   //    TRISDbits.TRISD2 = 1; //
124:                   //    TRISDbits.TRISD3 = 0; //
125:                   _TRISE6 = 0; //485
004680  A9C2E0     BCLR TRISE, #6
126:                   _LATE6 = 0; //,
004682  A9C2E4     BCLR LATE, #6
127:                   __builtin_write_OSCCONL(OSCCON & 0xbf); // unlock PPS
004684  803A11     MOV OSCCON, W1
004686  200BF0     MOV #0xBF, W0
004688  608100     AND W1, W0, W2
00468A  200460     MOV #0x46, W0
00468C  200571     MOV #0x57, W1
00468E  207423     MOV #0x742, W3
004690  784980     MOV.B W0, [W3]
004692  784981     MOV.B W1, [W3]
004694  784982     MOV.B W2, [W3]
128:                   RPOR13bits.RP26R = 0x1C; // RG7->UART3:U3TX
004696  8036D1     MOV RPOR13, W1
004698  2FFC00     MOV #0xFFC0, W0
00469A  608000     AND W1, W0, W0
00469C  B301C0     IOR #0x1C, W0
00469E  8836D0     MOV W0, RPOR13
129:                   RPINR17bits.U3RXR = 0x13; // RG8->UART3:U3RX 
0046A0  803511     MOV RPINR17, W1
0046A2  2C0FF0     MOV #0xC0FF, W0
0046A4  608080     AND W1, W0, W1
0046A6  213000     MOV #0x1300, W0
0046A8  700001     IOR W0, W1, W0
0046AA  883510     MOV W0, RPINR17
130:                   __builtin_write_OSCCONL(OSCCON | 0x40); // lock   PPS
0046AC  803A10     MOV OSCCON, W0
0046AE  780100     MOV W0, W2
0046B0  A06002     BSET W2, #6
0046B2  200460     MOV #0x46, W0
0046B4  200571     MOV #0x57, W1
0046B6  207423     MOV #0x742, W3
0046B8  784980     MOV.B W0, [W3]
0046BA  784981     MOV.B W1, [W3]
0046BC  784982     MOV.B W2, [W3]
131:               
132:                   /* Create the queues used by the com test task. */
133:                   xRxedChars = xQueueCreate(uxQueueLength, (unsigned portBASE_TYPE) sizeof ( signed char));
0046BE  EB4100     CLR.B W2
0046C0  200011     MOV #0x1, W1
0046C2  90003E     MOV [W14+6], W0
0046C4  02207C     CALL xQueueGenericCreate
0046C6  000000     NOP
0046C8  8844C0     MOV W0, xRxedChars
134:                   xCharsForTx = xQueueCreate(uxQueueLength, (unsigned portBASE_TYPE) sizeof ( signed char));
0046CA  EB4100     CLR.B W2
0046CC  200011     MOV #0x1, W1
0046CE  90003E     MOV [W14+6], W0
0046D0  02207C     CALL xQueueGenericCreate
0046D2  000000     NOP
0046D4  8844D0     MOV W0, xCharsForTx
135:               
136:                   /* Setup the UART. */
137:                   U3MODEbits.BRGH = serLOW_SPEED;
0046D6  A96250     BCLR U3MODE, #3
138:                   U3MODEbits.STSEL = serONE_STOP_BIT;
0046D8  A90250     BCLR U3MODE, #0
139:                   U3MODEbits.PDSEL = serEIGHT_DATA_BITS_NO_PARITY;
0046DA  801281     MOV U3MODE, W1
0046DC  2FFF90     MOV #0xFFF9, W0
0046DE  608000     AND W1, W0, W0
0046E0  881280     MOV W0, U3MODE
140:                   U3MODEbits.RXINV = serNORMAL_IDLE_STATE;
0046E2  A98250     BCLR U3MODE, #4
141:                   U3MODEbits.ABAUD = serAUTO_BAUD_OFF;
0046E4  A9A250     BCLR U3MODE, #5
142:                   U3MODEbits.LPBACK = serLOOPBACK_OFF;
0046E6  A9C250     BCLR U3MODE, #6
143:                   U3MODEbits.WAKE = serWAKE_UP_DISABLE;
0046E8  A9E250     BCLR U3MODE, #7
144:                   U3MODEbits.UEN = serNO_HARDWARE_FLOW_CONTROL;
0046EA  801281     MOV U3MODE, W1
0046EC  2FCFF0     MOV #0xFCFF, W0
0046EE  608000     AND W1, W0, W0
0046F0  881280     MOV W0, U3MODE
145:                   U3MODEbits.IREN = serNO_IRDA;
0046F2  A98251     BCLR 0x251, #4
146:                   U3MODEbits.USIDL = serCONTINUE_IN_IDLE_MODE;
0046F4  A9A251     BCLR 0x251, #5
147:                   U3MODEbits.UARTEN = serUART_ENABLED;
0046F6  A8E251     BSET 0x251, #7
148:               
149:                   U3BRG = (unsigned short) (((float) configCPU_CLOCK_HZ / ((float) 16 * (float) ulWantedBaud)) - (float) 0.5);
0046F8  90001E     MOV [W14+2], W0
0046FA  9000AE     MOV [W14+4], W1
0046FC  0206DC     CALL ___floatunsisf
0046FE  000000     NOP
004700  200002     MOV #0x0, W2
004702  241803     MOV #0x4180, W3
004704  020786     CALL ___mulsf3
004706  000000     NOP
004708  BE0100     MOV.D W0, W2
00470A  224000     MOV #0x2400, W0
00470C  24A741     MOV #0x4A74, W1
00470E  0205FE     CALL ___divsf3
004710  000000     NOP
004712  200002     MOV #0x0, W2
004714  23F003     MOV #0x3F00, W3
004716  020542     CALL ___subsf3
004718  000000     NOP
00471A  0206A0     CALL ___fixunssfsi
00471C  000000     NOP
00471E  780000     MOV W0, W0
004720  8812C0     MOV W0, U3BRG
150:               
151:                   U3STAbits.URXISEL = serINTERRUPT_ON_SINGLE_CHAR;
004722  801291     MOV U3STA, W1
004724  2FF3F0     MOV #0xFF3F, W0
004726  608000     AND W1, W0, W0
004728  881290     MOV W0, U3STA
152:                   U3STAbits.UTXEN = serTX_ENABLE;
00472A  A84253     BSET 0x253, #2
153:                   U3STAbits.UTXINV = serNORMAL_IDLE_STATE;
00472C  A9C253     BCLR 0x253, #6
154:                   U3STAbits.UTXISEL0 = serINTERRUPT_ON_SINGLE_CHAR;
00472E  A9A253     BCLR 0x253, #5
155:                   U3STAbits.UTXISEL1 = serINTERRUPT_ON_SINGLE_CHAR;
004730  A9E253     BCLR 0x253, #7
156:               
157:                   /* It is assumed that this function is called prior to the scheduler being
158:                   started.  Therefore interrupts must not be allowed to occur yet as they
159:                   may attempt to perform a context switch. */
160:                   portDISABLE_INTERRUPTS();
004732  800211     MOV SR, W1
004734  2FF1F0     MOV #0xFF1F, W0
004736  608000     AND W1, W0, W0
004738  A05000     BSET W0, #5
00473A  880210     MOV W0, SR
00473C  000000     NOP
00473E  000000     NOP
161:               
162:                   _U3RXIF = serCLEAR_FLAG;
004740  A9408E     BCLR IFS5, #2
163:                   _U3TXIF = serCLEAR_FLAG;
004742  A9608E     BCLR IFS5, #3
164:                   _U3RXIP = configKERNEL_INTERRUPT_PRIORITY;
004744  800661     MOV IPC20, W1
004746  2F8FF0     MOV #0xF8FF, W0
004748  608000     AND W1, W0, W0
00474A  A08000     BSET W0, #8
00474C  880660     MOV W0, IPC20
165:                   _U3TXIP = configKERNEL_INTERRUPT_PRIORITY;
00474E  800661     MOV IPC20, W1
004750  28FFF0     MOV #0x8FFF, W0
004752  608000     AND W1, W0, W0
004754  A0C000     BSET W0, #12
004756  880660     MOV W0, IPC20
166:                   _U3TXIE = serINTERRUPT_ENABLE;
004758  A8609E     BSET IEC5, #3
167:                   _U3RXIE = serINTERRUPT_ENABLE;
00475A  A8409E     BSET IEC5, #2
168:               
169:                   /* Clear the Rx buffer. */
170:                   while (U3STAbits.URXDA == serSET_FLAG) {
00475C  370002     BRA .L2
004762  801290     MOV U3STA, W0
004764  600061     AND W0, #0x1, W0
004766  E00000     CP0 W0
004768  3AFFFA     BRA NZ, .L3
171:                       cChar = U3RXREG;
00475E  8012B0     MOV U3RXREG, W0
004760  784F00     MOV.B W0, [W14]
172:                   }
173:               
174:                   xTxHasEnded = pdTRUE;
00476A  200010     MOV #0x1, W0
00476C  8844E0     MOV W0, xTxHasEnded
175:               
176:                   return NULL;
00476E  EB0000     CLR W0
177:               }
004770  FA8000     ULNK
004772  060000     RETURN
178:               
179:               /*-----------------------------------------------------------*/
180:               
181:               signed portBASE_TYPE xSerialGetChar(xComPortHandle pxPort, signed char *pcRxedChar, TickType_t xBlockTime) {
004774  FA0006     LNK #0x6
004776  780F00     MOV W0, [W14]
004778  980711     MOV W1, [W14+2]
00477A  980722     MOV W2, [W14+4]
182:                   /* Only one port is supported. */
183:                   (void) pxPort;
184:               
185:                   /* Get the next character from the buffer.  Return false if no characters
186:                   are available or arrive before xBlockTime expires. */
187:                   if (xQueueReceive(xRxedChars, pcRxedChar, xBlockTime)) {
00477C  8044C0     MOV xRxedChars, W0
00477E  EB0180     CLR W3
004780  90012E     MOV [W14+4], W2
004782  90009E     MOV [W14+2], W1
004784  0222D4     CALL xQueueGenericReceive
004786  000000     NOP
004788  E00000     CP0 W0
00478A  320002     BRA Z, .L5
188:                       return pdTRUE;
00478C  200010     MOV #0x1, W0
00478E  370001     BRA .L6
189:                   } else {
190:                       return pdFALSE;
004790  EB0000     CLR W0
191:                   }
192:               }
004792  FA8000     ULNK
004794  060000     RETURN
193:               
194:               /*-----------------------------------------------------------*/
195:               
196:               signed portBASE_TYPE xSerialPutChar(xComPortHandle pxPort, signed char cOutChar, TickType_t xBlockTime) {
004796  FA0006     LNK #0x6
004798  780F00     MOV W0, [W14]
00479A  984721     MOV.B W1, [W14+2]
00479C  980722     MOV W2, [W14+4]
197:                   /* Only one port is supported. */
198:                   (void) pxPort;
199:               
200:                   /* Return false if after the block time there is no room on the Tx queue. */
201:                   if (xQueueSend(xCharsForTx, &cOutChar, xBlockTime) != pdPASS) {
00479E  8044D0     MOV xCharsForTx, W0
0047A0  E8808E     INC2 W14, W1
0047A2  EB0180     CLR W3
0047A4  90012E     MOV [W14+4], W2
0047A6  0220F8     CALL xQueueGenericSend
0047A8  000000     NOP
0047AA  500FE1     SUB W0, #0x1, [W15]
0047AC  320002     BRA Z, .L8
202:                       return pdFAIL;
0047AE  EB0000     CLR W0
0047B0  370006     BRA .L9
203:                   }
204:               
205:                   /* A critical section should not be required as xTxHasEnded will not be
206:                   written to by the ISR if it is already 0 (is this correct?). */
207:                   if (xTxHasEnded) {
0047B2  8044E0     MOV xTxHasEnded, W0
0047B4  E00000     CP0 W0
0047B6  320002     BRA Z, .L10
208:                       xTxHasEnded = pdFALSE;
0047B8  EF289C     CLR xTxHasEnded
209:                       _U3TXIF = serSET_FLAG;
0047BA  A8608E     BSET IFS5, #3
210:                   }
211:               
212:                   return pdPASS;
0047BC  200010     MOV #0x1, W0
213:               }
0047BE  FA8000     ULNK
0047C0  060000     RETURN
214:               
215:               /*-----------------------------------------------------------*/
216:               
217:               void vSerialClose(xComPortHandle xPort) {
0047C2  FA0002     LNK #0x2
0047C4  780F00     MOV W0, [W14]
218:                   /* Note implemented. */
219:                   (void) xPort;
220:               }
0047C6  FA8000     ULNK
0047C8  060000     RETURN
221:               
222:               /*-----------------------------------------------------------*/
223:               
224:               void __attribute__((__interrupt__, auto_psv)) _U3RXInterrupt(void) {
000328  F80036     PUSH RCOUNT
00032A  BE9F80     MOV.D W0, [W15++]
00032C  BE9F82     MOV.D W2, [W15++]
00032E  BE9F84     MOV.D W4, [W15++]
000330  BE9F86     MOV.D W6, [W15++]
000332  F80032     PUSH DSRPAG
000334  F80034     PUSH DSWPAG
000336  200010     MOV #0x1, W0
000338  8801A0     MOV W0, DSWPAG
00033A  202000     MOV #0x200, W0
00033C  880190     MOV W0, DSRPAG
00033E  FA0004     LNK #0x4
225:                   char cChar;
226:                   portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
000340  EB0000     CLR W0
000342  980710     MOV W0, [W14+2]
227:               
228:                   /* Get the character and post it on the queue of Rxed characters.
229:                   If the post causes a task to wake force a context switch as the woken task
230:                   may have a higher priority than the task we have interrupted. */
231:                   _U3RXIF = serCLEAR_FLAG;
000344  A9408E     BCLR IFS5, #2
232:                   while (U3STAbits.URXDA) {
000346  37000A     BRA .L13
00035C  801290     MOV U3STA, W0
00035E  600061     AND W0, #0x1, W0
000360  E00000     CP0 W0
000362  3AFFF2     BRA NZ, .L14
233:                       cChar = U3RXREG;
000348  8012B0     MOV U3RXREG, W0
00034A  784000     MOV.B W0, W0
00034C  784F00     MOV.B W0, [W14]
234:                       xQueueSendFromISR(xRxedChars, &cChar, &xHigherPriorityTaskWoken);
00034E  8044C0     MOV xRxedChars, W0
000350  E8808E     INC2 W14, W1
000352  EB0180     CLR W3
000354  780101     MOV W1, W2
000356  78008E     MOV W14, W1
000358  0221F2     CALL xQueueGenericSendFromISR
00035A  000000     NOP
235:                   }
236:               
237:                   if (xHigherPriorityTaskWoken != pdFALSE) {
000364  90001E     MOV [W14+2], W0
000366  E00000     CP0 W0
000368  320003     BRA Z, .L12
238:                       taskYIELD();
00036A  0250DC     CALL .Letext0, .LFE1, _vPortYield
00036C  000000     NOP
00036E  000000     NOP
239:                   }
240:               }
000370  FA8000     ULNK
000372  F90034     POP DSWPAG
000374  F90032     POP DSRPAG
000376  BE034F     MOV.D [--W15], W6
000378  BE024F     MOV.D [--W15], W4
00037A  BE014F     MOV.D [--W15], W2
00037C  BE004F     MOV.D [--W15], W0
00037E  F90036     POP RCOUNT
000380  064000     RETFIE
241:               
242:               /*-----------------------------------------------------------*/
243:               
244:               void __attribute__((__interrupt__, auto_psv)) _U3TXInterrupt(void) {
000382  F80036     PUSH RCOUNT
000384  BE9F80     MOV.D W0, [W15++]
000386  BE9F82     MOV.D W2, [W15++]
000388  BE9F84     MOV.D W4, [W15++]
00038A  BE9F86     MOV.D W6, [W15++]
00038C  F80032     PUSH DSRPAG
00038E  F80034     PUSH DSWPAG
000390  200010     MOV #0x1, W0
000392  8801A0     MOV W0, DSWPAG
000394  202000     MOV #0x200, W0
000396  880190     MOV W0, DSRPAG
000398  FA0004     LNK #0x4
245:                   signed char cChar;
246:                   portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
00039A  EB0000     CLR W0
00039C  980710     MOV W0, [W14+2]
247:               
248:                   /* If the transmit buffer is full we cannot get the next character.
249:                   Another interrupt will occur the next time there is space so this does
250:                   not matter. */
251:                   _U3TXIF = serCLEAR_FLAG;
00039E  A9608E     BCLR IFS5, #3
252:                   while (!(U3STAbits.UTXBF)) {
0003A0  37000F     BRA .L17
0003C0  801291     MOV U3STA, W1
0003C2  202000     MOV #0x200, W0
0003C4  608000     AND W1, W0, W0
0003C6  E00000     CP0 W0
0003C8  32FFEC     BRA Z, .L20
253:                       if (xQueueReceiveFromISR(xCharsForTx, &cChar, &xHigherPriorityTaskWoken) == pdTRUE) {
0003A2  8044D0     MOV xCharsForTx, W0
0003A4  E8808E     INC2 W14, W1
0003A6  780101     MOV W1, W2
0003A8  78008E     MOV W14, W1
0003AA  0223F8     CALL xQueueReceiveFromISR
0003AC  000000     NOP
0003AE  500FE1     SUB W0, #0x1, [W15]
0003B0  3A0004     BRA NZ, .L18
254:                           /* Send the next character queued for Tx. */
255:                           U3TXREG = cChar;
0003B2  78401E     MOV.B [W14], W0
0003B4  FB0000     SE W0, W0
0003B6  8812A0     MOV W0, U3TXREG
0003B8  370003     BRA .L17
256:                       } else {
257:                           /* Queue empty, nothing to send. */
258:                           xTxHasEnded = pdTRUE;
0003BA  200010     MOV #0x1, W0
0003BC  8844E0     MOV W0, xTxHasEnded
259:                           break;
0003BE  370005     BRA .L19
260:                       }
261:                   }
262:               
263:                   if (xHigherPriorityTaskWoken != pdFALSE) {
0003CA  90001E     MOV [W14+2], W0
0003CC  E00000     CP0 W0
0003CE  320003     BRA Z, .L16
264:                       taskYIELD();
0003D0  0250DC     CALL .Letext0, .LFE1, _vPortYield
0003D2  000000     NOP
0003D4  000000     NOP
265:                   }
266:               }
0003D6  FA8000     ULNK
0003D8  F90034     POP DSWPAG
0003DA  F90032     POP DSRPAG
0003DC  BE034F     MOV.D [--W15], W6
0003DE  BE024F     MOV.D [--W15], W4
0003E0  BE014F     MOV.D [--W15], W2
0003E2  BE004F     MOV.D [--W15], W0
0003E4  F90036     POP RCOUNT
0003E6  064000     RETFIE
267:               
268:               void vSetUSER_Cop_CON(bool sta) {//UART3 485
0047CA  FA0002     LNK #0x2
0047CC  784F00     MOV.B W0, [W14]
269:                   _LATE6 = sta;
0047CE  FB801E     ZE [W14], W0
0047D0  600061     AND W0, #0x1, W0
0047D2  DD0046     SL W0, #6, W0
0047D4  801721     MOV LATE, W1
0047D6  A16001     BCLR W1, #6
0047D8  700001     IOR W0, W1, W0
0047DA  881720     MOV W0, LATE
270:               }
0047DC  FA8000     ULNK
0047DE  060000     RETURN
271:               
272:               
---  /home/zxc/Documents/WCGRTOS/Demo/App/PCF8583.c  ----------------------------------------------------
1:                 #include "PCF8583.h"
2:                 #include "I2C_S.h"
3:                 #include "Common.h"
4:                 #include "INT.h"
5:                 
6:                 
7:                 static sI2CDeviceAttribute sPCF8583;
8:                 
9:                 /*time around 2019 1 1 0:0:0 UTC*/
10:                volatile time_t tNowTimestamp = 1546272000; //every 24hour once upgrade 
11:                
12:                /*************************************
13:                Function: vPCF8583Init 
14:                Description: set INT0
15:                Input: void
16:                Output: void
17:                 *************************************/
18:                void vPCF8583Init(void) {
00375C  FA0000     LNK #0x0
19:                #ifndef Have_Initialized_I2C
20:                    vI2CInit();
00375E  023A2A     CALL vI2CInit
003760  000000     NOP
21:                #define Have_Initialized_I2C
22:                #endif 
23:                    INT0_Init();
003762  025130     CALL INT0_Init
003764  000000     NOP
24:                    SetPCFINT0Tris = 1; //RTCC INT0
003766  A8A2C9     BSET 0x2C9, #5
25:                    /*set PCF8583 time*/
26:                    vPCF8583SetTimeByTimestamp((time_t*) & tNowTimestamp);
003768  208A40     MOV #0x8A4, W0
00376A  07005A     RCALL vPCF8583SetTimeByTimestamp
27:                }
00376C  FA8000     ULNK
00376E  060000     RETURN
28:                
29:                /*************************************
30:                Function: vPCF8583SetTime
31:                Description: Set PCF Register to real time
32:                Input: stimes 
33:                Output: void
34:                 * ep: 
35:                 *  setarg = PCF_INIT_VALUE;
36:                    PCF8583_Write(PCF_CON_STA, &setarg, 1); //0x00    
37:                    PCF_Set_Time(settime); //
38:                    setarg = PCF_ALARM_VALUE;
39:                    PCF8583_Write(PCF_CON_ALARM, &setarg, 1); //0x08
40:                    PCF_Set_Alarm(settime, 0); //
41:                 *************************************/
42:                void vPCF8583SetTime(struct tm stimes) {
003770  FA0010     LNK #0x10
003772  781F88     MOV W8, [W15++]
43:                    /*Set 00h equal 0x85*/
44:                    unsigned char ucTmp[15];
45:                    /*set control status register*/
46:                    vPCF8583WriteRegister(PCF_CON_STA, PCF_INIT_VALUE);
003774  B3CCC1     MOV.B #0xCC, W1
003776  EB4000     CLR.B W0
003778  070121     RCALL vPCF8583WriteRegister
47:                    /*set 1/100s */
48:                    ucTmp[PCF_T_SEC_100] = 0x00;
00377A  EB4000     CLR.B W0
00377C  984710     MOV.B W0, [W14+1]
49:                    /*set seconds BCD*/
50:                    ucTmp[PCF_T_SEC] = DCH(stimes.tm_sec);
00377E  97B04E     MOV [W14-24], W0
003780  784000     MOV.B W0, W0
003782  022C82     CALL DCH
003784  000000     NOP
003786  984720     MOV.B W0, [W14+2]
51:                    /*set minutes */
52:                    ucTmp[PCF_T_MIN] = DCH(stimes.tm_min);
003788  97B05E     MOV [W14-22], W0
00378A  784000     MOV.B W0, W0
00378C  022C82     CALL DCH
00378E  000000     NOP
003790  984730     MOV.B W0, [W14+3]
53:                    /*set hour :format[7];am,pm[6];ten hour[4:5];unit hour[0:3]*/
54:                    ucTmp[PCF_T_HOUR] = (DCH(stimes.tm_hour) & 0x3F); //24hour
003792  97B06E     MOV [W14-20], W0
003794  784000     MOV.B W0, W0
003796  022C82     CALL DCH
003798  000000     NOP
00379A  B243F0     AND.B #0x3F, W0
00379C  984740     MOV.B W0, [W14+4]
55:                    /*set year and day:year[6:7];ten day[4:5];unit day[0-3]*/
56:                    ucTmp[PCF_T_DAY] = (GetMod(stimes.tm_year, 2) << 6) + (DCH(stimes.tm_mday) & 0x3F);
00379E  97B81E     MOV [W14-14], W0
0037A0  B3C021     MOV.B #0x2, W1
0037A2  022EAE     CALL GetMod
0037A4  000000     NOP
0037A6  200061     MOV #0x6, W1
0037A8  DD0401     SL W0, W1, W8
0037AA  97B07E     MOV [W14-18], W0
0037AC  784000     MOV.B W0, W0
0037AE  022C82     CALL DCH
0037B0  000000     NOP
0037B2  B243F0     AND.B #0x3F, W0
0037B4  444000     ADD.B W8, W0, W0
0037B6  984750     MOV.B W0, [W14+5]
57:                    /*set weekday and month:weekday[5:7;ten months[4];unit months[0-3] */
58:                    ucTmp[PCF_T_MONTH] = (DCH(stimes.tm_wday) << 5) + (DCH(stimes.tm_mon + 1) & 0x1F); //tm10
0037B8  97B82E     MOV [W14-12], W0
0037BA  784000     MOV.B W0, W0
0037BC  022C82     CALL DCH
0037BE  000000     NOP
0037C0  200051     MOV #0x5, W1
0037C2  DD0401     SL W0, W1, W8
0037C4  97B80E     MOV [W14-16], W0
0037C6  784000     MOV.B W0, W0
0037C8  E84000     INC.B W0, W0
0037CA  022C82     CALL DCH
0037CC  000000     NOP
0037CE  60407F     AND.B W0, #0x1F, W0
0037D0  444000     ADD.B W8, W0, W0
0037D2  984760     MOV.B W0, [W14+6]
59:                    /**/
60:                    ucTmp[7] = 0;
0037D4  EB4000     CLR.B W0
0037D6  984770     MOV.B W0, [W14+7]
61:                    /**/
62:                    ucTmp[PCF_CON_ALARM] = PCF_ALARM_VALUE; //0x90;
0037D8  B3C900     MOV.B #0x90, W0
0037DA  984F00     MOV.B W0, [W14+8]
63:                    /**/
64:                    ucTmp[PCF_A_SEC_100] = 00;
0037DC  EB4000     CLR.B W0
0037DE  984F10     MOV.B W0, [W14+9]
65:                    /**/
66:                    ucTmp[PCF_A_SEC] = 4; //GetMod(alarmtime, 30); 
0037E0  B3C040     MOV.B #0x4, W0
0037E2  984F20     MOV.B W0, [W14+10]
67:                    /**/
68:                    ucTmp[PCF_A_MIN] = 0; //GetMod(alarmtime / 30, 60); 
0037E4  EB4000     CLR.B W0
0037E6  984F30     MOV.B W0, [W14+11]
69:                    /**/
70:                    ucTmp[PCF_A_HOUR] = 0; //GetMod(alarmtime / 1800, 60); 
0037E8  EB4000     CLR.B W0
0037EA  984F40     MOV.B W0, [W14+12]
71:                    /**/
72:                    ucTmp[PCF_A_DAY] = ucTmp[PCF_A_MONTH] = 0;
0037EC  EB4000     CLR.B W0
0037EE  984F60     MOV.B W0, [W14+14]
0037F0  90486E     MOV.B [W14+14], W0
0037F2  984F50     MOV.B W0, [W14+13]
73:                
74:                    /*set PCF8583 atrribute*/
75:                    sPCF8583.ucSlaveAddress = PCF_ADD;
0037F4  21DB80     MOV #0x1DB8, W0
0037F6  B3CA01     MOV.B #0xA0, W1
0037F8  784801     MOV.B W1, [W0]
76:                    sPCF8583.usRegisterAddress = PCF_T_SEC_100;
0037FA  200010     MOV #0x1, W0
0037FC  88EDD0     MOV W0, 0x1DBA
77:                    sPCF8583.bIs16BitDevice = false;
0037FE  21DBC0     MOV #0x1DBC, W0
003800  EB4080     CLR.B W1
003802  784801     MOV.B W1, [W0]
78:                    sPCF8583.ucNeedDataBytes = PCF_A_MONTH - PCF_T_SEC_100 + 1;
003804  21DC00     MOV #0x1DC0, W0
003806  B3C0E1     MOV.B #0xE, W1
003808  784801     MOV.B W1, [W0]
79:                    sPCF8583.pucNeedData = ucTmp + PCF_T_SEC_100;
00380A  E8000E     INC W14, W0
00380C  88EDF0     MOV W0, 0x1DBE
80:                
81:                    /*write register*/
82:                    bI2CWriteSlave(&sPCF8583);
00380E  21DB80     MOV #0x1DB8, W0
003810  023B3E     CALL bI2CWriteSlave
003812  000000     NOP
83:                    /*start count*/
84:                    vPCF8583WriteRegister(PCF_CON_STA, PCF_START_VALUE);
003814  B3C0C1     MOV.B #0xC, W1
003816  EB4000     CLR.B W0
003818  0700D1     RCALL vPCF8583WriteRegister
85:                    /*if use rtos,enable tick interrupt*/
86:                }
00381A  78044F     MOV [--W15], W8
00381C  FA8000     ULNK
00381E  060000     RETURN
87:                
88:                /*************************************
89:                Function: vPCF8583SetTimeByTimestamp
90:                Description: set real time by timestamp
91:                Input: ultimestamp
92:                Output: void
93:                 * notice:1s2s
94:                 *************************************/
95:                void vPCF8583SetTimeByTimestamp(time_t* ultimestamp) {
003820  FA0014     LNK #0x14
003822  980F10     MOV W0, [W14+18]
96:                    struct tm stime_tmp;
97:                #ifdef TIME_ZONE
98:                    *ultimestamp += TIME_ZONE;
003824  90081E     MOV [W14+18], W0
003826  BE0110     MOV.D [W0], W2
003828  270800     MOV #0x7080, W0
00382A  200001     MOV #0x0, W1
00382C  400002     ADD W0, W2, W0
00382E  488083     ADDC W1, W3, W1
003830  90091E     MOV [W14+18], W2
003832  BE8900     MOV.D W0, [W2]
99:                #endif
100:                   /*timestamp convert stuct tm*/
101:                   stime_tmp = *gmtime((time_t*) ultimestamp);
003834  90081E     MOV [W14+18], W0
003836  020D42     CALL _gmtime
003838  000000     NOP
00383A  090008     REPEAT #0x8
00383C  781F30     MOV [W0++], [W14++]
00383E  B1012E     SUB #0x12, W14
003840  B10120     SUB #0x12, W0
102:                   /*set real time*/
103:                   vPCF8583SetTime(stime_tmp);
003842  4787F2     ADD W15, #0x12, W15
003844  578072     SUB W15, #0x12, W0
003846  090008     REPEAT #0x8
003848  78183E     MOV [W14++], [W0++]
00384A  B10120     SUB #0x12, W0
00384C  B1012E     SUB #0x12, W14
00384E  07FF90     RCALL vPCF8583SetTime
003850  5787F2     SUB W15, #0x12, W15
104:               }
003852  FA8000     ULNK
003854  060000     RETURN
105:               
106:               /*************************************
107:               Function: sPCF8583ReadTime
108:               Description: read real time ,output struct tm tpye varialbe
109:               Input: data 
110:               Output: is finish complete 
111:                *************************************/
112:               struct tm sPCF8583ReadTime(void) {
003856  FA001A     LNK #0x1A
003858  781F88     MOV W8, [W15++]
00385A  780400     MOV W0, W8
113:                   struct tm sReadTime;
114:                   unsigned char ucTmp[7] = {0, 0, 0, 0, 0, 0, 0};
00385C  4700F2     ADD W14, #0x12, W1
00385E  090002     REPEAT #0x2
003860  EB1880     CLR [W1++]
003862  EB5880     CLR.B [W1++]
115:                   /*set PCF atrribute*/
116:                   sPCF8583.ucSlaveAddress = PCF_ADD;
003864  21DB80     MOV #0x1DB8, W0
003866  B3CA01     MOV.B #0xA0, W1
003868  784801     MOV.B W1, [W0]
117:                   sPCF8583.usRegisterAddress = PCF_CON_STA;
00386A  EB0000     CLR W0
00386C  88EDD0     MOV W0, 0x1DBA
118:                   sPCF8583.bIs16BitDevice = false;
00386E  21DBC0     MOV #0x1DBC, W0
003870  EB4080     CLR.B W1
003872  784801     MOV.B W1, [W0]
119:                   sPCF8583.ucNeedDataBytes = 7;
003874  21DC00     MOV #0x1DC0, W0
003876  B3C071     MOV.B #0x7, W1
003878  784801     MOV.B W1, [W0]
120:                   sPCF8583.pucNeedData = ucTmp;
00387A  470072     ADD W14, #0x12, W0
00387C  88EDF0     MOV W0, 0x1DBE
121:               
122:                   /*read PCF8583 register*/
123:                   bI2CReadSlave(&sPCF8583);
00387E  21DB80     MOV #0x1DB8, W0
003880  023BD2     CALL bI2CReadSlave
003882  000000     NOP
124:               
125:                   /*get second*/
126:                   sReadTime.tm_sec = HCD(ucTmp[PCF_T_SEC]);
003884  90504E     MOV.B [W14+20], W0
003886  022C62     CALL HCD
003888  000000     NOP
00388A  FB8000     ZE W0, W0
00388C  780F00     MOV W0, [W14]
127:                   /*get min*/
128:                   sReadTime.tm_min = HCD(ucTmp[PCF_T_MIN]);
00388E  90505E     MOV.B [W14+21], W0
003890  022C62     CALL HCD
003892  000000     NOP
003894  FB8000     ZE W0, W0
003896  980710     MOV W0, [W14+2]
129:                   /*get hour*/
130:                   sReadTime.tm_hour = HCD(ucTmp[PCF_T_HOUR]&0x3F);
003898  90506E     MOV.B [W14+22], W0
00389A  B243F0     AND.B #0x3F, W0
00389C  022C62     CALL HCD
00389E  000000     NOP
0038A0  FB8000     ZE W0, W0
0038A2  980720     MOV W0, [W14+4]
131:                   /*get day*/
132:                   sReadTime.tm_mday = HCD(ucTmp[PCF_T_DAY]&0x3F);
0038A4  90507E     MOV.B [W14+23], W0
0038A6  B243F0     AND.B #0x3F, W0
0038A8  022C62     CALL HCD
0038AA  000000     NOP
0038AC  FB8000     ZE W0, W0
0038AE  980730     MOV W0, [W14+6]
133:                   /*get month*/
134:                   sReadTime.tm_mon = HCD(ucTmp[PCF_T_MONTH]&0x1F) - 1;
0038B0  90580E     MOV.B [W14+24], W0
0038B2  60407F     AND.B W0, #0x1F, W0
0038B4  022C62     CALL HCD
0038B6  000000     NOP
0038B8  FB8000     ZE W0, W0
0038BA  E90000     DEC W0, W0
0038BC  980740     MOV W0, [W14+8]
135:                   /*get year 2016E2ROM*/
136:                   sReadTime.tm_year = ucTmp[PCF_T_DAY] >> 6;
0038BE  90507E     MOV.B [W14+23], W0
0038C0  FB8000     ZE W0, W0
0038C2  DE0046     LSR W0, #6, W0
0038C4  784000     MOV.B W0, W0
0038C6  FB8000     ZE W0, W0
0038C8  980750     MOV W0, [W14+10]
137:                   return sReadTime;
0038CA  090008     REPEAT #0x8
0038CC  781C3E     MOV [W14++], [W8++]
0038CE  B10128     SUB #0x12, W8
0038D0  B1012E     SUB #0x12, W14
138:               }
0038D2  780008     MOV W8, W0
0038D4  78044F     MOV [--W15], W8
0038D6  FA8000     ULNK
0038D8  060000     RETURN
139:               
140:               /*************************************
141:               Function: tPCF8583ReadTime 
142:               Description: read real time
143:               Input: void  
144:               Output: time_t
145:                *************************************/
146:               time_t tPCF8583ReadTime(void) {
0038DA  FA003A     LNK #0x3A
147:                   struct tm sReadTime, sNowTime;
148:                   time_t tReadTime;
149:                   /*read real time ,output struct time type*/
150:                   sReadTime = sPCF8583ReadTime();
0038DC  200280     MOV #0x28, W0
0038DE  40000E     ADD W0, W14, W0
0038E0  07FFBA     RCALL sPCF8583ReadTime
0038E2  4700E4     ADD W14, #0x4, W1
0038E4  200282     MOV #0x28, W2
0038E6  470102     ADD W14, W2, W2
0038E8  090008     REPEAT #0x8
0038EA  7818B2     MOV [W2++], [W1++]
151:                   sReadTime.tm_yday = 0;
0038EC  EB0000     CLR W0
0038EE  980F10     MOV W0, [W14+18]
152:                   sReadTime.tm_wday = 0;
0038F0  EB0000     CLR W0
0038F2  980F00     MOV W0, [W14+16]
153:                   sReadTime.tm_isdst = 0;
0038F4  EB0000     CLR W0
0038F6  980F20     MOV W0, [W14+20]
154:                   /*get time struct*/
155:                   sNowTime = *gmtime((time_t *) & tNowTimestamp);
0038F8  208A40     MOV #0x8A4, W0
0038FA  020D42     CALL _gmtime
0038FC  000000     NOP
0038FE  4700F6     ADD W14, #0x16, W1
003900  090008     REPEAT #0x8
003902  7818B0     MOV [W0++], [W1++]
003904  B10120     SUB #0x12, W0
156:                   /*claculate year*/
157:                   sReadTime.tm_year = sNowTime.tm_year; //OffsetYear;
003906  90100E     MOV [W14+32], W0
003908  980770     MOV W0, [W14+14]
158:                   /*struct time to timeStampe*/
159:                   tReadTime = mktime(&sReadTime);
00390A  470064     ADD W14, #0x4, W0
00390C  020F56     CALL _mktime
00390E  000000     NOP
003910  BE8F00     MOV.D W0, [W14]
160:                   Nop();
003912  000000     NOP
161:                   return tReadTime;
003914  BE001E     MOV.D [W14], W0
162:               }
003916  FA8000     ULNK
003918  060000     RETURN
163:               
164:               /*************************************
165:               Function: vPCF8583SetAlarmTime
166:               Description: Set alarm
167:               Input: sAlarmTime
168:               Output: void
169:                *************************************/
170:               void vPCF8583SetAlarmTime(struct tm sAlarmTime) {
00391A  FA0008     LNK #0x8
00391C  781F88     MOV W8, [W15++]
171:                   unsigned char ucTemp[6];
172:                   unsigned char ucOffset;
173:               
174:                   /*Calc offset*/
175:                   ucOffset = 0;
00391E  EB4000     CLR.B W0
003920  784F00     MOV.B W0, [W14]
176:                   /*set alarm 10ms*/
177:                   ucTemp[ucOffset++] = 0;
003922  FB801E     ZE [W14], W0
003924  470000     ADD W14, W0, W0
003926  EB4080     CLR.B W1
003928  984011     MOV.B W1, [W0+1]
00392A  E84F1E     INC.B [W14], [W14]
178:                   /*set alarm seconds */
179:                   ucTemp[ucOffset++] = DCH(sAlarmTime.tm_sec);
00392C  FB841E     ZE [W14], W8
00392E  97B04E     MOV [W14-24], W0
003930  784000     MOV.B W0, W0
003932  022C82     CALL DCH
003934  000000     NOP
003936  470088     ADD W14, W8, W1
003938  984090     MOV.B W0, [W1+1]
00393A  E84F1E     INC.B [W14], [W14]
180:                   /*set alarm minute */
181:                   ucTemp[ucOffset++] = DCH(sAlarmTime.tm_min);
00393C  FB841E     ZE [W14], W8
00393E  97B05E     MOV [W14-22], W0
003940  784000     MOV.B W0, W0
003942  022C82     CALL DCH
003944  000000     NOP
003946  470088     ADD W14, W8, W1
003948  984090     MOV.B W0, [W1+1]
00394A  E84F1E     INC.B [W14], [W14]
182:                   /*set alarm hour */
183:                   ucTemp[ucOffset++] = DCH(sAlarmTime.tm_hour);
00394C  FB841E     ZE [W14], W8
00394E  97B06E     MOV [W14-20], W0
003950  784000     MOV.B W0, W0
003952  022C82     CALL DCH
003954  000000     NOP
003956  470088     ADD W14, W8, W1
003958  984090     MOV.B W0, [W1+1]
00395A  E84F1E     INC.B [W14], [W14]
184:                   /*set alarm day and month */
185:                   ucTemp[ucOffset++] = 0;
00395C  FB801E     ZE [W14], W0
00395E  470000     ADD W14, W0, W0
003960  EB4080     CLR.B W1
003962  984011     MOV.B W1, [W0+1]
003964  E84F1E     INC.B [W14], [W14]
186:                   ucTemp[ucOffset] = 0;
003966  FB801E     ZE [W14], W0
003968  470000     ADD W14, W0, W0
00396A  EB4080     CLR.B W1
00396C  984011     MOV.B W1, [W0+1]
187:               
188:                   sPCF8583.ucSlaveAddress = PCF_ADD;
00396E  21DB80     MOV #0x1DB8, W0
003970  B3CA01     MOV.B #0xA0, W1
003972  784801     MOV.B W1, [W0]
189:                   sPCF8583.usRegisterAddress = PCF_A_SEC_100;
003974  200090     MOV #0x9, W0
003976  88EDD0     MOV W0, 0x1DBA
190:                   sPCF8583.bIs16BitDevice = false;
003978  21DBC0     MOV #0x1DBC, W0
00397A  EB4080     CLR.B W1
00397C  784801     MOV.B W1, [W0]
191:                   sPCF8583.pucNeedData = ucTemp;
00397E  E8000E     INC W14, W0
003980  88EDF0     MOV W0, 0x1DBE
192:                   sPCF8583.ucNeedDataBytes = 6;
003982  21DC00     MOV #0x1DC0, W0
003984  B3C061     MOV.B #0x6, W1
003986  784801     MOV.B W1, [W0]
193:                   /*set alarm time*/
194:                   bI2CWriteSlave(&sPCF8583);
003988  21DB80     MOV #0x1DB8, W0
00398A  023B3E     CALL bI2CWriteSlave
00398C  000000     NOP
195:                   /*for test*/
196:                   Nop();
00398E  000000     NOP
197:               }
003990  78044F     MOV [--W15], W8
003992  FA8000     ULNK
003994  060000     RETURN
198:               
199:               /*************************************
200:               Function: vPCF8583SetAlarmTimeByTimestamp
201:               Description: set alarm by timestamp
202:               Input: tSetAlarmTimestamp
203:               Output: void 
204:                *************************************/
205:               void vPCF8583SetAlarmTimeByTimestamp(time_t *tSetAlarmTimestamp) {
003996  FA0014     LNK #0x14
003998  980F10     MOV W0, [W14+18]
206:                   struct tm sSetTime;
207:               
208:                   /*get time struct*/
209:                   sSetTime = *gmtime(tSetAlarmTimestamp);
00399A  90081E     MOV [W14+18], W0
00399C  020D42     CALL _gmtime
00399E  000000     NOP
0039A0  090008     REPEAT #0x8
0039A2  781F30     MOV [W0++], [W14++]
0039A4  B1012E     SUB #0x12, W14
0039A6  B10120     SUB #0x12, W0
210:                   /*set alarm time*/
211:                   vPCF8583SetAlarmTime(sSetTime);
0039A8  4787F2     ADD W15, #0x12, W15
0039AA  578072     SUB W15, #0x12, W0
0039AC  090008     REPEAT #0x8
0039AE  78183E     MOV [W14++], [W0++]
0039B0  B10120     SUB #0x12, W0
0039B2  B1012E     SUB #0x12, W14
0039B4  07FFB2     RCALL vPCF8583SetAlarmTime
0039B6  5787F2     SUB W15, #0x12, W15
212:               }
0039B8  FA8000     ULNK
0039BA  060000     RETURN
213:               
214:               /*************************************
215:               Function: vPCF8583WriteRegister 
216:               Description: Write data to I2C device
217:               Input: data 
218:               Output: is finish complete 
219:                *************************************/
220:               void vPCF8583WriteRegister(unsigned char ucRegisterAddress, unsigned char ucRegisterContext) {//
0039BC  FA0004     LNK #0x4
0039BE  984720     MOV.B W0, [W14+2]
0039C0  984731     MOV.B W1, [W14+3]
221:                   unsigned char ucControlStatusRegister = ucRegisterContext;
0039C2  9040BE     MOV.B [W14+3], W1
0039C4  784F01     MOV.B W1, [W14]
222:               
223:                   /*set PCF8583 attribute*/
224:                   sPCF8583.ucSlaveAddress = PCF_ADD;
0039C6  21DB80     MOV #0x1DB8, W0
0039C8  B3CA01     MOV.B #0xA0, W1
0039CA  784801     MOV.B W1, [W0]
225:                   sPCF8583.usRegisterAddress = ucRegisterAddress;
0039CC  90402E     MOV.B [W14+2], W0
0039CE  FB8000     ZE W0, W0
0039D0  88EDD0     MOV W0, 0x1DBA
226:                   sPCF8583.bIs16BitDevice = false;
0039D2  21DBC0     MOV #0x1DBC, W0
0039D4  EB4080     CLR.B W1
0039D6  784801     MOV.B W1, [W0]
227:                   sPCF8583.ucNeedDataBytes = 1;
0039D8  21DC00     MOV #0x1DC0, W0
0039DA  B3C011     MOV.B #0x1, W1
0039DC  784801     MOV.B W1, [W0]
228:                   sPCF8583.pucNeedData = &ucControlStatusRegister;
0039DE  88EDFE     MOV W14, 0x1DBE
229:                   /*read PCF8583 register*/
230:                   bI2CWriteSlave(&sPCF8583);
0039E0  21DB80     MOV #0x1DB8, W0
0039E2  023B3E     CALL bI2CWriteSlave
0039E4  000000     NOP
231:               }
0039E6  FA8000     ULNK
0039E8  060000     RETURN
232:               
233:               /*************************************
234:               Function: vPCF8583ReadStatus 
235:               Description: read data to I2C device
236:               Input: ucRegisterAddress 
237:               Output: register data
238:                *************************************/
239:               unsigned char ucPCF8583ReadRegister(unsigned char ucRegisterAddress) {
0039EA  FA0004     LNK #0x4
0039EC  984720     MOV.B W0, [W14+2]
240:                   unsigned char ucControlStatusRegister;
241:               
242:                   /*set PCF8585 attribute*/
243:                   sPCF8583.ucSlaveAddress = PCF_ADD;
0039EE  21DB80     MOV #0x1DB8, W0
0039F0  B3CA01     MOV.B #0xA0, W1
0039F2  784801     MOV.B W1, [W0]
244:                   sPCF8583.usRegisterAddress = ucRegisterAddress;
0039F4  90402E     MOV.B [W14+2], W0
0039F6  FB8000     ZE W0, W0
0039F8  88EDD0     MOV W0, 0x1DBA
245:                   sPCF8583.bIs16BitDevice = false;
0039FA  21DBC0     MOV #0x1DBC, W0
0039FC  EB4080     CLR.B W1
0039FE  784801     MOV.B W1, [W0]
246:                   sPCF8583.ucNeedDataBytes = 1;
003A00  21DC00     MOV #0x1DC0, W0
003A02  B3C011     MOV.B #0x1, W1
003A04  784801     MOV.B W1, [W0]
247:                   sPCF8583.pucNeedData = &ucControlStatusRegister;
003A06  88EDFE     MOV W14, 0x1DBE
248:                   /*read PCF8583 register*/
249:                   bI2CReadSlave(&sPCF8583);
003A08  21DB80     MOV #0x1DB8, W0
003A0A  023BD2     CALL bI2CReadSlave
003A0C  000000     NOP
250:                   return ucControlStatusRegister;
003A0E  78401E     MOV.B [W14], W0
251:               }
003A10  FA8000     ULNK
003A12  060000     RETURN
252:               
253:               
---  /home/zxc/Documents/WCGRTOS/Demo/App/LED.c  --------------------------------------------------------
1:                 /*
2:                  * File:   LED.c
3:                  * Author: zw
4:                  *
5:                  * Created on 201918, 2:50
6:                  */
7:                 #include "LED.h"
8:                 
9:                 
10:                #if  (UseFreeRTOS == 0)
11:                
12:                /*************************************
13:                Function: vDelay100ms
14:                Description: 100ms
15:                Input: 
16:                Output: 
17:                 *************************************/
18:                static void vDelay100ms(unsigned int usDelay100ms) {//100ms
19:                    unsigned int usCount;
20:                
21:                    while (usDelay100ms-- > 0)
22:                        for (usCount = 0; usCount < DELAY100MS; usCount++)
23:                            Nop();
24:                }
25:                #else
26:                #include "FreeRTOS.h"
27:                #include "task.h"
28:                #endif
29:                
30:                /*************************************
31:                Function: vLEDInit
32:                Description: initialization LED IO
33:                Input: 
34:                Output: 
35:                 *************************************/
36:                void vLEDInit(void) {//LATBbits.LATB15=1
004E66  FA0000     LNK #0x0
37:                    /*set led light*/
38:                    LEDGreenTRIS = 0;
004E68  A9A2E0     BCLR TRISE, #5
39:                    LEDRedTRIS = 0;
004E6A  A9E2E0     BCLR TRISE, #7
40:                }
004E6C  FA8000     ULNK
004E6E  060000     RETURN
41:                
42:                /*************************************
43:                Function: vLEDHandle
44:                Description: handle led
45:                Input: ucLEDIO,which LED ;bLEDSta:high:lignt;low:dark
46:                Output: 
47:                 *************************************/
48:                void vLEDHandle(unsigned char ucLEDIO, bool bLEDSta) {//LATBbits.LATB15=1
004E70  FA0002     LNK #0x2
004E72  784F00     MOV.B W0, [W14]
004E74  984711     MOV.B W1, [W14+1]
49:                    /*set led light*/
50:                    switch (ucLEDIO) {
004E76  FB801E     ZE [W14], W0
004E78  500FE2     SUB W0, #0x2, [W15]
004E7A  32000D     BRA Z, .L5
004E7C  500FE3     SUB W0, #0x3, [W15]
004E7E  320014     BRA Z, .L6
004E80  500FE1     SUB W0, #0x1, [W15]
004E82  3A0023     BRA NZ, .L2
51:                            /*only Green led*/
52:                        case 1:
53:                        {
54:                            LEDGreenLAT = bLEDSta;
004E84  90401E     MOV.B [W14+1], W0
004E86  FB8000     ZE W0, W0
004E88  600061     AND W0, #0x1, W0
004E8A  DD0045     SL W0, #5, W0
004E8C  801721     MOV LATE, W1
004E8E  A15001     BCLR W1, #5
004E90  700001     IOR W0, W1, W0
004E92  881720     MOV W0, LATE
55:                            break;
004E94  37001A     BRA .L2
56:                        }
57:                            /*only Red led*/
58:                        case 2:
59:                        {
60:                            LEDRedLAT = bLEDSta;
004E96  90401E     MOV.B [W14+1], W0
004E98  FB8000     ZE W0, W0
004E9A  600061     AND W0, #0x1, W0
004E9C  DD0047     SL W0, #7, W0
004E9E  801721     MOV LATE, W1
004EA0  A17001     BCLR W1, #7
004EA2  700001     IOR W0, W1, W0
004EA4  881720     MOV W0, LATE
61:                            break;
004EA6  370011     BRA .L2
62:                        }
63:                            /*only both led*/
64:                        case 3:
65:                        {
66:                            LEDGreenLAT = bLEDSta;
004EA8  90401E     MOV.B [W14+1], W0
004EAA  FB8000     ZE W0, W0
004EAC  600061     AND W0, #0x1, W0
004EAE  DD0045     SL W0, #5, W0
004EB0  801721     MOV LATE, W1
004EB2  A15001     BCLR W1, #5
004EB4  700001     IOR W0, W1, W0
004EB6  881720     MOV W0, LATE
67:                            LEDRedLAT = bLEDSta;
004EB8  90401E     MOV.B [W14+1], W0
004EBA  FB8000     ZE W0, W0
004EBC  600061     AND W0, #0x1, W0
004EBE  DD0047     SL W0, #7, W0
004EC0  801721     MOV LATE, W1
004EC2  A17001     BCLR W1, #7
004EC4  700001     IOR W0, W1, W0
004EC6  881720     MOV W0, LATE
68:                            break;
004EC8  000000     NOP
69:                        }
70:                    }
71:                }
004ECA  FA8000     ULNK
004ECC  060000     RETURN
72:                
73:                /*************************************
74:                Function: vLEDShark
75:                Description: LED
76:                Input: 
77:                Output: 
78:                 *************************************/
79:                void vLEDShark(unsigned char ucLEDIO,
80:                        unsigned int usLedOnTimeMs,
81:                        unsigned int usLedOffTimeMs,
82:                        unsigned char ucSharkCnt) {
004ECE  FA000A     LNK #0xA
004ED0  984720     MOV.B W0, [W14+2]
004ED2  980721     MOV W1, [W14+4]
004ED4  980732     MOV W2, [W14+6]
004ED6  984F03     MOV.B W3, [W14+8]
83:                    unsigned char ucCount;
84:                    for (ucCount = 0; ucCount < ucSharkCnt; ucCount++) {
004ED8  EB4000     CLR.B W0
004EDA  784F00     MOV.B W0, [W14]
004EDC  370012     BRA .L8
004F00  E84F1E     INC.B [W14], [W14]
004F02  90480E     MOV.B [W14+8], W0
004F04  78409E     MOV.B [W14], W1
004F06  50CF80     SUB.B W1, W0, [W15]
004F08  39FFEA     BRA NC, .L10
85:                        /*always in shark*/
86:                        if (ucSharkCnt == 255)
004EDE  90480E     MOV.B [W14+8], W0
004EE0  404FE1     ADD.B W0, #0x1, [W15]
004EE2  3A0002     BRA NZ, .L9
87:                            ucSharkCnt = 0;
004EE4  EB4000     CLR.B W0
004EE6  984F00     MOV.B W0, [W14+8]
88:                        /*set led light*/
89:                        vLEDHandle(ucLEDIO, 1);
004EE8  B3C011     MOV.B #0x1, W1
004EEA  90402E     MOV.B [W14+2], W0
004EEC  07FFC1     RCALL vLEDHandle
90:                #if (UseFreeRTOS==1)
91:                        vTaskDelay(usLedOnTimeMs);
004EEE  90002E     MOV [W14+4], W0
004EF0  021398     CALL vTaskDelay
004EF2  000000     NOP
92:                #else
93:                        vDelay100ms(usLedOnTimeMs);
94:                #endif
95:                        /*Set led dark*/
96:                        vLEDHandle(ucLEDIO, 0);
004EF4  EB4080     CLR.B W1
004EF6  90402E     MOV.B [W14+2], W0
004EF8  07FFBB     RCALL vLEDHandle
97:                #if (UseFreeRTOS==1)
98:                        vTaskDelay(usLedOffTimeMs);
004EFA  90003E     MOV [W14+6], W0
004EFC  021398     CALL vTaskDelay
004EFE  000000     NOP
99:                #else
100:                       vDelay100ms(usLedOffTimeMs);
101:               #endif
102:                   }
103:               }
004F0A  FA8000     ULNK
004F0C  060000     RETURN
104:               
---  /home/zxc/Documents/WCGRTOS/Demo/App/KEY.c  --------------------------------------------------------
1:                 /*
2:                  * File:   KEY.c
3:                  * Author: zw
4:                  *
5:                  * Created on 2019110, 2:36
6:                  */
7:                 
8:                 #include "KEY.h"
9:                 
10:                #if (UseFreeRTOSInKey == 1)
11:                #include "FreeRTOS.h"
12:                #include "semphr.h"
13:                extern xSemaphoreHandle xSemBinKey;
14:                #endif
15:                
16:                /*************************************
17:                Function: vDelay10ms
18:                Description: 10ms
19:                Input: 
20:                Output: 
21:                 *************************************/
22:                static void vKeyDelay10ms(unsigned int usDelay10ms) {
0044D6  FA0004     LNK #0x4
0044D8  980710     MOV W0, [W14+2]
23:                    unsigned int usConut;
24:                    while (usDelay10ms-- > 0)
0044DA  370009     BRA .L2
0044EE  90001E     MOV [W14+2], W0
0044F0  A7F000     BTSC W0, #15
0044F2  EA0000     NEG W0, W0
0044F4  EA0000     NEG W0, W0
0044F6  DE004F     LSR W0, #15, W0
0044F8  784000     MOV.B W0, W0
0044FA  90009E     MOV [W14+2], W1
0044FC  E90081     DEC W1, W1
0044FE  980711     MOV W1, [W14+2]
004500  E00400     CP0.B W0
004502  3AFFEC     BRA NZ, .L5
25:                        for (usConut = 0; usConut < DELAY10MS; usConut++)
0044DC  EB0000     CLR W0
0044DE  780F00     MOV W0, [W14]
0044E0  370002     BRA .L3
0044E4  E80F1E     INC [W14], [W14]
0044E6  2109A0     MOV #0x109A, W0
0044E8  78009E     MOV [W14], W1
0044EA  508F80     SUB W1, W0, [W15]
0044EC  36FFFA     BRA LEU, .L4
26:                            Nop();
0044E2  000000     NOP
27:                }
004504  FA8000     ULNK
004506  060000     RETURN
28:                
29:                /*************************************
30:                Function: vDelay100ms
31:                Description: 100ms
32:                Input: 
33:                Output: 
34:                 *************************************/
35:                /*static void vKeyDelay100ms(unsigned int usDelay100ms) {
36:                    unsigned int usConut;
37:                    while (usDelay100ms-- > 0)
38:                        for (usConut = 0; usConut < DELAY100MS; usConut++)
39:                            Nop();
40:                }*/
41:                
42:                #if  (UseKeyInterrupt == 1)
43:                
44:                /*************************************
45:                Function: vIOCInit
46:                Description: key interrupt initialization
47:                Input: void 
48:                Output: void
49:                 *************************************/
50:                void vKeyInterruptInit(void) {
004508  FA0000     LNK #0x0
51:                    _CN14PUE = 1;
00450A  A8C06F     BSET 0x6F, #6
52:                    _CN15PUE = 1;
00450C  A8E06F     BSET 0x6F, #7
53:                    _CN16PUE = 1;
00450E  A80070     BSET CNPU2, #0
54:                    _CN14IE = 1;
004510  A8C063     BSET 0x63, #6
55:                    _CN15IE = 1;
004512  A8E063     BSET 0x63, #7
56:                    _CN16IE = 1;
004514  A80064     BSET CNEN2, #0
57:                    /*freertos priority is 2*/
58:                    _CNIP = 1;
004516  800561     MOV IPC4, W1
004518  28FFF0     MOV #0x8FFF, W0
00451A  608000     AND W1, W0, W0
00451C  A0C000     BSET W0, #12
00451E  880560     MOV W0, IPC4
59:                    /**/
60:                    _CNIF = 0;
004520  A96086     BCLR IFS1, #3
61:                    _CNIE = 1;
004522  A86096     BSET IEC1, #3
62:                }
004524  FA8000     ULNK
004526  060000     RETURN
63:                #endif 
64:                
65:                #if (UseKeyInterrupt == 1)
66:                
67:                /*************************************
68:                Function: IOC
69:                Description: 
70:                Input: void 
71:                Output: void
72:                 *************************************/
73:                
74:                void __attribute__((interrupt, no_auto_psv)) _CNInterrupt(void) {
0003E8  F80036     PUSH RCOUNT
0003EA  BE9F80     MOV.D W0, [W15++]
0003EC  BE9F82     MOV.D W2, [W15++]
0003EE  BE9F84     MOV.D W4, [W15++]
0003F0  BE9F86     MOV.D W6, [W15++]
0003F2  FA0002     LNK #0x2
75:                #if (UseFreeRTOSInKey == 1)
76:                    BaseType_t xHigherPriorityTaskWoken = pdFALSE;
0003F4  EB0000     CLR W0
0003F6  780F00     MOV W0, [W14]
77:                #else
78:                    unsigned char ucKeyState;
79:                #endif
80:                    if (!ReadKey1State | !ReadKey2State | !ReadKey3State)
0003F8  8016D1     MOV PORTD, W1
0003FA  200800     MOV #0x80, W0
0003FC  608000     AND W1, W0, W0
0003FE  A7F000     BTSC W0, #15
000400  EA0000     NEG W0, W0
000402  E90000     DEC W0, W0
000404  DE004F     LSR W0, #15, W0
000406  784080     MOV.B W0, W1
000408  8016D2     MOV PORTD, W2
00040A  200400     MOV #0x40, W0
00040C  610000     AND W2, W0, W0
00040E  A7F000     BTSC W0, #15
000410  EA0000     NEG W0, W0
000412  E90000     DEC W0, W0
000414  DE004F     LSR W0, #15, W0
000416  784000     MOV.B W0, W0
000418  70C000     IOR.B W1, W0, W0
00041A  FB8080     ZE W0, W1
00041C  8016D2     MOV PORTD, W2
00041E  200200     MOV #0x20, W0
000420  610000     AND W2, W0, W0
000422  A7F000     BTSC W0, #15
000424  EA0000     NEG W0, W0
000426  E90000     DEC W0, W0
000428  DE004F     LSR W0, #15, W0
00042A  700001     IOR W0, W1, W0
00042C  E00000     CP0 W0
00042E  320004     BRA Z, .L8
81:                #if (UseFreeRTOSInKey == 1)    
82:                        xSemaphoreGiveFromISR(xSemBinKey, &xHigherPriorityTaskWoken);
000430  804430     MOV xSemBinKey, W0
000432  78008E     MOV W14, W1
000434  022266     CALL xQueueGiveFromISR
000436  000000     NOP
83:                    //        portYIELD_WITHIN_API(xHigherPriorityTaskWoken);
84:                #else
85:                        vKeyScan(&ucKeyState);
86:                #endif         
87:                    _CNIF = 0; //;
000438  A96086     BCLR IFS1, #3
88:                }
00043A  FA8000     ULNK
00043C  BE034F     MOV.D [--W15], W6
00043E  BE024F     MOV.D [--W15], W4
000440  BE014F     MOV.D [--W15], W2
000442  BE004F     MOV.D [--W15], W0
000444  F90036     POP RCOUNT
000446  064000     RETFIE
89:                #endif 
90:                
91:                /*************************************
92:                Function: vKeyInit
93:                Description: IO
94:                Input:  
95:                Output: 
96:                 *************************************/
97:                void vKeyInit(void) {
004528  FA0000     LNK #0x0
98:                    /*key1*/
99:                    SetKey1ANS = 0;
00452A  A9E4E6     BCLR ANSD, #7
100:                   /*key1*/
101:                   SetKey1Tris = 1;
00452C  A8E2D8     BSET TRISD, #7
102:                   /*key2*/
103:                   SetKey2ANS = 0;
00452E  A9C4E6     BCLR ANSD, #6
104:                   /*key2*/
105:                   SetKey2Tris = 1;
004530  A8C2D8     BSET TRISD, #6
106:                   //    /*key3*/
107:                   //    SetKey3ANS = 0;
108:                   /*key3*/
109:                   SetKey3Tris = 1;
110:               #if (UseKeyInterrupt == 1)
111:                   /*IOC*/
112:                   vKeyInterruptInit();
004532  A8A2D8     BSET TRISD, #5
004534  07FFE9     RCALL vKeyInterruptInit
113:               #endif 
114:               }
004536  FA8000     ULNK
004538  060000     RETURN
115:               
116:               /*************************************
117:               Function: usReadKeyIO
118:               Description: read key IO
119:               Input:  
120:               Output:key IO Port
121:                *************************************/
122:               static unsigned int usReadKeyIO(void) {
00453A  FA0000     LNK #0x0
123:                   return (ReadKey1State || (ReadKey2State << 1) || (ReadKey3State << 2));
00453C  8016D1     MOV PORTD, W1
00453E  200800     MOV #0x80, W0
004540  608000     AND W1, W0, W0
004542  E00000     CP0 W0
004544  3A000E     BRA NZ, .L11
004546  8016D0     MOV PORTD, W0
004548  DE0046     LSR W0, #6, W0
00454A  604061     AND.B W0, #0x1, W0
00454C  FB8000     ZE W0, W0
00454E  400000     ADD W0, W0, W0
004550  E00000     CP0 W0
004552  3A0007     BRA NZ, .L11
004554  8016D0     MOV PORTD, W0
004556  DE0045     LSR W0, #5, W0
004558  604061     AND.B W0, #0x1, W0
00455A  FB8000     ZE W0, W0
00455C  DD0042     SL W0, #2, W0
00455E  E00000     CP0 W0
004560  320002     BRA Z, .L12
004562  200010     MOV #0x1, W0
004564  370001     BRA .L13
004566  EB0000     CLR W0
124:               }
004568  FA8000     ULNK
00456A  060000     RETURN
125:               
126:               /*************************************
127:               Function: vKeyScan
128:               Description: 
129:               Input:  
130:               Output:
131:                *************************************/
132:               void vKeyScan(void* vKeyState) {
00456C  FA0008     LNK #0x8
00456E  980730     MOV W0, [W14+6]
133:                   unsigned char ucKeyState = InvalidKEY;
004570  B3C020     MOV.B #0x2, W0
004572  784F00     MOV.B W0, [W14]
134:                   unsigned char ucCount = 0;
004574  EB4000     CLR.B W0
135:                   unsigned int usKeyIOCurrent, usKeyIONext;
136:               
137:                   usKeyIOCurrent = usReadKeyIO();
004576  984710     MOV.B W0, [W14+1]
004578  07FFE0     RCALL _usReadKeyIO, .LFE3, .LFB4
00457A  980710     MOV W0, [W14+2]
138:                   if (usKeyIOCurrent) {
00457C  90001E     MOV [W14+2], W0
00457E  E00000     CP0 W0
004580  320031     BRA Z, .L15
139:                       /**/
140:                       vKeyDelay10ms(1);
004582  200010     MOV #0x1, W0
141:                       /*check key is really push*/
142:                       usKeyIOCurrent = usReadKeyIO();
004584  07FFA8     RCALL _vKeyDelay10ms, .Ltext0, .LFB0, .Letext0, .LFE8
004586  07FFD9     RCALL _usReadKeyIO, .LFE3, .LFB4
004588  980710     MOV W0, [W14+2]
143:                       if (usKeyIOCurrent) {
00458A  90001E     MOV [W14+2], W0
00458C  E00000     CP0 W0
00458E  320014     BRA Z, .L16
144:                           for (ucCount = 0; ucCount < 200; ucCount++) {
004590  EB4000     CLR.B W0
004592  984710     MOV.B W0, [W14+1]
004594  37000B     BRA .L17
0045A6  90401E     MOV.B [W14+1], W0
0045A8  E84000     INC.B W0, W0
0045AA  984710     MOV.B W0, [W14+1]
0045AC  90409E     MOV.B [W14+1], W1
0045AE  B3CC70     MOV.B #0xC7, W0
0045B0  50CF80     SUB.B W1, W0, [W15]
0045B2  36FFF1     BRA LEU, .L19
0045B4  370001     BRA .L16
145:                               vKeyDelay10ms(1);
004596  200010     MOV #0x1, W0
146:                               usKeyIONext = usReadKeyIO();
004598  07FF9E     RCALL _vKeyDelay10ms, .Ltext0, .LFB0, .Letext0, .LFE8
00459A  07FFCF     RCALL _usReadKeyIO, .LFE3, .LFB4
00459C  980720     MOV W0, [W14+4]
147:                               if (usKeyIONext != usKeyIOCurrent) {
00459E  9000AE     MOV [W14+4], W1
0045A0  90001E     MOV [W14+2], W0
0045A2  508F80     SUB W1, W0, [W15]
0045A4  3A0008     BRA NZ, .L22
148:                                   break;
0045B6  000000     NOP
149:                               }
150:                               /*for*/
151:                           }
152:                           /*end if (usKeyIOCurrent)*/
153:                       }
154:               
155:                       if (ucCount >= 200) {
0045B8  90409E     MOV.B [W14+1], W1
0045BA  B3CC70     MOV.B #0xC7, W0
0045BC  50CF80     SUB.B W1, W0, [W15]
0045BE  360005     BRA LEU, .L20
156:                           ucKeyState = (LongKEY << 6) | usKeyIOCurrent;
0045C0  90001E     MOV [W14+2], W0
0045C2  784080     MOV.B W0, W1
0045C4  B3CC00     MOV.B #0xC0, W0
0045C6  70CF00     IOR.B W1, W0, [W14]
0045C8  37000D     BRA .L15
157:                       } else if (ucCount > 20) {
0045CA  90401E     MOV.B [W14+1], W0
0045CC  504FF4     SUB.B W0, #0x14, [W15]
0045CE  360006     BRA LEU, .L21
158:                           ucKeyState = (ShortKEY << 6) | usKeyIOCurrent;
0045D0  90001E     MOV [W14+2], W0
0045D2  784000     MOV.B W0, W0
0045D4  784080     MOV.B W0, W1
0045D6  A06401     BSET.B W1, #6
0045D8  784F01     MOV.B W1, [W14]
0045DA  370004     BRA .L15
159:                       } else {
160:                           ucKeyState = (InvalidKEY << 6) | usKeyIOCurrent;
0045DC  90001E     MOV [W14+2], W0
0045DE  784080     MOV.B W0, W1
0045E0  B3C800     MOV.B #0x80, W0
0045E2  70CF00     IOR.B W1, W0, [W14]
161:                       }
162:                   }
163:                   /*return which key and key state*/
164:                   *((unsigned char*) vKeyState) = ucKeyState;
0045E4  90003E     MOV [W14+6], W0
0045E6  78481E     MOV.B [W14], [W0]
165:               }
0045E8  FA8000     ULNK
0045EA  060000     RETURN
166:               
167:               /*************************************
168:               Function: vKey1LongHandle
169:               Description: deal witch key by keystate 
170:               Input: ucKeyState 
171:               Output: void
172:                *************************************/
173:               
174:               static void vKey1LongHandle(void*parameter) {
0045EC  FA0004     LNK #0x4
0045EE  980710     MOV W0, [W14+2]
175:                   unsigned char ucLCDNum;
176:               
177:                   ucLCDNum = *((unsigned char *) parameter);
0045F0  90001E     MOV [W14+2], W0
0045F2  784F10     MOV.B [W0], [W14]
178:                   /*increase*/
179:                   ucLCDNum++;
0045F4  E84F1E     INC.B [W14], [W14]
180:                   /*mod*/
181:                   ucLCDNum %= 10;
0045F6  FB811E     ZE [W14], W2
0045F8  2CCCD0     MOV #0xCCCD, W0
0045FA  B81000     MUL.UU W2, W0, W0
0045FC  DE0843     LSR W1, #3, W0
0045FE  B9006A     MUL.SU W0, #10, W0
004600  780000     MOV W0, W0
004602  510000     SUB W2, W0, W0
004604  784F00     MOV.B W0, [W14]
182:                   /*return parameter*/
183:                   *((unsigned char *) parameter) = ucLCDNum;
004606  90001E     MOV [W14+2], W0
004608  78481E     MOV.B [W14], [W0]
184:               }
00460A  FA8000     ULNK
00460C  060000     RETURN
185:               
186:               /*************************************
187:               Function: vKey1ShortHandle
188:               Description: deal witch key by keystate 
189:               Input: ucKeyState 
190:               Output: void
191:                *************************************/
192:               
193:               static void vKey1ShortHandle(void*parameter) {
00460E  FA0004     LNK #0x4
004610  980710     MOV W0, [W14+2]
194:                   unsigned char ucLCDNum;
195:               
196:                   ucLCDNum = *((unsigned char *) parameter);
004612  90001E     MOV [W14+2], W0
004614  784F10     MOV.B [W0], [W14]
197:                   /*increase*/
198:                   ucLCDNum++;
004616  E84F1E     INC.B [W14], [W14]
199:                   /*mod*/
200:                   ucLCDNum %= 10;
004618  FB811E     ZE [W14], W2
00461A  2CCCD0     MOV #0xCCCD, W0
00461C  B81000     MUL.UU W2, W0, W0
00461E  DE0843     LSR W1, #3, W0
004620  B9006A     MUL.SU W0, #10, W0
004622  780000     MOV W0, W0
004624  510000     SUB W2, W0, W0
004626  784F00     MOV.B W0, [W14]
201:                   /*return parameter*/
202:                   *((unsigned char *) parameter) = ucLCDNum;
004628  90001E     MOV [W14+2], W0
00462A  78481E     MOV.B [W14], [W0]
203:               }
00462C  FA8000     ULNK
00462E  060000     RETURN
204:               
205:               /*************************************
206:               Function: vKeyUserFunction
207:               Description: deal witch key by keystate 
208:               Input: ucKeyState 
209:               Output: void
210:                *************************************/
211:               void vKeyUserFunction(unsigned char ucKeyState) {
004630  FA0004     LNK #0x4
004632  984720     MOV.B W0, [W14+2]
212:                   unsigned char ucNum;
213:                   /*switch key function*/
214:                   switch (ucKeyState) {
004634  90402E     MOV.B [W14+2], W0
004636  FB8000     ZE W0, W0
004638  200441     MOV #0x44, W1
00463A  500F81     SUB W0, W1, [W15]
00463C  320016     BRA Z, .L34
00463E  200441     MOV #0x44, W1
004640  500F81     SUB W0, W1, [W15]
004642  3C0004     BRA GT, .L33
004644  200411     MOV #0x41, W1
004646  500F81     SUB W0, W1, [W15]
004648  32000D     BRA Z, .L27
00464C  200C21     MOV #0xC2, W1
00464E  500F81     SUB W0, W1, [W15]
004650  32000E     BRA Z, .L35
004652  200C41     MOV #0xC4, W1
004654  500F81     SUB W0, W1, [W15]
004656  32000D     BRA Z, .L36
004658  200C11     MOV #0xC1, W1
00465A  500F81     SUB W0, W1, [W15]
00465C  3A000B     BRA NZ, .L25
215:                       case 0xC1://LongKEY1
216:                       {
217:                           vKey1LongHandle(&ucNum);
00465E  78000E     MOV W14, W0
004660  07FFC5     RCALL _vKey1LongHandle, .LFE5, .LFB6
218:                           break;
004662  370008     BRA .L25
219:                       }
220:                       case 0x41://ShortKEY1
221:                       {
222:                           vKey1ShortHandle(&ucNum);
004664  78000E     MOV W14, W0
004666  07FFD3     RCALL _vKey1ShortHandle, .LFE6, .LFB7
223:                           break;
004668  370005     BRA .L25
224:                       }
225:                       case 0xC2://LongKEY2
226:                       {
227:                           break;
00466E  000000     NOP
004670  370001     BRA .L25
228:                       }
229:                       case 0x42://ShortKEY2
230:                       {
231:                           break;
00464A  370014     BRA .L25
232:                       }
233:                       case 0xC4://LongKEY2
234:                       {
235:                           break;
004672  000000     NOP
236:                       }
237:                       case 0x44://ShortKEY2
238:                       {
239:                           break;
00466A  000000     NOP
00466C  370003     BRA .L25
240:                       }
241:                   }
242:               }
004674  FA8000     ULNK
004676  060000     RETURN
243:               
244:               
245:               
246:               
247:               
248:               
---  /home/zxc/Documents/WCGRTOS/Demo/App/Common.c  -----------------------------------------------------
1:                 #include "Common.h"
2:                 
3:                 /*************************************
4:                 Function: FloatToChar 
5:                 Description: char
6:                 Input:  4  8  
7:                 Output: 
8:                  *************************************/
9:                 void FloatToChar(float *f, uint8_t *ch) {
002BD8  FA0008     LNK #0x8
002BDA  980720     MOV W0, [W14+4]
002BDC  980731     MOV W1, [W14+6]
10:                    uint8_t count;
11:                    void * pf;
12:                    pf = f;
002BDE  9000AE     MOV [W14+4], W1
002BE0  980711     MOV W1, [W14+2]
13:                
14:                    for (count = 0; count < 4; count++) {
002BE2  EB4000     CLR.B W0
002BE4  784F00     MOV.B W0, [W14]
002BE6  37000A     BRA .L2
002BFA  E84F1E     INC.B [W14], [W14]
002BFC  78401E     MOV.B [W14], W0
002BFE  504FE3     SUB.B W0, #0x3, [W15]
002C00  36FFF3     BRA LEU, .L3
15:                        *(ch + count) = *((uint8_t *) pf + 3 - count);
002BE8  FB801E     ZE [W14], W0
002BEA  9000BE     MOV [W14+6], W1
002BEC  408000     ADD W1, W0, W0
002BEE  90011E     MOV [W14+2], W2
002BF0  FB809E     ZE [W14], W1
002BF2  1080E3     SUBR W1, #0x3, W1
002BF4  410081     ADD W2, W1, W1
002BF6  784091     MOV.B [W1], W1
002BF8  784801     MOV.B W1, [W0]
16:                    }
17:                }
002C02  FA8000     ULNK
002C04  060000     RETURN
18:                
19:                /*************************************
20:                Function: CharToFloat 
21:                Description: char 
22:                Input:     4  8  
23:                Output: 
24:                 *************************************/
25:                void CharToFloat(float *f, uint8_t *ch) {
002C06  FA0008     LNK #0x8
002C08  980720     MOV W0, [W14+4]
002C0A  980731     MOV W1, [W14+6]
26:                    uint8_t count;
27:                    void *pf;
28:                    pf = f;
002C0C  9000AE     MOV [W14+4], W1
002C0E  980711     MOV W1, [W14+2]
29:                
30:                    for (count = 0; count < 4; count++) {
002C10  EB4000     CLR.B W0
002C12  784F00     MOV.B W0, [W14]
002C14  37000A     BRA .L5
002C28  E84F1E     INC.B [W14], [W14]
002C2A  78401E     MOV.B [W14], W0
002C2C  504FE3     SUB.B W0, #0x3, [W15]
002C2E  36FFF3     BRA LEU, .L6
31:                        *((uint8_t *) pf + count) = *(ch + 3 - count);
002C16  90009E     MOV [W14+2], W1
002C18  FB801E     ZE [W14], W0
002C1A  408000     ADD W1, W0, W0
002C1C  FB809E     ZE [W14], W1
002C1E  1080E3     SUBR W1, #0x3, W1
002C20  90013E     MOV [W14+6], W2
002C22  410081     ADD W2, W1, W1
002C24  784091     MOV.B [W1], W1
002C26  784801     MOV.B W1, [W0]
32:                    }
33:                }
002C30  FA8000     ULNK
002C32  060000     RETURN
34:                
35:                /*************************************
36:                Function: FloatToChar 
37:                Description: char
38:                Input:  4  8  
39:                Output: 
40:                 *************************************/
41:                void DoubleToChar(long double *d, uint8_t *ch) {
002C34  FA0008     LNK #0x8
002C36  980720     MOV W0, [W14+4]
002C38  980731     MOV W1, [W14+6]
42:                    uint8_t count;
43:                    void * pf;
44:                    pf = d;
002C3A  9000AE     MOV [W14+4], W1
002C3C  980711     MOV W1, [W14+2]
45:                
46:                    for (count = 0; count < 8; count++) {
002C3E  EB4000     CLR.B W0
002C40  784F00     MOV.B W0, [W14]
002C42  37000A     BRA .L8
002C56  E84F1E     INC.B [W14], [W14]
002C58  78401E     MOV.B [W14], W0
002C5A  504FE7     SUB.B W0, #0x7, [W15]
002C5C  36FFF3     BRA LEU, .L9
47:                        *(ch + count) = *((uint8_t *) pf + 7 - count);
002C44  FB801E     ZE [W14], W0
002C46  9000BE     MOV [W14+6], W1
002C48  408000     ADD W1, W0, W0
002C4A  90011E     MOV [W14+2], W2
002C4C  FB809E     ZE [W14], W1
002C4E  1080E7     SUBR W1, #0x7, W1
002C50  410081     ADD W2, W1, W1
002C52  784091     MOV.B [W1], W1
002C54  784801     MOV.B W1, [W0]
48:                    }
49:                }
002C5E  FA8000     ULNK
002C60  060000     RETURN
50:                
51:                /*************************************
52:                Function: HCD 
53:                Description: 1610
54:                Input: 
55:                Output: 
56:                 *************************************/
57:                uint8_t HCD(uint8_t dat) {
002C62  FA0002     LNK #0x2
002C64  781F88     MOV W8, [W15++]
002C66  784F00     MOV.B W0, [W14]
58:                    return (dat >> 4)*10 + GetMod(dat, 4);
002C68  FB801E     ZE [W14], W0
002C6A  DE0044     LSR W0, #4, W0
002C6C  784000     MOV.B W0, W0
002C6E  B9006A     MUL.SU W0, #10, W0
002C70  780000     MOV W0, W0
002C72  784400     MOV.B W0, W8
002C74  FB801E     ZE [W14], W0
002C76  B3C041     MOV.B #0x4, W1
002C78  07011A     RCALL GetMod
002C7A  444000     ADD.B W8, W0, W0
59:                }
002C7C  78044F     MOV [--W15], W8
002C7E  FA8000     ULNK
002C80  060000     RETURN
60:                
61:                /*************************************
62:                Function: DCH 
63:                Description: 1016
64:                Input: 
65:                Output: 
66:                 *************************************/
67:                uint8_t DCH(uint8_t dat) { //0x11 17
002C82  FA0002     LNK #0x2
002C84  784F00     MOV.B W0, [W14]
68:                    return ((dat / 10 << 4)&0xF0) | ((dat % 10)&0x0F);
002C86  FB809E     ZE [W14], W1
002C88  2CCCD0     MOV #0xCCCD, W0
002C8A  B80800     MUL.UU W1, W0, W0
002C8C  DE0843     LSR W1, #3, W0
002C8E  784000     MOV.B W0, W0
002C90  FB8000     ZE W0, W0
002C92  DD0044     SL W0, #4, W0
002C94  784180     MOV.B W0, W3
002C96  FB811E     ZE [W14], W2
002C98  2CCCD0     MOV #0xCCCD, W0
002C9A  B81000     MUL.UU W2, W0, W0
002C9C  DE0843     LSR W1, #3, W0
002C9E  B9006A     MUL.SU W0, #10, W0
002CA0  780000     MOV W0, W0
002CA2  510000     SUB W2, W0, W0
002CA4  784000     MOV.B W0, W0
002CA6  60406F     AND.B W0, #0xF, W0
002CA8  71C000     IOR.B W3, W0, W0
69:                }
002CAA  FA8000     ULNK
002CAC  060000     RETURN
70:                
71:                //uint8_t D2Hex(uint8_t dat)//0x1117-> 0x17  
72:                //{
73:                //    if(dat>)
74:                //}
75:                
76:                /*************************************
77:                Function: DataIsVaild 
78:                Description: 
79:                Input: 
80:                Output: 
81:                 *************************************/
82:                bool DataIsVaild(uint16_t dat, const uint16_t max, const uint16_t min) {
002CAE  FA0006     LNK #0x6
002CB0  780F00     MOV W0, [W14]
002CB2  980711     MOV W1, [W14+2]
002CB4  980722     MOV W2, [W14+4]
83:                    if (dat > max) return false;
002CB6  90001E     MOV [W14+2], W0
002CB8  78009E     MOV [W14], W1
002CBA  508F80     SUB W1, W0, [W15]
002CBC  360002     BRA LEU, .L13
002CBE  EB4000     CLR.B W0
002CC0  370007     BRA .L14
84:                    else if (dat < min) return false;
002CC2  90002E     MOV [W14+4], W0
002CC4  78009E     MOV [W14], W1
002CC6  508F80     SUB W1, W0, [W15]
002CC8  310002     BRA C, .L15
002CCA  EB4000     CLR.B W0
002CCC  370001     BRA .L14
85:                    return true;
002CCE  B3C010     MOV.B #0x1, W0
86:                }
002CD0  FA8000     ULNK
002CD2  060000     RETURN
87:                
88:                /*************************************
89:                Function: SetVaildData 
90:                Description: 
91:                Input: 
92:                Output: 
93:                 *************************************/
94:                void SetVaildData(uint16_t * dat, const uint32_t max, const uint16_t min) {
002CD4  FA000A     LNK #0xA
002CD6  980710     MOV W0, [W14+2]
002CD8  980722     MOV W2, [W14+4]
002CDA  980733     MOV W3, [W14+6]
002CDC  980741     MOV W1, [W14+8]
95:                    uint16_t tmp = ((*dat) << 8) + *(dat + 1);
002CDE  90001E     MOV [W14+2], W0
002CE0  780010     MOV [W0], W0
002CE2  DD00C8     SL W0, #8, W1
002CE4  90001E     MOV [W14+2], W0
002CE6  E88000     INC2 W0, W0
002CE8  780010     MOV [W0], W0
002CEA  408F00     ADD W1, W0, [W14]
96:                
97:                    if (tmp > max) {
002CEC  78001E     MOV [W14], W0
002CEE  B80161     MUL.UU W0, #1, W2
002CF0  90002E     MOV [W14+4], W0
002CF2  9000BE     MOV [W14+6], W1
002CF4  510F80     SUB W2, W0, [W15]
002CF6  598F81     SUBB W3, W1, [W15]
002CF8  360004     BRA LEU, .L17
98:                        *dat = max;
002CFA  9000AE     MOV [W14+4], W1
002CFC  90001E     MOV [W14+2], W0
002CFE  780801     MOV W1, [W0]
002D00  370007     BRA .L16
99:                    } else if (tmp < min) {
002D02  90004E     MOV [W14+8], W0
002D04  78009E     MOV [W14], W1
002D06  508F80     SUB W1, W0, [W15]
002D08  310003     BRA C, .L16
100:                       *dat = min;
002D0A  90001E     MOV [W14+2], W0
002D0C  9000CE     MOV [W14+8], W1
002D0E  780801     MOV W1, [W0]
101:                   }
102:               }
002D10  FA8000     ULNK
002D12  060000     RETURN
103:               //
104:               
105:               void DataReverse(uint8_t *dat, const uint8_t byte) {
002D14  FA0006     LNK #0x6
002D16  980710     MOV W0, [W14+2]
002D18  984741     MOV.B W1, [W14+4]
106:                   uint8_t tmp, cnt;
107:               
108:                   for (cnt = 0; cnt < byte / 2; cnt++) {
002D1A  EB4000     CLR.B W0
002D1C  784F00     MOV.B W0, [W14]
002D1E  37001B     BRA .L20
002D54  E84F1E     INC.B [W14], [W14]
002D56  90404E     MOV.B [W14+4], W0
002D58  FB8000     ZE W0, W0
002D5A  D10000     LSR W0, W0
002D5C  784000     MOV.B W0, W0
002D5E  504F9E     SUB.B W0, [W14], [W15]
002D60  3EFFDF     BRA GTU, .L21
109:                       tmp = dat[cnt];
002D20  FB801E     ZE [W14], W0
002D22  90009E     MOV [W14+2], W1
002D24  408000     ADD W1, W0, W0
002D26  784090     MOV.B [W0], W1
002D28  984711     MOV.B W1, [W14+1]
110:                       dat[cnt] = dat[byte - 1 - cnt];
002D2A  FB801E     ZE [W14], W0
002D2C  90009E     MOV [W14+2], W1
002D2E  408000     ADD W1, W0, W0
002D30  9040CE     MOV.B [W14+4], W1
002D32  FB8081     ZE W1, W1
002D34  E90101     DEC W1, W2
002D36  FB809E     ZE [W14], W1
002D38  510081     SUB W2, W1, W1
002D3A  90011E     MOV [W14+2], W2
002D3C  410081     ADD W2, W1, W1
002D3E  784091     MOV.B [W1], W1
002D40  784801     MOV.B W1, [W0]
111:                       dat[byte - 1 - cnt] = tmp;
002D42  90404E     MOV.B [W14+4], W0
002D44  FB8000     ZE W0, W0
002D46  E90080     DEC W0, W1
002D48  FB801E     ZE [W14], W0
002D4A  508000     SUB W1, W0, W0
002D4C  90009E     MOV [W14+2], W1
002D4E  408000     ADD W1, W0, W0
002D50  90409E     MOV.B [W14+1], W1
002D52  784801     MOV.B W1, [W0]
112:                   }
113:               }
002D62  FA8000     ULNK
002D64  060000     RETURN
114:               
115:               //void Delayms(uint16_t time) {//1000,
116:               //    TMR2 = 0; //2
117:               //    PR2 = 625 * time / 10; //
118:               //    IFS0bits.T2IF = 0;
119:               //    T2CONbits.TON = 1; //    
120:               //    while (!IFS0bits.T2IF); //
121:               //    T2CONbits.TON = 0; //
122:               //    IFS0bits.T2IF = 0; //
123:               //}
124:               //8MHz-4Mhz 
125:               //0x0271 10ms
126:               
127:               //32Mhz
128:               
129:               void Delay1ms(int8_t time) {
002D66  FA0004     LNK #0x4
002D68  984720     MOV.B W0, [W14+2]
130:                   uint16_t i;
131:                   while (time-- > 0)
002D6A  370009     BRA .L23
002D7E  B3C010     MOV.B #0x1, W0
002D80  9040AE     MOV.B [W14+2], W1
002D82  E00401     CP0.B W1
002D84  3C0001     BRA GT, .L26
002D86  EB4000     CLR.B W0
002D88  9040AE     MOV.B [W14+2], W1
002D8A  E94081     DEC.B W1, W1
002D8C  984721     MOV.B W1, [W14+2]
002D8E  E00400     CP0.B W0
002D90  3AFFED     BRA NZ, .L27
132:                       for (i = 0; i < 144; i++)
002D6C  EB0000     CLR W0
002D6E  780F00     MOV W0, [W14]
002D70  370002     BRA .L24
002D74  E80F1E     INC [W14], [W14]
002D76  2008F0     MOV #0x8F, W0
002D78  78009E     MOV [W14], W1
002D7A  508F80     SUB W1, W0, [W15]
002D7C  36FFFA     BRA LEU, .L25
133:                           Nop();
002D72  000000     NOP
134:               }
002D92  FA8000     ULNK
002D94  060000     RETURN
135:               
136:               void Delay10ms(int8_t time) {
002D96  FA0004     LNK #0x4
002D98  984720     MOV.B W0, [W14+2]
137:                   uint16_t i;
138:                   while (time-- > 0)
002D9A  370009     BRA .L29
002DAE  B3C010     MOV.B #0x1, W0
002DB0  9040AE     MOV.B [W14+2], W1
002DB2  E00401     CP0.B W1
002DB4  3C0001     BRA GT, .L32
002DB6  EB4000     CLR.B W0
002DB8  9040AE     MOV.B [W14+2], W1
002DBA  E94081     DEC.B W1, W1
002DBC  984721     MOV.B W1, [W14+2]
002DBE  E00400     CP0.B W0
002DC0  3AFFED     BRA NZ, .L33
139:                       for (i = 0; i < 1440; i++)
002D9C  EB0000     CLR W0
002D9E  780F00     MOV W0, [W14]
002DA0  370002     BRA .L30
002DA4  E80F1E     INC [W14], [W14]
002DA6  2059F0     MOV #0x59F, W0
002DA8  78009E     MOV [W14], W1
002DAA  508F80     SUB W1, W0, [W15]
002DAC  36FFFA     BRA LEU, .L31
140:                           Nop();
002DA2  000000     NOP
141:               }
002DC2  FA8000     ULNK
002DC4  060000     RETURN
142:               
143:               void Delay100ms(int8_t time) {
002DC6  FA0006     LNK #0x6
002DC8  984740     MOV.B W0, [W14+4]
144:                   uint32_t i;
145:                   while (time-- > 0)
002DCA  37000E     BRA .L35
002DE8  B3C010     MOV.B #0x1, W0
002DEA  9040CE     MOV.B [W14+4], W1
002DEC  E00401     CP0.B W1
002DEE  3C0001     BRA GT, .L38
002DF0  EB4000     CLR.B W0
002DF2  9040CE     MOV.B [W14+4], W1
002DF4  E94081     DEC.B W1, W1
002DF6  984741     MOV.B W1, [W14+4]
002DF8  E00400     CP0.B W0
002DFA  3AFFE8     BRA NZ, .L39
146:                       for (i = 0; i < 14400; i++)
002DCC  B80060     MUL.UU W0, #0, W0
002DCE  BE8F00     MOV.D W0, [W14]
002DD0  370005     BRA .L36
002DD4  200012     MOV #0x1, W2
002DD6  200003     MOV #0x0, W3
002DD8  410F1E     ADD W2, [W14], [W14]
002DDA  49975E     ADDC W3, [++W14], [W14--]
002DDC  2383F0     MOV #0x383F, W0
002DDE  200001     MOV #0x0, W1
002DE0  BE011E     MOV.D [W14], W2
002DE2  510F80     SUB W2, W0, [W15]
002DE4  598F81     SUBB W3, W1, [W15]
002DE6  36FFF5     BRA LEU, .L37
147:                           Nop();
002DD2  000000     NOP
148:               }
002DFC  FA8000     ULNK
002DFE  060000     RETURN
149:               
150:               void Delay1s(void) {
002E00  FA0004     LNK #0x4
151:                   uint32_t i = 0; //,j;
002E02  B80060     MUL.UU W0, #0, W0
002E04  BE8F00     MOV.D W0, [W14]
152:                   //    uint8_t t = t2;
153:                   //    while (t-- > 0)
154:                   for (i = 0; i < 144000; i++)
002E06  B80060     MUL.UU W0, #0, W0
002E08  BE8F00     MOV.D W0, [W14]
002E0A  370005     BRA .L41
002E0E  200012     MOV #0x1, W2
002E10  200003     MOV #0x0, W3
002E12  410F1E     ADD W2, [W14], [W14]
002E14  49975E     ADDC W3, [++W14], [W14--]
002E16  2327F0     MOV #0x327F, W0
002E18  200021     MOV #0x2, W1
002E1A  BE011E     MOV.D [W14], W2
002E1C  510F80     SUB W2, W0, [W15]
002E1E  598F81     SUBB W3, W1, [W15]
002E20  36FFF5     BRA LEU, .L42
155:                       Nop();
002E0C  000000     NOP
156:               }
002E22  FA8000     ULNK
002E24  060000     RETURN
157:               
158:               //void Delay1s(const int8_t t2) {
159:               //    uint32_t i = 0; //,j;
160:               //    uint8_t t = t2;
161:               //    while (t-- > 0)
162:               //        for (i = 0; i < 144000; i++)
163:               //            Nop();
164:               //}
165:               
166:               //void Delays(char time) {
167:               //    uint8_t cnt;
168:               //    for (cnt = 0; cnt < time; cnt++)
169:               //        Delayms(1000);
170:               //}
171:               
172:               void CopyDat(uint8_t* output, const uint8_t *input, const uint8_t bytes) {
002E26  FA0008     LNK #0x8
002E28  980710     MOV W0, [W14+2]
002E2A  980721     MOV W1, [W14+4]
002E2C  984762     MOV.B W2, [W14+6]
173:                   uint8_t num;
174:                   for (num = 0; num < bytes; num++)
002E2E  EB4000     CLR.B W0
002E30  784F00     MOV.B W0, [W14]
002E32  370009     BRA .L44
002E44  E84F1E     INC.B [W14], [W14]
002E46  90406E     MOV.B [W14+6], W0
002E48  78409E     MOV.B [W14], W1
002E4A  50CF80     SUB.B W1, W0, [W15]
002E4C  39FFF3     BRA NC, .L45
175:                       *(output + num) = *(input + num);
002E34  FB801E     ZE [W14], W0
002E36  90009E     MOV [W14+2], W1
002E38  408000     ADD W1, W0, W0
002E3A  FB809E     ZE [W14], W1
002E3C  90012E     MOV [W14+4], W2
002E3E  410081     ADD W2, W1, W1
002E40  784091     MOV.B [W1], W1
002E42  784801     MOV.B W1, [W0]
176:               }
002E4E  FA8000     ULNK
002E50  060000     RETURN
177:               
178:               void ClearDat(uint8_t *output, const uint8_t dat, const uint8_t bytes) {
002E52  FA0006     LNK #0x6
002E54  980710     MOV W0, [W14+2]
002E56  984741     MOV.B W1, [W14+4]
002E58  984752     MOV.B W2, [W14+5]
179:                   uint8_t num;
180:                   for (num = 0; num < bytes; num++)
002E5A  EB4000     CLR.B W0
002E5C  784F00     MOV.B W0, [W14]
002E5E  370006     BRA .L47
002E6A  E84F1E     INC.B [W14], [W14]
002E6C  90405E     MOV.B [W14+5], W0
002E6E  78409E     MOV.B [W14], W1
002E70  50CF80     SUB.B W1, W0, [W15]
002E72  39FFF6     BRA NC, .L48
181:                       *(output + num) = dat;
002E60  FB801E     ZE [W14], W0
002E62  90009E     MOV [W14+2], W1
002E64  408000     ADD W1, W0, W0
002E66  9040CE     MOV.B [W14+4], W1
002E68  784801     MOV.B W1, [W0]
182:               }
002E74  FA8000     ULNK
002E76  060000     RETURN
183:               
184:               bool ValueIsEqual(const uint8_t *str1, const uint8_t *str2, const uint8_t bytes) {
002E78  FA0008     LNK #0x8
002E7A  980710     MOV W0, [W14+2]
002E7C  980721     MOV W1, [W14+4]
002E7E  984762     MOV.B W2, [W14+6]
185:                   uint8_t cnt;
186:                   for (cnt = 0; cnt < bytes; cnt++)
002E80  EB4000     CLR.B W0
002E82  784F00     MOV.B W0, [W14]
002E84  37000D     BRA .L50
002E9E  E84F1E     INC.B [W14], [W14]
002EA0  90406E     MOV.B [W14+6], W0
002EA2  78409E     MOV.B [W14], W1
002EA4  50CF80     SUB.B W1, W0, [W15]
002EA6  39FFEF     BRA NC, .L53
187:                       if (*(str1 + cnt) != *(str2 + cnt))
002E86  FB801E     ZE [W14], W0
002E88  90009E     MOV [W14+2], W1
002E8A  408000     ADD W1, W0, W0
002E8C  784090     MOV.B [W0], W1
002E8E  FB801E     ZE [W14], W0
002E90  90012E     MOV [W14+4], W2
002E92  410000     ADD W2, W0, W0
002E94  784010     MOV.B [W0], W0
002E96  50CF80     SUB.B W1, W0, [W15]
002E98  320002     BRA Z, .L51
188:                           return false;
002E9A  EB4000     CLR.B W0
002E9C  370006     BRA .L52
189:                   return true;
002EA8  B3C010     MOV.B #0x1, W0
190:               }
002EAA  FA8000     ULNK
002EAC  060000     RETURN
191:               
192:               //
193:               
194:               uint8_t GetMod(uint16_t num, uint8_t mod_num) {
002EAE  FA0004     LNK #0x4
002EB0  780F00     MOV W0, [W14]
002EB2  984721     MOV.B W1, [W14+2]
195:                   return num - ((num >> mod_num) << mod_num);
002EB4  78001E     MOV [W14], W0
002EB6  784080     MOV.B W0, W1
002EB8  90402E     MOV.B [W14+2], W0
002EBA  FB8000     ZE W0, W0
002EBC  78011E     MOV [W14], W2
002EBE  DE1100     LSR W2, W0, W2
002EC0  90402E     MOV.B [W14+2], W0
002EC2  FB8000     ZE W0, W0
002EC4  DD1000     SL W2, W0, W0
002EC6  784000     MOV.B W0, W0
002EC8  50C000     SUB.B W1, W0, W0
196:               }
002ECA  FA8000     ULNK
002ECC  060000     RETURN
197:               
198:               //16
199:               
200:               uint8_t my_itoa(uint16_t i, uint8_t *str) {
002ECE  FA000E     LNK #0xE
002ED0  980750     MOV W0, [W14+10]
002ED2  980761     MOV W1, [W14+12]
201:                   uint8_t buf[6];
202:                   uint8_t cnt = 0, len;
002ED4  EB4000     CLR.B W0
002ED6  784F00     MOV.B W0, [W14]
203:                   uint16_t tmp = i;
002ED8  9000DE     MOV [W14+10], W1
002EDA  980711     MOV W1, [W14+2]
204:                   if (!tmp) {
002EDC  90001E     MOV [W14+2], W0
002EDE  E00000     CP0 W0
002EE0  3A001D     BRA NZ, .L58
205:                       *str = '0';
002EE2  90006E     MOV [W14+12], W0
002EE4  B3C301     MOV.B #0x30, W1
002EE6  784801     MOV.B W1, [W0]
206:                       *(str + 1) = '\0';
002EE8  90006E     MOV [W14+12], W0
002EEA  E80000     INC W0, W0
002EEC  EB4080     CLR.B W1
002EEE  784801     MOV.B W1, [W0]
207:                       len = 1;
002EF0  B3C010     MOV.B #0x1, W0
002EF2  984710     MOV.B W0, [W14+1]
002EF4  370033     BRA .L57
208:                   } else {
209:                       while (tmp) {
002F1C  90001E     MOV [W14+2], W0
002F1E  E00000     CP0 W0
002F20  3AFFEA     BRA NZ, .L59
210:                           *(buf + cnt++) = tmp % 10 + 0x30;
002EF6  FB801E     ZE [W14], W0
002EF8  4700E4     ADD W14, #0x4, W1
002EFA  408180     ADD W1, W0, W3
002EFC  90011E     MOV [W14+2], W2
002EFE  2CCCD0     MOV #0xCCCD, W0
002F00  B81000     MUL.UU W2, W0, W0
002F02  DE0843     LSR W1, #3, W0
002F04  B9006A     MUL.SU W0, #10, W0
002F06  780000     MOV W0, W0
002F08  510000     SUB W2, W0, W0
002F0A  784000     MOV.B W0, W0
002F0C  B04300     ADD.B #0x30, W0
002F0E  784980     MOV.B W0, [W3]
002F10  E84F1E     INC.B [W14], [W14]
211:                           tmp /= 10;
002F12  90009E     MOV [W14+2], W1
002F14  2CCCD0     MOV #0xCCCD, W0
002F16  B80800     MUL.UU W1, W0, W0
002F18  DE0843     LSR W1, #3, W0
002F1A  980710     MOV W0, [W14+2]
212:                       }
213:                       len = cnt;
002F22  78409E     MOV.B [W14], W1
002F24  984711     MOV.B W1, [W14+1]
214:                       cnt += 1;
002F26  E84F1E     INC.B [W14], [W14]
215:                       while (cnt--) {
002F28  37000C     BRA .L60
002F42  FB801E     ZE [W14], W0
002F44  EA0000     NEG W0, W0
002F46  DE004F     LSR W0, #15, W0
002F48  784000     MOV.B W0, W0
002F4A  E94F1E     DEC.B [W14], [W14]
002F4C  E00400     CP0.B W0
002F4E  3AFFED     BRA NZ, .L61
216:                           *(str + cnt - 1) = *(buf + len - cnt);
002F2A  FB801E     ZE [W14], W0
002F2C  E90000     DEC W0, W0
002F2E  9000EE     MOV [W14+12], W1
002F30  408000     ADD W1, W0, W0
002F32  90409E     MOV.B [W14+1], W1
002F34  FB8101     ZE W1, W2
002F36  FB809E     ZE [W14], W1
002F38  510081     SUB W2, W1, W1
002F3A  470164     ADD W14, #0x4, W2
002F3C  410081     ADD W2, W1, W1
002F3E  784091     MOV.B [W1], W1
002F40  784801     MOV.B W1, [W0]
217:                       }
218:                       *(str + len) = '\0';
002F50  90401E     MOV.B [W14+1], W0
002F52  FB8000     ZE W0, W0
002F54  9000EE     MOV [W14+12], W1
002F56  408000     ADD W1, W0, W0
002F58  EB4080     CLR.B W1
002F5A  784801     MOV.B W1, [W0]
219:                   }
220:                   return len;
002F5C  90401E     MOV.B [W14+1], W0
221:               }
002F5E  FA8000     ULNK
002F60  060000     RETURN
222:               
223:               uint8_t Str_Find_Head(uint8_t* str1, const uint8_t *str2, const uint8_t str1_bytes, const uint8_t str2_bytes) {
002F62  FA000C     LNK #0xC
002F64  980730     MOV W0, [W14+6]
002F66  980741     MOV W1, [W14+8]
002F68  984F22     MOV.B W2, [W14+10]
002F6A  984F33     MOV.B W3, [W14+11]
224:                   uint8_t cnt = 0, cnt1 = 0;
002F6C  EB4000     CLR.B W0
002F6E  784F00     MOV.B W0, [W14]
002F70  EB4000     CLR.B W0
002F72  984710     MOV.B W0, [W14+1]
225:                   uint8_t position = 0;
002F74  EB4000     CLR.B W0
002F76  984720     MOV.B W0, [W14+2]
226:                   bool is_find = false;
002F78  EB4000     CLR.B W0
002F7A  984730     MOV.B W0, [W14+3]
227:                   uint8_t *ptr = (uint8_t *) str1;
002F7C  9000BE     MOV [W14+6], W1
002F7E  980721     MOV W1, [W14+4]
228:                   if (str2_bytes > str1_bytes)//
002F80  9048BE     MOV.B [W14+11], W1
002F82  90482E     MOV.B [W14+10], W0
002F84  50CF80     SUB.B W1, W0, [W15]
002F86  360002     BRA LEU, .L63
229:                       return 0;
002F88  EB4000     CLR.B W0
002F8A  370042     BRA .L64
230:               
231:                   if (str1_bytes == 1) {//
002F8C  90482E     MOV.B [W14+10], W0
002F8E  504FE1     SUB.B W0, #0x1, [W15]
002F90  3A003A     BRA NZ, .L67
232:                       if (*ptr == *str2)
002F92  90002E     MOV [W14+4], W0
002F94  784090     MOV.B [W0], W1
002F96  90004E     MOV [W14+8], W0
002F98  784010     MOV.B [W0], W0
002F9A  50CF80     SUB.B W1, W0, [W15]
002F9C  3A0002     BRA NZ, .L66
233:                           return true;
002F9E  B3C010     MOV.B #0x1, W0
002FA0  370037     BRA .L64
234:                       else
235:                           return false;
002FA2  EB4000     CLR.B W0
002FA4  370035     BRA .L64
236:                   }
237:                   while (cnt < str1_bytes) {
003006  90482E     MOV.B [W14+10], W0
003008  78409E     MOV.B [W14], W1
00300A  50CF80     SUB.B W1, W0, [W15]
00300C  39FFCC     BRA NC, .L74
238:                       ptr = (uint8_t *) str1 + cnt;
002FA6  FB801E     ZE [W14], W0
002FA8  9000BE     MOV [W14+6], W1
002FAA  408000     ADD W1, W0, W0
002FAC  980720     MOV W0, [W14+4]
239:                       if (*ptr == *str2) {//==head 
002FAE  90002E     MOV [W14+4], W0
002FB0  784090     MOV.B [W0], W1
002FB2  90004E     MOV [W14+8], W0
002FB4  784010     MOV.B [W0], W0
002FB6  50CF80     SUB.B W1, W0, [W15]
002FB8  3A0025     BRA NZ, .L68
240:                           is_find = true; //str2
002FBA  B3C010     MOV.B #0x1, W0
002FBC  984730     MOV.B W0, [W14+3]
241:                           for (cnt1 = 1; cnt1 < str2_bytes; cnt1++) {
002FBE  B3C010     MOV.B #0x1, W0
002FC0  984710     MOV.B W0, [W14+1]
002FC2  370016     BRA .L69
002FEA  90401E     MOV.B [W14+1], W0
002FEC  E84000     INC.B W0, W0
002FEE  984710     MOV.B W0, [W14+1]
002FF0  90409E     MOV.B [W14+1], W1
002FF2  90483E     MOV.B [W14+11], W0
002FF4  50CF80     SUB.B W1, W0, [W15]
002FF6  39FFE6     BRA NC, .L72
242:                               if (*(str1 + cnt1 + cnt) != *(str2 + cnt1)) {
002FC4  90401E     MOV.B [W14+1], W0
002FC6  FB8080     ZE W0, W1
002FC8  FB801E     ZE [W14], W0
002FCA  408000     ADD W1, W0, W0
002FCC  9000BE     MOV [W14+6], W1
002FCE  408000     ADD W1, W0, W0
002FD0  784090     MOV.B [W0], W1
002FD2  90401E     MOV.B [W14+1], W0
002FD4  FB8000     ZE W0, W0
002FD6  90014E     MOV [W14+8], W2
002FD8  410000     ADD W2, W0, W0
002FDA  784010     MOV.B [W0], W0
002FDC  50CF80     SUB.B W1, W0, [W15]
002FDE  320003     BRA Z, .L70
243:                                   is_find = false;
002FE0  EB4000     CLR.B W0
002FE2  984730     MOV.B W0, [W14+3]
244:                                   break;
002FE4  370009     BRA .L71
245:                               } else
246:                                   is_find = true;
002FE6  B3C010     MOV.B #0x1, W0
002FE8  984730     MOV.B W0, [W14+3]
247:                           }
248:                           if (is_find) {
002FF8  90403E     MOV.B [W14+3], W0
002FFA  E00400     CP0.B W0
002FFC  320003     BRA Z, .L68
249:                               position = cnt + 1;
002FFE  E8401E     INC.B [W14], W0
003000  984720     MOV.B W0, [W14+2]
250:                               break;
003002  370005     BRA .L73
251:                           }
252:                       }
253:                       cnt += 1;
003004  E84F1E     INC.B [W14], [W14]
254:                   }
255:                   return position;
00300E  90402E     MOV.B [W14+2], W0
256:               }
003010  FA8000     ULNK
003012  060000     RETURN
257:               
258:               
259:               
260:               
261:               
---  /home/zxc/Documents/WCGRTOS/Demo/App/CheckData.c  --------------------------------------------------
1:                 #include "CheckData.h"
2:                 
3:                 /*************************************
4:                  * Function: CRC16_Check
5:                  * Description: CRC16
6:                  * Input: pucCRCBuf:
7:                  *        ucBufLenght:
8:                  * Output: CRC_Value:CRC
9:                  * notice: 
10:                 *************************************/
11:                uint16_t usCRC16Check(uint8_t *pucCRCBuf, const uint8_t ucBufLenght) {
004F0E  FA000A     LNK #0xA
004F10  980730     MOV W0, [W14+6]
004F12  984F01     MOV.B W1, [W14+8]
12:                    uint16_t usCount1, usCount2;
13:                    uint16_t usCRCSumx;
14:                
15:                    usCRCSumx = 0xFFFF;
004F14  EB8000     SETM W0
004F16  980720     MOV W0, [W14+4]
16:                    for (usCount1 = 0; usCount1 < ucBufLenght; usCount1++) {
004F18  EB0000     CLR W0
004F1A  780F00     MOV W0, [W14]
004F1C  370021     BRA .L2
004F5E  E80F1E     INC [W14], [W14]
004F60  90480E     MOV.B [W14+8], W0
004F62  FB8000     ZE W0, W0
004F64  500F9E     SUB W0, [W14], [W15]
004F66  3EFFDB     BRA GTU, .L7
17:                        /**/
18:                        usCRCSumx ^= *(pucCRCBuf + usCount1);
004F1E  90003E     MOV [W14+6], W0
004F20  40001E     ADD W0, [W14], W0
004F22  784010     MOV.B [W0], W0
004F24  FB8000     ZE W0, W0
004F26  9000AE     MOV [W14+4], W1
004F28  688000     XOR W1, W0, W0
004F2A  980720     MOV W0, [W14+4]
19:                        for (usCount2 = 0; usCount2 < 8; usCount2++) {
004F2C  EB0000     CLR W0
004F2E  980710     MOV W0, [W14+2]
004F30  370013     BRA .L3
004F52  90001E     MOV [W14+2], W0
004F54  E80000     INC W0, W0
004F56  980710     MOV W0, [W14+2]
004F58  90001E     MOV [W14+2], W0
004F5A  500FE7     SUB W0, #0x7, [W15]
004F5C  36FFEA     BRA LEU, .L6
20:                            if (usCRCSumx & 0x01) {
004F32  90002E     MOV [W14+4], W0
004F34  600061     AND W0, #0x1, W0
004F36  784000     MOV.B W0, W0
004F38  E00400     CP0.B W0
004F3A  320008     BRA Z, .L4
21:                                usCRCSumx >>= 1;
004F3C  90002E     MOV [W14+4], W0
004F3E  D10000     LSR W0, W0
004F40  980720     MOV W0, [W14+4]
22:                                usCRCSumx ^= 0xA001;
004F42  9000AE     MOV [W14+4], W1
004F44  2A0010     MOV #0xA001, W0
004F46  688000     XOR W1, W0, W0
004F48  980720     MOV W0, [W14+4]
004F4A  370003     BRA .L5
23:                            } else {
24:                                usCRCSumx >>= 1;
004F4C  90002E     MOV [W14+4], W0
004F4E  D10000     LSR W0, W0
004F50  980720     MOV W0, [W14+4]
25:                            }
26:                        }
27:                    }   
28:                    return (usCRCSumx);
004F68  90002E     MOV [W14+4], W0
29:                }
004F6A  FA8000     ULNK
004F6C  060000     RETURN
30:                
31:                /*************************************
32:                Function: SumCheck 
33:                Description: 
34:                Input: pucCRCBufucBufLenght 
35:                Output: 
36:                 *************************************/
37:                uint16_t usSumCheck(uint8_t *pucCRCBuf, const uint8_t ucBufLenght) {
004F6E  FA0008     LNK #0x8
004F70  980720     MOV W0, [W14+4]
004F72  984761     MOV.B W1, [W14+6]
38:                    uint16_t usSum = 0;
004F74  EB0000     CLR W0
004F76  780F00     MOV W0, [W14]
39:                    uint16_t usCount = ucBufLenght;
004F78  90406E     MOV.B [W14+6], W0
004F7A  FB8000     ZE W0, W0
004F7C  980710     MOV W0, [W14+2]
40:                    while (usCount > 0) {
004F7E  37000A     BRA .L9
004F94  90001E     MOV [W14+2], W0
004F96  E00000     CP0 W0
004F98  3AFFF3     BRA NZ, .L10
41:                        usSum += *pucCRCBuf++;
004F80  90002E     MOV [W14+4], W0
004F82  784010     MOV.B [W0], W0
004F84  FB8000     ZE W0, W0
004F86  400F1E     ADD W0, [W14], [W14]
004F88  90002E     MOV [W14+4], W0
004F8A  E80000     INC W0, W0
004F8C  980720     MOV W0, [W14+4]
42:                        usCount--;
004F8E  90001E     MOV [W14+2], W0
004F90  E90000     DEC W0, W0
004F92  980710     MOV W0, [W14+2]
43:                    }
44:                    return usSum;
004F9A  78001E     MOV [W14], W0
45:                }
004F9C  FA8000     ULNK
004F9E  060000     RETURN
46:                
47:                
48:                
49:                
50:                
51:                
52:                
53:                
54:                
55:                
---  /home/zxc/Documents/WCGRTOS/Demo/App/CAT24C512.c  --------------------------------------------------
1:                 #include <stdint.h>
2:                 
3:                 #include "CAT24C512.h"
4:                 #include "I2C_S.h"
5:                 
6:                 sI2CDeviceAttribute sCAT24C512;
7:                 
8:                 /*************************************
9:                 Function: vCAT24Init
10:                Description: CATWPI2CI2C
11:                Input: void
12:                Output: void
13:                 *************************************/
14:                void vCAT24Init(void) {
005084  FA0000     LNK #0x0
15:                #ifndef Have_Initialized_I2C
16:                    vI2CInit();
005086  023A2A     CALL vI2CInit
005088  000000     NOP
17:                #define Have_Initialized_I2C
18:                #endif 
19:                    /*CAT24C512*/
20:                    CAT24_WP_DIR = 0;
00508A  A942E8     BCLR TRISF, #2
21:                    /**/
22:                    CAT24_WP = 1;
00508C  A842EC     BSET LATF, #2
23:                    /*doing some setting here*/
24:                }
00508E  FA8000     ULNK
005090  060000     RETURN
25:                
26:                /*************************************
27:                Function: xCAT24WritePage
28:                Description: CAT24
29:                Input: adddatabytes,operation(write or read)
30:                Output: CAT24CAT24_STA
31:                 *************************************/
32:                CAT24_STA xCAT24WriteReadPage(const unsigned int usRegisterAddress,
33:                        unsigned char* pucFirstByteAddress,
34:                        const unsigned char ucWriteReadBytes,
35:                        bool bWriteRead) {
005092  FA0008     LNK #0x8
005094  980710     MOV W0, [W14+2]
005096  980721     MOV W1, [W14+4]
005098  984762     MOV.B W2, [W14+6]
00509A  984773     MOV.B W3, [W14+7]
36:                    CAT24_STA xCATSta = 0;
00509C  EB4000     CLR.B W0
00509E  784F00     MOV.B W0, [W14]
37:                    /**/
38:                    CAT24_WP = 0;
0050A0  A942EC     BCLR LATF, #2
39:                
40:                    /*set cat24c512 attribute*/
41:                    sCAT24C512.ucSlaveAddress = CAT24_ADD;
0050A2  21DAE0     MOV #0x1DAE, W0
0050A4  B3CA81     MOV.B #0xA8, W1
0050A6  784801     MOV.B W1, [W0]
42:                    sCAT24C512.usRegisterAddress = usRegisterAddress;
0050A8  90009E     MOV [W14+2], W1
0050AA  88ED81     MOV W1, .LFE36, .LFB37, _xTaskGenericNotifyFromISR
43:                    sCAT24C512.bIs16BitDevice = true;
0050AC  21DB20     MOV #0x1DB2, W0
0050AE  B3C011     MOV.B #0x1, W1
0050B0  784801     MOV.B W1, [W0]
44:                    sCAT24C512.pucNeedData = pucFirstByteAddress;
0050B2  9000AE     MOV [W14+4], W1
0050B4  88EDA1     MOV W1, 0x1DB4
45:                    sCAT24C512.ucNeedDataBytes = ucWriteReadBytes;
0050B6  21DB60     MOV #0x1DB6, W0
0050B8  9040EE     MOV.B [W14+6], W1
0050BA  784801     MOV.B W1, [W0]
46:                    /*select read or write*/
47:                    if (bWriteRead) {
0050BC  90407E     MOV.B [W14+7], W0
0050BE  E00400     CP0.B W0
0050C0  320005     BRA Z, .L3
48:                        /*read data*/
49:                        xCATSta = bI2CReadSlave(&sCAT24C512);
0050C2  21DAE0     MOV #0x1DAE, W0
0050C4  023BD2     CALL bI2CReadSlave
0050C6  000000     NOP
0050C8  784F00     MOV.B W0, [W14]
0050CA  370004     BRA .L4
50:                    } else {
51:                        /*write  data*/
52:                        xCATSta = bI2CWriteSlave(&sCAT24C512);
0050CC  21DAE0     MOV #0x1DAE, W0
0050CE  023B3E     CALL bI2CWriteSlave
0050D0  000000     NOP
0050D2  784F00     MOV.B W0, [W14]
53:                    }
54:                    /**/
55:                    CAT24_WP = 1;
0050D4  A842EC     BSET LATF, #2
56:                    return xCATSta;
0050D6  78401E     MOV.B [W14], W0
57:                }
0050D8  FA8000     ULNK
0050DA  060000     RETURN
58:                
59:                
60:                
